https://www.avanderlee.com/swiftui/conditional-view-modifier/

#####
Conditional View Modifier creation in SwiftUI allows you only to apply modifiers if a certain condition is true.
#####


==================================================Creating a Conditional View Modifier extension
extension View {
    /// Applies the given transform if the given condition evaluates to `true`.
    /// - Parameters:
    ///   - condition: The condition to evaluate.
    ///   - transform: The transform to apply to the source `View`.
    /// - Returns: Either the original `View` or the modified `View` if the condition is `true`.
    @ViewBuilder func `if`<Content: View>(_ condition: Bool, transform: (Self) -> Content) -> some View {
        if condition {
            transform(self)
        } else {
            self
        }
    }
}


struct ContentView: View {
    
    private var shouldApplyBackground: Bool {
        guard #available(iOS 14, *) else {
            return true
        }
        return false
    }
    
    var body: some View {
        Text("Hello, world!")
            .padding()
            .if(shouldApplyBackground) { view in
                // We only apply this background color if shouldApplyBackground is true
                view.background(Color.red)
            }
    }
}
However, it does require us to create computed properties for each conditional View Modifier, which is not ideal.


==================================================Using @autoclosure for inline statements
extension View {
    /// Applies the given transform if the given condition evaluates to `true`.
    /// - Parameters:
    ///   - condition: The condition to evaluate.
    ///   - transform: The transform to apply to the source `View`.
    /// - Returns: Either the original `View` or the modified `View` if the condition is `true`.
    @ViewBuilder func `if`<Content: View>(_ condition: @autoclosure () -> Bool, transform: (Self) -> Content) -> some View {
        if condition() {
            transform(self)
        } else {
            self
        }
    }
}

The @autoclosure keyword allows us to either use a boolean statement directly like in our previous code examples or to pass in a closure manually to create a conditional view modifier

struct ContentView: View {    
    var body: some View {
        Text("Hello, world!")
            .padding()
            .if({
                if #available(iOS 14, *) {
                    return true
                }
                return false
            }()) { view in
                view.background(Color.red)
            }
    }
}

By allowing ourselves to make inline statements, we take away the requirement of creating computed properties. 
However, the code becomes less readable and is less scalable if applied in multiple places through your code.


==================================================Creating a Bool extension for OS specific checks
extension Bool {
    static var iOS13: Bool {
        guard #available(iOS 14, *) else {
            // It's iOS 13 so return true.
            return true
        }
        // It's iOS 14 so return false.
        return false
    }
}

We can now revert our @autoclosure change from before and use the boolean extension directly:

struct ContentView: View {
    
    var body: some View {
        Text("Hello, world!")
            .padding()
            .if(.iOS13) { view in
                view.background(Color.red)
            }
    }
}

We got ourselves a readable view combined with a conditional View Modifier based on a boolean that checks for iOS 13 only.