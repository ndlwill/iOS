https://swiftui-lab.com/frame-behaviors/

grow: 放大
shrink: 缩小

#####
Modifiers in SwiftUI do not actually modify views. 
Most of the time, when we apply a modifier on a view, 
a new view is created that is wrapped around the view being “modified”. 
It is that wrapper view that we must think of as the “frame”.

在SwiftUI中，frame()是一个modifier，modifier在SwiftUI中并不是真的修改了view。
大多数情况下，当我们对某个view应用一个modifier的时候，实际上会创建一个新的view。


Behaviors:
we can group views by the way they react to the offered space:
1. Views that will only take as much space as needed to fit their own content. 
Stack containers are one example.
2. Views that will take only what they need.
And if what they’ve been offered is not enough to draw all the contents, they will do their best to respect the offered space. Text views are a mixed example: If not enough horizontal space is available they will either truncate or wrap the text. 
However vertically, at least one line of text will be shown, irrespective of how small the frame might be.
3. Views that will grow to fill all the space offered (but not a pixel more). 
Shapes are usually a good example, such as Rectangle().
4. Views that may decide to draw even outside the area offered by the parent. 
Some custom views can use this approach. For example, a speech balloon may draw the little tail outside its bounds.

Note that a view may behave differently on each axis. 
For example, a Spacer inside a VStack will probably take all it can vertically, 
but will not use any space horizontally. Having said that, there are cases when the behavior in one axis will be affected by the other. 
Such an example is the Text view, as its height may depend on the proposed width.

view在计算自己size的时候会有不同的行为方式，我们分为4类
类似于Vstack，它们会尽可能让自己内部的内容展示完整，但也不会多要其他的额外空间
类似于Text这种只返回自身需要的size，如果size不够，它非常聪明的做一些额外的操作，比如换行等等
类似于Shape这种给多大尺寸就使用多大尺寸
还有一些可能超出父控件的view


布局原则:
父view为子view提供一个建议的size
子view根据自身的特性，返回一个size
父view根据子view返回的size为其进行布局

frame起的作用就是提供一个建议的size
struct ContentView: View {
    var body: some View {
        Text("Hello, world")
            .background(Color.green)
            .frame(width: 200, height: 50) // frame中的alignment会对其内部的views做整体的对齐处理
    }
}
frame为background提供了一个(200, 50)的size，background还需要去问它的child，也就是Text， 
Text返回了一个自身需要的size，于是background也返回了Text的实际尺寸，
这就造成了绿色背景跟文本同样大小的效果。
调整了frame和background的顺序，就会有不同的效果

各个View不同的特性，像Text，会返回自身需要的size，像Shape，则会返回父view建议的size

或者：
当布局某个view时，其父view会给出一个建议的size
如果该view存在child，那么就拿着这个建议的尺寸去问他的child，child根据自身的behavior返回一个size，如果没有child，则根据自身的behavior返回一个size
用该size在其父view中进行布局
#####


在考虑布局的时候，是自下而上的。

struct ContentView: View {
    var body: some View {
        Text("Hello, World!")
    }
}
ContentView的size其实是跟Text一样的


#####
struct ContentView: View {
    var body: some View {
        Text("Hello, World!")
            .frame(width: 200, height: 100)
            .background(Color.green)
            .frame(width: 400, height: 200)
            .background(Color.orange.opacity(0.5))
    }
}
用Xcode看图层层级：从下到上
ContentView-background-orange-background-green-Text

我们先考虑ContentView，他的父view给他的建议尺寸为整个屏幕的大小，我们称为size0，他去询问他的child，
他的child为最下边的那个background，这个background自己也不知道自己的size，因此他继续拿着size0去询问他自己的child，
他的child是个frame，返回了width400， height200， 因此background告诉ContentView他需要的size为width400， height200，
因此最终ContentView的size为width400， height200。

很显然，我们也计算出了最下边background的size，注意，里边的Color也是一个view，Color本身是一个Shape，background返回一个透明的view

我们再考虑最上边的background，他父view给的建议的size为width: 400, height: 200，他询问其child，得到了需要的size为width: 200, height: 100，
因此该background的size为width: 200, height: 100。

我们在看Text，父View给的建议的size为width: 200, height: 100，但其只需要正好容纳文本的size，因此他的size并不会是width: 200, height: 100
必须要理解Text的size并不会是width: 200, height: 100，这跟我们平时开发的思维有所不同。

实际上frame本质上并不能直接修改view的size
#####


==================================================func frame(width: CGFloat? = nil, height: CGFloat? = nil, alignment: Alignment = .center)
#####
When we use this method, it may seem we are forcing the view’s width and height. 
That is usually the visual effect we achieve. 
However, that is not what is going on. 
What we are really doing, is changing the offered size. 
What the view will do with it, will be up to the view itself.
#####
Most views will adjust to the new offered size, which may lead us to the false assumption that we forced the size of the view. 
We did not.


struct ExampleView: View {
    @State private var width: CGFloat = 50

    var body: some View {
        VStack {
            SubView()
                .frame(width: self.width, height: 120) // We are using .frame() to change what’s offered to the child.
                .border(Color.blue, width: 2)

            Text("Offered Width \(Int(width))")
            Slider(value: $width, in: 0...200, step: 1)
        }
    }
}

struct SubView: View {
    var body: some View {
        GeometryReader { proxy in
            Rectangle()
                .fill(Color.yellow.opacity(0.7))
                .frame(width: max(proxy.size.width, 120), height: max(proxy.size.height, 120))
        }
    }
}
黄色方块的宽度依赖frame(width: max(proxy.size.width, 120), height: max(proxy.size.height, 120))


==================================================func frame(minWidth: CGFloat? = nil, idealWidth: CGFloat? = nil, maxWidth: CGFloat? = nil, minHeight: CGFloat? = nil, idealHeight: CGFloat? = nil, maxHeight: CGFloat? = nil, alignment: Alignment = .center)
https://developer.apple.com/documentation/swiftui/view/frame(minwidth:idealwidth:maxwidth:minheight:idealheight:maxheight:alignment:)
Positions this view within an invisible frame having the specified size constraints.

#####官方文档:
“当父视图给 frame 一个尺寸建议（proposal）时，frame 本身是如何决定自己尺寸的”

The size proposed to this view is the size proposed to the frame, limited by any constraints specified, 
and with any ideal dimensions specified replacing any corresponding unspecified dimensions in the proposal.

If no minimum or maximum constraint is specified in a given dimension, 
the frame adopts the sizing behavior of its child in that dimension（维度）. 
如果你没有设置 min/max 宽度或高度，那这个 .frame(...) 不会限制子视图的尺寸，它的宽高行为就跟 子视图自身的尺寸一样。
Text("Hello")
    .frame() // 没设置任何宽高限制
Text 的 intrinsic width 可能是 100
由于没限制，frame 直接跟随 Text，结果宽度也是 100。

If both constraints are specified in a dimension, 
the frame unconditionally adopts the size proposed for it, clamped to the constraints. 
如果你同时设置了 minWidth 和 maxWidth，那么：
无论子视图大小是多少；
frame 直接接受父视图提议的宽度（比如 500），然后：
限制在你设置的 min/max 区间内（clamp）
Text("Hi")
    .frame(minWidth: 100, maxWidth: 300)
如果父视图提议宽度为 500：
500 会被 clamp 到 300；
所以最终宽度就是 300。

Otherwise, the size of the frame in either dimension is: 接下来说的是如果 只设置了 min 或 max（不是两个一起） 时，怎么处理：
1. If a minimum constraint is specified and the size proposed for the frame by the parent is less than the size of this view, 
the proposed size, clamped to that minimum. 否则：无论 proposal 多大，只要 child 小于 minWidth，frame 会被扩展以满足 minWidth。

如果只设置了 minWidth（或者 minHeight），并且：
父视图提议的尺寸比子视图的内容 还要小，
那么就取：
proposal 和 min 之间更大的那个（也就是 clamp 到 min）
Text("Hello, World!")
    .frame(minWidth: 300)
Text intrinsic width ≈ 180；
proposal（来自父视图）= 150；
因为 proposal 太小 → clamp 到 300；
所以最终宽度是 300。

2. If a maximum constraint is specified and the size proposed for the frame by the parent is greater than the size of this view, 
the proposed size, clamped to that maximum.
如果只设置了 maxWidth（或 maxHeight），并且：
父视图提议的尺寸比子视图内容还要大；
就 clamp 到最大值。

Text("Hello")
    .frame(maxWidth: 100)
proposal = 500；
intrinsic = 80；
proposal > intrinsic → clamp 到 100；

3. Otherwise, the size of this view.
上面这些条件都不满足的情况下，frame 就直接采用子视图的尺寸（即 Text 或其他内容本身决定的大小）
#####


这么多参数可以分为3组：
minWidth，idealWidth，maxWidth
minHeight，idealHeight，maxHeight
alignment

当我们给minWidth，idealWidth，maxWidth赋值的时候，一定要遵循数值递增原则，否则，xcode会给出错误提示。
minWidth表示的是最小的宽度， idealWidth表示最合适(理想)的宽度，maxWidth表示最大的宽度，通常如果我们用到了该方法，我们只需要考虑minWidth和maxWidth就行了。

frame modifier通过计算minWidth，maxWidth和child size ，就可以看着###规则###返回一个size，
view用这个size作为自身在父view中的size。

struct ContentView: View {
    var body: some View {
        Text("Hello, World!")
            .frame(minWidth: 40, maxWidth: 300)
            .background(Color.orange.opacity(0.5)) // 300
            .font(.largeTitle)
    }
}

----------
minWidth: 300
maxWidth: nil
proposed size = ∞
child intrinsic size （假设Text宽） = 180

struct ContentView: View {
    var body: some View {
        Text("Hello, World!")
            .frame(minWidth: 300)
            .background(Color.orange.opacity(0.5)) // 宽300
            .font(.largeTitle)
    }
}
因为你只设置了 .frame(minWidth: 300)，没有设置 maxWidth 或 width，所以 SwiftUI 会在满足 minWidth 后，选择子视图最小需要的尺寸**，而不是“最大能有多少”。
“我希望最小这么大，如果空间允许，我也许会更大，但不是必须。” 但 不会无限制扩张

我的理解：proposed size = ∞，询问background的需求尺寸（就以宽为例子），background不知道，问frame，因为不是直接设置width，所以也不知道，再问child即Text，
Text返回180作为需求尺寸，通过图的规则比对， NO，frame得到child size：180后，和minWidth: 300比较，最终frame返回需求尺寸300（180比最小的300还小，所以取300），所以background为300

struct ContentView: View {
    var body: some View {
        Text("Hello, World!")
            .frame(minWidth: 300, maxWidth: .infinity) 
            .background(Color.orange.opacity(0.5)) // 屏幕宽度，大于300
            .font(.largeTitle)
    }
}

----------

struct ContentView: View {
    var body: some View {
        Text("Hello, World!")
            .frame(maxWidth: 300) // 这边根据图规则，YES，直接将 proposed size（即图中的黄色块） 限制到maxWidth 最大约束，即300 （把proposed size看成 width设置）
            .background(Color.orange.opacity(0.5))
            .font(.largeTitle)
    }
}


==================================================Fixed Size Views
func fixedSize() -> some View
func fixedSize(horizontal: Bool, vertical: Bool) -> some View

在SwiftUI中，任何View都可以用这个modifer，当我们应用了该modifier后，布局系统在返回size的时候，就会返回与之对应的idealWIdth或者idealHeight。

先看一段代码：
struct ContentView: View {
    var body: some View {
        Text("这个文本还挺长的，到达了一定字数后，就超过了一行的显示范围了！！！")
            .border(Color.blue)
            .frame(width: 200, height: 100)
            .border(Color.green)
            .font(.title)
    }
}
按照3大布局原则，绿色边框的宽为200， 高为100， 
蓝色边框的父view提供的宽为200， 高为100，其child， 
text在宽为200， 高为100限制下，返回了篮框的size，
因此篮框和text的size相同。


修改一下代码：
struct ContentView: View {
    var body: some View {
        Text("这个文本还挺长的，到达了一定字数后，就超过了一行的显示范围了！！！")
            .fixedSize(horizontal: true, vertical: false)
            .border(Color.blue)
            .frame(width: 200, height: 100)
            .border(Color.green)
            .font(.title)
    }
}
可以看到，绿框没有任何变化，篮框变宽了，当在水平方向上应用了fixedSize时，.border(Color.blue)在询问child的size时，
child会返回它的idealWidth，我们并没有给出一个指定的idealWidth，每个view里边都有自己的idealWidth。

我们给它显式的指定一个idealWidth：
struct ContentView: View {
    var body: some View {
        Text("这个文本还挺长的，到达了一定字数后，就超过了一行的显示范围了！！！")
            .frame(idealWidth: 300)
            .fixedSize(horizontal: true, vertical: false)
            .border(Color.blue)
            .frame(width: 200, height: 100)
            .border(Color.green)
            .font(.title)
    }
}
当我们想要固定某个view的某个轴的尺寸的时候，fixedSize这个modifier是一个利器。


==========fixedSize的小demo
GeometryReader { geometry in
    Text("Hello")
        .frame(width: geometry.size.width / 2)
}
geometry.size：容器自身的尺寸(去除了安全区域)

Text 的父视图是 GeometryReader
所以，GeometryReader 会向 Text 提议无限大的尺寸（proposed size 为 .infinity）

GeometryReader 是一种「自适应容器」，它 不限制子视图的大小；
所以它对其子视图提出的建议尺寸是：
ProposedViewSize(width: .infinity, height: .infinity)
即：“你可以随便占，我不限制你。”

假设 geometry.size.width = 300
那么即使 proposal 是无限大，Text 会忽略它，强行设置自己为 150 宽度。



struct ExampleView: View {
    @State private var width: CGFloat = 150
    @State private var fixedSize: Bool = true

    var body: some View {
        GeometryReader { proxy in

            VStack {
                Spacer()

                VStack {
                    LittleSquares(total: 7)
                        .border(Color.green)
                        .fixedSize(horizontal: self.fixedSize, vertical: false)
                }
                .frame(width: self.width)
                .border(Color.primary)
                .background(MyGradient())

                Spacer()

                Form {
                    Slider(value: self.$width, in: 0...proxy.size.width)
                    Toggle(isOn: self.$fixedSize) { Text("Fixed Width") }
                }
            }
        }.padding(.top, 140)
    }
}

struct LittleSquares: View {
    let sqSize: CGFloat = 20
    let total: Int

    var body: some View {
        GeometryReader { proxy in
            HStack(spacing: 5) {
                ForEach(0..<self.maxSquares(proxy), id: \.self) { _ in
                    RoundedRectangle(cornerRadius: 5).frame(width: self.sqSize, height: self.sqSize)
                        .foregroundColor(self.allFit(proxy) ? .green : .red)
                }
            }
        }.frame(idealWidth: (5 + self.sqSize) * CGFloat(self.total), maxWidth: (5 + self.sqSize) * CGFloat(self.total))
    }

    func maxSquares(_ proxy: GeometryProxy) -> Int {
        return min(Int(proxy.size.width / (sqSize + 5)), total)
    }

    func allFit(_ proxy: GeometryProxy) -> Bool {
        return maxSquares(proxy) == total
    }
}

struct MyGradient: View {
    var body: some View {
        LinearGradient(gradient: Gradient(colors: [Color.red.opacity(0.1), Color.green.opacity(0.1)]), startPoint: UnitPoint(x: 0, y: 0), endPoint: UnitPoint(x: 1, y: 1))
    }
}

如果idealWidth来固定住view的宽度，那么view的宽度就不会改变，这在某些场景下还是挺有用的。

最核心的代码是：
.frame(idealWidth: (5 + self.sqSize) * CGFloat(self.total), maxWidth: (5 + self.sqSize) * CGFloat(self.total))

==========Layout Priority:
SwiftUI中，view默认的layout priority 都是0，对于同一层级的view来说，系统会按照顺序进行布局，
当我们使用.layourPriority()修改了布局的优先级后，系统则优先布局高优先级的view。


struct ContentView: View {
    var body: some View {
        VStack {
            Text("床前明月光，疑是地上霜")
                .background(Color.green)
            Text("举头望明月，低头思故乡")
                .background(Color.blue)
        }
        .frame(width: 100, height: 100)
    }
}
这2个text的优先级是相同的，因此他们平分布局空间，我们给第2个text提升一点优先级:
struct ContentView: View {
    var body: some View {
        VStack {
            Text("床前明月光，疑是地上霜")
                .background(Color.green)
            Text("举头望明月，低头思故乡")
                .background(Color.blue)
                .layoutPriority(1)
        }
        .frame(width: 100, height: 100)
    }
}
可以明显的看出来，优先布局第2个text。

总结:
父view提供一个建议的size
view根据自身的特点再结合它的child计算出一个size
使用该size在父view中布局

