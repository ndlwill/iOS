func test(val: SomeProtocol) {
// protocol
}

func test<T: SomeProtocol>(val: T) {
// generic
}

协议大部分情况下通过查表动态派发
而范型大部分情况下可以优化为直接使用对应类型，效率更高


==================================================


泛型的本质是 参数化类型。⾥⾯的 T 就是个占位符，系统这样就不会检查类型了
associatedtype（关联类型） 是在 protocol ⾥使⽤的泛型


func add<T>(input: T) -> T {
    return input
}
当你使用泛型 T 时，你明确了输入和输出的类型必须保持一致。泛型函数会在编译时确定类型，确保类型安全。
使用泛型可以让你的代码更安全，因为编译器会在编译时检查类型一致性。
泛型还可以有类型约束，比如你可以指定 T 必须遵循某个协议，这样可以进一步限制 T 的类型范围。


func anyAdd(input: Any) -> Any {
    return input
}
Any 是一个可以表示任何类型的通用类型
使用 Any 的函数可以接受和返回任意类型，Any 类型会避开编译时的类型检查
使用 Any 时，输入和输出类型可以不一致，这使得函数更加灵活，但也更容易出错，因为类型必须在运行时手动检查和转换。


一般来说，如果你知道输入和输出的类型是一致的，使用泛型 T 是更好的选择