https://docs.swift.org/swift-book/documentation/the-swift-programming-language


==================================================Xcode15.1 Swift5.9.2

Writing <T: Equatable> is the same as writing <T> ... where T: Equatable.

--------------------------------------------------The Basics:

Swift provides an additional integer type, Int, which has the same size as the current platformâ€™s native word size:
On a 32-bit platform, Int is the same size as Int32.
On a 64-bit platform, Int is the same size as Int64.


Swift provides two signed floating-point number types:
Double represents a 64-bit floating-point number.
Float represents a 32-bit floating-point number.
Double has a precision of at least 15 decimal digits, whereas the precision of Float can be as little as 6 decimal digits.


Numeric Literals:
A decimal number, with no prefix
A binary number, with a 0b prefix
An octal number, with a 0o prefix
A hexadecimal number, with a 0x prefix
let decimalInteger = 17
let binaryInteger = 0b10001       // 17 in binary notation
let octalInteger = 0o21           // 17 in octal notation
let hexadecimalInteger = 0x11     // 17 in hexadecimal notation


Floating-point literals can be decimal (with no prefix), or hexadecimal (with a 0x prefix).
They must always have a number (or hexadecimal number) on both sides of the decimal point.
Decimal floats can also have an optional exponent, indicated by an uppercase or lowercase e; 
hexadecimal floats must have an exponent, indicated by an uppercase or lowercase p.
For decimal numbers with an exponent of x, the base number is multiplied by 10Ë£:
1.25e2 means 1.25 x 10Â², or 125.0.
1.25e-2 means 1.25 x 10â»Â², or 0.0125.
For hexadecimal numbers with an exponent of x, the base number is multiplied by 2Ë£:
0xFp2 means 15 x 2Â², or 60.0.
0xFp-2 means 15 x 2â»Â², or 3.75.
All of these floating-point literals have a decimal value of 12.1875:
let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0
Both integers and floats can be padded with extra zeros and can contain underscores to help with readability.
let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1


An Int8 constant or variable can store numbers between -128 and 127, whereas a UInt8 constant or variable can store numbers between 0 and 255.
SomeType(ofInitialValue) is the default way to call the initializer of a Swift type and pass in an initial value.
Floating-point values are always truncated when used to initialize a new integer value in this way. This means that 4.75 becomes 4, and -3.9 becomes -3.


typealias AudioSample = UInt16


let (statusCode, statusMessage) = http404Error
access the individual element values in a tuple using index numbers starting at zero:
You can name the individual elements in a tuple when the tuple is defined:
let http200Status = (statusCode: 200, description: "OK")


In Objective-C, nil is a pointer to a nonexistent object. 
In Swift, nil isnâ€™t a pointer â€” itâ€™s the absence of a value of a certain type. 
Optionals of any type can be set to nil, not just object types.


Optional Binding:
if let <#constantName#> = <#someOptional#> {
   <#statements#>
}
If you donâ€™t need to refer to the original, optional constant or variable after accessing the value it contains, you can use the same name for the new constant or variable:
let myNumber = Int(possibleNumber)
// Here, myNumber is an optional integer
if let myNumber = myNumber {
    // Here, myNumber is a non-optional integer
    print("My number is \(myNumber)")
}
you can use a shorter spelling to unwrap an optional value
if let myNumber {
    print("My number is \(myNumber)")
}
Constants and variables created with optional binding in an if statement are available only within the body of the if statement.


Providing a Fallback Value:
using the nil-coalescing operator (??)


Force Unwrapping:


implicitly or explicitly: éšå¼æˆ–æ˜¾å¼
Implicitly Unwrapped Optionals:
The primary use of implicitly unwrapped optionals in Swift is during class initialization
Donâ€™t use an implicitly unwrapped optional when thereâ€™s a possibility of a variable becoming nil at a later point. 
Always use a normal optional type if you need to check for a nil value during the lifetime of a variable.
let assumedString: String! = "An implicitly unwrapped optional string."
let implicitString: String = assumedString // Unwrapped automatically
optionalString doesnâ€™t have an explicit type so itâ€™s an ordinary optional.
let optionalString = assumedString
// The type of optionalString is "String?" and assumedString isn't force-unwrapped.


Error Handling:
func canThrowAnError() throws {
    // this function may or may not throw an error
}
do {
    try canThrowAnError()
    // no error was thrown
} catch {
    // an error was thrown
}

func makeASandwich() throws {
    // ...
}
do {
    try makeASandwich()
    eatASandwich()
} catch SandwichError.outOfCleanDishes {
    washDishes()
} catch SandwichError.missingIngredients(let ingredients) {
    buyGroceries(ingredients)
}


Debugging with Assertions:
let age = -3
assert(age >= 0, "A person's age can't be less than zero.")
The difference between assertions and preconditions is in when theyâ€™re checked: Assertions are checked only in debug builds, but preconditions are checked in both debug and production builds. 
In production builds, the condition inside an assertion isnâ€™t evaluated. 
This means you can use as many assertions as you want during your development process, without impacting performance in production.
If the code already checks the condition, you use the assertionFailure(_:file:line:) function to indicate that an assertion has failed.
if age > 10 {
    print("You can ride the roller-coaster or the ferris wheel.")
} else if age >= 0 {
    print("You can ride the ferris wheel.")
} else {
    assertionFailure("A person's age can't be less than zero.")
}


Enforcing Preconditions:
// In the implementation of a subscript...
precondition(index > 0, "Index must be greater than zero.")
If you compile in unchecked mode (-Ounchecked), preconditions arenâ€™t checked. 
The compiler assumes that preconditions are always true, and it optimizes your code accordingly.
However, the fatalError(_:file:line:) function always halts execution, regardless of optimization settings.
Because fatal errors are never optimized out, unlike assertions or preconditions, you can be sure that execution always halts if it encounters a stub implementation.


--------------------------------------------------Basic Operators
let (x, y) = (1, 2)
Unlike the assignment operator in C and Objective-C, the assignment operator in Swift doesnâ€™t itself return a value. 
The following statement isnâ€™t valid:
if x = y {
    // This isn't valid, because x = y doesn't return a value.
}


The remainder operator (%) is also known as a modulo operator in other languages. 
However, its behavior in Swift for negative numbers means that, strictly speaking, itâ€™s a remainder rather than a modulo operation.
a % b
a = (b x some multiplier) + remainder
The sign of b is ignored for negative values of b. This means that a % b and a % -b always give the same answer.


Compound Assignment Operators:
var a = 1
a += 2
// a is now equal to 3
The expression a += 2 is shorthand for a = a + 2.
he compound assignment operators donâ€™t return a value. For example, you canâ€™t write let b = a += 2.


Comparison Operators:
Equal to (a == b)
Not equal to (a != b)
Greater than (a > b)
Less than (a < b)
Greater than or equal to (a >= b)
Less than or equal to (a <= b)

Swift also provides two identity operators (=== and !==), which you use to test whether two object references both refer to the same object instance.

You can compare two tuples if they have the same type and the same number of values.
Tuples are compared from left to right, one value at a time, until the comparison finds two values that arenâ€™t equal.
Those two values are compared, and the result of that comparison determines the overall result of the tuple comparison.
If all the elements are equal, then the tuples themselves are equal.
(1, "zebra") < (2, "apple")   // true because 1 is less than 2; "zebra" and "apple" aren't compared
(3, "apple") < (3, "bird")    // true because 3 is equal to 3, and "apple" is less than "bird"
(4, "dog") == (4, "dog")      // true because 4 is equal to 4, and "dog" is equal to "dog"
you can compare two tuples of type (String, Int) because both String and Int values can be compared using the < operator.
In contrast, two tuples of type (String, Bool) canâ€™t be compared with the < operator because the < operator canâ€™t be applied to Bool values.
("blue", -1) < ("purple", 1)        // OK, evaluates to true
("blue", false) < ("purple", true)  // Error because < can't compare Boolean values
The Swift standard library includes tuple comparison operators for tuples with fewer than seven elements. 
To compare tuples with seven or more elements, you must implement the comparison operators yourself.


Nil-Coalescing Operator:
(a ?? b) 
If the value of a is non-nil, the value of b isnâ€™t evaluated. This is known as short-circuit evaluation.


Closed Range Operator:
The closed range operator (a...b) defines a range that runs from a to b, and includes the values a and b. The value of a must not be greater than b.


Half-Open Range Operator:
The half-open range operator (a..<b) defines a range that runs from a to b, but doesnâ€™t include b.
If the value of a is equal to b, then the resulting range will be empty.
let names = ["Anna", "Alex", "Brian", "Jack"]
let count = names.count
for i in 0..<count {
    print("Person \(i + 1) is called \(names[i])")
}


One-Sided Ranges:
a range that includes all the elements of an array from index 2 to the end of the array.
for name in names[2...] {
    print(name)
}

for name in names[...2] {
    print(name)
}
for name in names[..<2] {
    print(name)
}

let range = ...5
range.contains(7)   // false
range.contains(4)   // true
range.contains(-1)  // true


The Swift logical operators && and || are left-associative, meaning that compound expressions with multiple logical operators evaluate the leftmost subexpression first.


Explicit Parentheses:
if (enteredDoorCode && passedRetinaScan) || hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}


--------------------------------------------------Strings and Characters
Swiftâ€™s String type is bridged with Foundationâ€™s NSString class.
Foundation also extends String to expose methods defined by NSString. 
This means, if you import Foundation, you can access those NSString methods on String without casting.


let quotation = """

The White Rabbit put on his spectacles.  "Where shall I begin,

please your Majesty?" he asked.

"""


If you want to use line breaks to make your source code easier to read, but you donâ€™t want the line breaks to be part of the stringâ€™s value, write a backslash (\) at the end of those lines:
let softWrappedQuotation = """
The White Rabbit put on his spectacles.  "Where shall I begin, \
please your Majesty?" he asked.

"Begin at the beginning," the King said gravely, "and go on \
till you come to the end; then stop."
"""


An arbitrary Unicode scalar value, written as \u{n}, where n is a 1â€“8 digit hexadecimal number 


To include the text """ in a multiline string, escape at least one of the quotation marks.
let threeDoubleQuotationMarks = """
Escaping the first quotation mark \"""
Escaping all three quotation marks \"\"\"
"""


Unicode Scalar Values:
Behind the scenes, Swiftâ€™s native String type is built from Unicode scalar values.
A Unicode scalar value is a unique 21-bit number for a character or modifier, such as U+0061 for LATIN SMALL LETTER A ("a"), or U+1F425 for FRONT-FACING BABY CHICK ("ğŸ¥").
Note that not all 21-bit Unicode scalar values are assigned to a character â€” some scalars are reserved for future assignment or for use in UTF-16 encoding.
Scalar values that have been assigned to a character typically also have a name, such as LATIN SMALL LETTER A and FRONT-FACING BABY CHICK in the examples above.


Extended String Delimiters:
printing the string literal #"Line 1\nLine 2"# prints the line feed escape sequence (\n) rather than printing the string across two lines.
If you need the special effects of a character in a string literal, match the number of number signs within the string following the escape character (\).
if your string is #"Line 1\nLine 2"# and you want to break the line, you can use #"Line 1\#nLine 2"# instead.
let threeMoreDoubleQuotationMarks = #"""
Here are three more double quotes: """
"""#


let catCharacters: [Character] = ["C", "a", "t", "!", "ğŸ±"]
let catString = String(catCharacters)


let exclamationMark: Character = "!"
welcome.append(exclamationMark)


let badStart = """
    one
    two
    """
let end = """
    three
    """
print(badStart + end)
// Prints two lines:
// one
// twothree
let goodStart = """
    one
    two

    """
print(goodStart + end)
// Prints three lines:
// one
// two
// three


print(#"Write an interpolated string in Swift using \(multiplier)."#)
// Prints "Write an interpolated string in Swift using \(multiplier)."
print(#"6 times 7 is \#(6 * 7)."#)
// Prints "6 times 7 is 42."


Extended Grapheme Clusters:
In both cases, the letter Ã© is represented as a single Swift Character value that represents an extended grapheme cluster. 
In the first case, the cluster contains a single scalar; in the second case, itâ€™s a cluster of two scalars:
let eAcute: Character = "\u{E9}"                         // Ã©
let combinedEAcute: Character = "\u{65}\u{301}"          // e followed by Ì
// eAcute is Ã©, combinedEAcute is eÌ
let precomposed: Character = "\u{D55C}"                  // í•œ
let decomposed: Character = "\u{1112}\u{1161}\u{11AB}"   // á„’, á…¡, á†«
// precomposed is í•œ, decomposed is á„’á…¡á†«
let regionalIndicatorForUS: Character = "\u{1F1FA}\u{1F1F8}"
// regionalIndicatorForUS is ğŸ‡ºğŸ‡¸


Note that Swiftâ€™s use of extended grapheme clusters for Character values means that string concatenation and modification may not always affect a stringâ€™s character count.
For example, if you initialize a new string with the four-character word cafe, 
and then append a COMBINING ACUTE ACCENT (U+0301) to the end of the string, 
the resulting string will still have a character count of 4, with a fourth character of eÌ, not e:
var word = "cafe"
print("the number of characters in \(word) is \(word.count)")
// Prints "the number of characters in cafe is 4"
word += "\u{301}"    // COMBINING ACUTE ACCENT, U+0301
print("the number of characters in \(word) is \(word.count)")
// Prints "the number of characters in cafeÌ is 4"


Note
Extended grapheme clusters can be composed of multiple Unicode scalars.
This means that different characters â€” and different representations of the same character â€” can require different amounts of memory to store.
Because of this, characters in Swift donâ€™t each take up the same amount of memory within a stringâ€™s representation.
###
If you are working with particularly long string values, 
be aware that the count property must iterate over the Unicode scalars in the entire string in order to determine the characters for that string.
###
The count of the characters returned by the count property isnâ€™t always the same as the length property of an NSString that contains the same characters. 
The length of an NSString is based on the number of 16-bit code units within the stringâ€™s UTF-16 representation and not the number of Unicode extended grapheme clusters within the string.


String Indices:
Each String value has an associated index type, String.Index, which corresponds to the position of each Character in the string.
so in order to determine which Character is at a particular position, you must iterate over each Unicode scalar from the start or end of that String. 
For this reason, Swift strings canâ€™t be indexed by integer values.
Use the startIndex property to access the position of the first Character of a String. 
The endIndex property is the position after the last character in a String. 
As a result, the endIndex property isnâ€™t a valid argument to a stringâ€™s subscript. If a String is empty, startIndex and endIndex are equal.
let greeting = "Guten Tag!"
greeting[greeting.startIndex]
// G
greeting[greeting.index(before: greeting.endIndex)]
// !
greeting[greeting.index(after: greeting.startIndex)]
// u
let index = greeting.index(greeting.startIndex, offsetBy: 7)
greeting[index]
// a
greeting[greeting.endIndex] // Error
greeting.index(after: greeting.endIndex) // Error
Note:
You can use the startIndex and endIndex properties and the index(before:), index(after:), and index(_:offsetBy:) methods on any type that conforms to the Collection protocol.
This includes String, as shown here, as well as collection types such as Array, Dictionary, and Set.


Inserting and Removing:
Note:
You can use the insert(_:at:), insert(contentsOf:at:), remove(at:), and removeSubrange(_:) methods on any type that conforms to the RangeReplaceableCollection protocol. 
This includes String, as shown here, as well as collection types such as Array, Dictionary, and Set.


Substrings:
When you get a substring from a string â€” for example, using a subscript or a method like prefix(_:) â€” the result is an instance of Substring, not another string.
However, unlike strings, you use substrings for only a short amount of time while performing actions on a string. 
When youâ€™re ready to store the result for a longer time, you convert the substring to an instance of String.
let greeting = "Hello, world!"
let index = greeting.firstIndex(of: ",") ?? greeting.endIndex
let beginning = greeting[..<index]
// beginning is "Hello"
// Convert the result to a String for long-term storage.
let newString = String(beginning)
The difference between strings and substrings is that, as a performance optimization, 
a substring can reuse part of the memory thatâ€™s used to store the original string, 
or part of the memory thatâ€™s used to store another substring. (Strings have a similar optimization, but if two strings share memory, theyâ€™re equal.) 
This performance optimization means you donâ€™t have to pay the performance cost of copying memory until you modify either the string or substring.
Note:
Both String and Substring conform to the StringProtocol protocol, 
which means itâ€™s often convenient for string-manipulation functions to accept a StringProtocol value. You can call such functions with either a String or Substring value.


Comparing Strings:
Two String values (or two Character values) are considered equal if their extended grapheme clusters are canonically equivalent.
Extended grapheme clusters are canonically equivalent if they have the same linguistic meaning and appearance, even if theyâ€™re composed from different Unicode scalars behind the scenes.

For example, LATIN SMALL LETTER E WITH ACUTE (U+00E9) is canonically equivalent to LATIN SMALL LETTER E (U+0065) followed by COMBINING ACUTE ACCENT (U+0301). 
Both of these extended grapheme clusters are valid ways to represent the character Ã©, and so theyâ€™re considered to be canonically equivalent
// "Voulez-vous un cafÃ©?" using LATIN SMALL LETTER E WITH ACUTE
let eAcuteQuestion = "Voulez-vous un caf\u{E9}?"
// "Voulez-vous un cafeÌ?" using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT
let combinedEAcuteQuestion = "Voulez-vous un caf\u{65}\u{301}?"
if eAcuteQuestion == combinedEAcuteQuestion {
    print("These two strings are considered equal")
}
// Prints "These two strings are considered equal"

Conversely, LATIN CAPITAL LETTER A (U+0041, or "A"), as used in English, is not equivalent to CYRILLIC CAPITAL LETTER A (U+0410, or "Ğ"), as used in Russian. 
The characters are visually similar, but donâ€™t have the same linguistic meaning
let latinCapitalLetterA: Character = "\u{41}"
let cyrillicCapitalLetterA: Character = "\u{0410}"
if latinCapitalLetterA != cyrillicCapitalLetterA {
    print("These two characters aren't equivalent.")
}
// Prints "These two characters aren't equivalent."


Unicode Representations of Strings:
When a Unicode string is written to a text file or some other storage, the Unicode scalars in that string are encoded in one of several Unicode-defined encoding forms.
Each form encodes the string in small chunks known as code units.
These include the UTF-8 encoding form (which encodes a string as 8-bit code units), the UTF-16 encoding form (which encodes a string as 16-bit code units), and the UTF-32 encoding form (which encodes a string as 32-bit code units).

Swift provides several different ways to access Unicode representations of strings. 
You can iterate over the string with a for-in statement, to access its individual Character values as Unicode extended grapheme clusters. 
Alternatively, access a String value in one of three other Unicode-compliant representations:
A collection of UTF-8 code units (accessed with the stringâ€™s utf8 property)
A collection of UTF-16 code units (accessed with the stringâ€™s utf16 property)
A collection of 21-bit Unicode scalar values, equivalent to the stringâ€™s UTF-32 encoding form (accessed with the stringâ€™s unicodeScalars property)
let dogString = "Dogâ€¼ğŸ¶"

UTF-8 Representation:
You can access a UTF-8 representation of a String by iterating over its utf8 property. 
This property is of type String.UTF8View, which is a collection of unsigned 8-bit (UInt8) values, 
one for each byte in the stringâ€™s UTF-8 representation:
for codeUnit in dogString.utf8 {
    print("\(codeUnit) ", terminator: "")
}
print("")
// Prints "68 111 103 226 128 188 240 159 144 182 "

UTF-16 Representation:
You can access a UTF-16 representation of a String by iterating over its utf16 property. 
This property is of type String.UTF16View, which is a collection of unsigned 16-bit (UInt16) values, 
one for each 16-bit code unit in the stringâ€™s UTF-16 representation:
for codeUnit in dogString.utf16 {
    print("\(codeUnit) ", terminator: "")
}
print("")
// Prints "68 111 103 8252 55357 56374 "
The fifth and sixth codeUnit values (55357 and 56374) are a UTF-16 surrogate pair representation of the DOG FACE character. 
These values are a high-surrogate value of U+D83D (decimal value 55357) and a low-surrogate value of U+DC36 (decimal value 56374).

Unicode Scalar Representation:
You can access a Unicode scalar representation of a String value by iterating over its unicodeScalars property. 
This property is of type UnicodeScalarView, which is a collection of values of type UnicodeScalar.
Each UnicodeScalar has a value property that returns the scalarâ€™s 21-bit value, represented within a UInt32 value:
for scalar in dogString.unicodeScalars {
    print("\(scalar.value) ", terminator: "")
}
print("")
// Prints "68 111 103 8252 128054 "
As an alternative to querying their value properties, each UnicodeScalar value can also be used to construct a new String value, such as with string interpolation:
for scalar in dogString.unicodeScalars {
    print("\(scalar) ")
}
// D
// o
// g
// â€¼
// ğŸ¶


"code unit"ï¼ˆä»£ç å•å…ƒï¼‰å’Œ "code point"ï¼ˆç ç‚¹ï¼‰
Code Pointï¼ˆç ç‚¹ï¼‰ï¼š ç ç‚¹æ˜¯ Unicode ä¸­çš„ä¸€ä¸ªæœ¯è¯­ï¼Œè¡¨ç¤ºä¸ºä¸€ä¸ªå”¯ä¸€çš„æ•´æ•°å€¼ï¼Œç”¨æ¥æ ‡è¯†å­—ç¬¦åœ¨ Unicode ä¸­çš„ä½ç½®ã€‚
æ¯ä¸ªå­—ç¬¦éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ç ç‚¹ï¼Œä¾‹å¦‚ U+0041 è¡¨ç¤ºå¤§å†™å­—æ¯ "A" çš„ç ç‚¹ã€‚ç ç‚¹æ˜¯å­—ç¬¦çš„æŠ½è±¡æ ‡è¯†ã€‚
Code Unitï¼ˆä»£ç å•å…ƒï¼‰ï¼š ä»£ç å•å…ƒæ˜¯åœ¨å­—ç¬¦ç¼–ç ä¸­çš„æœ€å°å­˜å‚¨å•å…ƒã€‚
åœ¨ Unicode ä¸­ï¼Œå¸¸è§çš„ä»£ç å•å…ƒå¤§å°æœ‰ 8 ä½ï¼ˆå³å­—èŠ‚ï¼‰ã€16 ä½å’Œ 32 ä½ã€‚
ä¸åŒçš„å­—ç¬¦ç¼–ç æ–¹æ¡ˆä½¿ç”¨ä¸åŒå¤§å°çš„ä»£ç å•å…ƒæ¥è¡¨ç¤ºå­—ç¬¦ã€‚
ä¾‹å¦‚ï¼Œåœ¨ UTF-8 ç¼–ç ä¸­ï¼Œä¸€ä¸ªä»£ç å•å…ƒæ˜¯ 8 ä½ï¼ˆä¸€ä¸ªå­—èŠ‚ï¼‰ï¼Œè€Œåœ¨ UTF-16 ç¼–ç ä¸­ï¼Œä¸€ä¸ªä»£ç å•å…ƒæ˜¯ 16 ä½ã€‚

https://symbl.cc/cn/search/?q=%E5%8F%8C%E5%8F%B9%E5%8F%B7
åŒå¹å·
U+203C
&#8252;
&#8252; è¡¨ç¤ºçš„æ˜¯ä¸€ä¸ª Unicode å­—ç¬¦ï¼Œå…¶åè¿›åˆ¶ç¼–ç ä¸º 8252ã€‚è¿™ç§è¡¨ç¤ºæ–¹å¼ä½¿ç”¨äº†æ•°å­—å®ä½“å¼•ç”¨ã€‚&# åé¢çš„æ•°å­—è¡¨ç¤º Unicode ç ç‚¹çš„åè¿›åˆ¶å€¼
U+203C; "U+" è¡¨ç¤º Unicode ç ç‚¹ï¼ˆUnicode Code Pointï¼‰çš„å‰ç¼€ã€‚Unicode ç ç‚¹æ˜¯ Unicode å­—ç¬¦é›†ä¸­çš„å”¯ä¸€æ ‡è¯†ç¬¦ã€‚æ¯ä¸ªå­—ç¬¦éƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„ç ç‚¹ï¼Œå®ƒæ˜¯ä¸€ä¸ªåå…­è¿›åˆ¶æ•°å­—ã€‚
å¯¹äº "U+203C"ï¼Œå…¶ä¸­ "U+" è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ª Unicode ç ç‚¹ï¼Œè€Œ "203C" æ˜¯è¯¥å­—ç¬¦çš„åå…­è¿›åˆ¶ç ç‚¹å€¼ã€‚æ¢å¥è¯è¯´ï¼Œ"U+203C" è¡¨ç¤º Unicode å­—ç¬¦é›†ä¸­çš„ä¸€ä¸ªç‰¹å®šå­—ç¬¦ï¼Œå…¶ç ç‚¹ä¸º 0x203Cã€‚

UTF-8 æ˜¯ä¸€ç§å¯å˜é•¿åº¦çš„å­—ç¬¦ç¼–ç æ–¹å¼ï¼Œç”¨äºè¡¨ç¤º Unicode å­—ç¬¦ã€‚åœ¨ UTF-8 ä¸­ï¼Œæ¯ä¸ªå­—ç¬¦å¯èƒ½ç”±ä¸€ä¸ªåˆ°å››ä¸ªå­—èŠ‚ç»„æˆã€‚
è®©æˆ‘ä»¬æ¥çœ‹çœ‹å­—ç¬¦ä¸² "Dogâ€¼ğŸ¶" åœ¨ UTF-8 ç¼–ç ä¸­çš„è¡¨ç¤º:
å­—ç¬¦ "D" å¯¹åº”çš„ UTF-8 ç¼–ç æ˜¯ 0x44ã€‚
å­—ç¬¦ "o" å¯¹åº”çš„ UTF-8 ç¼–ç æ˜¯ 0x6Fã€‚
å­—ç¬¦ "g" å¯¹åº”çš„ UTF-8 ç¼–ç æ˜¯ 0x67ã€‚
å­—ç¬¦ "â€¼"ï¼ˆåŒæ„Ÿå¹å·ï¼‰å¯¹åº”çš„ UTF-8 ç¼–ç æ˜¯ 0xE280BCã€‚
å­—ç¬¦ "ğŸ¶"ï¼ˆç‹—çš„ Emojiï¼‰å¯¹åº”çš„ UTF-8 ç¼–ç æ˜¯ 0xF09F90B6ã€‚

Dogâ€¼ğŸ¶ä½¿ç”¨utf8è¡¨ç¤ºçš„è½¬æ¢åŸç†:
UTF-8 ç¼–ç çš„è½¬æ¢åŸç†æ¶‰åŠåˆ° Unicode å­—ç¬¦åˆ°å­—èŠ‚åºåˆ—çš„æ˜ å°„
1.Unicode å­—ç¬¦åˆ°ç ç‚¹çš„æ˜ å°„ï¼š (å³ D->U+0044)
é¦–å…ˆï¼Œå°†å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ª Unicode å­—ç¬¦æ˜ å°„åˆ°å…¶å¯¹åº”çš„ Unicode ç ç‚¹ã€‚
æ¯ä¸ª Unicode ç ç‚¹æ˜¯ä¸€ä¸ªå”¯ä¸€çš„æ•´æ•°å€¼ï¼Œæ ‡è¯†äº†å­—ç¬¦åœ¨ Unicode ä¸­çš„ä½ç½®ã€‚
2.ç ç‚¹åˆ° UTF-8 å­—èŠ‚åºåˆ—çš„æ˜ å°„ï¼š 
å°†æ¯ä¸ª Unicode ç ç‚¹æ˜ å°„åˆ°å…¶åœ¨ UTF-8 ç¼–ç ä¸­çš„è¡¨ç¤ºå½¢å¼ã€‚è¿™ä¸ªæ˜ å°„è§„åˆ™å¦‚ä¸‹ï¼š
å¦‚æœç ç‚¹åœ¨ U+0000 åˆ° U+007F èŒƒå›´å†…ï¼Œå®ƒç”¨ä¸€ä¸ªå­—èŠ‚è¡¨ç¤ºï¼Œå½¢å¼ä¸º 0xxxxxxxã€‚
å¦‚æœç ç‚¹åœ¨ U+0080 åˆ° U+07FF èŒƒå›´å†…ï¼Œå®ƒç”¨ä¸¤ä¸ªå­—èŠ‚è¡¨ç¤ºï¼Œå½¢å¼ä¸º 110xxxxx 10xxxxxxã€‚
å¦‚æœç ç‚¹åœ¨ U+0800 åˆ° U+FFFF èŒƒå›´å†…ï¼Œå®ƒç”¨ä¸‰ä¸ªå­—èŠ‚è¡¨ç¤ºï¼Œå½¢å¼ä¸º 1110xxxx 10xxxxxx 10xxxxxxã€‚
å¦‚æœç ç‚¹åœ¨ U+10000 åˆ° U+10FFFF èŒƒå›´å†…ï¼Œå®ƒç”¨å››ä¸ªå­—èŠ‚è¡¨ç¤ºï¼Œå½¢å¼ä¸º 11110xxx 10xxxxxx 10xxxxxx 10xxxxxxã€‚

U+203Cè½¬æˆutf-8ä¸ºä»€ä¹ˆæ˜¯226ï¼Œ128ï¼Œ188ï¼Œæ€ä¹ˆè®¡ç®—çš„:
(1)ç¡®å®šç¼–ç èŒƒå›´ï¼š æŸ¥çœ‹ Unicode ç ç‚¹èŒƒå›´ï¼ŒU+203C åœ¨ U+0800 åˆ° U+FFFF èŒƒå›´å†…ï¼Œå› æ­¤å®ƒç”¨ä¸‰ä¸ªå­—èŠ‚è¡¨ç¤ºã€‚
(2)å°† Unicode ç ç‚¹è½¬æ¢ä¸ºäºŒè¿›åˆ¶ï¼š å°† U+203C è½¬æ¢ä¸ºäºŒè¿›åˆ¶è¡¨ç¤ºã€‚U+203C çš„äºŒè¿›åˆ¶è¡¨ç¤ºæ˜¯ 0010 0000 0011 1100
å°†æ¯ä¸ªåå…­è¿›åˆ¶æ•°è½¬æ¢ä¸º 4 ä¸ªäºŒè¿›åˆ¶æ•°å­—
0x203C->0010 0000 0011 1100
(3)å¡«å……æ¯”ç‰¹å¹¶è½¬æ¢ä¸ºå­—èŠ‚ï¼š
ç¬¬ä¸€ä¸ªå­—èŠ‚ï¼š1110xxxxï¼Œå¡«å…… x ä¸º U+203C äºŒè¿›åˆ¶è¡¨ç¤ºçš„å‰å››ä½ï¼Œå¾—åˆ° 11100010ã€‚
ç¬¬äºŒä¸ªå­—èŠ‚ï¼š10xxxxxxï¼Œå¡«å…… x ä¸º U+203C äºŒè¿›åˆ¶è¡¨ç¤ºçš„ä¸­é—´å…­ä½ï¼Œå¾—åˆ° 10000000ã€‚
ç¬¬ä¸‰ä¸ªå­—èŠ‚ï¼š10xxxxxxï¼Œå¡«å…… x ä¸º U+203C äºŒè¿›åˆ¶è¡¨ç¤ºçš„æœ€åå…­ä½ï¼Œå¾—åˆ° 10111100ã€‚

3.æ‹¼æ¥å­—èŠ‚åºåˆ—ï¼š å°†æ¯ä¸ªå­—ç¬¦çš„ UTF-8 ç¼–ç å­—èŠ‚åºåˆ—æŒ‰é¡ºåºæ‹¼æ¥èµ·æ¥ï¼Œå¾—åˆ°æœ€ç»ˆçš„ UTF-8 å­—èŠ‚åºåˆ—ã€‚


--------------------------------------------------Collection Types
Organize data using arrays, sets, and dictionaries.
Arrays are ordered collections of values. 
Sets are unordered collections of unique values. 
Dictionaries are unordered collections of key-value associations.

Arrays:
When you use subscript syntax, the index you specify needs to be valid. 
For example, writing shoppingList[shoppingList.count] = "Salt" to try to append an item to the end of the array results in a runtime error.

You can also use subscript syntax to change a range of values at once, even if the replacement set of values has a different length than the range you are replacing.
shoppingList[4...6] = ["Bananas", "Apples"]
// shoppingList now contains 6 items

This method removes the item at the specified index and returns the removed item
let mapleSyrup = shoppingList.remove(at: 0)


Sets:
Hash Values for Set Types
A type must be hashable in order to be stored in a set â€” that is, the type must provide a way to compute a hash value for itself. 
A hash value is an Int value thatâ€™s the same for all objects that compare equally, such that if a == b, the hash value of a is equal to the hash value of b.
All of Swiftâ€™s basic types (such as String, Int, Double, and Bool) are hashable by default, and can be used as set value types or dictionary key types.
Enumeration case values without associated values are also hashable by default.

Note
You can use your own custom types as set value types or dictionary key types by making them conform to the Hashable protocol from the Swift standard library. 
For information about implementing the required hash(into:) method, see Hashable.

Unlike arrays, sets donâ€™t have an equivalent shorthand form.
var letters = Set<Character>()
letters = []

Swiftâ€™s Set type doesnâ€™t have a defined ordering. 
To iterate over the values of a set in a specific order, use the sorted() method, which returns the setâ€™s elements as an array sorted using the < operator.
for genre in favoriteGenres.sorted() {
    print("\(genre)")
}
// Classical
// Hip hop
// Jazz


Dictionaries:
Note
A dictionary Key type must conform to the Hashable protocol, like a setâ€™s value type.
You can also write the type of a dictionary in shorthand form as [Key: Value].

You can use subscript syntax to remove a key-value pair from a dictionary by assigning a value of nil for that key:
airports["APL"] = nil

You can also retrieve an iterable collection of a dictionaryâ€™s keys or values by accessing its keys and values properties
for airportCode in airports.keys {
    print("Airport code: \(airportCode)")
}
If you need to use a dictionaryâ€™s keys or values with an API that takes an Array instance, initialize a new array with the keys or values property:
let airportCodes = [String](airports.keys)
// airportCodes is ["LHR", "YYZ"]


--------------------------------------------------Control Flow
for-in loops with numeric ranges:
for index in 1...5 {
    print("\(index) times 5 is \(index * 5)")
}

let minutes = 60
let minuteInterval = 5
for tickMark in stride(from: 0, to: minutes, by: minuteInterval) {
    // render the tick mark every 5 minutes (0, 5, 10, 15 ... 45, 50, 55)
}

Closed ranges are also available, by using stride(from:through:by:) instead:
let hours = 12
let hourInterval = 3
for tickMark in stride(from: 3, through: hours, by: hourInterval) {
    // render the tick mark every 3 hours (3, 6, 9, 12)
}

The examples above use a for-in loop to iterate ranges, arrays, dictionaries, and strings. 
However, you can use this syntax to iterate any collection, including your own classes and collection types, as long as those types conform to the Sequence protocol.


Using the alternate syntax, known as an if expression:
let weatherAdvice = if temperatureInCelsius <= 0 {
    "It's very cold. Consider wearing a scarf."
} else if temperatureInCelsius >= 30 {
    "It's really warm. Don't forget to wear sunscreen."
} else {
    "It's not that cold. Wear a T-shirt."
}
let freezeWarning: String? = if temperatureInCelsius <= 0 {
    "It's below freezing. Watch for ice!"
} else {
    nil
}
let freezeWarning = if temperatureInCelsius <= 0 {
    "It's below freezing. Watch for ice!"
} else {
    nil as String?
}
let weatherAdvice = if temperatureInCelsius > 100 {
    throw TemperatureError.boiling
} else {
    "It's a reasonable temperature."
}


Switch:
switch <#some value to consider#> {
case <#value 1#>:
    <#respond to value 1#>
case <#value 2#>,
    <#value 3#>:
    <#respond to value 2 or 3#>
default:
    <#otherwise, do something else#>
}

let anotherCharacter: Character = "a"
let message = switch anotherCharacter {
case "a":
    "The first letter of the Latin alphabet"
case "z":
    "The last letter of the Latin alphabet"
default:
    "Some other character"
}

No Implicit Fallthrough:
Instead, the entire switch statement finishes its execution as soon as the first matching switch case is completed, without requiring an explicit break statement.
Note:
Although break isnâ€™t required in Swift, you can use a break statement to match and ignore a particular case or to break out of a matched case before that case has completed its execution.
The body of each case must contain at least one executable statement.
For readability, a compound case can also be written over multiple lines.
Note:
To explicitly fall through at the end of a particular switch case, use the fallthrough keyword

Interval Matching:
let approximateCount = 62
let countedThings = "moons orbiting Saturn"
let naturalCount: String
switch approximateCount {
case 0:
    naturalCount = "no"
case 1..<5:
    naturalCount = "a few"
case 5..<12:
    naturalCount = "several"
case 12..<100:
    naturalCount = "dozens of"
case 100..<1000:
    naturalCount = "hundreds of"
default:
    naturalCount = "many"
}

Tuples:
Alternatively, use the underscore character (_), also known as the wildcard pattern, to match any possible value.
let somePoint = (1, 1)
switch somePoint {
case (0, 0):
    print("\(somePoint) is at the origin")
case (_, 0):
    print("\(somePoint) is on the x-axis")
case (0, _):
    print("\(somePoint) is on the y-axis")
case (-2...2, -2...2):
    print("\(somePoint) is inside the box")
default:
    print("\(somePoint) is outside of the box")
}

Value Bindings:
A switch case can name the value or values it matches to temporary constants or variables, for use in the body of the case. 
This behavior is known as value binding, because the values are bound to temporary constants or variables within the caseâ€™s body.
let anotherPoint = (2, 0)
switch anotherPoint {
case (let x, 0):
    print("on the x-axis with an x value of \(x)")
case (0, let y):
    print("on the y-axis with a y value of \(y)")
case let (x, y):
    print("somewhere else at (\(x), \(y))")
}
The first case, case (let x, 0), matches any point with a y value of 0 and assigns the pointâ€™s x value to the temporary constant x.

Where:
A switch case can use a where clause to check for additional conditions.
let yetAnotherPoint = (1, -1)
switch yetAnotherPoint {
case let (x, y) where x == y:
    print("(\(x), \(y)) is on the line x == y")
case let (x, y) where x == -y:
    print("(\(x), \(y)) is on the line x == -y")
case let (x, y):
    print("(\(x), \(y)) is just some arbitrary point")
}
// Prints "(1, -1) is on the line x == -y"

Compound Cases:
let someCharacter: Character = "e"
switch someCharacter {
case "a", "e", "i", "o", "u":
    print("\(someCharacter) is a vowel")
case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
    "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
    print("\(someCharacter) is a consonant")
default:
    print("\(someCharacter) isn't a vowel or a consonant")
}
let stillAnotherPoint = (9, 0)
switch stillAnotherPoint {
case (let distance, 0), (0, let distance):
    print("On an axis, \(distance) from the origin")
default:
    print("Not on an axis")
}

Control Transfer Statements:
continue
break
fallthrough
return
throw

Labeled Statements:
<#label name#>: while <#condition#> {
   <#statements#>
}
With a loop statement, you can use a statement label with the break or continue statement to end or continue the execution of the labeled statement.

let finalSquare = 25
var board = [Int](repeating: 0, count: finalSquare + 1)
board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
var square = 0
var diceRoll = 0
gameLoop: while square != finalSquare {
    diceRoll += 1
    if diceRoll == 7 { diceRoll = 1 }
    switch square + diceRoll {
    case finalSquare:
        // diceRoll will move us to the final square, so the game is over
        break gameLoop
    case let newSquare where newSquare > finalSquare:
        // diceRoll will move us beyond the final square, so roll again
        continue gameLoop
    default:
        // this is a valid move, so find out its effect
        square += diceRoll
        square += board[square]
    }
}
print("Game over!")
Note
If the break statement above didnâ€™t use the gameLoop label, it would break out of the switch statement, 
not the while statement. Using the gameLoop label makes it clear which control statement should be terminated.
It isnâ€™t strictly necessary to use the gameLoop label when calling continue gameLoop to jump to the next iteration of the loop. 
Thereâ€™s only one loop in the game, and therefore no ambiguity as to which loop the continue statement will affect.
However, thereâ€™s no harm in using the gameLoop label with the continue statement. 
Doing so is consistent with the labelâ€™s use alongside the break statement and helps make the gameâ€™s logic clearer to read and understand.


Early Exit:
A guard statement
It can do this with a control transfer statement such as return, break, continue, or throw, 
or it can call a function or method that doesnâ€™t return, such as fatalError(_:file:line:).


Deferred Actions:
You use a defer block to write code that will be executed later, when your program reaches the end of the current scope.
var score = 1
if score < 10 {
    defer {
        print(score)
    }
    score += 5
}
Then, before exiting the if statementâ€™s scope, the deferred code is run, which prints score.
The code inside of the defer always runs, regardless of how the program exits that scope. 
That includes code like an early exit from a function, breaking out of a for loop, or throwing an error. 
This behavior makes defer useful for operations where you need to guarantee a pair of actions happen â€” like manually allocating and freeing memory, 
opening and closing low-level file descriptors, 
and beginning and ending transactions in a database â€” because you can write both actions next to each other in your code.

If you write more than one defer block in the same scope, the first one you specify is the last one to run.
if score < 10 {
    defer {
        print(score)
    }
    defer {
        print("The score is:")
    }
    score += 5
}
// Prints "The score is:"
// Prints "6"

If your program stops running â€” for example, because of a runtime error or a crash â€” deferred code doesnâ€™t execute. 
However, deferred code does execute after an error is thrown

Checking API Availability:
if #available(iOS 10, macOS 10.12, *) {
    // Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS
} else {
    // Fall back to earlier iOS and macOS APIs
}

if #available(<#platform name#> <#version#>, <#...#>, *) {
    <#statements to execute if the APIs are available#>
} else {
    <#fallback statements to execute if the APIs are unavailable#>
}

When you use an availability condition with a guard statement, it refines the availability information thatâ€™s used for the rest of the code in that code block.
@available(macOS 10.12, *)
struct ColorPreference {
    var bestColor = "blue"
}

func chooseBestColor() -> String {
    guard #available(macOS 10.12, *) else {
       return "gray"
    }
    let colors = ColorPreference()
    return colors.bestColor
}

if #available(iOS 10, *) {
} else {
    // Fallback code
}
if #unavailable(iOS 10) {
    // Fallback code
}

--------------------------------------------------How to Read the Grammar
The notation used to describe the formal grammar of the Swift programming language follows a few conventions:
An arrow (â†’) is used to mark grammar productions and can be read as â€œcan consist of.â€
Syntactic categories are indicated by italic text and appear on both sides of a grammar production rule.
Literal words and punctuation are indicated by boldface constant width text and appear only on the right-hand side of a grammar production rule.
Alternative grammar productions are separated by vertical bars (|). When alternative productions are too long to read easily, theyâ€™re broken into multiple grammar production rules on new lines.
In a few cases, regular font text is used to describe the right-hand side of a grammar production rule.
Optional syntactic categories and literals are marked by a trailing question mark, ?.

Grammar of a getter-setter block:
getter-setter-block â†’ { getter-clause setter-clause? } | { setter-clause getter-clause }
æˆ–è€…
getter-setter-block â†’ { getter-clause setter-clause? }
getter-setter-block â†’ { setter-clause getter-clause }