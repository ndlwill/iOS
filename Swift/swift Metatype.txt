https://developer.apple.com/documentation/swift/type(of:)


Returns the dynamic type of a value.
iOS 8.0+
func type<T, Metatype>(of value: T) -> Metatype

Parameters
value
The value for which to find the dynamic type.

Return Value
The dynamic type, which is a metatype instance.


You can use the type(of:) function to find the dynamic type of a value, particularly when the dynamic type is different from the static type.
The static type of a value is the known, compile-time type of the value.
The dynamic type of a value is the valueâ€™s actual type at run-time, which can be a subtype of its concrete type.



the count variable has the same static and dynamic type: Int. 
When count is passed to the printInfo(_:) function, however, 
the value parameter has a static type of Any (the type declared for the parameter) and a dynamic type of Int.

func printInfo(_ value: Any) {
    let t = type(of: value)
    print("'\(value)' of type '\(t)'")
}

let count: Int = 5
printInfo(count)
// '5' of type 'Int'

###
The dynamic type returned from type(of:) is a concrete metatype (T.Type) for a class, structure, enumeration, or other nonprotocol type T, or an existential metatype (P.Type) for a protocol or protocol composition P.
###
When the static type of the value passed to type(of:) is constrained to a class or protocol, you can use that metatype to access initializers or other static members of the class or protocol.


class Smiley {
    class var text: String {
        return ":)"
    }
}


class EmojiSmiley: Smiley {
     override class var text: String {
        return "ğŸ˜€"
    }
}


func printSmileyInfo(_ value: Smiley) {
    let smileyType = type(of: value)
    print("Smile!", smileyType.text)
}


let emojiSmiley = EmojiSmiley()
printSmileyInfo(emojiSmiley)
// Smile! ğŸ˜€
The function uses type(of:) to find the dynamic type of value, which itself is an instance of the Smiley.Type metatype.



Finding the Dynamic Type in a Generic Context:
Normally, you donâ€™t need to be aware of the difference between concrete and existential metatypes, but calling type(of:) can yield unexpected results in a generic context with a type parameter bound to a protocol.

where a generic parameter T is bound to a protocol P, the type parameter is not statically known to be a protocol type in the body of the generic function. 
As a result, type(of:) can only produce the concrete metatype P.Protocol.

When printGenericInfo(_:) is called with a string that has P as its static type, the call to type(of:) returns P.self instead of String.self (the dynamic type inside the parameter).

func printGenericInfo<T>(_ value: T) {
    let t = type(of: value)
    print("'\(value)' of type '\(t)'")
}


protocol P {}
extension String: P {}


let stringAsP: P = "Hello!"
printGenericInfo(stringAsP)
// 'Hello!' of type 'P'

This unexpected result occurs because the call to type(of: value) inside printGenericInfo(_:) must return a metatype that is an instance of T.Type, but String.self (the expected dynamic type) is not an instance of P.Type (the concrete metatype of value).
To get the dynamic type inside value in this generic context, cast the parameter to Any when calling type(of:).
func betterPrintGenericInfo<T>(_ value: T) {
    let t = type(of: value as Any)
    print("'\(value)' of type '\(t)'")
}


betterPrintGenericInfo(stringAsP)
// 'Hello!' of type 'String'


struct SwiftRocks {
    static let author = "Bruno Rocha"
    func postArticle(name: String) {}
}

let blog: SwiftRocks = SwiftRocks()
SwiftRocks.Typeæ˜¯SwiftRocksçš„å…ƒç±»å‹ã€‚
let something = type(of: blog) // SwiftRocks.Type
let author: String = something.author
let instance: SwiftRocks = something.init()


å…ƒç±»å‹ä¹Ÿå¯ä»¥ç”¨äºç›¸ç­‰æ€§æ£€æŸ¥ï¼Œåœ¨è®¾è®¡å·¥å‚æ—¶è§‰å¾—è¿™å¾ˆæ–¹ä¾¿ã€‚
func create<T: BlogPost>(blogType: T.Type) -> T {
    switch blogType {
    case is TutorialBlogPost.Type:
        return blogType.init(subject: currentSubject)
    case is ArticleBlogPost.Type:
        return blogType.init(subject: getLatestFeatures().random())
    case is TipBlogPost.Type:
        return blogType.init(subject: getKnowledge().random())
    default:
        fatalError("Unknown blog kind!")
    }
}


SwiftRocksæŒ‡çš„æ˜¯å®ä¾‹çš„ç±»å‹ï¼Œå®ƒåªå…è®¸ä½ ä½¿ç”¨å®ä¾‹å±æ€§ï¼›
å…ƒç±»å‹SwiftRocks. TypeæŒ‡çš„æ˜¯ç±»æœ¬èº«çš„ç±»å‹ï¼Œå®ƒå…è®¸ä½ ä½¿ç”¨SwiftRocksçš„ç±»å±æ€§

æ‰€ä»¥type(of:)è¿”å›å¯¹è±¡çš„å…ƒç±»å‹


è¦å°†å…ƒç±»å‹ä½œä¸ºå€¼ æ‚¨éœ€è¦é”®å…¥è¯¥ç±»å‹çš„String.self

###
Stringæ˜¯ç±»å‹ï¼Œ"Hello World" æ˜¯å®ä¾‹çš„å€¼ä¸€æ ·;String.Typeæ˜¯ç±»å‹ï¼ŒString.selfæ˜¯å…ƒç±»å‹çš„å€¼ã€‚
String.Type is the type and String.self is the value of a metatype

let intMetatype: Int.Type = Int.self
###


.selfæ˜¯è‹¹æœæ‰€è°“çš„é™æ€å…ƒç±»å‹ï¼Œå®ƒæŒ‡çš„æ˜¯å¯¹è±¡çš„ç¼–è¯‘æ—¶ç±»å‹
SwiftRocks.author å®ƒè¿˜å¯ä»¥å†™æˆæ˜¯SwiftRocks.self.authorã€‚

type(of:)å°†è¿”å›ä¸€ä¸ªåŠ¨æ€å…ƒç±»å‹ï¼Œå®ƒæ˜¯å¯¹è±¡çš„çœŸå®è¿è¡Œæ—¶ç±»å‹çš„å…ƒç±»å‹ã€‚
let myNum: Any = 1 // Compile time type of myNum is Any, but the runtime type is Int.
type(of: myNum) // Int.type

å¦‚æœå¯¹è±¡çš„å­ç±»å¾ˆé‡è¦ï¼Œä½ åº”è¯¥ä½¿ç”¨type(of:)æ¥è®¿é—®è¯¥å­ç±»çš„å…ƒç±»å‹ã€‚å¦åˆ™ï¼Œä½ å¯ä»¥ç›´æ¥é€šè¿‡.selfè®¿é—®é™æ€å…ƒç±»å‹ã€‚



åè®®å…ƒç±»å‹(Protocol Metatypes):
ä»¥ä¸‹ä»£ç å°†æ— æ³•ç¼–è¯‘
protocol MyProtocol {}
let metatype: MyProtocol.Type = MyProtocol.self // Cannot convert value of...

MyProtocol.Typeä¸å¼•ç”¨åè®®è‡ªå·±çš„å…ƒç±»å‹ï¼Œè€Œæ˜¯ä»»ä½•ç»§æ‰¿è¯¥åè®®çš„å…ƒç±»å‹ã€‚è‹¹æœç§°ä¹‹ä¸ºexistential metatypeã€‚
The reason for that is that in the context of protocols,Â MyProtocol.TypeÂ doesn't refer to the protocol's own metatype,
but the metatype of whatever type isÂ inheritingÂ that protocol. Apple calls this anÂ existential metatype.


protocol MyProtocol {}
struct MyType: MyProtocol {}
let metatype: MyProtocol.Type = MyType.self // Now works!

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œmetatypeåªèƒ½è®¿é—®MyProtocolç±»å±æ€§å’Œæ–¹æ³•ï¼Œä½†ä¼šè°ƒç”¨MyTypeçš„å®ç°ã€‚
è¦è·å–åè®®ç±»å‹æœ¬èº«çš„å…·ä½“å…ƒç±»å‹ï¼Œå¯ä»¥ä½¿ç”¨.Protocolåç¼€ã€‚è¿™ä¸åœ¨å…¶ä»–ç±»å‹ä¸Šä½¿ç”¨.TypeåŸºæœ¬ç›¸åŒã€‚
let protMetatype: MyProtocol.Protocol = MyProtocol.self