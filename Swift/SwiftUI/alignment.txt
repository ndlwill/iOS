struct TestWrappedLayout: View {
    let w: CGFloat
    var texts: [String]

    var body: some View {
        self.generateContent(in: w)
    }

    private func generateContent(in w: CGFloat) -> some View {
        var width = CGFloat.zero
        var height = CGFloat.zero

        return ZStack(alignment: .topLeading) {
            ForEach(self.texts, id: \.self) { t in
                self.item(for: t)
                    .padding([.trailing, .bottom], 4)
                    .alignmentGuide(.leading, computeValue: { d in

                        if (abs(width - d.width) > w)
                        {
                            width = 0
                            height -= d.height
                        }
                        let result = width
                        if t == self.texts.last! {
                            width = 0 //last item
                        } else {
                            width -= d.width
                        }
                        return result
                    })
                    .alignmentGuide(.top, computeValue: {d in
                        let result = height
                        if t == self.texts.last! {
                            height = 0 // last item
                        }
                        return result
                    })
            }
        }
    }

    func item(for text: String) -> some View {
        Text(text)
            .padding([.leading, .trailing], 8)
            .frame(height: 30)
            .font(.subheadline)
            .background(Color.orange)
            .foregroundColor(.white)
            .cornerRadius(15)
            .onTapGesture {
                print("ä½ å¥½å•Š")
        }
    }
}

å®¹å™¨containerä¸­çš„æ¯ä¸ªViewéƒ½æœ‰å®ƒçš„alignment guide

æˆ‘ä»¬å¯¹å®¹å™¨å†…çš„Viewsä½¿ç”¨Alignment guideã€‚
å¯¹é½å…±åˆ†ä¸ºä¸¤ç§ï¼šæ°´å¹³å¯¹é½(horizontal),åž‚ç›´å¯¹é½(vertical)

æˆ‘ä»¬æŠŠAï¼ŒBï¼ŒCæ”¾åˆ°äº†VStackä¸­ï¼ŒVStackä¸­ä½¿ç”¨çš„å¯¹é½æ–¹å¼æ˜¯æ°´å¹³å¯¹é½ï¼Œæ¯”å¦‚VStack(alignment: .center)
alignment guideè¿”å›žçš„å€¼è¡¨è¾¾çš„æ˜¯è¿™3ä¸ªviewçš„ä½ç½®å…³ç³»ï¼Œå¹¶ä¸æ˜¯è¯´Açš„è¿”å›žå€¼ä¸º0ï¼ŒAå°±ä¸åç§»ï¼Œæˆ‘ä»¬éœ€è¦æŠŠä»–ä»¬ä½œä¸ºä¸€ä¸ªæ•´ä½“æ¥çœ‹ï¼Œ
é€šè¿‡åç§»é‡æ¥æè¿°ä»–ä»¬ä¹‹é—´çš„ä½ç½®å…³ç³»ï¼Œç„¶åŽè®©ä»–ä»¬3ä¸ªviewåœ¨VStackä¸­æ•´ä½“å±…ä¸­
alignment guideæè¿°çš„æ˜¯viewsä¹‹é—´çš„ä½ç½®å…³ç³»ï¼Œç³»ç»Ÿåœ¨å¸ƒå±€çš„æ—¶å€™ï¼Œä¼šæŠŠä»–ä»¬çœ‹æˆä¸€ä¸ªæ•´ä½“ï¼Œç„¶åŽåœ¨ä½¿ç”¨frame alignment guideå¯¹æ•´ä½“è¿›è¡Œå¸ƒå±€


Container Alignment: å®¹å™¨çš„å¯¹é½æ–¹å¼ä¸»è¦æœ‰2ä¸ªç›®çš„ï¼Œé¦–å…ˆå®ƒå®šä¹‰äº†å…¶å†…éƒ¨viewsçš„éšå¼å¯¹é½æ–¹å¼ï¼Œæ²¡æœ‰ä½¿ç”¨alignmentGuides()modifierçš„viewéƒ½ä½¿ç”¨éšå¼å¯¹é½ï¼Œç„¶åŽå®šä¹‰äº†å†…éƒ¨viewsä¸­ä½¿ç”¨äº†alignmentGuides()çš„viewï¼Œåªæœ‰å‚æ•°ä¸Žå®¹å™¨å¯¹é½å‚æ•°ç›¸åŒï¼Œå®¹å™¨æ‰ä¼šæ ¹æ®è¿”å›žå€¼è®¡ç®—å¸ƒå±€
Alignment Guideï¼šå¦‚æžœè¯¥å€¼å’ŒContainer Alignmentçš„å‚æ•°ä¸åŒ¹é…ï¼Œåˆ™ä¸ä¼šç”Ÿæ•ˆ
Implicit Alignment Valueï¼šé€šå¸¸æ¥è¯´ï¼Œéšå¼å¯¹é½é‡‡ç”¨çš„å€¼éƒ½æ˜¯é»˜è®¤çš„å€¼ï¼Œç³»ç»Ÿé€šå¸¸ä¼šä½¿ç”¨å’Œå¯¹é½å‚æ•°ç›¸åŒ¹é…çš„å€¼
Explicit Alignment Valueï¼šæ˜¾å¼å¯¹é½è·Ÿéšå¼å¯¹é½ç›¸åï¼Œæ˜¯æˆ‘ä»¬è‡ªå·±ç”¨ç¨‹åºæ˜Žç¡®ç»™å‡ºçš„è¿”å›žå€¼
Frame Alignmentï¼šè¡¨ç¤ºå®¹å™¨ä¸­viewsçš„å¯¹é½æ–¹å¼ï¼ŒæŠŠviewsçœ‹ä½œä¸€ä¸ªæ•´ä½“ï¼Œæ•´ä½“åå·¦ï¼Œå±…ä¸­ï¼Œæˆ–å±…å³
Text Alignmentï¼šæŽ§åˆ¶å¤šè¡Œæ–‡æœ¬çš„å¯¹é½æ–¹å¼

éšå¼å’Œæ˜¾å¼å¯¹é½çš„åŒºåˆ«:
æ¯ä¸ªviewéƒ½æœ‰ä¸€ä¸ªalignment
å½“æˆ‘ä»¬ä½¿ç”¨.alignmentGuide()è®¾ç½®å¯¹é½æ–¹å¼æ—¶ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºæ˜¾å¼ï¼Œç›¸ååˆ™ç§°ä¹‹ä¸ºéšå¼
éšå¼çš„æƒ…å†µä¸‹ï¼Œ.alignmentGuide()çš„è¿”å›žå€¼å’Œå®ƒçˆ¶ç±»å®¹å™¨çš„å¯¹é½å‚æ•°æœ‰å…³ã€‚

å¦‚æžœæˆ‘ä»¬æ²¡æœ‰ä¸ºVStack, HStack å’Œ ZStackæä¾›alignmentå‚æ•°ï¼Œé»˜è®¤å€¼ä¸ºcenterã€‚


ViewDimensions:
func alignmentGuide(_ g: HorizontalAlignment, computeValue: @escaping (ViewDimensions) -> CGFloat) -> some View
func alignmentGuide(_ g: VerticalAlignment, computeValue: @escaping (ViewDimensions) -> CGFloat) -> some View

public struct ViewDimensions {
    public var width: CGFloat { get } // The view's width
    public var height: CGFloat { get } // The view's height

    public subscript(guide: HorizontalAlignment) -> CGFloat { get }
    public subscript(guide: VerticalAlignment) -> CGFloat { get }
    public subscript(explicit guide: HorizontalAlignment) -> CGFloat? { get }
    public subscript(explicit guide: VerticalAlignment) -> CGFloat? { get }
}
é€šè¿‡widthå’Œheight,æˆ‘ä»¬å¾ˆå®¹æ˜“èŽ·å¾—è¯¥viewçš„å®½å’Œé«˜ï¼Œè¿™åœ¨æˆ‘ä»¬è¿”å›žå¯¹é½å€¼çš„æ—¶å€™éžå¸¸æœ‰ç”¨
subscriptè¡¨æ˜Žæˆ‘ä»¬å¯ä»¥åƒè¿™æ ·è®¿é—®ï¼šd[HorizontalAlignment.leading]ã€‚

struct Example6: View {
    var body: some View {
        ZStack(alignment: .topLeading) {
            Text("Hello")
                .alignmentGuide(HorizontalAlignment.leading, computeValue: { d in return 0 })
                .alignmentGuide(.top, computeValue: { d in return 0 })
                .background(Color.green)

            Text("World")
                .alignmentGuide(.top, computeValue: { d in return 100 })
                .alignmentGuide(HorizontalAlignment.leading, computeValue: { d in return 0 })
                .background(Color.purple)

        }
        .background(Color.orange)
    }
}
ç”±äºŽæˆ‘ä»¬ç»™Text("World")è®¾ç½®äº†.alignmentGuide(.top, computeValue: { d in return 100 })ï¼Œå› æ­¤ï¼Œå®ƒå‡ºçŽ°åœ¨helloçš„ä¸Šè¾¹æ²¡ä»€ä¹ˆé—®é¢˜
å¦‚æžœæŠŠ.alignmentGuide(HorizontalAlignment.leading, computeValue: { d in return 0 })æ”¹æˆ.alignmentGuide(HorizontalAlignment.leading, computeValue: { d in return d[.top] })å‘¢
åœ¨è®¾ç½®leadingå¯¹é½çš„æ—¶å€™ä½¿ç”¨äº†topå¯¹é½çš„æ•°æ®
worldåˆå‘å·¦åç§»äº†100çš„è·ç¦»
ç±»ä¼¼d[HorizontalAlignment.leading]è¿™æ ·çš„å‚æ•°ï¼Œæˆ‘ä»¬éƒ½å¯ç®€å†™æˆd[.leading]
ä½†æ˜¯centeré™¤å¤–ï¼ŒåŽŸå› æ˜¯HorizontalAlignmentå’ŒVerticalAlignmentéƒ½æœ‰centerã€‚


extension HorizontalAlignment {
    public static let leading: HorizontalAlignment
    public static let center: HorizontalAlignment
    public static let trailing: HorizontalAlignment
}
å½“æˆ‘ä»¬ä½¿ç”¨ä¸‹æ ‡è®¿é—®æ•°æ®çš„æ—¶å€™ï¼Œæœ‰ä¸¤ç§æ–¹å¼:
d[.trailing]
d[explicit: .trailing]
d[.trailing]è¡¨ç¤ºèŽ·å–dçš„éšå¼leadingï¼Œä¹Ÿå°±æ˜¯é»˜è®¤å€¼ï¼Œé€šå¸¸æƒ…å†µä¸‹ï¼Œ.leadingçš„å€¼ä¸º0ï¼Œ.centerçš„å€¼ä¸ºwidthçš„ä¸€åŠï¼Œ.trailingçš„å€¼ä¸ºwidthã€‚

d[explicit: .trailing]è¡¨ç¤ºèŽ·å–dçš„æ˜¾å¼çš„trailingï¼Œå½“æ²¡æœ‰é€šè¿‡.alignmentGuide()æŒ‡å®šå€¼çš„æ—¶å€™ï¼Œå®ƒè¿”å›žnil

extension VerticalAlignment {
    public static let top: VerticalAlignment
    public static let center: VerticalAlignment
    public static let bottom: VerticalAlignment
    public static let firstTextBaseline: VerticalAlignment
    public static let lastTextBaseline: VerticalAlignment
}
firstTextBaselineè¡¨ç¤ºæ‰€æœ‰textçš„ä»¥å„è‡ªæœ€ä¸Šè¾¹çš„é‚£ä¸€è¡Œçš„base lineå¯¹é½ï¼ŒlastTextBaselineè¡¨ç¤ºæ‰€æœ‰textçš„ä»¥æœ€ä¸‹è¾¹çš„é‚£ä¸€è¡Œçš„base lineå¯¹é½ã€‚
å¯¹äºŽæŸä¸ªviewè€Œè¨€ï¼Œå¦‚æžœå®ƒä¸æ˜¯å¤šè¡Œæ–‡æœ¬ï¼Œåˆ™firstTextBaselineå’ŒlastTextBaselineæ˜¯ä¸€æ ·çš„ã€‚

HStack(alignment: .firstTextBaseline) {
            Text("åºŠå‰æ˜Žæœˆå…‰")
                .font(.caption)
                .frame(width: 50)
                .background(Color.orange)

            Text("ç–‘æ˜¯åœ°ä¸Šéœœ")
                .font(.body)
                .frame(width: 50)
                .background(Color.green)

            Text("ä¸¾å¤´æœ›æ˜Žæœˆ")
                .font(.largeTitle)
                .frame(width: 50)
                .background(Color.blue)
        }
ä¸Šè¾¹çš„ä»£ç éƒ½ä½¿ç”¨äº†éšå¼çš„alignment guide

æˆ‘ä»¬ç»™ç¬¬3ä¸ªtextä¸€ä¸ªæ˜¾å¼çš„alignment guideä¼šæ˜¯æ€Žä¹ˆæ ·çš„ï¼Ÿ
HStack(alignment: .lastTextBaseline) {
            Text("åºŠå‰æ˜Žæœˆå…‰")
                .font(.caption)
                .frame(width: 50)
                .background(Color.orange)

            Text("ç–‘æ˜¯åœ°ä¸Šéœœ")
                .font(.body)
                .frame(width: 50)
                .background(Color.green)

            Text("ä¸¾å¤´æœ›æ˜Žæœˆ")
                .font(.largeTitle)
                .alignmentGuide(.lastTextBaseline, computeValue: { (d) -> CGFloat in
                    d[.firstTextBaseline]
                })
                .frame(width: 50)
                .background(Color.blue)

        }
å¯¹é½æè¿°çš„æ˜¯å®¹å™¨å†…viewä¹‹é—´çš„å¸ƒå±€å…³ç³»ï¼Œç”±äºŽcomputeValueå‡½æ•°çš„è¿”å›žå€¼éƒ½æ˜¯CGFloatï¼Œå› æ­¤ä¸ç®¡æ˜¯å“ªç§å¯¹é½æ–¹å¼ï¼Œæœ€ç»ˆéƒ½æ˜¯å¾—åˆ°ä¸€ä¸ªCGFloatã€‚


å¦‚æžœæˆ‘ä»¬åœ¨textä¸­é—´åŠ å…¥ä¸€ä¸ªå…¶ä»–çš„viewå‘¢ï¼Ÿ
HStack(alignment: .firstTextBaseline) {
            Text("åºŠå‰æ˜Žæœˆå…‰")
                .font(.caption)
                .frame(width: 50)
                .background(Color.orange)

            RoundedRectangle(cornerRadius: 3)
                .foregroundColor(.green)
                .frame(width: 50, height: 40)

            Text("ç–‘æ˜¯åœ°ä¸Šéœœ")
                .font(.body)
                .frame(width: 50)
                .background(Color.green)

            Text("ä¸¾å¤´æœ›æ˜Žæœˆ")
                .font(.largeTitle)
                .alignmentGuide(.firstTextBaseline, computeValue: { (d) -> CGFloat in
                    return 0
                })
                .frame(width: 50)
                .background(Color.blue)
        }
é™¤äº†textä¹‹å¤–çš„å…¶ä»–viewï¼Œéƒ½ä½¿ç”¨bottomå¯¹é½æ–¹å¼
ä¸ç®¡æ˜¯lastTextBaselineè¿˜æ˜¯firstTextBaseline,å¸ƒå±€çš„ç®—æ³•éƒ½æ˜¯.top + computeValue ,ä¹Ÿå°±æ˜¯è¯´ä»¥å®ƒçš„é¡¶éƒ¨ä¸ºå¸ƒå±€çš„åŸºçº¿
alignment æè¿°çš„æ˜¯viewä¹‹é—´çš„å…³ç³»ï¼ŒæŠŠä»–ä»¬ä½œä¸ºä¸€ä¸ªæ•´ä½“æˆ–è€…ä¸€ç»„æ¥çœ‹å¾…


ZStackåŒæ—¶éœ€è¦ä¸¤ç§å¯¹é½æ–¹å¼
ZStack(alignment: Alignment(horizontal: .leading, vertical: .top)) { ... }
æœ¬è´¨ä¸Šï¼Œå®ƒæŠŠhorizontalå’Œverticalå°è£…åœ¨äº†ä¸€èµ·ï¼Œæˆ‘ä»¬å¹³æ—¶ç»å¸¸ç”¨çš„æ˜¯ä¸‹è¾¹è¿™ä¸ªå†™æ³•ï¼Œåªæ˜¯å†™æ³•ä¸åŒè€Œå·²
ZStack(alignment: .topLeading) { ... }



Container Alignment:
å®¹å™¨çš„å¯¹é½æ–¹å¼æŒ‡çš„æ˜¯ä¸‹è¾¹è¿™é‡Œ
VStack(alignment: .leading)
HStack(alignment: .top)
ZStack(alignment: .topLeading)

å®¹å™¨ä¸­çš„viewéƒ½èƒ½å¤Ÿç”¨.alignmentGuides()modifieræ¥æ˜¾å¼çš„è¿”å›žå¯¹é½å€¼ï¼Œ.alignmentGuides()çš„ç¬¬ä¸€ä¸ªå‚æ•°å¦‚æžœä¸ŽContainer Alignmentä¸ä¸€æ ·ï¼Œå®¹å™¨åœ¨å¸ƒå±€çš„æ—¶å€™å°±ä¼šå¿½ç•¥è¿™ä¸ªviewçš„.alignmentGuides()
å®ƒæä¾›äº†å®¹å™¨ä¸­viewçš„éšå¼alignment guide

struct Example3: View {
    @State private var alignment: HorizontalAlignment = .leading

    var body: some View {
        VStack {
            Spacer()

             VStack(alignment: alignment) {
               LabelView(title: "Athos", color: .green)
                .alignmentGuide(.leading, computeValue: { _ in 30 } )
                   .alignmentGuide(HorizontalAlignment.center, computeValue: { _ in 30 } )
                   .alignmentGuide(.trailing, computeValue: { _ in 90 } )

               LabelView(title: "Porthos", color: .red)
                   .alignmentGuide(.leading, computeValue: { _ in 90 } )
                   .alignmentGuide(HorizontalAlignment.center, computeValue: { _ in 30 } )
                   .alignmentGuide(.trailing, computeValue: { _ in 30 } )

                LabelView(title: "Aramis", color: .blue) // use implicit guide

             }

            Spacer()
            HStack {
                Button("leading") { withAnimation(.easeInOut(duration: 2)) { self.alignment = .leading }}
                Button("center") { withAnimation(.easeInOut(duration: 2)) { self.alignment = .center }}
                Button("trailing") { withAnimation(.easeInOut(duration: 2)) { self.alignment = .trailing }}
            }
        }
    }
}
å½“æˆ‘ä»¬åˆ‡æ¢container alignmentçš„å‚æ•°æ—¶ï¼Œå®ƒå†…éƒ¨çš„viewçš„alignmenté‚£äº›è¢«å¿½ç•¥ï¼Œé‚£äº›è¢«ä½¿ç”¨ã€‚


Frame Alignment:
æŠŠå®¹å™¨å†…éƒ¨çš„viewçœ‹æˆä¸€ç»„ï¼Œé‚£ä¹ˆFrame Alignmentå°±éžå¸¸å®¹æ˜“ç†è§£äº†
container alignmentåªå½±å“å®¹å™¨å†…çš„å¸ƒå±€ï¼Œè¦è®©å®¹å™¨å†…çš„viewsæ•´ä½“å·¦å¯¹é½æˆ–è€…å±…ä¸­ï¼Œéœ€è¦ä½¿ç”¨Frame Alignment.
.frame(maxWidth: .infinity, alignment: .leading)
å…³äºŽFrame Alignmentæœ‰ä¸€ç‚¹éœ€è¦ç‰¹åˆ«æ³¨æ„ï¼Œæœ‰æ—¶å€™çœ‹ä¸ŠåŽ»æˆ‘ä»¬çš„è®¾ç½®æ²¡æœ‰ç”Ÿæ•ˆ
åŽŸå› å°±æ˜¯ï¼Œåœ¨SwiftUIä¸­ï¼Œå¤§å¤šæ•°æƒ…å†µä¸‹Viewçš„å¸ƒå±€æ”¿ç­–åŸºäºŽæ”¶ç´§ç­–ç•¥ï¼Œä¹Ÿå°±æ˜¯Viewçš„å®½åº¦åªæ˜¯è‡ªå·±éœ€è¦çš„å®½åº¦ï¼Œè¿™ç§æƒ…å†µä¸‹è®¾ç½®frameå¯¹é½å½“ç„¶å°±æ²¡æœ‰æ„ä¹‰äº†ã€‚


==========Multiline Text Alignment():
å¤šè¡Œæ–‡æœ¬å¯¹é½å°±æ¯”è¾ƒç®€å•äº†


==========Interacting with the Alignment Guides:
https://gist.github.com/swiftui-lab/793ca53ad1f2f0d7eb07aa23b54d9cbf
// The SwiftUI Lab
// Website: https://swiftui-lab.com
// Article: https://swiftui-lab.com/alignment-guides
import SwiftUI

class Model: ObservableObject {
    @Published var minimumContainer = true
    @Published var extendedTouchBar = false
    @Published var twoPhases = true
    @Published var addImplicitView = false
    @Published var showImplicit = false
    
    @Published var algn: [AlignmentEnum] = [.center, .center, .center]
    @Published var delayedAlgn: [AlignmentEnum] = [.center, .center, .center]
    @Published var frameAlignment: Alignment = .center
    @Published var stackAlignment: HorizontalAlignment = .leading
    
    func nextAlignment() -> Alignment {
        if self.frameAlignment == .leading {
            return .center
        } else if self.frameAlignment == .center {
            return .trailing
        } else {
            return .leading
        }
    }
}

extension Alignment {
    var asString: String {
        switch self {
        case .leading:
            return ".leading"
        case .center:
            return ".center"
        case .trailing:
            return ".trailing"
        default:
            return "unknown"
        }
    }
}

extension HorizontalAlignment {
    var asString: String {
        switch self {
        case .leading:
            return ".leading"
        case .trailing:
            return ".trailing"
        case .center:
            return ".center"
        default:
            return "unknown"
        }
    }
}

extension HorizontalAlignment: Hashable {
    public func hash(into hasher: inout Hasher) {
        switch self {
        case .leading:
            hasher.combine(0)
        case .center:
            hasher.combine(1)
        case .trailing:
            hasher.combine(2)
        default:
            hasher.combine(3)
        }
    }
}

extension Alignment: Hashable {
    public func hash(into hasher: inout Hasher) {
        switch self {
        case .leading:
            hasher.combine(0)
        case .center:
            hasher.combine(1)
        case .trailing:
            hasher.combine(2)
        default:
            hasher.combine(3)
        }
    }
}

struct ContentView: View {
    
    var body: some View {
        Group {
            if UIDevice.current.userInterfaceIdiom == .pad
            {
                GeometryReader { proxy in
            
                    VStack(spacing: 0) {
                        HStack(spacing: 0) {
                            ControlsView().frame(width: 380).layoutPriority(1).background(Color(UIColor.secondarySystemBackground))

                            DisplayView(width: proxy.size.width - 380).frame(maxWidth: proxy.size.width - 380).clipShape(Rectangle())//.border(Color.green, width: 3)
                            
                        }.frame(height: (proxy.size.height - 300))

                        VStack {
                            CodeView().frame(height: 300)
                        }.frame(width: proxy.size.width, alignment: .center).background(Color(UIColor.secondarySystemBackground))

                        
                    }.environmentObject(Model())
                }
            } else {
                VStack(spacing: 30) {
                    Text("I need an iPad to run!")
                    Text("ðŸ˜Ÿ").scaleEffect(2)
                }.font(.largeTitle)
            }
        }
    }
}

struct ControlsView: View {
    @EnvironmentObject var model: Model
    
    var body: some View {
        
        return Form {
            HStack { Spacer(); Text("Settings").font(.title); Spacer() }
            Toggle(isOn: self.$model.minimumContainer, label: { Text("Narrow Container") })
            Toggle(isOn: self.$model.extendedTouchBar, label: { Text("Extended Bar") })
            Toggle(isOn: self.$model.twoPhases, label: { Text("Show in Two Phases") })
            Toggle(isOn: self.$model.addImplicitView, label: { Text("Include Implicitly View") })
            
            if self.model.addImplicitView {
                Toggle(isOn: self.$model.showImplicit, label: { Text("Show Implicit Guides") })//.disabled(!self.model.addImplicitView)
            }
            
            HStack {
                Text("Frame Alignment")
                Picker(selection: self.$model.frameAlignment.animation(), label: EmptyView()) {
                    Text(".leading").tag(Alignment.leading)
                    Text(".center").tag(Alignment.center)
                    Text(".trailing").tag(Alignment.trailing)
                }.pickerStyle(SegmentedPickerStyle())
            }
            
            HStack {
                Text("Stack Alignment")
                Picker(selection: self.$model.stackAlignment.animation(), label: EmptyView()) {
                    Text(".leading").tag(HorizontalAlignment.leading)
                    Text(".center").tag(HorizontalAlignment.center)
                    Text(".trailing").tag(HorizontalAlignment.trailing)
                }.pickerStyle(SegmentedPickerStyle())
            }
        }.padding(10).background(Color(UIColor.secondarySystemBackground))
    }
}

struct CodeView: View {
    @EnvironmentObject var model: Model
    
    var body: some View {
        VStack(alignment: .leading) {
            
            Text("VStack(alignment: \(self.model.stackAlignment.asString) {")
            
            CodeFragment(idx: 0)
            CodeFragment(idx: 1)
            
            if model.addImplicitView {
                VStack(alignment: .leading, spacing: 0) {
                    HStack(spacing: 0) {
                        Text("    SomeView()").foregroundColor(.primary)
                        Text(".alignmentGuide(\(self.model.stackAlignment.asString), computedValue { d in ")
                        Text("d[\(self.model.stackAlignment.asString)]").padding(5)
                        Text(" }")
                    }.foregroundColor(self.model.showImplicit ? .secondary : .clear)//.transition(AnyTransition.opacity.animation())
                }
            }
            
            CodeFragment(idx: 2)
            
            HStack(spacing: 0) {
                Text("}.frame(alignment: ")
                Text("\(self.model.frameAlignment.asString)").padding(5)
                Text(")")
            }
            
        }
        .font(Font.custom("Menlo", size: 16))
        .padding(20)
    }
}

struct CodeFragment: View {
    @EnvironmentObject var model: Model
    
    var idx: Int
    
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            HStack(spacing: 0) {
                Text("    SomeView()")
                Text(".alignmentGuide(\(self.model.stackAlignment.asString), computedValue { d in ")
                Text("\(self.model.algn[idx].asString)").padding(5).background(self.model.algn[idx] != self.model.delayedAlgn[idx] ? Color.yellow : Color.clear)
                Text(" }")
            }
        }
    }
}

struct DisplayView: View {
    @EnvironmentObject var model: Model
    let width: CGFloat
    
    var body: some View {
        
        VStack(alignment: self.model.stackAlignment, spacing: 20) {
            
            Block(algn: binding(0)).frame(width: 250)
                .alignmentGuide(self.model.stackAlignment, computeValue: { d in self.model.delayedAlgn[0].computedValue(d) })
            
            Block(algn: binding(1)).frame(width: 200)
                .alignmentGuide(self.model.stackAlignment, computeValue: { d in self.model.delayedAlgn[1].computedValue(d) })
            
            if model.addImplicitView {
                RoundedRectangle(cornerRadius: 8).fill(Color.gray).frame(width: 250, height: 50)
                    .overlay(Text("Implicitly Aligned").foregroundColor(.white))
                    .overlay(Marker(algn: AlignmentEnum.fromHorizontalAlignment(self.model.stackAlignment)).opacity(0.5))
            }
            
            Block(algn: binding(2)).frame(width: 300)
                .alignmentGuide(self.model.stackAlignment, computeValue: { d in self.model.delayedAlgn[2].computedValue(d) })
            
                        
        }.frame(width: self.model.minimumContainer ? nil : width, alignment: self.model.frameAlignment).border(Color.red)
        
    }
    
    func binding(_ idx: Int) -> Binding<AlignmentEnum> {
        return Binding<AlignmentEnum>(get: {
            self.model.algn[idx]
        }, set: { v in
            self.model.algn[idx] = v
            
            let delay = self.model.twoPhases ? 500 : 0
            
            DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(delay)) {
                withAnimation(.easeInOut(duration: 0.5)
                ) {
                    self.model.delayedAlgn[idx] = v
                }
            }
        })
    }
    
}

struct Block: View {
    @Binding var algn: AlignmentEnum
    
    let a = Animation.easeInOut(duration: 0.5)
    
    var body: some View {
        let gesture = DragGesture(minimumDistance: 0, coordinateSpace: .local)
            .onEnded({v in
                withAnimation(self.a) {
                    self.algn = .value(v.startLocation.x)
                }
            })
        
        return VStack(spacing: 0) {
            HStack {
                AlignButton(label: "L", action: { withAnimation(self.a) { self.algn = .leading } })
                Spacer()
                AlignButton(label: "C", action: { withAnimation(self.a) { self.algn = .center } })
                Spacer()
                AlignButton(label: "T", action: { withAnimation(self.a) { self.algn = .trailing } })
            }.padding(5)
                .padding(.bottom, 20)
            
        }
        .background(RoundedRectangle(cornerRadius: 8).foregroundColor(.gray))
        .overlay(TouchBar().gesture(gesture))
        .overlay(Marker(algn: algn).opacity(0.5))
    }
}

struct TouchBar: View {
    @EnvironmentObject var model: Model
    
    @State private var flag = false
    
    var body: some View {
        GeometryReader { proxy in
            RoundedRectangle(cornerRadius: 8)
                .foregroundColor(.yellow)
                .frame(width: proxy.size.width + (self.model.extendedTouchBar ? 100 : 0), height: 20)
                .offset(x: 0, y: proxy.size.height / 2.0 - 10)
        }
    }
}


struct AlignButton: View {
    let label: String
    let action: () -> ()
    
    var body: some View {
        Button(action: {
            self.action()
        }, label: {
            Text(label)
                .foregroundColor(.black)
                .padding(10)
                .background(RoundedRectangle(cornerRadius: 8).foregroundColor(.green))
        })
    }
}

struct Marker: View {
    let algn: AlignmentEnum
    
    var body: some View {
        GeometryReader { proxy in
            MarkerLine().offset(x: self.algn.asNumber(width: proxy.size.width))
        }
    }
}

struct MarkerLine: Shape {
    func path(in rect: CGRect) -> Path {
        var p = Path()
                
        p.move(to: CGPoint(x: 0, y: 0))
        p.addLine(to: CGPoint(x: 0, y: rect.maxY))
        p = p.strokedPath(.init(lineWidth: 4, lineCap: .round, lineJoin: .bevel, miterLimit: 1, dash: [6, 6], dashPhase: 3))
        
        return p
    }
}

enum AlignmentEnum: Equatable {
    case leading
    case center
    case trailing
    case value(CGFloat)
    
    var asString: String {
        switch self {
        case .leading:
            return "d[.leading]"
        case .center:
            return "d[.center]"
        case .trailing:
            return "d[.trailing]"
        case .value(let v):
            return "\(v)"
        }
    }
    
    func asNumber(width: CGFloat) -> CGFloat {
        switch self {
        case .leading:
            return 0
        case .center:
            return width / 2.0
        case .trailing:
            return width
        case .value(let v):
            return v
        }
    }
    
    func computedValue(_ d: ViewDimensions) -> CGFloat {
        switch self {
        case .leading:
            return d[.leading]
        case .center:
            return d.width / 2.0
        case .trailing:
            return d[.trailing]
        case .value(let v):
            return v
        }
    }
    
    static func fromHorizontalAlignment(_ a: HorizontalAlignment) -> AlignmentEnum {
        switch a {
        case .leading:
            return .leading
        case .center:
            return .center
        case .trailing:
            return .trailing
        default:
            return .value(0)
        }
    }
}


==========Custom Alignments:
è‡ªå®šä¹‰å¯¹é½çš„åŸºæœ¬å†™æ³•å¦‚ä¸‹ï¼š

extension HorizontalAlignment {
    private enum WeirdAlignment: AlignmentID {
        static func defaultValue(in d: ViewDimensions) -> CGFloat {
            return d.height
        }
    }

    static let weirdAlignment = HorizontalAlignment(WeirdAlignment.self)
}

å†³å®šæ˜¯horizontalè¿˜æ˜¯vertical
æä¾›ä¸€ä¸ªéšå¼å¯¹é½çš„é»˜è®¤å€¼

æ¯ä¸ªviewçš„åç§»éƒ½æ˜¯å®ƒè‡ªèº«çš„é«˜åº¦ï¼Œè¿™æ ·çš„æ•ˆæžœçœ‹ä¸ŠåŽ»è¿˜æŒºæœ‰æ„æ€ã€‚å®Œæ•´ä»£ç å¦‚ä¸‹ï¼š

struct Example4: View {
    var body: some View {
        VStack(alignment: .weirdAlignment, spacing: 10) {

            Rectangle()
                .fill(Color.primary)
                .frame(width: 1)
                .alignmentGuide(.weirdAlignment, computeValue: { d in 0 })

            ColorLabel(label: "Monday", color: .red, height: 50)
            ColorLabel(label: "Tuesday", color: .orange, height: 70)
            ColorLabel(label: "Wednesday", color: .yellow, height: 90)
            ColorLabel(label: "Thursday", color: .green, height: 40)
            ColorLabel(label: "Friday", color: .blue, height: 70)
            ColorLabel(label: "Saturday", color: .purple, height: 40)
            ColorLabel(label: "Sunday", color: .pink, height: 40)

            Rectangle()
                .fill(Color.primary)
                .frame(width: 1)
                .alignmentGuide(.weirdAlignment, computeValue: { d in 0 })
        }
    }
}

struct ColorLabel: View {
    let label: String
    let color: Color
    let height: CGFloat

    var body: some View {
        Text(label).font(.title).foregroundColor(.primary).frame(height: height).padding(.horizontal, 20)
            .background(RoundedRectangle(cornerRadius: 8).fill(color))
    }
}


----------
extension VerticalAlignment {
    private enum MyAlignment : AlignmentID {
        static func defaultValue(in d: ViewDimensions) -> CGFloat {
            return d[.bottom]
        }
    }
    static let myAlignment = VerticalAlignment(MyAlignment.self)
}

struct CustomView: View {
    @State private var selectedIdx = 1

    let days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]

    var body: some View {
            HStack(alignment: .myAlignment) {
                Image(systemName: "arrow.right.circle.fill")
                    .alignmentGuide(.myAlignment, computeValue: { d in d[VerticalAlignment.center] })
                    .foregroundColor(.green)

                VStack(alignment: .leading) {
                    ForEach(days.indices, id: \.self) { idx in
                        Group {
                            if idx == self.selectedIdx {
                                Text(self.days[idx])
                                    .transition(AnyTransition.identity)
                                    .alignmentGuide(.myAlignment, computeValue: { d in d[VerticalAlignment.center] })
                            } else {
                                Text(self.days[idx])
                                    .transition(AnyTransition.identity)
                                    .onTapGesture {
                                        withAnimation {
                                            self.selectedIdx = idx
                                        }
                                }
                            }
                        }
                    }
                }
            }
            .padding(20)
            .font(.largeTitle)
    }
}


å¦‚æžœè¦è‡ªå®šä¹‰ZStackçš„alignment:
extension VerticalAlignment {
    private enum MyVerticalAlignment : AlignmentID {
        static func defaultValue(in d: ViewDimensions) -> CGFloat {
            return d[.bottom]
        }
    }

    static let myVerticalAlignment = VerticalAlignment(MyVerticalAlignment.self)
}

extension HorizontalAlignment {
    private enum MyHorizontalAlignment : AlignmentID {
        static func defaultValue(in d: ViewDimensions) -> CGFloat {
            return d[.leading]
        }
    }

    static let myHorizontalAlignment = HorizontalAlignment(MyHorizontalAlignment.self)
}

extension Alignment {
    static let myAlignment = Alignment(horizontal: .myHorizontalAlignment, vertical: .myVerticalAlignment)
}

struct CustomView: View {
    var body: some View {
        ZStack(alignment: .myAlignment) {
            ...
        }
    }
}