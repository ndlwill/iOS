###
Use macros to generate code at compile time.
###

Macros transform your source code when you compile it, letting you avoid writing repetitive code by hand. 
During compilation, Swift expands any macros in your code before building your code as usual.

###
Expanding a macro is always an additive operation: Macros add new code, but they never delete or modify existing code.
###

Both the input to a macro and the output of macro expansion are checked to ensure they’re syntactically valid Swift code
Likewise, the values you pass to a macro and the values in code generated by a macro are checked to ensure they have the correct types.
In addition, if the macro’s implementation encounters an error when expanding that macro, the compiler treats this as a compilation error.

###
Swift has two kinds of macros:
Freestanding macros appear on their own, without being attached to a declaration.
Attached macros modify the declaration that they’re attached to.
###

You call attached and freestanding macros slightly differently, 
but they both follow the same model for macro expansion, and you implement them both using the same approach



Freestanding Macros:
To call a freestanding macro, you write a number sign (#) before its name, and you write any arguments to the macro in parentheses after its name. For example:
func myFunction() {
    print("Currently running \(#function)")
    #warning("Something's wrong")
}

In the first line, #function calls the function() macro from the Swift standard library. 
When you compile this code, Swift calls that macro’s implementation, which replaces #function with the name of the current function. 
When you run this code and call myFunction(), it prints “Currently running myFunction()”. 
In the second line, #warning calls the warning(_:) macro from the Swift standard library to produce a custom compile-time warning.

Freestanding macros can produce a value, like #function does, or they can perform an action at compile time, like #warning does.



Attached Macros:
To call an attached macro, you write an at sign (@) before its name, and you write any arguments to the macro in parentheses after its name.
Attached macros modify the declaration that they’re attached to. 
They add code to that declaration, like defining a new method or adding conformance to a protocol.
For example, consider the following code that doesn’t use macros:

struct SundaeToppings: OptionSet {
    let rawValue: Int
    static let nuts = SundaeToppings(rawValue: 1 << 0)
    static let cherry = SundaeToppings(rawValue: 1 << 1)
    static let fudge = SundaeToppings(rawValue: 1 << 2)
}
In this code, each of the options in the SundaeToppings option set includes a call to the initializer, which is repetitive and manual.

Here’s a version of this code that uses a macro instead:
@OptionSet<Int>
struct SundaeToppings {
    private enum Options: Int {
        case nuts
        case cherry
        case fudge
    }
}
This version of SundaeToppings calls an @OptionSet macro.
The macro reads the list of cases in the private enumeration, generates the list of constants for each option, and adds a conformance to the OptionSet protocol.

For comparison, here’s what the expanded version of the @OptionSet macro looks like. 
You don’t write this code, and you would see it only if you specifically asked Swift to show the macro’s expansion.
struct SundaeToppings {
    private enum Options: Int {
        case nuts
        case cherry
        case fudge
    }


    typealias RawValue = Int
    var rawValue: RawValue
    init() { self.rawValue = 0 }
    init(rawValue: RawValue) { self.rawValue = rawValue }
    static let nuts: Self = Self(rawValue: 1 << Options.nuts.rawValue)
    static let cherry: Self = Self(rawValue: 1 << Options.cherry.rawValue)
    static let fudge: Self = Self(rawValue: 1 << Options.fudge.rawValue)
}
extension SundaeToppings: OptionSet { }

All of the code after the private enumeration comes from the @OptionSet macro. 
The version of SundaeToppings that uses a macro to generate all of the static variables is easier to read and easier to maintain than the manually coded version, earlier.



Macro Declarations:
###
However, for macros, the declaration and implementation are separate.
###
A macro’s declaration contains its name, the parameters it takes, where it can be used, and what kind of code it generates. 
A macro’s implementation contains the code that expands the macro by generating Swift code.

You introduce a macro declaration with the macro keyword. For example, here’s part of the declaration for the @OptionSet macro used in the previous example:
public macro OptionSet<RawType>() =
        #externalMacro(module: "SwiftMacros", type: "OptionSetMacro")
The first line specifies the macro’s name and its arguments — the name is OptionSet, and it doesn’t take any arguments.
The second line uses the externalMacro(module:type:) macro from the Swift standard library to tell Swift where the macro’s implementation is located.
In this case, the SwiftMacros module contains a type named OptionSetMacro, which implements the @OptionSet macro.

Because OptionSet is an attached macro, its name uses upper camel case, like the names for structures and classes. 
Freestanding macros have lower camel case names, like the names for variables and functions.

Note:
Macros are always declared as public. Because the code that declares a macro is in a different module from code that uses that macro, 
there isn’t anywhere you could apply a nonpublic macro.

A macro declaration defines the macro’s roles — the places in source code where that macro can be called, and the kinds of code the macro can generate.
Every macro has one or more roles, which you write as part of the attributes at the beginning of the macro declaration.
Here’s a bit more of the declaration for @OptionSet, including the attributes for its roles:
@attached(member)
@attached(extension, conformances: OptionSet)
public macro OptionSet<RawType>() =
        #externalMacro(module: "SwiftMacros", type: "OptionSetMacro")

The @attached attribute appears twice in this declaration, once for each macro role.
The first use, @attached(member), indicates that the macro adds new members to the type you apply it to.
The @OptionSet macro adds an init(rawValue:) initializer that’s required by the OptionSet protocol, as well as some additional members.
The second use, @attached(extension, conformances: OptionSet), tells you that @OptionSet adds conformance to the OptionSet protocol.
The @OptionSet macro extends the type that you apply the macro to, to add conformance to the OptionSet protocol.


For a freestanding macro, you write the @freestanding attribute to specify its role:
@freestanding(expression)
public macro line<T: ExpressibleByIntegerLiteral>() -> T =
        /* ... location of the macro implementation... */

The #line macro above has the expression role. An expression macro produces a value, or performs a compile-time action like generating a warning.

In addition to the macro’s role, a macro’s declaration provides information about the names of the symbols that the macro generates. 
When a macro declaration provides a list of names, it’s guaranteed to produce only declarations that use those names, 
which helps you understand and debug the generated code. 
Here’s the full declaration of @OptionSet:
@attached(member, names: named(RawValue), named(rawValue),
        named(`init`), arbitrary)
@attached(extension, conformances: OptionSet)
public macro OptionSet<RawType>() =
        #externalMacro(module: "SwiftMacros", type: "OptionSetMacro")

In the declaration above, the @attached(member) macro includes arguments after the named: label for each of the symbols that the @OptionSet macro generates.
The macro adds declarations for symbols named RawValue, rawValue, and init — because those names are known ahead of time, the macro declaration lists them explicitly.
The macro declaration also includes arbitrary after the list of names, allowing the macro to generate declarations whose names aren’t known until you use the macro. 
For example, when the @OptionSet macro is applied to the SundaeToppings above, it generates type properties that correspond to the enumeration cases, nuts, cherry, and fudge.

For more information, including a full list of macro roles, see attached and freestanding in Attributes.
https://docs.swift.org/swift-book/documentation/the-swift-programming-language/attributes/


==================================================Macro Expansion:
When building Swift code that uses macros, the compiler calls the macros’ implementation to expand them.

###
Specifically, Swift expands macros in the following way:
The compiler reads the code, creating an in-memory representation of the syntax.
The compiler sends part of the in-memory representation to the macro implementation, which expands the macro.
The compiler replaces the macro call with its expanded form.
The compiler continues with compilation, using the expanded source code.

Swift 宏的展开过程:
Swift 编译器从源码中提取宏的调用，转化为原始语法树，发送给包含宏实现的编译器插件（Compiler Plug-in）
编译器插件在 独立进程 和 安全沙盒 中获取到原始语法树后，调用宏定义的实现
宏的实现完成对原始语法树的展开(expansion)，并生成新的语法树
编译器插件将新的语法树序列化后插入到源码中，参与后续的编译过程
###

To go through the specific steps, consider the following:
let magicNumber = #fourCharacterCode("ABCD")
The #fourCharacterCode macro takes a string that’s four characters long and returns an unsigned 32-bit integer that corresponds to the ASCII values in the string joined together.
The Implementing a Macro section below shows how to implement this macro.

To expand the macros in the code above, the compiler reads the Swift file and creates an in-memory representation of that code known as an abstract syntax tree, or AST.
The AST makes the code’s structure explicit, which makes it easier to write code that interacts with that structure — like a compiler or a macro implementation.
The diagram above shows how the structure of this code is represented in memory.
Each element in the AST corresponds to a part of the source code.

As part of constructing this AST, the compiler checks that the source code is valid Swift. 
For example, #fourCharacterCode takes a single argument, which must be a string. 
If you tried to pass an integer argument, or forgot the quotation mark (") at the end of the string literal, you’d get an error at this point in the process.

The compiler finds the places in the code where you call a macro, and loads the external binary that implements those macros.
For each macro call, the compiler passes part of the AST to that macro’s implementation.

The implementation of the #fourCharacterCode macro reads this partial AST as its input when expanding the macro. 
A macro’s implementation operates only on the partial AST that it receives as its input, 
meaning a macro always expands the same way regardless of what code comes before and after it. 
This limitation helps make macro expansion easier to understand, and helps your code build faster because Swift can avoid expanding macros that haven’t changed.

Swift helps macro authors avoid accidentally reading other input by restricting the code that implements macros:
1.The AST passed to a macro implementation contains only the AST elements that represent the macro, not any of the code that comes before or after it.
2.The macro implementation runs in a sandboxed environment that prevents it from accessing the file system or the network.

In addition to these safeguards, the macro’s author is responsible for not reading or modifying anything outside of the macro’s inputs. 
For example, a macro’s expansion must not depend on the current time of day.

The implementation of #fourCharacterCode generates a new AST containing the expanded code. 
Here’s what that code returns to the compiler: 
integer literal: 1145258561

When the compiler receives this expansion, it replaces the AST element that contains the macro call with the element that contains the macro’s expansion. 
After macro expansion, the compiler checks again to ensure the program is still syntactically valid Swift and all the types are correct. 
That produces a final AST that can be compiled as usual:

This AST corresponds to Swift code like this:
let magicNumber = 1145258561 as UInt32

In this example, the input source code has only one macro, 
but a real program could have several instances of the same macro and several calls to different macros. 
The compiler expands macros one at a time.

If one macro appears inside another, the outer macro is expanded first — this lets the outer macro modify the inner macro before it’s expanded.


==================================================Implementing a Macro:
###
To implement a macro, you make two components: A type that performs the macro expansion, and a library that declares the macro to expose it as API.
These parts are built separately from code that uses the macro, even if you’re developing the macro and its clients together, 
because the macro implementation runs as part of building the macro’s clients.
###

To create a new macro using Swift Package Manager, run swift package init --type macro — this creates several files, 
including a template for a macro implementation and declaration.


To add macros to an existing project, edit the beginning of your Package.swift file as follows:
Set a Swift tools version of 5.9 or later in the swift-tools-version comment
Import the CompilerPluginSupport module.
Include macOS 10.15 as a minimum deployment target in the platforms list.

The code below shows the beginning of an example Package.swift file.
// swift-tools-version: 5.9
import PackageDescription
import CompilerPluginSupport

let package = Package(
    name: "MyPackage",
    platforms: [ .iOS(.v17), .macOS(.v13)],
    // ...
)

Next, add a target for the macro implementation and a target for the macro library to your existing Package.swift file. 
For example, you can add something like the following, changing the names to match your project:

targets: [
    // Macro implementation that performs the source transformations.
    .macro(
        name: "MyProjectMacros",
        dependencies: [
            .product(name: "SwiftSyntaxMacros", package: "swift-syntax"),
            .product(name: "SwiftCompilerPlugin", package: "swift-syntax")
        ]
    ),


    // Library that exposes a macro as part of its API.
    .target(name: "MyProject", dependencies: ["MyProjectMacros"]),
]

The code above defines two targets: MyProjectMacros contains the implementation of the macros, and MyProject makes those macros available.

The implementation of a macro uses the SwiftSyntax module to interact with Swift code in a structured way, using an AST. 
If you created a new macro package with Swift Package Manager, 
the generated Package.swift file automatically includes a dependency on SwiftSyntax. 
If you’re adding macros to an existing project, add a dependency on SwiftSyntax in your Package.swift file:

dependencies: [
    .package(url: "https://github.com/apple/swift-syntax", from: "509.0.0")
],

Depending on your macro’s role, there’s a corresponding protocol from SwiftSyntax that the macro implementation conforms to. 
For example, consider #fourCharacterCode from the previous section. Here’s a structure that implements that macro:

import SwiftSyntax
import SwiftSyntaxMacros


public struct FourCharacterCode: ExpressionMacro {
    public static func expansion(
        of node: some FreestandingMacroExpansionSyntax,
        in context: some MacroExpansionContext
    ) throws -> ExprSyntax {
        guard let argument = node.argumentList.first?.expression,
              let segments = argument.as(StringLiteralExprSyntax.self)?.segments,
              segments.count == 1,
              case .stringSegment(let literalSegment)? = segments.first
        else {
            throw CustomError.message("Need a static string")
        }


        let string = literalSegment.content.text
        guard let result = fourCharacterCode(for: string) else {
            throw CustomError.message("Invalid four-character code")
        }


        return "\(raw: result) as UInt32"
    }
}


private func fourCharacterCode(for characters: String) -> UInt32? {
    guard characters.count == 4 else { return nil }


    var result: UInt32 = 0
    for character in characters {
        result = result << 8
        guard let asciiValue = character.asciiValue else { return nil }
        result += UInt32(asciiValue)
    }
    return result
}
enum CustomError: Error { case message(String) }

If you’re adding this macro to an existing Swift Package Manager project, 
add a type that acts as the entry point for the macro target and lists the macros that the target defines:

import SwiftCompilerPlugin
@main
struct MyProjectMacros: CompilerPlugin {
    var providingMacros: [Macro.Type] = [FourCharacterCode.self]
}

The #fourCharacterCode macro is a freestanding macro that produces an expression, 
so the FourCharacterCode type that implements it conforms to the ExpressionMacro protocol.
The ExpressionMacro protocol has one requirement, an expansion(of:in:) method that expands the AST.
For the list of macro roles and their corresponding SwiftSyntax protocols, see attached and freestanding in Attributes.

###
To expand the #fourCharacterCode macro, 
Swift sends the AST for the code that uses this macro to the library that contains the macro implementation. 
Inside the library, Swift calls FourCharacterCode.expansion(of:in:), 
passing in the AST and the context as arguments to the method. 
The implementation of expansion(of:in:) finds the string that was passed as an argument to #fourCharacterCode and calculates the corresponding 32-bit unsigned integer literal value.

In the example above, the first guard block extracts the string literal from the AST, assigning that AST element to literalSegment. 
The second guard block calls the private fourCharacterCode(for:) function. 
Both of these blocks throw an error if the macro is used incorrectly — the error message becomes a compiler error at the malformed call site. 
For example, if you try to call the macro as #fourCharacterCode("AB" + "CD") the compiler shows the error “Need a static string”.

The expansion(of:in:) method returns an instance of ExprSyntax, 
a type from SwiftSyntax that represents an expression in an AST.
Because this type conforms to the StringLiteralConvertible protocol, 
the macro implementation uses a string literal as a lightweight syntax to create its result. 
All of the SwiftSyntax types that you return from a macro implementation conform to StringLiteralConvertible, 
so you can use this approach when implementing any kind of macro.
###


==================================================Developing and Debugging Macros:
Macros are well suited to development using tests: They transform one AST into another AST without depending on any external state, 
and without making changes to any external state. In addition, you can create syntax nodes from a string literal, 
which simplifies setting up the input for a test. You can also read the description property of an AST to get a string to compare against an expected value. 
For example, here’s a test of the #fourCharacterCode macro from previous sections:


let source: SourceFileSyntax =
    """
    let abcd = #fourCharacterCode("ABCD")
    """

let file = BasicMacroExpansionContext.KnownSourceFile(
    moduleName: "MyModule",
    fullFilePath: "test.swift"
)

let context = BasicMacroExpansionContext(sourceFiles: [source: file])

let transformedSF = source.expand(
    macros:["fourCharacterCode": FourCharacterCode.self],
    in: context
)

let expectedDescription =
    """
    let abcd = 1145258561 as UInt32
    """

precondition(transformedSF.description == expectedDescription)

The example above tests the macro using a precondition, but you could use a testing framework instead.


==================================================https://juejin.cn/post/7249888320166903867
/*
https://juejin.cn/post/7283691376650223652
https://huishao.cc/2024/04/18/484.%E8%81%8A%E8%81%8ASwift%E4%B8%AD%E7%9A%84%E5%AE%8F/
https://juejin.cn/post/7273121437732110394
*/

由于宏的定义和实现是放在单独的 Swift Package 中，使其也同时具备了可共享的特点。 
在此之前，Swift 已经内置了很多支持在编译期自动展开的功能。如我们常用的 Property Wrapper， Result builder 等。

是因为宏的能力是基于语法树去实现的，所谓的宏展开本质也是返回一个新的语法树去生成必要的代码。

###
Swift 宏具备类型检查和语法树检查能力，能够限定宏的使用场景，还可以明确宏接受的参数类型
而对于宏的不合理使用，可以抛出诊断信息，又称为 Diagnostic
Swift 宏只能新增源码，不能删除或者修改已有的源码，从而保证宏的代码插入是可预测的
Swift 宏内部使用 SwiftSyntax 访问源码和组装新代码，确保了展开前后语法树的结构不会被破坏，也实现了类型检查和错误提示能力
###
Swift 编译器从源码中提取宏的调用，转化为原始语法树，发送给包含宏实现的编译器插件（Compiler Plug-in）
编译器插件在 独立进程 和 安全沙盒 中获取到原始语法树后，调用宏定义的实现
宏的实现完成对原始语法树的展开(expansion)，并生成新的语法树
编译器插件将新的语法树序列化后插入到源码中，参与后续的编译过程

编译器插件是一个独立进程

打开 Package 文件，我们可以看到它依赖了前面提到的 SwiftSyntax 库
除此之外，工程其实还依赖了两个库， SwiftSyntaxBuilder 和 SwiftSyntaxMacros ，这三个库的职责分别是
SwiftSyntax：提供 Swift 语法树支持
SwiftSyntaxMacros：提供实现宏所需要的协议和类型
SwiftSyntaxBuilder：为展开新代码提供便捷的语法树创建 API

整个工程的源码主要有 4 个部分:
SwiftMacroKit：包含 Swift 宏的定义，注意这里不提供实现，但是会将定义与实现连接起来
SwiftMacroKitClient：一个测试工程（所以称为 Client），可以在 main 函数里测试 SwiftMacroKit 定义的宏
SwiftMacroKitMacros：宏的核心实现部分，最终打包成 macro 产物提供给其他模块使用，例如在 SwiftMacroKit 中引用
SwiftMacroKitTests：Swift 宏的测试模块，苹果官方推荐我们采用 TDD 的方式开发我们的宏

Swift 宏分类:
按照不同宏在源码中扮演的角色（role），以及在源代码中可以扩展的不同位置，Swift 将宏分为了两大类
独立宏(Freestanding)：顾名思义，可以独立存在的宏，不依赖于已有的代码实现
绑定宏(Attached)：需要绑定到特定源码位置的宏，包括类型、枚举、方法、函数等等

独立宏:
进一步地，独立宏可以分为
表达式宏(Expression)
声明宏(Declaration)

在计算机编程中，表达式和声明是两个不同的概念
表达式表示计算和返回一个值的特定操作或语句。表达式可以包括基本的算术操作（例如：+、-、*、/ 等），逻辑操作（例如：&&、||、！等），
还可以包括函数调用、变量赋值、字面量等。表达式通常会产生一个结果值，并且可以把这个值传递给其他的表达式或语句进行操作。

声明用于将一个实体引入到程序中，例如变量、常量、函数、类、结构体、枚举等。
声明提供了实体的定义，包括其名称、类型、作用域等信息，并且告诉编译器如何在程序中创建该实体。
声明并不执行任何操作，并且不会产生结果值。而是定义程序中特定实体的属性和行为，以及该实体如何执行操作。

表达式用于执行操作并输出结果值，声明用于引入实体，并定义其属性和行为。

简单而言，表达式和声明的区别在于，表达式有一个返回值结果，而声明会引入新的实体，例如属性、类型等等
表达式的返回值是可以作为参数传递给其他函数的，而声明没有返回值，所以不能作为参数传递

var x: Int // 声明一个名为 x 的变量，类型为整数
x = 10 // 表达式，将 x 的值设置为 10
print(var y: Int) // Error: Expected expression in list of expressions
print(x = 10) // 打印结果：()

绑定宏
绑定宏也可以进一步分为 5 类，分别标识了绑定宏所绑定的对象
对等宏(peer)
访问器宏(accessor)
成员宏(member)
成员属性宏(memberAttribute)
一致性宏(conformance)
这些绑定宏的命名和它们的用法息息相关


表达式宏（Expression Macro）:
@freestanding(expression)
public macro stringify<T>(_ value: T) -> (T, String) = #externalMacro(module: "SwiftMacroKitMacros", type: "StringifyMacro")
@freestanding(expression) 修饰符表明了这个宏是一个独立表达式宏，本质上这里的 freestanding 扮演的就是宏的角色。
用到了 macro 关键字来声明一个名为 stringify 的宏，它接受一个泛型参数 T，和一个 T 类型的参数 value，同时返回一个元组，分别包含一个 T 类型的实例和一个 String 字符串
整个宏定义非常类似于一个函数
externalMacro 关键字，它类似一个独立表达式宏，因为它用到了 # 前缀符号。externalMacro 用于引用一个外部模块的宏实现，这里我们将 stringify 的实现绑定到  SwiftMacroKitMacros 模块的 StringifyMacro

@main
struct SwiftMacroKitPlugin: CompilerPlugin {
    let providingMacros: [Macro.Type] = [
        StringifyMacro.self,
    ]
}
@main 修饰的结构体 SwiftMacroKitPlugin，实际上这就是 SwiftMacroKitMacro 的 main 函数，
它实现了 CompilerPlugin 协议，并通过 providingMacros 对外暴露了 StringifyMacro 的类型，
由于所有的宏协议的核心方法都是静态方法，我们在这里不需要初始化任何宏对象，直接返回类型即可

public struct StringifyMacro: ExpressionMacro 
StringifyMacro 这个结构体，它实现了 ExpressionMacro 协议，表明它是一个表达式宏




==================================================
An excellent example of a macro allows you to validate URLs at compile time, 
returning an unwrapped value when the URL is valid:

let swiftLeeBlogURL = #URL("https://www.avanderlee.com")

you can say the underlying code looks somewhat like this:
let swiftLeeBlogURL = {
    guard let swiftLeeBlogURL = URL(string: "https://www.avanderlee.com") else {
        /// Throw compiler error
    }
    return swiftLeeBlogURL
}()

Our macro validates the URL and emits a compile-time error if the URL is invalid. 
This is an incredible use case and prevents us from running into runtime crashes when we try to unwrap an invalid URL.

In this example, we’re using a so-called freestanding expression macro. 
This is just one of the currently seven available different roles:
@freestanding(expression)
Creates a piece of code that returns a value
@freestanding(declaration)
Creates one or more declarations
@attached(peer)
Adds new declarations alongside the declaration it’s applied to
@attached(accessor)
Adds accessors to a property
@attached(memberAttribute)
Adds attributes to the declarations in the type/extension it’s applied to
@attached(member)
Adds new declarations inside the type/extension it’s applied to
@attached(conformance)
Adds conformances to the type/extension it’s applied to

As you can see, there are two main types of macros:
Freestanding: declared using the hashtag
e.g. #URL(…)
Attached: declared using the at sign
e.g. @Observable

You can attach multiple roles to a macro, depending on your requirements. 
They form a powerful toolset to extend the compiler with reusable functionality.


How to write a custom Macro:
Xcode will generate a new Swift Package containing the following structure:
An exploration library that publicly exposes the macro functionality
A client library containing a main execution file to run and test your macros
The compiler plugin containing all macro implementation details
A testing target to write tests for your implementation


Theoretically, you’ll only need the exploration library and compiler plugin definition. 
The client executable can help test your macro in isolation, so I recommend keeping that around. 
Applying test-driven development while writing your macros is helpful, meaning you’ll instantly validate your implementation via unit tests.


Defining the public Macro:
/// A macro that produces an unwrapped URL in case of a valid input URL.
/// For example,
///
///     #URL("https://www.avanderlee.com")
///
/// produces an unwrapped `URL` if the URL is valid. Otherwise, it emits a compile-time error.
@freestanding(expression)
public macro URL(_ stringLiteral: String) -> URL = #externalMacro(module: "SwiftMacrosExplorationMacros", type: "URLMacro")

Writing the URL unwrapping implementation:
After defining our public accessor, we must create a matching macro instance. 
In our case, we have to match the type name URLMacro and ensure it conforms to the ExpressionMacro protocol:

public struct URLMacro: ExpressionMacro {
    public static func expansion(
        of node: some FreestandingMacroExpansionSyntax,
        in context: some MacroExpansionContext
    ) throws -> ExprSyntax {
        print(node.argumentList.map { $0.expression })
        
        return "URL(string: \"https://www.avanderlee.com\")!"
    }
}
The above example demonstrates a hardcoded example that will always return our expected URL. 
While we’re about to make that dynamic, it’s good to have a look at the print statement output:

[
    StringLiteralExprSyntax
    ├─openQuote: stringQuote
    ├─segments: StringLiteralSegmentsSyntax
    │ ╰─[0]: StringSegmentSyntax
    │   ╰─content: stringSegment("https://www.avanderlee.com")
    ╰─closeQuote: stringQuote
]

This is an example of an abstract syntax tree and is essential for you to be aware of when developing custom macros. 
I recommend swift-ast-explorer.com as a playground to familiarize yourself with this kind of syntax.
https://swift-ast-explorer.com/

In our case, we want to extract the contents of the string literal segment.
Once we have the input string, we should use the string initializer to ensure it’s a valid URL. The implementation looks as follows:
public struct URLMacro: ExpressionMacro {
    public static func expansion(
        of node: some FreestandingMacroExpansionSyntax,
        in context: some MacroExpansionContext
    ) throws -> ExprSyntax {
        guard
            /// 1. Grab the first (and only) Macro argument.
            let argument = node.argumentList.first?.expression,
            /// 2. Ensure the argument contains of a single String literal segment.
            let segments = argument.as(StringLiteralExprSyntax.self)?.segments,
            segments.count == 1,
            /// 3. Grab the actual String literal segment.
            case .stringSegment(let literalSegment)? = segments.first
        else {
            throw URLMacroError.requiresStaticStringLiteral
        }

        /// 4. Validate whether the String literal matches a valid URL structure.
        guard let _ = URL(string: literalSegment.content.text) else {
            throw URLMacroError.malformedURL(urlString: "\(argument)")
        }

        return "URL(string: \(argument))!"
    }
}

In any case of failure, we’ll throw a custom Swift error:

enum URLMacroError: Error, CustomStringConvertible {
    case requiresStaticStringLiteral
    case malformedURL(urlString: String)

    var description: String {
        switch self {
        case .requiresStaticStringLiteral:
            return "#URL requires a static string literal"
        case .malformedURL(let urlString):
            return "The input URL is malformed: \(urlString)"
        }
    }
}

Xcode will show the error at compile time in case you’re submitting an invalid input URL
You’ll notice the error shows up before building your project.
This shows the added value macros can bring as they let you know as early as possible when writing invalid code.


Testing your Swift Macro:
Xcode automatically generates a test target for you, including an example unit test for the stringify implementation. 
We can leverage that unit test and write a custom test for a valid input URL:
func testValidURL() {
    assertMacroExpansion(
        #"""
        #URL("https://www.avanderlee.com")
        """#,
        expandedSource: #"""
        URL(string: "https://www.avanderlee.com")!
        """#,
        macros: testMacros
    )
}

The macro expansion assertion requires passing in an input string matching the macro definition. 
The expanded source matches what you will see if you expand the macro in Xcode. You can do this by right-clicking your macro and selecting “Expand Macro”:

Finally, we need to tell our assertion how to match the input macro definition with the right implementation:
let testMacros: [String: Macro.Type] = [
    "URL": URLMacro.self // #URL should use URLMacro
]


Validating compiler errors:
After validating our success case, it’s time to write a test for any emitted errors. 
We can make use of the same assertion, but we need to add an extra parameter to match the thrown failure:
func testURLStringLiteralError() {
    assertMacroExpansion(
        #"""
        #URL("https://www.avanderlee.com/\(Int.random())")
        """#,
        expandedSource: #"""

        """#,
        diagnostics: [
            DiagnosticSpec(message: "#URL requires a static string literal", line: 1, column: 1)
        ],
        macros: testMacros
    )
}
We will receive the literal error since we passed in a non-literal string. Due to the mistake, there’s no expanded source as a result.