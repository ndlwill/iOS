You can apply a declaration attribute to declarations only.


==================================================attached



==================================================resultBuilder

Apply this attribute to a class, structure, enumeration to use that type as a result builder. 
A result builder is a type that builds a nested data structure step by step. 
You use result builders to implement a domain-specific language (DSL) for creating nested data structures in a natural, declarative way.

Result-Building Methods:
A result builder implements static methods described below. 
Because all of the result builder’s functionality is exposed through static methods, 
you don’t ever initialize an instance of that type. 
A result builder must implement either the buildBlock(_:) method or both the buildPartialBlock(first:) and buildPartialBlock(accumulated:next:) methods. 
The other methods — which enable additional functionality in the DSL — are optional. 
The declaration of a result builder type doesn’t actually have to include any protocol conformance.

The description of the static methods uses three types as placeholders. 
The type Expression is a placeholder for the type of the result builder’s input, 
Component is a placeholder for the type of a partial result, 
and FinalResult is a placeholder for the type of the result that the result builder produces. 
You replace these types with the actual types that your result builder uses. 
If your result-building methods don’t specify a type for Expression or FinalResult, they default to being the same as Component.

The block-building methods are as follows:



Custom Result-Builder Attributes:
Creating a result builder type creates a custom attribute with the same name. 
You can apply that attribute in the following places:
1. On a function declaration, the result builder builds the body of the function.
2. On a variable or subscript declaration that includes a getter, the result builder builds the body of the getter.
3. On a parameter in a function declaration, the result builder builds the body of a closure that’s passed as the corresponding argument.

Applying a result builder attribute doesn’t impact ABI compatibility. 
Applying a result builder attribute to a parameter makes that attribute part of the function’s interface, 
which can affect source compatibility.


==================================================NSApplicationMain
Deprecated
This attribute is deprecated; use the main attribute instead. In Swift 6, using this attribute will be an error.

Apply this attribute to a class to indicate that it’s the app delegate. Using this attribute is equivalent to calling the NSApplicationMain(_:_:) function.

If you don’t use this attribute, supply a main.swift file with code at the top level that calls the NSApplicationMain(_:_:) function as follows:

import AppKit
NSApplicationMain(CommandLine.argc, CommandLine.unsafeArgv)

The Swift code you compile to make an executable can contain at most one top-level entry point, as discussed in Top-Level Code.
https://docs.swift.org/swift-book/documentation/the-swift-programming-language/declarations/#Top-Level-Code


==================================================unchecked
Apply this attribute to a protocol type as part of a type declaration’s list of adopted protocols to turn off enforcement of that protocol’s requirements.
The only supported protocol is Sendable.