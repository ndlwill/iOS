https://docs.swift.org/swift-book/documentation/the-swift-programming-language/expressions/#Capture-Lists

class SimpleClass {
var value: Int = 0
}
var x = SimpleClass()
var y = SimpleClass()
let closure = { [x] in
print(x.value, y.value)
}

x.value = 10
y.value = 10
closure()
// Prints "10 10"

闭包显式捕获了 x，带来的结果是：若 x 的值发生改变，闭包的运行结果也会改变；而 y 也一样。

There are two things named x in the code, a variable in the outer scope and a constant in the inner scope, but they both refer to the same object because of reference semantics.
存在两个名叫 x 的东西，一个是闭包外的变量，一个是闭包内的常量，但由于他们是引用类型，所以都指向同一个对象。
当我们「显式」地使用捕获列表 [x] 时，我们「隐式」地声明了一个新的量，一个名为 x 的常量，它的作用域是闭包内。它的显式写法是：
let closure = { [x = x] in
print(x.value, y.value)
}

或者我们也可以把它写成：
let closure = { [常量 X = x] in
print(常量 X.value)
print(x.value, y.value)
}

因此这里发生了一次声明、赋值的操作。任何的赋值操作，我们都可以认为是一次「复制」。
对引用类型来说，你像这样赋值，是复制了一次「x 所指向的对象」的引用，因此，x 和 常量 X 就指向了同一个对象；而对于值类型来说，你可以认为，一复制，整个对象就都被复制过去了。

var a = 0
var b = 0
let closure = { [a] in
print(a, b)
}

a = 10
b = 10
closure()
// Prints "0 10"

由于 [a] 相当于 [a = a]，加上 Int 是值类型，所以闭包中的 a 就是对原 a 的复制。所以当外部的 a 发生变化，内部的 a 是不会受影响的。

我们也可以把闭包写成：
let closure = { [aCopy = a] in
print(aCopy, a, b)
}

By default, a closure expression captures constants and variables from its surrounding scope with strong references to those values. 
You can use a capture list to explicitly control how values are captured in a closure.

There are two different things named a, the variable in the surrounding scope and the constant in the closure’s scope, 
but only one variable named b. 
The a in the inner scope is initialized with the value of the a in the outer scope when the closure is created, 
but their values aren’t connected in any special way. 
This means that a change to the value of a in the outer scope doesn’t affect the value of a in the inner scope, 
nor does a change to a inside the closure affect the value of a outside the closure. 
In contrast, there’s only one variable named b — the b in the outer scope — so changes from inside or outside the closure are visible in both places.

This distinction isn’t visible when the captured variable’s type has reference semantics. 
For example, there are two things named x in the code below, 
a variable in the outer scope and a constant in the inner scope, but they both refer to the same object because of reference semantics.

If the type of the expression’s value is a class, you can mark the expression in a capture list with weak or unowned to capture a weak or unowned reference to the expression’s value.
myFunction { print(self.title) }                    // implicit strong capture
myFunction { [self] in print(self.title) }          // explicit strong capture
myFunction { [weak self] in print(self!.title) }    // weak capture
myFunction { [unowned self] in print(self.title) }  // unowned capture

You can also bind an arbitrary expression to a named value in a capture list. 
The expression is evaluated when the closure is created, and the value is captured with the specified strength. For example:

// Weak capture of "self.parent" as "parent"
myFunction { [weak parent = self.parent] in print(parent!.title) }