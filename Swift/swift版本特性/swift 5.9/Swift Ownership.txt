Swift 的 Ownership（所有权）模型，是 Swift 语言在内存管理和并发安全上的一个底层基础，目的是让编译器能在编译期推理出对象的生命周期，减少运行时开销，并保证数据在并发环境下的正确性。

Swift 团队引入 Ownership Model，让编译器能静态地追踪“谁拥有数据、谁负责释放、是否允许复制”。

~Copyable 配合 consume & consuming & borrowing 使用，效仿rust

#####
sswift.org/blog/swift-5.9-released/

Ownership features can help developers fine-tune memory management behavior in performance-critical code.

The new consume operator tells Swift to deinitialize a variable and transfer its contents without copying it. 
The consuming and borrowing parameter modifiers provide hints that Swift can use to eliminate unnecessary copying and reference-counting operations when passing a parameter. 
Finally, noncopyable structs and enums allow you to create types which, like a class, 
can’t be meaningfully copied when assigned, but like a struct or enum, 
do not need to be reference-counted because only one storage location can own the instance at a time.


// consume operator to end the lifetime of a variable binding
https://github.com/swiftlang/swift-evolution/blob/main/proposals/0366-move-function.md#consume-operator-to-end-the-lifetime-of-a-variable-binding
// borrowing and consuming parameter ownership modifiers
https://github.com/swiftlang/swift-evolution/blob/main/proposals/0377-parameter-ownership-modifiers.md
// Noncopyable structs and enums
https://github.com/swiftlang/swift-evolution/blob/main/proposals/0390-noncopyable-structs-and-enums.md
#####


消费（consume / consuming）
语义：函数内部拥有值的独占所有权
行为：
可以 读取和修改值（如果类型可变）
可以 move 或 转移所有权
调用结束后，原变量在调用者处不可再使用

/*
在 Swift 的 ownership system（所有权系统）里，~Copyable 表示这个类型 不是总是可复制 (non-copyable) 的。
普通 struct 默认是 Copyable 的，也就是说你可以随意赋值、传参，它会隐式拷贝
加了 ~Copyable 后，这个类型就变成 不可随意拷贝（move-only type）。也就是说，它更像 Rust 里的 move semantics 或者 C++ 里的 unique_ptr。
这样 Swift 编译器就会强制你去管理值的唯一性和生命周期，避免像文件句柄这种系统资源被复制后多次关闭。

一般是配合 consuming 使用的。
consume 表示“消耗掉”某个值的所有权，把它的唯一所有权转移出来。之后你就不能再用原来的值了。
如果没有 ~Copyable，编译器无法保证 f 在调用后就被“唯一消耗”，因为默认 struct 是 copyable 的，你可能偷偷拷贝一份继续用，这样就破坏了资源管理。

典型场景就是 资源管理：
文件句柄 (FileHandle)
网络 socket
GPU buffer
Mutex/锁对象
这些东西都应该有 唯一所有者，不能随便复制。否则可能导致二次释放、重复关闭、未定义行为。

用 ~Copyable + consume，Swift 可以在编译期帮你防止这类错误。
~Copyable 的作用是让类型成为 move-only，不能被随意复制。
*/
struct FileHandle: ~Copyable {
    var fd: Int
}

func useFile(_ fh: consuming FileHandle) {
    print("Using fd: \(fh.fd)")   // 读取
    // 这里也可以修改 fh 内部状态
}

var fh = FileHandle(fd: 3)
useFile(fh)  // 所有权 move
// print(fh.fd) ❌ 编译报错，fh 已被消费


借用（borrowing）
语义：函数内部只借用值
行为：
只能 读取值，不能修改/消费
调用结束后，原变量仍然可用
多线程借用是允许的（只读安全）

func printFile(@borrow fh: FileHandle) {
    print("Borrowed fd: \(fh.fd)")  // 只读
    // ❌ fh.fd = 10 不能修改
}

var fh = FileHandle(fd: 3)
printFile(fh)   // 借用，调用后 fh 仍然可用

#####
所以“消费”不是只读，而是拥有独占读写权限，与借用只读完全不同。
#####