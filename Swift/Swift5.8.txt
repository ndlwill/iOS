1.功能返回部署
增加了@backDeployed(before: ...)属性，允许将修饰的功能扩展到没有将其作为应用程序二进制接口（ABI）的旧操作系统中，即在旧版本上使用新 API。
@backDeployed(before: iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4)
@backDeployed要求当前所在类型与修饰内容的访问权限不低于public
@backDeployed适用于计算属性与方法。

@backDeployed to extend function availability to older OS releases
For example, imagine that we had a new Temperature type introduced a few years back in iOS 15:
@available(iOS 15, *)
public struct Temperature {
    public var degreesCelsius: Double
    
    // ...
}

A few years later, Apple decides to implement an often requested feature in their iOS 17 SDK:
extension Temperature {
    @available(iOS 17, *)
    public var degreesFahrenheit: Double {
        return (degreesCelsius * 9 / 5) + 32
    }
}

The availability attribute marks the method as available only for iOS 17 and up.
However, the method is self-contained and could run unmodified on older OS versions as we only need the degreesCelsius input parameter.
Therefore, Apple could decide to mark the method as back deployed:
extension Temperature {
    @available(iOS 15, *)
    @backDeployed(before: iOS 17)
    public var degreesFahrenheit: Double {
        return (degreesCelsius * 9 / 5) + 32
    }
}
We’ve also updated the availability attribute since the method became available as a back-deployed function for older OS versions.

To better understand the execution of back-deployed functions, it’s good to look at the final code generated by the compiler:
print(temperature.degreesFahrenheit_bridge)

extension Temperature {
    var degreesFahrenheit_bridge: Double {
        if #available(iOS 17.0, *) {
            /// Call the original parameter since it's available on this OS version.
            return degreesFahrenheit
        } else {
            /// Use the local copy instead.
            return degreesFahrenheit_fallback
        }
    }
}
The compiler creates a bridge between the original property and the back-deployed function. 
The new bridged property replaces our original reference inside the print statement to ensure older OS versions get supported correctly.


2.[weak self]
let action = UIAction(title: "计数") { [weak self] _ in
    guard let self = self else { return }
    // Swift 5.8之前
    // self.count += 1
    // print(self.count)

    // Swift 5.8之后
    count += 1
    print(count)
}

3.取消result builders中对变量的使用限制
Swift 5.4 中引入的 result builders 对局部变量有一些限制：不能使用lazy、不能被计算、不能有观察器、不能附加属性包装等。Swift 5.8 之后解除了所有使用限制。
import SwiftUI

struct ContentView: View {
    var body: some View {
        VStack {
            lazy var name = "zhangsan"

            var age: Int {
                return 10
            }

            var sex: String = "male" {
                willSet {
                    print(newValue)
                }

                didSet {
                    print(oldValue)
                }
            }

            Text("Hello, \(name), \(age), \(sex)")

            Button("change") {
                sex = "female"
            }
        }
        .padding()
    }
}

4.支持集合类型向下类型转换
Swift 5.8 之前集合类型不支持直接向下类型转换，需要使用if let as?。Swift 5.8 之后语法上支持直接向下类型转换，但也仅仅是语法不再报错，并不能保证转换成功。
class Vehicle {
    var name: String

    init(name: String) {
        self.name = name
    }
}

class Bicycle: Vehicle {
    func run() {
        print("Bicycle \(name) Run run")
    }
}

func test(vehicles: [Vehicle]) {
    // Swift 5.8之前
    if let bicycles = vehicles as? [Bicycle] {
        for bicycle in bicycles {
            bicycle.run()
        }
    } else {
        print("error")
    }

    // Swift 5.8之后
    switch vehicles {
    case let bicycles as [Bicycle]:
        for bicycle in bicycles {
            bicycle.run()
        }
    default:
        print("default")
    }
}

5.#file与#filepath
#file的输出不再包含文件的完整路径，只包含模块与文件名，如果需要显示完整路径使用新的编译符号#filePath
func test() {
    print(#file)
    print(#filePath)
}