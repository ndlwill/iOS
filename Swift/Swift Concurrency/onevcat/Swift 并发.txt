https://onevcat.com/2021/07/swift-concurrency/


==================================================同步和异步
说到线程的执行方式时，同步 (synchronous) 和异步 (asynchronous) 是这个话题中最基本的一组概念

#####
同步操作意味着在操作完成之前，运行这个操作的线程都将被占用，直到函数最终被抛出或者返回
#####

var results: [String] = []
func addAppending(_ value: String, to string: String) {
    results.append(value.appending(string))
}

Swift 5.5 之前，所有的函数都是同步函数
同步函数，在它返回之前，运行它的线程将无法执行其他操作，或者说它不能被用来运行其他函数，必须等待当前函数执行完成后这个线程才能做其他事情。

使用的 UI 开发框架，也就是 UIKit 或者 SwiftUI，不是线程安全的
对用户输入的处理和 UI 的绘制，必须在与主线程绑定的 main runloop 中进行
假设我们希望用户界面以每秒 60 帧的速率运行，那么主线程中每两次绘制之间，所能允许的处理时间最多只有 16 毫秒 (1 / 60s)。
当主线程中要同步处理的其他操作耗时很少时 (可能耗时只有几十纳秒)，这不会造成什么问题。
但是，如果这个同步操作耗时过长的话，主线程将被阻塞。它不能接受用户输入，也无法向 GPU 提交请求去绘制新的 UI，这将导致用户界面掉帧甚至卡死。
这种“长耗时”的操作，其实是很常见的：比如从网络请求中获取数据，从磁盘加载一个大文件，或者进行某些非常复杂的加解密运算等。
如果最终的耗时超过 16 ms，对 UI 的刷新或操作的处理不得不被延后。在用户观感上，将表现为掉帧或者整个界面卡住。
Swift 5.5 之前，要解决这个问题，最常见的做法是将耗时的同步操作转换为异步操作：
把实际长时间执行的任务放到另外的线程 (或者叫做后台线程) 运行，然后在操作结束时提供运行在主线程的回调

在底层，GCD 库 (Grand Central Dispatch) 会进行线程调度，为实际耗时繁重的 Data.init(contentsOf:) 分配合适的线程。
耗时任务在主线程外进行处理，完成后再由 DispatchQueue.main 派发回主线程，并按照结果调用 completion 回调方法。

虽然我们将运行在后台线程加载数据的行为称为异步操作，但是接受回调函数作为参数的方法，其本身依然是一个###同步函数###。
这个方法在返回前仍旧会占据主线程，只不过它现在的执行时间非常短，UI 相关的操作不再受影响。


==================================================串行和并行
对于通过同步方法执行的同步操作来说，这些操作一定是以串行方式在同一线程中发生的。“做完一件事，然后再进行下一件事”

同步方法执行的同步操作，是串行的充分但非必要条件。异步操作也可能会以串行方式执行。

在不同的线程中同时执行，我们就将它称为并行 (parallel)


==================================================并发 (concurrency) 
在计算机科学中，并发指的是多个计算同时执行的特性。并发计算中涉及的同时执行，主要是若干个操作的开始和结束时间之间存在重叠。

我们可以把同一个线程中的多个操作交替运行 (这需要这类操作能够暂时被置于暂停状态) 叫做并发，这几个操作将会是分时运行的
我们也可以把在不同处理器核心中运行的任务叫做并发，此时这些任务必定是并行的。

Swift 并发
Swift 提供内建的支持，让开发者能以结构化的方式书写异步和并行的代码。并发这个术语，指的是异步和并行这一常见组合。
所以在提到 Swift 并发时，它指的就是异步和并行代码的组合。

并发编程最大的困难，以及所要解决的问题大致上只有两个：
如何确保不同运算运行步骤之间的交互或通信可以按照正确的顺序执行
如何确保运算资源在不同运算之间被安全地共享、访问和传递
第一个问题负责并发的逻辑正确，第二个问题负责并发的内存安全。

#####
Swift 5.5 设计了异步函数的书写方法，在此基础上，利用结构化并发确保运算步骤的交互和通信正确，利用 actor 模型确保共享的计算资源能在隔离的情况下被正确访问和操作。
#####


==================================================使用 async 修饰的异步函数
func loadSignature() async throws -> String {

}

异步函数的 async 关键字会帮助编译器确保两件事情：
它允许我们在函数体内部使用 await 关键字；
它要求其他人在调用这个函数时，使用 await 关键字。

这和与它处于类似位置的 throws 关键字有点相似。在使用 throws 时，它允许我们在函数内部使用 throw 抛出错误，并要求调用者使用 try 来处理可能的抛出。

try/throw 代表了函数可以被抛出，而 await 则代表了函数在此处可能会放弃当前线程，它是程序的潜在暂停点。

放弃线程的能力，意味着异步方法可以被“暂停”，这个线程可以被用来执行其他代码。
被 await 的语句将被底层机制分配到其他合适的线程，在执行完成后，之前的“暂停”将结束，异步方法从刚才的 await 语句后开始，继续向下执行。

func loadSignature() async throws -> String? {
  let (data, _) = try await URLSession.shared.data(from: someURL)
  return String(data: data, encoding: .utf8)
}


==================================================结构化并发
对于同步函数来说，线程决定了它的执行环境。而对于异步函数，则由任务 (Task) 决定执行环境。

为每一组并发任务构建出一棵结构化的任务树：
一个任务具有它自己的优先级和取消标识，它可以拥有若干个子任务并在其中执行异步函数。
当一个父任务被取消时，这个父任务的取消标识将被设置，并向下传递到所有的子任务中去。
无论是正常完成还是抛出错误，子任务会将结果向上报告给父任务，在所有子任务完成之前 (不论是正常结束还是抛出)，父任务是不会完成的。

Task.init 就可以让我们获取一个任务执行的上下文环境，它接受一个 async 标记的闭包：
struct Task<Success, Failure> where Failure : Error {
  init(
    priority: TaskPriority? = nil, 
    operation: @escaping @Sendable () async throws -> Success
  )
}


var results: [String] = []

func someSyncMethod() {
  Task {
    try await processFromScratch()
    print("Done: \(results)")
  }
}

func processFromScratch() async throws {
  let strings = try await loadFromDatabase()
  if let signature = try await loadSignature() {
    strings.forEach {
      results.append($0.appending(signature))
    }
  } else {
    throw NoSignatureError()
  }
}
在 processFromScratch 中的处理依然是串行的：对 loadFromDatabase 的 await 将使这个异步函数在此暂停，直到实际操作结束，接下来才会执行 loadSignature


我们当然会希望这两个操作可以同时进行。在两者都准备好后，再调用 appending 来实际将签名附加到数据上。
这需要任务以结构化的方式进行组织。使用 async let 绑定可以做到这一点：
func processFromScratch() async throws {
  async let loadStrings = loadFromDatabase()
  async let loadSignature = loadSignature()

  results = []

  let strings = try await loadStrings
  if let signature = try await loadSignature {
      strings.forEach {
        addAppending(signature, to: $0)
      }
  } else {
    throw NoSignatureError()
  }
}

async let 被称为异步绑定，它在当前 Task 上下文中创建新的子任务，并将它用作被绑定的异步函数 (也就是 async let 右侧的表达式) 的运行环境。
和 Task.init 新建一个任务根节点不同，async let 所创建的子任务是任务树上的叶子节点。
被异步绑定的操作会立即开始执行，即使在 await 之前执行就已经完成，其结果依然可以等到 await 语句时再进行求值。
在上面的例子中，loadFromDatabase 和 loadSignature 将被并发执行。


假设我们以前可能就做过类似的事情，并且在服务器上已经存储了所有结果，于是我们有机会在进行本地运算的同时，去尝试直接加载这些结果
func loadResultRemotely() async throws {
  // 模拟网络加载的耗时
  await Task.sleep(2 * NSEC_PER_SEC)
  results = ["data1^sig", "data2^sig", "data3^sig"]
}
除了 async let 外，另一种创建结构化并发的方式，是使用任务组 (Task group)。
我们希望在执行 loadResultRemotely 的同时，让 processFromScratch 一起运行，可以用 withThrowingTaskGroup 将两个操作写在同一个 task group 中
func someSyncMethod() {
  Task {
    await withThrowingTaskGroup(of: Void.self) { group in
      group.addTask {
        try await self.loadResultRemotely()
      }
      group.addTask(priority: .low) {
        try await self.processFromScratch()
      }    
    }          
    print("Done: \(results)")
  }
}
对于 processFromScratch，我们为它特别指定了 .low 的优先级，这会导致该任务在另一个低优先级线程中被调度。
withThrowingTaskGroup 和它的非抛出版本 withTaskGroup 提供了另一种创建结构化并发的组织方式。
当在运行时才知道任务数量时，或是我们需要为不同的子任务设置不同优先级时，我们将只能选择使用 Task Group。
在其他大部分情况下，async let 和 task group 可以混用甚至互相替代

闭包中的 group 满足 AsyncSequence 协议，它让我们可以使用 for await 的方式用类似同步循环的写法来访问异步操作的结果。
另外，通过调用 group 的 cancelAll，我们可以在适当的情况下将任务标记为取消。
比如在 loadResultRemotely 很快返回时，我们可以取消掉正在进行的 processFromScratch，以节省计算资源。


==================================================actor 模型和数据隔离
为了确保资源 (在这个例子里，是 results 指向的内存) 在不同运算之间被安全地共享和访问
以前通常的做法是将相关的代码放入一个串行的 dispatch queue 中，然后以同步的方式把对资源的访问派发到队列中去执行，这样我们可以避免多个线程同时对资源进行访问。
class Holder {
    private let queue = DispatchQueue(label: "resultholder.queue")
    private var results: [String] = []
    
    func getResults() -> [String] {
        queue.sync { results } // queue.sync 的返回值是闭包的返回值， queue.async 的返回值是 Void
    }
    
    func setResults(_ results: [String]) {
        queue.sync { self.results = results }
    }
    
    func append(_ value: String) {
        queue.sync { self.results.append(value) }
    }
}
在使用 GCD 进行并发操作时，这种模式非常常见。但是它存在一些难以忽视的问题：
凡是涉及 results 的操作，都需要使用 queue.sync 包围起来，但是编译器并没有给我们任何保证。
在一个 queue.sync 中调用另一个 queue.sync 的方法，会造成线程死锁。

Swift 并发引入了一种在业界已经被多次证明有效的新的数据共享模型，actor 模型 (参与者模型)，来解决这些问题。
可以认为 actor 就是一个“封装了私有队列”的 class。
将上面 Holder 中 class 改为 actor，并把 queue 的相关部分去掉，我们就可以得到一个 actor 类型。
它拥有引用语义
actor Holder {
  var results: [String] = []
  func setResults(_ results: [String]) {
    self.results = results
  }
    
  func append(_ value: String) {
    results.append(value)
  }
}
actor 内部会提供一个隔离域：在 actor 内部对自身存储属性或其他方法的访问，比如在 append(_:) 函数中使用 results 时，可以不加任何限制，这些代码都会被自动隔离在被封装的“私有队列”里。
但是从外部对 actor 的成员进行访问时，编译器会要求切换到 actor 的隔离域，以确保数据安全。
在这个要求发生时，当前执行的程序可能会发生暂停。编译器将自动把要跨隔离域的函数转换为异步函数，并要求我们使用 await 来进行调用。

虽然实际底层实现中，actor 并非持有一个私有队列，但是现在，你可以就这样简单理解。

非隔离标记 (nonisolated) 


==================================================
queue.sync 来确保 只有一个线程在访问 results，这是一种线程安全的做法。

同步 (sync) 写操作没问题，但读取用 sync 有阻塞风险
虽然这样能确保线程安全，但 sync 是阻塞调用，如果这个方法在多个线程上频繁读取，会降低性能。
更好的做法是：将 queue 设置为并发队列 + 用 barrier 控制写入。

目标：
使用 并发队列 来提升多线程读取性能
使用 .barrier 写操作，确保写时独占访问
class Holder {
    // 并发队列（支持并发读 + barrier 写）
    private let queue = DispatchQueue(label: "resultholder.queue", attributes: .concurrent)
    
    // 被保护的资源
    private var results: [String] = []
    
    // 线程安全的读取，允许并发
    func getResults() -> [String] {
        queue.sync {
            results
        }
    }

    // 线程安全的写入（同步 + barrier，确保独占）
    func setResults(_ newResults: [String]) {
        queue.sync(flags: .barrier) {
            self.results = newResults
        }
    }

    // 线程安全的追加（同步 + barrier）
    func append(_ value: String) {
        queue.sync(flags: .barrier) {
            self.results.append(value)
        }
    }
}
推荐用 .concurrent + barrier 而不是串行队列？
因为串行队列：
所有任务都串行执行（包括读），没有任何并发能力。
在读多写少场景下，会浪费并发性能。
而并发队列 + barrier 的做法：适合高性能多读场景。
允许并发读
写操作使用 barrier 独占执行



这种方式才会在多个线程并发执行 getResults()，这时就能体现 .concurrent 队列的威力。
“多线程异步执行 holder.getResults()，体现的是全局并发队列（DispatchQueue.global()）的并发，还是 Holder 里面那个并发队列的并发能力？”
体现的是两者的“协同”效果，但真正保障对 results 读写安全和并发访问的是 Holder 内部的并发队列。
DispatchQueue.global().async 启动了3个异步执行任务，这保证这3个任务在不同线程或时间片并发执行。
它负责调度这些任务尽可能并行运行。

Holder 内部的并发队列负责资源保护：
这些任务在调用 holder.getResults() 时，内部会通过 queue.sync（queue 是一个并发队列）来同步访问 results。
Holder 的并发队列是实际对 results 的读写加锁和管理机制。
这个并发队列允许多个读操作并发执行（因为 .sync 作用于一个 .concurrent 队列，不是串行队列）。

#####
这里“同步访问”听起来像“串行执行”，但其实并不完全是那样。
queue.sync { ... } 表示当前调用线程阻塞等待该任务执行完成，这叫“同步”。
但是 queue 是并发队列（.concurrent），它能允许多个任务并发执行。
#####

let holder = Holder()
DispatchQueue.global().async {
    print("1", holder.getResults())
}
DispatchQueue.global().async {
    print("2", holder.getResults())
}
DispatchQueue.global().async {
    print("3", holder.getResults())
}


如果多个 holder.getResults() 调用都在主线程执行，不会并发执行。
即使 queue 是并发队列，在主线程上连续调用 queue.sync {} 的多个代码块，也会串行执行，因为主线程必须等待每一个 sync 返回后才能执行下一个。
print("1", holder.getResults())
print("2", holder.getResults())
print("3", holder.getResults())
并发的能力指的是可以并发处理多个任务，但前提是你允许这么做，而 sync 会主动等待任务完成，这就限制了并发的发生。


==================================================
import Foundation

class SharedResource {
    private var data: [String] = []
    private let queue = DispatchQueue(label: "com.example.shared", attributes: .concurrent)

    func read(id: Int) {
        queue.async {
            print("🔍 [Read \(id)] 开始")
            Thread.sleep(forTimeInterval: 1)  // 模拟耗时
            print("🔍 [Read \(id)] 完成: \(self.data)")
        }
    }

    func write(value: String, id: Int) {
        queue.async(flags: .barrier) {
            print("✏️ [Write \(id)] 开始")
            Thread.sleep(forTimeInterval: 2)  // 模拟耗时写入
            self.data.append(value)
            print("✏️ [Write \(id)] 完成")
        }
    }
}

let resource = SharedResource()

// 发起多个读任务（并发）
resource.read(id: 1)
resource.read(id: 2)

// 发起写任务（barrier，应独占）
resource.write(value: "A", id: 1)

写操作（带 .barrier）在执行之前，之前已提交的所有读任务必须先完成。

read(id: 1) 和 read(id: 2) 是通过 .async 提交到并发队列 → 它们可以并发执行 
write(value: "A", id: 1) 是通过 .async(flags: .barrier) 提交的 → 它必须等前面的所有任务（包括读）都执行完，才会被执行 
在 write(value: "A") 执行期间，它会独占整个队列：不会有其他读/写插入 


==================================================
异步函数：提供语法工具，使用更简洁和高效的方式，表达异步行为。
结构化并发：提供并发的运行环境，负责正确的函数调度、取消和执行顺序以及任务的生命周期。
actor 模型：提供封装良好的数据隔离，确保并发代码的安全。