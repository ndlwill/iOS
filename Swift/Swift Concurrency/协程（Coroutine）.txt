“协程”这个概念常常在并发、异步编程中被提到，它是一种比线程更轻量、切换开销更小的执行单元。

协程（Coroutine）是一种可以在执行中被挂起（suspend）和恢复（resume）的函数或任务。
它的本质是：
一个可以中断和恢复执行的函数 —— 在执行过程中可以“暂停”，把控制权交还出去，之后再从暂停点“继续执行”。


Swift 的 async / await 机制，其底层模型就是 协程
func foo() async { ... } // 就是协程
Swift 编译器会把 async 函数编译为：
➡️ 能被挂起（suspend）和恢复（resume）的状态机，这就是协程的本质。


协程是一种能“暂停和恢复”的函数，用于实现结构化的异步代码，是现代并发编程的重要基础。


协程并不等于线程。协程是运行在线程里的任务单位，多个协程可能共享同一个线程（这就是为什么它被称为“轻量线程”）。

Task {
    await download()
    await process()
}
这个 Task 在底层就是一个协程，它：
在 await 时会 挂起自己
等待条件满足后 恢复继续执行
这一切都由 Swift 的并发运行时（Executor）来调度，不需要线程上下文切换

协程最终是在系统线程上跑的，但切换/调度是在用户态完成的（无线程切换），由语言运行时（如 Swift、Kotlin、Go）控制。


import Foundation

func heavyComputation(_ id: Int) async {
    print("Start \(id) on thread: \(Thread.current)")
    try? await Task.sleep(nanoseconds: 1_000_000_000) // 模拟挂起1秒
    print("End \(id) on thread: \(Thread.current)")
}

Task {
    async let a = heavyComputation(1)
    async let b = heavyComputation(2)
    async let c = heavyComputation(3)
    
    _ = await (a, b, c)
}

Task {} 创建的是 Swift 中的 协程（task）
async let 是多个独立协程
await 时，协程会自动挂起（暂停）自己，控制权让出
后续恢复时，运行时决定在哪个线程执行（有时还是原线程）

➡️ 整个过程不需要线程切换，调度发生在 Swift 的运行时层（用户态）。


线程调度	协程调度
由 OS（内核）管理	由 Swift runtime 管理
切换开销大	切换极小，结构体状态切换
难以预测	可控、挂起点明确（await）

#####
协程跑在线程上，但协程与协程之间切换，不需要 OS 帮忙，由语言运行时控制，在用户态完成，这就是它轻量高效的根本原因。
#####


线程（多线程）像是老师说：“你们几个同时开始做题，我来分配你们谁做谁停” → 老师控制（系统调度）
协程 像是一个学生自己说：“我做完第1题先停一下，让别人做，等会我再继续” → 自己控制何时交出控制权（程序/语言控制）
这边的学生或者说【自己控制何时交出控制权（程序/语言控制）】，其实指的就是swift运行时是吗，而不是真的写代码的程序员控制
学生“自己控制何时交出控制权”
实际上指的不是“写代码的你手动控制”，
而是语言本身（如 Swift）在运行时自动完成调度控制。

这个“学生”不是你（程序员），
而是 Swift 生成的协程代码本身，
它知道在什么地方（比如 await 处）该暂停、保存状态，然后挂起。

所以准确地说：
“控制权交出与恢复” → 由 Swift 的运行时系统 完成
“你决定哪里可以挂起” → 是你通过 await 告诉编译器
编译器：
在编译期会分析你的 async/await，生成协程状态机（状态保存点）
在运行时由 executor 调度，执行、挂起、恢复

例子：
func fetch() async {
    print("start")
    let data = await download() // <-- 你在这告诉编译器 “这里可以暂停”
    print("done", data)
}
你在这里的行为是：
告诉 Swift：这行可以挂起（用 await 写出来）
真正怎么暂停、保存、恢复、调度协程：全是 Swift 编译器 + 运行时 在做