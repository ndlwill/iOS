https://github.com/apple/swift-evolution
https://github.com/apple/swift-evolution/tree/main/proposals

https://www.avanderlee.com/swift/asyncthrowingstream-asyncstream/


AsyncThrowingStream and AsyncStream are part of the concurrency framework introduced in Swift 5.5 due to SE-314.
https://github.com/swiftlang/swift-evolution/blob/main/proposals/0314-async-stream.md


#####
Async streams allow you to replace existing code that is based on closures or Combine publishers.
#####

AsyncSequence 是 Swift 5.5 引入的 异步序列协议
可以使用 for await 循环迭代异步元素。
每个元素可能来自异步事件（网络、定时器、通知等）。
类似于 Sequence，但支持 await 异步等待。
struct Counter: AsyncSequence {
    typealias Element = Int
    let max: Int
    
    struct AsyncIterator: AsyncIteratorProtocol {
        let max: Int
        var current = 0
        
        mutating func next() async -> Int? {
            guard current < max else { return nil }
            current += 1
            try? await Task.sleep(nanoseconds: 500_000_000) // 0.5s
            return current
        }
    }
    
    func makeAsyncIterator() -> AsyncIterator {
        AsyncIterator(max: max)
    }
}

// 使用
for await number in Counter(max: 3) {
    print(number)
}
// 输出：1 2 3，每次间隔0.5秒
结论：AsyncSequence 是抽象概念，它定义了异步获取元素的协议。


AsyncStream：异步序列的具体实现
struct AsyncStream<Element>: AsyncSequence
AsyncStream 是 Swift 标准库提供的一个 异步序列实现，可以通过外部推送值的方式生成元素，常用于事件流。
提供 AsyncStream.Continuation 对象：
yield(_:) → 推送一个元素
finish() → 完成序列
terminate() → 异常终止
支持 自动清理（RAII），当 Continuation 被释放时，流会自动结束。
let stream = AsyncStream<String> { continuation in
    DispatchQueue.global().asyncAfter(deadline: .now() + 1) {
        continuation.yield("Hello")
    }
    DispatchQueue.global().asyncAfter(deadline: .now() + 2) {
        continuation.yield("World")
        continuation.finish()
    }
}

Task {
    for await message in stream {
        print(message)
    }
}
// 输出：Hello （1秒后）
//      World （2秒后）


AsyncSequence：
封装异步生成的元素，如计时器、网络流、异步文件读取。

AsyncStream：
把传统回调/代理转换成异步序列：
    NotificationCenter 事件
    UI 控件事件（按钮点击）
    WebSocket 消息
异步队列、生产者-消费者模型
类似 Rust / Go 的 channel


AsyncStream迭代逻辑：
AsyncStream 内部维护一个 事件队列，以及一个 Continuation 对象（AsyncStream.Continuation）。
当你调用 yield(_:) 时，会把元素加入队列。
AsyncStream.Iterator 的 next() 方法会从队列中异步取出元素。
当队列为空时，next() 会 挂起，等待新的元素或 finish。

注意：虽然内部有 Continuation 对象，但它只是生产者接口，不是实现 AsyncSequence 的对象。真正实现 AsyncSequence 的是 AsyncStream 本身和它的 Iterator。

stream 直接就是 AsyncSequence 类型，可以被 for await 使用。
Continuation 只是辅助生成元素

AsyncStream = 可迭代的异步序列
Continuation = “生产端”接口
Iterator = “消费端”迭代器


#####
Continuation 是 AsyncStream 的“生产端接口”，用来 向 AsyncStream 推送元素或结束流。
AsyncStream 本身是异步序列（消费者可以用 for await 遍历）。
Continuation 让你在任意时刻把新元素放进序列，或者通知序列结束。
它是一种 生产者-消费者模型的桥梁
#####


回调转异步流:
let stream = AsyncStream<Int> { continuation in
    timer.schedule { value in
        continuation.yield(value)
    }
}

WebSocket / 网络事件:
let stream = AsyncStream<Message> { continuation in
    websocket.onReceive = { msg in
        continuation.yield(msg)
    }
}

RAII 自动清理:
let stream = AsyncStream<Int> { continuation in
    // 当 continuation 被释放时，AsyncStream 自动 finish
}


[Producer] --yield--> [AsyncStream.Continuation] --push--> [AsyncStream Queue] --next()--> [Consumer]
Producer：你的业务逻辑、回调、计时器等
Continuation：发送数据、结束流、通知终止
AsyncStream Queue：内部缓冲队列
Consumer：for await 循环或 Task


==================================================What is an AsyncThrowingStream?
#####
You can see an AsyncThrowingStream as a stream of elements that could potentially result in a thrown error. 
Values deliver over time, and the stream can be closed by a finish event. 
A finish event could either be a success or a failure once an error occurs.
#####

==================================================What is an AsyncStream? // 异步流
#####
An AsyncStream is similar to the throwing variant but will never result in a throwing error.
A non-throwing async stream finishes based on an explicit finished call or when the stream cancels.
#####

==================================================How to use AsyncThrowingStream:
#####
An AsyncThrowingStream can be an excellent replacement for existing code based upon closures like progress and completion handlers. 
AsyncThrowingStream 可以很好地替代现有的基于闭包（例如进度处理程序和完成处理程序）的代码
#####

struct FileDownloader {
    enum Status {
        case downloading(Float)
        case finished(Data)
    }

    func download(_ url: URL, progressHandler: (Float) -> Void, completion: (Result<Data, Error>) -> Void) throws {
        // .. Download implementation
    }
}
The file downloader takes a URL, reports progress, and completes with a result containing the downloaded data or an error on failure.

The file downloader reports a stream of values during the file download. 
In this case, it’s reporting a stream of status values to report the current status of the running download.
The FileDownloader is a perfect example of a piece of code that you can rewrite to use AsyncThrowingStream.
Though, rewriting requires you to rewrite your code at the implementation level as well, so let’s define an overload method instead:

extension FileDownloader {
    func download(_ url: URL) -> AsyncThrowingStream<Status, Error> {
        return AsyncThrowingStream { continuation in
            do {
                try self.download(url, progressHandler: { progress in
                    continuation.yield(.downloading(progress))
                }, completion: { result in
                    switch result {
                    case .success(let data):
                        continuation.yield(.finished(data))
                        continuation.finish()
                    case .failure(let error):
                        continuation.finish(throwing: error)
                    }
                })
            } catch {
                continuation.finish(throwing: error)
            }
        }
    }
}

#####
As you can see, we wrapped the download method inside an AsyncThrowingStream. 
We describe the stream’s type of value Status as a generic, allowing us to continue the stream with status updates.
We will finish the stream by throwing an error whenever an error occurs.
In the case of the completion handler, we’re either finishing by throwing an error or following up the yield with data with a non-throwing finish callback:
#####

switch result {
case .success(let data):
    continuation.yield(.finished(data))
    continuation.finish()
case .failure(let error):
    continuation.finish(throwing: error)
}
#####
It’s essential to not forget about the finish() callback after you’ve received the final status update.
Otherwise, we will keep the stream alive, and code at the implementation level will never continue.
#####

We could rewrite the above code by making use of another yield method, accepting a Result enum as an argument:
continuation.yield(with: result.map { .finished($0) })
continuation.finish()

The rewrite simplifies our code and takes away the switch case. 
We do have to map our Result enum to match the expected Status value. 
Our stream will finish after throwing the contained error if we yield a failing result.


==================================================Iterating over an AsyncThrowingStream:
You can start iterating over the stream of values once you’ve configured your async throwing stream.
do {
    for try await status in download(url) {
        switch status {
        case .downloading(let progress):
            print("Downloading progress: \(progress)")
        case .finished(let data):
            print("Downloading completed with data: \(data)")
        }
    }
    print("Download finished and stream closed")
} catch {
    print("Download failed with \(error)")
}

#####
We handle any status update, and we can use the catch closure to handle any occurred errors.
You can iterate using a for ... in loop based on the AsyncSequence interface, which works the same for an AsyncStream.
#####

The print statements in the above code example help you understand the lifecycle of an AsyncThrowingStream. 
You can replace the print statements to handle the progress updates and process the data to visualize it for your users.


==================================================Debugging an AsyncStream:
If a stream fails to report values, we could debug the stream’s yield callbacks by placing breakpoints.
Though it could also be that the above “Download finished and stream closed” print statement won’t call, 
which means your code at the implementation level never continues. 
The latter could be a result of an unfinished stream.

To validate, we could make use of the onTermination callback:
func download(_ url: URL) -> AsyncThrowingStream<Status, Error> {
    return AsyncThrowingStream { continuation in

        /// Configure a termination callback to understand the lifetime of your stream.
        continuation.onTermination = { @Sendable status in
            print("Stream terminated with status \(status)")
        }

        // ..
    }
}
#####
The callback is called on termination of the stream and will tell you whether your stream is still alive or not.
#####
In case of a thrown error, the output could look as follows:
Stream terminated with status finished(Optional(FileDownloader.FileDownloadingError.example))
The above output will only be possible when using an AsyncThrowingStream. 

In the case of a regular AsyncStream, the finished output looks as follows:
Stream terminated with status finished

While the result of cancellation looks like this for both types of streams:
Stream terminated with status cancelled

You can also use this termination callback for any cleanup after the stream finishes. 
Examples could be removing any observers or cleaning disk space after the file download.


==================================================Canceling an AsyncStream:
An AsyncStream or AsyncThrowingStream can cancel due to an enclosing task getting canceled.
let task = Task.detached {
    do {
        for try await status in download(url) {
            switch status {
            case .downloading(let progress):
                print("Downloading progress: \(progress)")
            case .finished(let data):
                print("Downloading completed with data: \(data)")
            }
        }
    } catch {
        print("Download failed with \(error)")
    }
}
task.cancel()

A stream cancels when going out of scope or when the enclosing task cancels. 
the cancellation will trigger the onTermination callback accordingly.


An AsyncThrowingStream or AsyncStream is a great way to rewrite existing code based on closures to async-await supporting alternatives.
You can deliver a continuous stream of values and finish a stream on success or failure.
You can iterate values on the implementation level using a for loop based on the AsyncSequence APIs.