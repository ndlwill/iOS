ç‰ˆæœ¬ Aï¼ˆTask è¢« awaitï¼‰
let t = Task {
    let a = try await fetchA()
    let b = try await fetchB()
}
try await t.value
ğŸ‘‰ æ˜¯ç»“æ„åŒ–å¹¶å‘ ï¼Ÿï¼Ÿï¼Ÿ // ###å¥½åƒä¸ç®—ç»“æ„åŒ–å¹¶å‘ï¼Œæˆ‘è§‰å¾—###

ç‰ˆæœ¬ Bï¼ˆTask fire-and-forgetï¼‰
Task {
    let a = try await fetchA()
    let b = try await fetchB()
}
ğŸ‘‰ ä¸æ˜¯ç»“æ„åŒ–å¹¶å‘


==================================================


https://www.avanderlee.com/swift/what-is-structured-concurrency/

What is Structured Concurrency?
When we talk about Swift Concurrency, we also often mention Structured Concurrency.

#####
Before async/await, we wrote our asynchronous methods using closures and Grand Central Dispatch (GCD). 
#####
This worked well but often resulted in a so-called closure hellâ€”missing an overview due to chained closures. 
Structured concurrency makes asynchronous code easier to follow, but we still have unstructured tasks. 


==================================================What does Structured Concurrency stand for?
#####
Structured Concurrency is a model that makes asynchronous code easier to read, maintain, and reason about. 

Before structured concurrency, asynchronous code often relied on callback hell or manually managed tasks using DispatchQueue or OperationQueue. 
This led to scattered execution flows, making it hard to understand the order of execution.

With structured concurrency, Swift ensures that child tasks stay within a defined scope, meaning:
1. Tasks are created and awaited in a clear, structured wayâ€”from top to bottom.
2. The parent task waits for child tasks to finish before continuing.
3. Errors are automatically propagated, reducing the need for manual error handling across multiple completion handlers.

Especially error handling is so much easier with structured concurrency. 
Youâ€™ll no longer have the optional error parameters inside closures or endless error unwrapping that would clutter your code.
#####


==================================================Structured Concurrency in action // ç»“æ„åŒ–å¹¶å‘çš„å®é™…åº”ç”¨
Fetching data with closures:
Without structured concurrency, we would use traditional callbacks. This could result in the following code example:

func fetchData(completion: @escaping (String) -> Void) {
    let seconds = 1.0 // Simulating network delay
    DispatchQueue.global().asyncAfter(deadline: .now() + seconds) {
        completion("Data")
    }
}

func loadData() {
    fetchData { data1 in
        fetchData { data2 in
            fetchData { data3 in
                print("Finished loading: \(data1), \(data2), \(data3)")
            }
        }
    }
}

There are a few problems with this approach:
The indentation grows deeper with every nested callback (callback hell).
Hard to follow the order of execution.
Error handling gets complicated.

The code has already become quite complicated. We could use the result enum instead of the error, but the code would not improve:
func fetchData(completion: @escaping (Result<String, Error>) -> Void) {
    let seconds = 1.0 // Simulating network delay
    DispatchQueue.global().asyncAfter(deadline: .now() + seconds) {
        completion(.success("Data"))
    }
}

func loadData() {
    fetchData { result1 in
        switch result1 {
        case .success(let data1):
            fetchData { result2 in
                switch result2 {
                case .success(let data2):
                    fetchData { result3 in
                        switch result1 {
                        case .success(let data3):
                            fetchData { result2 in
                                print("Finished loading: \(data1), \(data2), \(data3)")
                            }
                        case .failure:
                            print("Request 3 failed!")
                        }
                    }
                case .failure:
                    print("Request 2 failed!")
                }
            }
        case .failure:
            print("Request 1 failed!")
        }
    }
}


==================================================Fetching data with Structured Concurrency (async/await)
func fetchData() async throws -> String {
    try await Task.sleep(for: .seconds(1)) // Simulating network delay
    return "Data"
}

func loadData() async throws { // åŸå§‹ä»£ç åªæ˜¯ä¸²è¡Œçš„å¼‚æ­¥è°ƒç”¨ï¼Œä¸å±äºç»“æ„åŒ–å¹¶å‘ã€‚
    let data1 = try await fetchData()
    let data2 = try await fetchData()
    let data3 = try await fetchData()
    
    print("Finished loading: \(data1), \(data2), \(data3)")
}

è¿™ä¸‰ä¸ª fetchData() æ˜¯é¡ºåºæ‰§è¡Œçš„ï¼Œæ¯ä¸ªéƒ½ç­‰ä¸Šä¸€ä¸ªå®Œæˆæ‰å¼€å§‹ä¸‹ä¸€ä¸ªï¼Œæ²¡æœ‰å½¢æˆâ€œå¤šä¸ªå­ä»»åŠ¡å¹¶å‘æ‰§è¡Œå¹¶åœ¨ä½œç”¨åŸŸæ”¶æ‹¢â€çš„ç»“æ„ã€‚æ‰€ä»¥è¿™ä¸ªä¾‹å­ä¸ç®—ä¸¥æ ¼æ„ä¹‰ä¸Šçš„â€œç»“æ„åŒ–å¹¶å‘â€

ç»“æ„åŒ–å¹¶å‘ï¼ˆstructured concurrencyï¼‰
æ ¸å¿ƒæ€æƒ³ï¼šåœ¨ä¸€ä¸ªä½œç”¨åŸŸå†…åˆ›å»ºå¤šä¸ªå­ä»»åŠ¡ï¼ˆtasksï¼‰ï¼Œä½œç”¨åŸŸé€€å‡ºæ—¶å®ƒä»¬å¿…é¡»éƒ½ç»“æŸï¼ˆæˆåŠŸæˆ–æŠ›é”™ï¼‰ã€‚
Swift æä¾›çš„ä¸»è¦å·¥å…·ï¼šasync letã€withTaskGroupã€withThrowingTaskGroupã€‚
ç‰¹ç‚¹æ˜¯**â€œå¹¶å‘å¯åŠ¨ + è‡ªåŠ¨æ”¶æ‹¢â€**ï¼Œä¸ä¼šå‡ºç°æ‚¬ç©ºä»»åŠ¡ã€‚

ç»“æ„åŒ–å¹¶å‘éœ€è¦å¤šä¸ªå­ä»»åŠ¡å¹¶å‘æ‰§è¡Œ + åœ¨åŒä¸€ä½œç”¨åŸŸæ”¶æ‹¢ç»“æœã€‚
Swift æä¾›çš„æ–¹å¼ä¸»è¦æ˜¯ async letï¼ˆé™æ€æ•°é‡ï¼‰ å’Œ withThrowingTaskGroupï¼ˆåŠ¨æ€æ•°é‡ï¼‰ã€‚

éç»“æ„åŒ–å¹¶å‘ï¼ˆunstructured concurrencyï¼‰
ä½¿ç”¨ Task { ... } ç›´æ¥å¯åŠ¨åå°ä»»åŠ¡ï¼Œæ²¡æœ‰æ˜ç¡®çš„ä½œç”¨åŸŸæ¥æ”¶æ‹¢å®ƒä»¬ã€‚

This code example has several improvements:
Clear Execution Order: The code reads from top to bottomâ€”just like synchronous code.
Easier to Maintain: No deep nesting of callbacks.
Automatic Error Propagation: If fetchData() threw an error, it would bubble up naturally.


==================================================How about unstructured tasks?
You might have heard about unstructured tasks in Swift Concurrency. 
They exist indeed, and the most common example is a detached task.
these are the most important characteristics of an unstructured task:

1. Not tied to a parent: They exist independently and donâ€™t automatically inherit cancellation behavior.
2. Manual cancellation required: Developers need to manage task cancellation explicitly.
3. More flexibility, but more risk: While they offer more control, they also introduce potential pitfalls like race conditions or orphaned tasks.

