@preconcurrency 是 Swift 引入的一种 属性（attribute），它的作用是在迁移到并发模型（Concurrency Model）过程中，
为兼容旧代码提供过渡手段，防止由于 actor 隔离（如 @MainActor）而导致现有使用者编译报错或行为变化。

@preconcurrency 表示“这是一个在 Swift 并发模型引入之前写的接口”，编译器在调用这类接口时，允许一些并发模型下本该报错的用法继续工作，以便过渡。

@preconcurrency	表示这个声明来自并发模型推出前，允许老代码不符合 actor 要求继续工作


==================================================@preconcurrency（预并发）: Incremental migration to concurrency checking
https://www.avanderlee.com/concurrency/preconcurrency-checking-swift/

preconcurrency
Apply this attribute to a declaration, to suppress strict concurrency checking.

###
The @preconcurrency attribute is part of the tools that help you incrementally migrate to strict concurrency checking.
###
When async/await was introduced by Apple, we were writing non-structured asynchronous code, mainly using closures. 
On our road to Swift 6, we must prepare our projects for strict concurrency checks done by the compiler. 
The SE-0337 proposal makes it possible to migrate incrementally.
https://github.com/swiftlang/swift-evolution/blob/main/proposals/0337-support-incremental-migration-to-concurrency-checking.md


==================================================What is the @preconcurrency attribute?
#####
Like @unchecked Sendable, the @preconcurrency attribute helps you silence concurrency-related warnings without implementing Sendable conformance. 
#####
While updating your codebase（代码库） to make use of the latest concurrency changes, you might have been running into the following warning:
Add ‘@preconcurrency’ to suppress ‘Sendable’-related warnings from module ‘<some module>’

The Xcode compiler recognizes 3rd-party modules that are not in your control. 
In other words, libraries that you can’t easily migrate to work with Swift Concurrency. 
In those cases, you can suppress warnings triggered from those libraries by using the @preconcurrency attribute before an import:
@preconcurrency import Auth0

The compiler will no longer trigger warnings related to code from this specific library.
While adding the attribute and getting rid of many warnings is easy, it’s essential to understand the risks you take.


==================================================The risks of using @preconcurrency:
In an ideal world, there should be no risks when adding the @preconcurrency attribute. 
If the library owners did a good job, all their code is thread-safe, and they prevented data races by synchronizing access.

#####
However, it could also be that none of the code is thread-safe. 
Usually, we would be warned by the compiler due to missing Sendable conformance:
Capture of ‘highlight’ with non-sendable type ‘SWHighlight?’ in a @Sendable closure
#####

These warnings will no longer be triggered since we marked the library as a pre-concurrency import. 
You are taking ownership of ensuring thread-safe code. 
Keep this in mind when adding the attribute and try to see if an alternative solution is available, 
###
like updating the dependency to a newer version that possibly supports concurrency.
###


==================================================Should I import all 3rd party libraries using @preconcurrency?
However, if there’s no need to import a library to prevent concurrency warnings, it’s better not to do it. 
The compiler will warn you if you’ve imported a library using the attribute for no reason:
‘@preconcurrency’ attribute on module ‘Alamofire’ is unused

By not using the attribute and keeping the warnings visible, you allow yourself to revisit the code in the future when a fix from the 3rd party maintainer might be available.
Suppressing the warnings can feel like a great solution today, but it will also hide possibly vulnerable code in your project.


==================================================Revisiting pre-concurrency imports regularly:
If you decide to use the @preconcurrency import, planning a revisit of your code is essential. 
###
Once the library maintainers add support for concurrency, you can remove the attribute and see whether new warnings appear in your code that you need to fix. 
###
Any Sendable-related failures involving that module will no longer suggest the @preconcurrency import and will result in errors once using Swift 6.



https://www.donnywals.com/preconcurrency-usage-in-swift-explained/