https://www.andyibanez.com/posts/understanding-async-await-in-swift/


ä¼ ç»Ÿå¹¶å‘æ¨¡å‹æ˜¯åŸºäºå¼‚æ­¥æ¨¡å¼ï¼Œä»£ç ç»´æŠ¤æ€§ä¸å¤Ÿå‹å¥½
å¹¶å‘å¾€å¾€æ„å‘³ç€ Data Racesï¼Œè¿™æ˜¯ä¸€ç±»éš¾å¤ç°ã€éš¾æ’æŸ¥çš„å¸¸è§é—®é¢˜
Swift åœ¨ 5.5 å¼€å§‹å¼•å…¥çš„æ–°å¹¶å‘æ¡†æ¶ä¸»è¦ç€åŠ›è§£å†³è¿™ 2 ä¸ªé—®é¢˜ã€‚
Swift 5.5 å¼•å…¥çš„ async/await

åŒæ­¥(Synchronous)ã€å¼‚æ­¥(Asynchronous) é€šå¸¸æŒ‡æ–¹æ³•(/å‡½æ•°)ï¼ŒåŒæ­¥æ–¹æ³•è¡¨ç¤ºç›´åˆ°ä»»åŠ¡å®Œæˆæ‰è¿”å›ï¼Œå¼‚æ­¥æ–¹æ³•åˆ™æ˜¯å°†ä»»åŠ¡æŠ›å‡ºå»ï¼Œåœ¨ä»»åŠ¡å®Œæˆå‰å°±è¿”å›
éœ€è¦é€šè¿‡æŸç§æ–¹å¼è·å¾—å¼‚æ­¥ä»»åŠ¡çš„ç»“æœï¼Œå¦‚ï¼šDelegateã€Closure ç­‰ã€‚
ä¸²è¡Œ(Serial)ã€å¹¶è¡Œ(Concurrent) é€šå¸¸æŒ‡ App æ‰§è¡Œä¸€ç»„ä»»åŠ¡çš„æ¨¡å¼ï¼Œä¸²è¡Œè¡¨ç¤ºä¸€æ¬¡åªèƒ½æ‰§è¡Œä¸€ä¸ªä»»åŠ¡ï¼Œåªæœ‰å½“å‰ä»»åŠ¡å®Œæˆåæ‰å¯åŠ¨ä¸‹ä¸€ä¸ªä»»åŠ¡ï¼Œè€Œå¹¶è¡ŒæŒ‡å¯ä»¥åŒæ—¶æ‰§è¡Œå¤šä¸ªä»»åŠ¡ã€‚æœ€å¸¸è§çš„è«è¿‡äº GCD ä¸­çš„ä¸²è¡Œã€å¹¶è¡Œé˜Ÿåˆ—ï¼›
ä¼ ç»Ÿçš„å¹¶å‘æ¨¡å‹éƒ½æ˜¯åŸºäºå¼‚æ­¥æ¨¡å¼çš„ï¼Œå³å¼‚æ­¥è·å–å¹¶å‘ä»»åŠ¡çš„ç»“æœã€‚
å¼‚æ­¥ä»£ç æ˜¯éçº¿æ€§çš„ã€è·³è·ƒå¼çš„ (ç±»ä¼¼äº goto è¯­å¥)
å¼‚æ­¥ä»£ç åœ¨å…·ä½“å®ç°ä¸Šå¸¸ä¼´æœ‰ä»¥ä¸‹é—®é¢˜:
å›è°ƒåœ°ç‹± (Callback Hell)
é”™è¯¯å¤„ç† (Error Handling)

é”™è¯¯å¤„ç†åˆ†ä¸º 2 ç§æƒ…å†µ:
åŒæ­¥æ–¹æ³•ï¼šä¼˜å…ˆè€ƒè™‘é€šè¿‡ throw æŠ›å‡ºerrorï¼Œè¿™æ ·è°ƒç”¨æ–¹å°±ä¸å¾—ä¸å¤„ç†é”™è¯¯ï¼Œå› æ­¤å¸¦æœ‰ä¸€å®šçš„å¼ºåˆ¶æ€§
å¼‚æ­¥æ–¹æ³•ï¼šåœ¨å›è°ƒä¸­ä¼ é€’ errorï¼Œè¿™ç§æƒ…å†µä¸‹è°ƒç”¨æ–¹é€šå¸¸ä¼šæœ‰æ„æ— æ„åœ°å¿½ç•¥é”™è¯¯ï¼Œä½¿å¥å£®æ€§å¤§æ‰“æŠ˜æ‰£ã€‚

ä¸ºäº†å¤„ç†é”™è¯¯ï¼Œåœ¨ completion ä¸­å¢åŠ äº† error å‚æ•°ï¼ŒåŒæ—¶éœ€è¦å°† 2 ä¸ªå‚æ•°éƒ½å®šä¹‰æˆ Optionalã€‚
completion: (String?, Error?) -> Void)
Swift 5 å¼•å…¥äº† Result ç”¨äºä¼˜åŒ–ä¸Šè¿°é”™è¯¯å¤„ç†åœºæ™¯
Result<String, Error>
Result æ˜¯ enum ç±»å‹ï¼Œå«æœ‰ successã€failure 2 ä¸ª caseã€‚
é€šè¿‡ä½¿ç”¨ Resultï¼Œå‚æ•°ä¸å¿…æ˜¯ Optionalï¼Œå¦å¤–å¯ä»¥é€šè¿‡ switch/case æ¥å¤„ç†ç»“æœ
å°†å¼‚æ­¥ä»£ç åŒæ­¥åŒ–ä¸€ç›´æ˜¯ä¸šç•ŒåŠªåŠ›çš„æ–¹å‘ã€‚
å¦‚ï¼šPromiseï¼Œä¸è¿‡å…¶åŒæ­¥ä¹Ÿæ˜¯å»ºç«‹åœ¨ callback åŸºç¡€ä¸Šçš„ã€‚
Swift 5.5 å¼•å…¥äº† async/await ç”¨äºå°†å¼‚æ­¥ä»£ç åŒæ­¥åŒ–ã€‚
async â€” ç”¨äºä¿®é¥°æ–¹æ³•ï¼Œè¢«ä¿®é¥°çš„æ–¹æ³•åˆ™è¢«ç§°ä¸ºå¼‚æ­¥æ–¹æ³• (asynchronous method)ï¼Œå¼‚æ­¥æ–¹æ³•æ„å‘³ç€å…¶åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­å¯èƒ½ä¼šè¢«æš‚åœ (æŒ‚èµ·)
await â€” å¯¹ asynchronous method çš„è°ƒç”¨éœ€åŠ ä¸Š awaitã€‚åŒæ—¶ï¼Œawaitåªèƒ½å‡ºç°åœ¨å¼‚æ­¥ä¸Šä¸‹æ–‡ä¸­ (asynchronous context)
await åˆ™è¡¨ç¤ºä¸€ä¸ªæ½œåœ¨æš‚åœç‚¹ (potential suspension points)
ä»€ä¹ˆæ˜¯ asynchronous context ï¼Ÿå…¶å­˜åœ¨äº 2 ç§ç¯å¢ƒä¸‹:
asynchronous method body â€” å¼‚æ­¥æ–¹æ³•ä½“å±äºå¼‚æ­¥ä¸Šä¸‹æ–‡çš„èŒƒç•´
Task closure â€” Task ä»»åŠ¡é—­åŒ…ä¹Ÿå±äº asynchronous contextã€‚
åªèƒ½åœ¨å¼‚æ­¥æ–¹æ³•æˆ– Task é—­åŒ…ä¸­é€šè¿‡ await è°ƒç”¨å¼‚æ­¥æ–¹æ³•ã€‚

å¼‚æ­¥æ–¹æ³•æ‰§è¡Œè¿‡ç¨‹ä¸­å¯èƒ½ä¼šæš‚åœï¼Ÿ
æš‚åœçš„æ˜¯æ–¹æ³•ï¼Œè€Œä¸æ˜¯æ‰§è¡Œæ–¹æ³•çš„çº¿ç¨‹
æš‚åœç‚¹å‰åå¯èƒ½ä¼šå‘ç”Ÿçº¿ç¨‹åˆ‡æ¢
åœ¨ Swift æ–°å¹¶å‘æ¨¡å‹ä¸­è¿›ä¸€æ­¥å¼±åŒ–äº†çº¿ç¨‹,ç†æƒ³æƒ…å†µä¸‹æ•´ä¸ª App çš„çº¿ç¨‹æ•°åº”ä¸å†…æ ¸æ•°ä¸€è‡´ï¼Œçº¿ç¨‹çš„åˆ›å»ºã€ç®¡ç†å®Œå…¨äº¤ç”±å¹¶å‘æ¡†æ¶è´Ÿè´£ã€‚

Swift å¯¹å¼‚æ­¥æ–¹æ³• (asynchronous method) çš„å¤„ç†å°±éµå®ˆäº†ä¸Šè¿°æ€æƒ³:
å¼‚æ­¥æ–¹æ³•è¢«æš‚åœç‚¹ (suspension points) åˆ†å‰²ä¸ºè‹¥å¹²ä¸ª Jobï¼›
åœ¨å¹¶å‘æ¡†æ¶ä¸­ Job æ˜¯ä»»åŠ¡è°ƒåº¦çš„åŸºæœ¬å•å…ƒï¼›
å¹¶å‘æ¡†æ¶æ ¹æ®å®æ—¶æƒ…å†µåŠ¨æ€å†³å®šæŸä¸ª Job çš„æ‰§è¡Œçº¿ç¨‹ï¼›
ä¹Ÿå°±æ˜¯åŒä¸€ä¸ªå¼‚æ­¥æ–¹æ³•ä¸­çš„ä¸åŒ Job å¯èƒ½è¿è¡Œåœ¨ä¸åŒçº¿ç¨‹ä¸Šã€‚
æ­£æ˜¯ç”±äºå¼‚æ­¥æ–¹æ³•åœ¨å…¶æš‚åœç‚¹å‰åå¯èƒ½ä¼šå˜æ¢æ‰§è¡Œçº¿ç¨‹ï¼Œå› æ­¤åœ¨å¼‚æ­¥æ–¹æ³•ä¸­è¦æ…ç”¨é”ã€ä¿¡å·é‡ç­‰åŒæ­¥æ“ä½œã€‚
let lock = NSLock.init()
func test() async {
  lock.lock()
  try? await Task.sleep(nanoseconds: 1_000_000_000)
  lock.unlock()
}
è¿™æ ·çš„ä»£ç åœ¨ lock.lock() å¤„ä¼šäº§ç”Ÿæ­»é”
await ä¹‹æ‰€ä»¥ç§°ä¸ºæ½œåœ¨æš‚åœç‚¹ï¼Œè€Œä¸æ˜¯æš‚åœç‚¹ï¼Œæ˜¯å› ä¸ºå¹¶ä¸æ˜¯æ‰€æœ‰çš„ await éƒ½ä¼šæš‚åœï¼Œåªæœ‰é‡åˆ°ç±»ä¼¼ IOã€æ‰‹åŠ¨èµ·å­çº¿ç¨‹ç­‰æƒ…å†µæ—¶æ‰ä¼šæš‚åœå½“å‰è°ƒç”¨æ ˆçš„è¿è¡Œã€‚
https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html#


==================================================https://www.avanderlee.com/swift/async-await/

Async await is part of the new structured concurrency changes that arrived in Swift 5.5 during WWDC 2021.
Concurrency in Swift means allowing multiple pieces of code to run at the same time. 
With the new async methods and await statements, we can define methods performing work asynchronously.

https://gist.github.com/lattner/31ed37682ef1576b16bca1432ea9f782

async:
Async stands for asynchronous and can be seen as a method attribute making it clear that a method performs asynchronous work. 
An example of such a method looks as follows:
func fetchImages() async throws -> [UIImage] {
    // .. perform data request
}
The fetchImages method is defined as async throwing, which means that itâ€™s performing a failable asynchronous job. 
The method would return a collection of images if everything went well or throws an error if something went wrong.

How async replaces closure completion callbacks:
#####
Async methods replace the often seen closure completion callbacks.
Completion callbacks were common in Swift to return from an asynchronous task, 
often combined with a Result type parameter. 
#####

The above method would have been written as followed:

func fetchImages(completion: (Result<[UIImage], Error>) -> Void) {
    // .. perform data request
}
Defining a method using a completion closure is still possible in Swift today, 
but it has a few downsides that are solved by using async instead:
You have to make sure yourself to call the completion closure in each possible method exit. Not doing so will possibly result in an app waiting for a result endlessly.
Closures are harder to read. Itâ€™s not as easy to reason about the order of execution as compared to how easy it is with structured concurrency.
Retain cycles need to be avoided using weak references.
Implementors need to switch over the result to get the outcome. Itâ€™s not possible to use try catch statements from the implementation level.

These downsides are based on the closure version using the relatively new Result enum. Itâ€™s likely that a lot of projects still make use of completion callbacks without this enumeration:
func fetchImages(completion: ([UIImage]?, Error?) -> Void) {
    // .. perform data request
}
Defining a method like this makes it even harder to reason about the outcome on the callerâ€™s side. 
Both value and error are optional, which requires us to perform an unwrap in any case. 
Unwrapping these optionals results in more code clutter which does not help to improve readability.


await:
Await is the keyword to be used for calling async methods.
You can see them as best friends in Swift as one will never go without the other. 
You could basically say:
â€œAwait is awaiting a callback from his buddy asyncâ€
do {
    let images = try await fetchImages()
    print("Fetched \(images.count) images.")
} catch {
    print("Fetching images failed with error \(error)")
}

#####
Using the await keyword, we tell our program to await a result from the fetchImages method and only continue after a result arrived. 
#####
This could either be a collection of images or an error if anything went wrong while fetching the images.


What is structured concurrency?
#####
ä»€ä¹ˆæ˜¯ç»“æ„åŒ–å¹¶å‘ï¼Ÿ
å³ä½¿è¿›è¡Œå¹¶å‘æ“ä½œï¼Œä¹Ÿè¦ä¿è¯æ§åˆ¶æµè·¯å¾„çš„å•ä¸€å…¥å£å’Œå•ä¸€å‡ºå£ã€‚
ç¨‹åºå¯ä»¥äº§ç”Ÿå¤šä¸ªæ§åˆ¶æµæ¥å®ç°å¹¶å‘ï¼Œä½†æ˜¯æ‰€æœ‰çš„å¹¶å‘è·¯å¾„åœ¨å‡ºå£æ—¶éƒ½åº”è¯¥å¤„äºå®Œæˆ (æˆ–å–æ¶ˆ) çŠ¶æ€ï¼Œå¹¶åˆå¹¶åˆ°ä¸€èµ·ã€‚

ä½¿ç”¨ async-await æ–¹æ³•çš„ç»“æ„åŒ–å¹¶å‘
Structured concurrency with async-await method calls makes it easier to reason about the order of execution.
Methods are linearly executed without going back and forth like you would with closures.
#####


// 1. Call the method
fetchImages { result in
    // 3. The asynchronous method returns
    switch result {
    case .success(let images):
        print("Fetched \(images.count) images.")
    case .failure(let error):
        print("Fetching images failed with error \(error)")
    }
}
// 2. The calling method exits

the calling method returns before the images are fetched.
#####
Eventually, a result is received, and we go back into our flow within the completion callback. 
This is an unstructured order of execution and can be hard to follow. 
#####
This is especially true if we would perform another asynchronous method within our completion callback which would add another closure callback:

// 1. Call the method
fetchImages { result in
    // 3. The asynchronous method returns
    switch result {
    case .success(let images):
        print("Fetched \(images.count) images.")
        
        // 4. Call the resize method
        resizeImages(images) { result in
            // 6. Resize method returns
            switch result {
            case .success(let images):
                print("Decoded \(images.count) images.")
            case .failure(let error):
                print("Decoding images failed with error \(error)")
            }
        }
        // 5. Fetch images method returns
    case .failure(let error):
        print("Fetching images failed with error \(error)")
    }
}
// 2. The calling method exits

Each closure adds another level of indentation, which makes it harder to follow the order of execution.
Rewriting the above code example by making use of async-await explains best what structured concurrency does:

do {
    // 1. Call the method
    let images = try await fetchImages()
    // 2. Fetch images method returns
    
    // 3. Call the resize method
    let resizedImages = try await resizeImages(images)
    // 4. Resize method returns
    
    print("Fetched \(images.count) images.")
} catch {
    print("Fetching images failed with error \(error)")
}
// 5. The calling method exits

The order of execution is linear and, therefore, easy to follow and easy to reason about.
Understanding asynchronous code will be easier while weâ€™re still performing sometimes complex asynchronous tasks.


#####
Async methods call in a function that does not support concurrency:
This error occurs as we try to call an asynchronous method from a synchronous calling environment that does not support concurrency.
#####

We can solve this error by either defining our fetchData method as async as well:

func fetchData() async {
    do {
        try await fetchImages()
    } catch {
        // .. handle error
    }
}

However, this would move the error to a different place. 
Instead, we could use the Task.init method to call the asynchronous method from a new task that does support concurrency and assign the outcome result to a property in our view model:
final class ContentViewModel: ObservableObject {
    
    @Published var images: [UIImage] = []
    
    func fetchData() {
        Task { @MainActor in
            do {
                self.images = try await fetchImages()
            } catch {
                // .. handle error
            }
        }
    }
}
The Task initializer method creates a new asynchronous context for asynchronous methods. 
We must use the @MainActor attribute since weâ€™re updating a @Published property that triggers UI updates.
You can learn more about this in my article MainActor usage in Swift explained to dispatch to the main thread.
https://www.avanderlee.com/swift/mainactor-dispatch-main-thread/

Using the async method using the trailing closure, we create an environment in which we can call asynchronous methods.
The fetch data method returns as soon as the async method is called, 
after which all asynchronous callbacks will happen within the closure.

å½“ä½ åœ¨ Task { @MainActor in ... } ä¸­å†™ä»£ç æ—¶ï¼Œæ•´ä¸ªé—­åŒ…çš„æ‰§è¡Œéƒ½ä¼šè¢«è°ƒåº¦åˆ°ä¸»çº¿ç¨‹ã€‚
è¿™æ ·å†™çš„ç›®çš„æ˜¯ä¸ºäº†ç¡®ä¿ï¼š
self.images = ... è¿™ç±»å¯èƒ½ä¼šè§¦å‘ UI æ›´æ–°çš„ä»£ç åœ¨ä¸»çº¿ç¨‹ä¸Šå®‰å…¨æ‰§è¡Œã€‚
é¿å…å› åœ¨éä¸»çº¿ç¨‹æ›´æ–° @Published å±æ€§è€Œå¯¼è‡´çš„æœªå®šä¹‰è¡Œä¸ºï¼ˆSwiftUI è¦æ±‚ UI æ›´æ–°å¿…é¡»åœ¨ä¸»çº¿ç¨‹ï¼‰ã€‚

ä¸ºä»€ä¹ˆä¸æ˜¯ç›´æ¥å†™ @MainActor func fetchData()
ä½ å¯ä»¥è¿™ä¹ˆå†™ï¼Œé‚£æ · fetchData() æ•´ä¸ªæ–¹æ³•å°±éƒ½åœ¨ä¸»çº¿ç¨‹ä¸Šæ‰§è¡Œäº†ã€‚ä¸è¿‡è¿™ä¹ˆå†™çš„åŒºåˆ«æ˜¯ï¼š
ä½ ç°åœ¨æ˜¯å…ˆåœ¨ åå°çº¿ç¨‹ å¯åŠ¨äº† Task { ... }ï¼Œç„¶ååªæŠŠå…¶ä¸­é—­åŒ…æŒ‡å®šåˆ°äº†ä¸»çº¿ç¨‹ï¼Œè¿™æ · fetchData() æ–¹æ³•æœ¬èº«å¯ä»¥åœ¨ä»»æ„çº¿ç¨‹è¢«è°ƒç”¨ã€‚
æœ¬è´¨ï¼š
Task { @MainActor in
    self.images = try await fetchImages()
}
self.images = ... æ˜¯åœ¨ä¸»çº¿ç¨‹ä¸Šæ‰§è¡Œçš„ï¼›ä½† fetchImages() æ˜¯åœ¨å…¶é»˜è®¤è°ƒåº¦ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œçš„ï¼Œä¸ä¸€å®šæ˜¯ä¸»çº¿ç¨‹ã€‚
å¯ä»¥è¢«ç†è§£ä¸º åœ¨ä¸»çº¿ç¨‹ä¸Šæ‰§è¡Œè¿™æ®µä»£ç çš„ç»“æ„ï¼Œä½† await ä¼šå…ˆæš‚åœï¼Œç„¶å resume æ—¶å†å›åˆ°ä¸»çº¿ç¨‹ç»§ç»­æ‰§è¡Œèµ‹å€¼ã€‚
æ‹†è§£è¿™æ®µä»£ç è¿è¡Œé¡ºåºï¼š
1. Task åˆ›å»ºäº†ä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡ï¼›
2. ç”±äºåŠ äº† @MainActorï¼Œè¿™ä¸ªä»»åŠ¡ä¼šåœ¨ä¸»çº¿ç¨‹ä¸Šå¼€å§‹ï¼›
3. æ‰§è¡Œåˆ° try await fetchImages()ï¼š
æ­¤æ—¶ fetchImages() æ˜¯ä¸€ä¸ªå¼‚æ­¥å‡½æ•°ï¼Œå®é™… å¯èƒ½åœ¨åå°çº¿ç¨‹æ‰§è¡Œï¼ˆå–å†³äºå†…éƒ¨å®ç°ï¼‰ï¼›
å½“å‰ä¸»çº¿ç¨‹ä»»åŠ¡æš‚åœç­‰å¾…ç»“æœï¼›
4. fetchImages() æ‰§è¡Œå®Œè¿”å›ç»“æœï¼›
5. resume æ—¶ï¼Œç”±äºä¸Šä¸‹æ–‡æ˜¯ @MainActorï¼Œæ¢å¤åä¼šåœ¨ä¸»çº¿ç¨‹ç»§ç»­æ‰§è¡Œï¼Œç„¶åæ‰§è¡Œï¼š
self.images = ...
Task { @MainActor in
    // ğŸ‘‡ ä¸»çº¿ç¨‹ï¼šå¼€å§‹æ‰§è¡Œ
    let result = try await fetchImages() // â›”ï¸æš‚åœï¼Œè·³å»æ‰§è¡Œ fetchImages
    // ğŸ” fetchImages åœ¨åå°çº¿ç¨‹æ‰§è¡Œå®Œæ¯•å resume å›æ¥
    self.images = result // âœ… ä¸»çº¿ç¨‹èµ‹å€¼
}


å¦‚æœä½ å†™æˆè¿™æ ·ï¼š
@MainActor
func fetchData() async {
    self.images = try await fetchImages()
}
é‚£å°±è¡¨ç¤ºæ•´ä¸ªæ–¹æ³•éƒ½å¿…é¡»åœ¨ä¸»çº¿ç¨‹ä¸Šè°ƒç”¨ï¼Œé€‚åˆå½“ä½ éœ€è¦ç¡®ä¿è°ƒç”¨æ–¹ä¹Ÿæ˜¯åœ¨ä¸»çº¿ç¨‹æ—¶ä½¿ç”¨ã€‚


fetchImages()å®ç°ä¾‹å­ï¼š
æ–¹æ³•ä¸€ï¼šä½¿ç”¨ Task.detached {} åœ¨åå°çº¿ç¨‹è¿è¡Œ
func fetchImages() async throws -> [UIImage] {
    return try await Task.detached(priority: .background) {
        // ä¿è¯è¿™æ®µä»£ç åœ¨åå°æ‰§è¡Œ
        return try loadImagesFromDisk()
    }.value
}

æ–¹æ³•äºŒï¼šç”¨ withCheckedContinuation + GCD åå°é˜Ÿåˆ—
func fetchImages() async throws -> [UIImage] {
    try await withCheckedThrowingContinuation { continuation in
        DispatchQueue.global(qos: .userInitiated).async {
            do {
                let result = try loadImagesFromDisk()
                continuation.resume(returning: result)
            } catch {
                continuation.resume(throwing: error)
            }
        }
    }
}
å¦‚æœ fetchImages() æœ¬èº«å·²ç»æ˜¯ä½¿ç”¨äº† URLSession.data(for:) ç­‰å¼‚æ­¥ APIï¼Œé‚£ä½ ä¸éœ€è¦æ‰‹åŠ¨è½¬åå°çº¿ç¨‹ï¼Œå› ä¸ºç³»ç»Ÿå·²ç»ä¸ºä½ è°ƒåº¦åˆ°åˆé€‚çº¿ç¨‹ã€‚
åªæœ‰å½“ä½ æ˜ç¡®ç”¨åˆ°äº†åŒæ­¥ã€è€—æ—¶çš„ä»£ç ï¼ˆä¾‹å¦‚è¯»å–æœ¬åœ°å¤§å›¾ç‰‡ã€å‹ç¼©æ–‡ä»¶ç­‰ï¼‰æ‰éœ€è¦æ˜¾å¼å»åå°çº¿ç¨‹ã€‚
Task.detached æ˜¯æœ€ç°ä»£ã€æ¨èçš„æ–¹å¼ï¼Œå°¤å…¶é€‚ç”¨äºç»“æ„åŒ–å¹¶å‘ç¯å¢ƒä¸­è¦åˆ‡æ¢çº¿ç¨‹ã€‚




Adopting async-await in an existing project:
it can make it easier to try out async-await in your project. 
Xcode makes it super easy to refactor your code and also provides an option to create a separate async method

weâ€™ll use the following code as refactor input:
struct ImageFetcher {
    func fetchImages(completion: @escaping (Result<[UIImage], Error>) -> Void) {
        // .. perform data request
    }
}
1.Convert Function to Async
The first refactor option converts the fetch images method into an async variant without keeping the non-async alternative. 
This option will be useful if you donâ€™t want to maintain your old implementation. The resulting code looks as follows:
struct ImageFetcher {
    func fetchImages() async throws -> [UIImage] {
        // .. perform data request
    }
}

2.Add Async Alternative
The add async alternative refactor option makes sure to keep the old implementation in place but does take care of adding an available attribute:
struct ImageFetcher {
    @available(*, renamed: "fetchImages()")
    func fetchImages(completion: @escaping (Result<[UIImage], Error>) -> Void) {
        Task {
            do {
                let result = try await fetchImages()
                completion(.success(result))
            } catch {
                completion(.failure(error))
            }
        }
    }


    func fetchImages() async throws -> [UIImage] {
        // .. perform data request
    }
}

The available attribute is useful to know where you need to update your code towards the new concurrency variant.
Though, the default implementation Xcode provides does not come with any warning since itâ€™s not marked as deprecated.
To do so, youâ€™ll need to adjust the available marker as follows:
#####
@available(*, deprecated, renamed: "fetchImages()")
#####

https://www.avanderlee.com/swift/available-deprecated-renamed/


The benefit of using this refactor option is that it allows you to progressively adapt to the new structured concurrency changes without having to convert your complete project at once. 
Building in-between is valuable so that you know that your code changes work as expected. 
Implementations that make use of the old method will get a warning

You can progressively change your implementations throughout your project and use the provided fix button in Xcode to automatically convert your code to make use of the new implementation.


3.Add Async Wrapper
The final refactor method will result in the easiest conversion since it will simply make use of your existing code:
struct ImageFetcher {
    @available(*, renamed: "fetchImages()")
    func fetchImages(completion: @escaping (Result<[UIImage], Error>) -> Void) {
        // .. perform data request
    }

    func fetchImages() async throws -> [UIImage] {
        return try await withCheckedThrowingContinuation { continuation in
            fetchImages() { result in
                continuation.resume(with: result)
            }
        }
    }
}

The newly added method makes use of the withCheckedThrowingContinuation method which was introduced in Swift to convert closure-based methods without much effort.
Non-throwing methods can make use of the withCheckedContinuation which works the same but does not support throwing errors.

#####
These two methods suspend the current task until the given closure is called to trigger the continuation of the async-await method.
#####
In other words: youâ€™ll have to make sure to call the continuation closure based on the callback of your own closure-based method.
In our example, this comes down to calling the continuation with our result value returned from the original fetch images callback.



Picking the right async-await refactor method for your project:
These three refactor options should be enough to convert your existing code into async alternatives.
Depending on the size of your project and the amount of time you have for the refactor you might want to pick a different refactor option.
Though, I would strongly advise progressively applying changes since it allows you to isolate parts that changed, making it easier to test whether your changes work as expected.


Migrating to Swift 6:
structured concurrency supports the Swift 6 compile-time checks, 
so I recommend migrating to async/await before ###following my detailed steps for migrating to Swift 6.###
https://www.avanderlee.com/concurrency/swift-6-migrating-xcode-projects-packages/


Solving the â€œReference to captured parameter â€˜selfâ€™ in concurrently-executing codeâ€ error:
Another common error when working with async methods is the following one:
â€œReference to captured parameter â€˜selfâ€™ in concurrently-executing codeâ€

This means that weâ€™re trying to reference an immutable instance of self. 
In other words, youâ€™re likely referencing either a property or an instance thatâ€™s immutable, 
for example, a structure like in the following example:

func fetchImages() async throws -> [UIImage] {
    return [UIImage()]
}

struct TestModel {
    var images: [UIImage] = []
    
    init() {
        Task.init {
            images = try! await fetchImages()
        }
    }
}
Mutating immutable properties or instances from concurrently executing code is not supported.

This error can be fixed by either making your properties mutable or by changing the struct into a reference type, like a class.


Async-await in Swift allows for structured concurrency, which will improve the readability of complex asynchronous code.


Will async await be the end of the Result enum?
https://www.avanderlee.com/swift/result-enum-type/
Weâ€™ve seen that async methods replace asynchronous methods that use closure callbacks.
We could ask ourselves whether this will be the end of the Result enum in Swift. 
In the end, we donâ€™t really need them anymore as we can make use of try-catch statements in combination with async-await.

The Result enum wonâ€™t disappear anytime soon, as itâ€™s still used in many places throughout Swift projects. 
However, I wonâ€™t be surprised to see it deprecated once the adoption rate of async-await increases. 
Personally, Iâ€™ve not been using the Result enum in any other place than completion callbacks. 
Once I fully use async-await, I wonâ€™t use the enum anymore.