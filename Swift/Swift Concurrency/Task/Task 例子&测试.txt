在concurrency环境中创建的 Task：

func doSomething() async {
    print("11111#doSomething")
}

func load111() async {
    print("11111#load1")
    Task {
        print("11111#task1")
        await doSomething()
        print("11111#task2")
    }
    print("11111#load2")
}

override func viewDidLoad() {
    super.viewDidLoad()
    
    Task {
        await load111()
    }

    // 'async' call in a function that does not support concurrency
    // await load111()
    
}

11111#load1
11111#load2
11111#task1
11111#doSomething
11111#task2

这个 Task {}：
是结构化任务（因为它在 async 函数里创建）；
但你没有 await 它的 .value 或结果；
所以它是异步“fire and forget”地开始执行，load111() 继续往下走，不会等它。



如果你写成这样就会等待了：
func load111() async {
    print("11111#load1")
    let t = Task {
        print("11111#task1")
        await doSomething()
        print("11111#task2")
    }
    await t.value // // 手动等待这个结构化任务完成
    print("11111#load2")
}
11111#load1
11111#task1
11111#doSomething
11111#task2
11111#load2

「任务在返回前等待完成」


其他例子:
func doSomething() async {
    try? await Task.sleep(nanoseconds: 2000000000)
    print("11111#doSomething")
}

func doSomething2() async {
    try? await Task.sleep(nanoseconds: 1000000000)
    print("11111#doSomething2")
}

func load111() async {
    print("11111#load1")
    let t = Task {
        print("11111#task1")
        await doSomething()
        print("11111#task2")
    }
    let t2 = Task {
        print("11111#task3")
        await doSomething2()
        print("11111#task4")
    }
    await t.value
    await t2.value
    print("11111#load2")
}

11111#load1
11111#task3
11111#task1
11111#doSomething2
11111#task4
11111#doSomething
11111#task2
11111#load2

用 async let 改写，效果基本一致

#####
但：
async let 创建的是结构化并发任务，自动绑定到当前任务作用域中
把你的 async 函数想象成一个“任务树的节点”：
你每调用一个 async 函数，它就变成一个结构化任务；
你在里面用 async let 创建的任务，是它的“子任务”；

Task {} 是非结构化并发任务，独立运行，需要手动管理引用和生命周期。它不属于任何函数的作用域
#####

==================================================测试
1.
@MainActor
class TestClass {
    func test() {
        print("TestClass=====111", Thread.current)
        Task {
            print("TestClass=====333", Thread.current)
        }
        print("TestClass=====222", Thread.current)
    }
}
TestClass=====111 <_NSMainThread: 0x60000170c040>{number = 1, name = main}
TestClass=====222 <_NSMainThread: 0x60000170c040>{number = 1, name = main}
TestClass=====333 <_NSMainThread: 0x60000170c040>{number = 1, name = main}


2.
class TestClass {
    func test() {
        print("TestClass=====111", Thread.current)
        Task {
            print("TestClass=====333", Thread.current)
        }
        print("TestClass=====222", Thread.current)
    }
}
TestClass=====111 <_NSMainThread: 0x60000170c040>{number = 1, name = main}
TestClass=====222 <_NSMainThread: 0x60000170c040>{number = 1, name = main}
TestClass=====333 <NSThread: 0x600001710380>{number = 6, name = (null)}


3.
@MainActor
class TestClass {
    func test() {
        print("TestClass=====111", Thread.current)
        Task.detached {
            print("TestClass=====333", Thread.current)
        }
        print("TestClass=====222", Thread.current)
    }
}
TestClass=====111 <_NSMainThread: 0x60000170c040>{number = 1, name = main}
TestClass=====222 <_NSMainThread: 0x60000170c040>{number = 1, name = main}
TestClass=====333 <NSThread: 0x600001710380>{number = 7, name = (null)}


4.
@MainActor
override func viewDidLoad() {
    super.viewDidLoad()
    
    print("=====111", Thread.current)
    Task {
        print("=====333", Thread.current)
    }
    print("=====222", Thread.current)
}
=====111 <_NSMainThread: 0x283dc8380>{number = 1, name = main}
=====222 <_NSMainThread: 0x283dc8380>{number = 1, name = main}
=====333 <_NSMainThread: 0x283dc8380>{number = 1, name = main}


5.
class Test {
    func test1() {
        print("===1111", Thread.current)
        Task {
            print("===111", Thread.current)
        }
    }
    
    @MainActor
    func test2() {
        print("===2222", Thread.current)
        Task {
/*
标记
@MainActor
func test2()
使用Thread.current也会警告: 
Class property 'current' is unavailable from asynchronous contexts;
Thread.current cannot be used from async contexts.;
this is an error in the Swift 6 language mode
 */
            print("===222", Thread.current)
        }
    }
}

@MainActor
func application(_ application: UIApplication,
                     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
    let test = Test()
    test.test1()
    test.test2()                
}
===1111 <_NSMainThread: 0x2808d4380>{number = 1, name = main}
===2222 <_NSMainThread: 0x2808d4380>{number = 1, name = main}
/*
Task {} 的默认行为是：
从调用点捕获其所在的 actor（如 MainActor）

func test1()没有标记MainActor，即使它在标记MainActor的didFinishLaunchingWithOptions中被调用
*/
===111 <NSThread: 0x280884280>{number = 6, name = (null)}
===222 <_NSMainThread: 0x2808d4380>{number = 1, name = main} 


==================================================Task { @MainActor in ... }
Task { @MainActor in ... } 这个写法其实是 Swift 5.9（正式支持） 开始支持的**“任务局部执行上下文标注”**（task local actor isolation）语法糖。
Task { @MainActor in ... } 让你启动一个异步任务，并且任务内部的代码自动运行在 MainActor 上。
这是对以前需要写成 await MainActor.run { ... } 的简写 // Swift 5.5

Task { @MainActor in
    // 这里的代码自动切换到主线程执行
    print(Thread.current)
    // 可以安全访问 UI 相关代码
}
等价于：
Task {
    await MainActor.run {
        print(Thread.current)
    }
}

==================================================TaskGroup中的结构化并发任务
func loadAllImages(urls: [URL]) async -> [UIImage] {
    await withTaskGroup(of: UIImage?.self) { group in
        for url in urls {
            group.addTask {
                return await loadImage(url: url)
            }
        }

        var images: [UIImage] = []
        for await image in group {
            if let img = image {
                images.append(img)
            }
        }
        return images
    }
}
所有子任务在 withTaskGroup 作用域内完成；
自动并发、自动取消、自动收集；
更加结构化、安全。


==================================================结构化任务 & 结构化并发
结构化任务 = 有父任务（async上下文）来等它、取消它、跟踪它的任务。否则就是“野任务”。


"结构化任务" 是 "结构化并发" 的组成部分。


结构化并发（Structured Concurrency）
是一种整体并发模型的设计思想：
并发任务应该像函数作用域一样，有父子关系、有生命周期、自动管理、易于推理。
它是一套原则 / 约束，包括：
父子任务之间有生命周期绑定；
子任务不能“悬挂”在系统中；
错误传播是可控的；
自动传递取消信号；
作用域内的并发任务必须在退出前完成。


结构化任务（Structured Task）
是这个模型下的具体执行单位，也就是实际被创建出来、受控于结构化体系的 Task 实例。
比如：
async let 创建的任务
withTaskGroup 中的任务
这些都是“结构化任务”，因为它们：
有“父任务”（比如调用它们的 async 函数）
会在作用域结束前被等待和清理
被 Swift 编译器和运行时自动管理


概念	类比
结构化并发	法律、制度、规则
结构化任务	遵守这个制度的每一个具体任务


func fetchData() async {
    async let user = loadUser()
    async let posts = loadPosts()
    let (u, p) = await (user, posts) // 👈 结构化任务必须 await 回来
}
这里 loadUser() 和 loadPosts() 对应的就是结构化任务；
而整个 fetchData() 的行为，符合结构化并发的模型。


结构化并发是模型，结构化任务是这个模型中的具体任务实例。
有了结构化并发的原则，结构化任务才能有意义地被管理。