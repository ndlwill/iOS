https://nshipster.com/isolated-any/?utm_source=fatbobman%20weekly%20issue%2097&utm_medium=web


基于 Swift version 6.0


To understand why @isolated(any) was introduced, we need to take a look at async functions.
let respondToEmergency: () async -> Void

A variable with this type must always be invoked with await.
await respondToEmergency()

All async functions have been called with await. But! Consider this:
let sendAmbulance: @MainActor () -> Void = {
    print("🚑 WEE-OOO WEE-OOO!")
}

let respondToEmergency: () async -> Void = sendAmbulance

await respondToEmergency()

The explicit types are there to help make what’s going on clear.
We first define a synchronous function that must run on the MainActor.
And then we assign that to a plain old, non-MainActor async function.
We’ve changed so much that you might find it surprising this even compiles.


#####
Remember what await actually does. 
It allows the current task to suspend. 
That doesn’t just let the task wait for future work to complete. 
It also is an opportunity to change isolation. // 它还是一个改变隔离性的机会
This makes async functions very flexible!
#####

#####
Just like a dispatcher doesn’t sit there doing nothing while waiting for the ambulance to arrive, 
a suspended task doesn’t block its thread. // 暂停的任务也不会阻塞其线程
#####
When the dispatcher puts you on hold to coordinate with the ambulance team, 
that’s the isolation switch - they’re transferring your request to a different department that specializes in that type of work.

==================================================

func dispatchResponder(_ responder: () async -> Void) async {
    await responder()
}

await dispatchResponder {
    // no explicit isolation => nonisolated
    print("🚒 HONK HOOOOONK!")
    await airSupport()
    print("🚁 SOI SOI SOI SOI SOI!")
}

await dispatchResponder { @MainActor in
    print("🚑 WEE-OOO WEE-OOO!")
}

We now have a function that accepts other functions as arguments. 
It’s possible to pass in lots of different kinds of functions to dispatchResponder.
#####
They could be async functions themselves, or even be synchronous.
#####
And they can be isolated to any actor. 
All thanks to the power of await.


Except there’s a little problem now. Have a look at dispatchResponder on its own:
func dispatchResponder(_ responder: () async -> Void) async {
    await responder()
}
The type of responder fully describes everything about this function, except for one thing.
#####
We have no way to know its isolation.
That information is only available at callsites.
The isolation is still present, so the right thing happens at runtime.
It’s just not possible to inspect it statically or even programmatically.
#####
If you’ve encountered type erasure before, this should seem familiar. 
The flexibility of async has come with a price - a loss of information.

This is where @isolated(any) comes in.


==================================================Using @isolated(any)

We can change the definition of dispatchResponder to fix this.

func dispatchResponder(_ responder: @isolated(any) () async -> Void) async {
    print("responder isolation:", responder.isolation)

    await responder()
}

#####
When you apply @isolated(any) to a function type, it does two things.

1.
Most importantly, it gives you access to a special isolation property.
You can use this property to inspect the isolation of the function.
The isolation could be an actor. Or it could be non-isolated. 
This is expressible in the type system with (any Actor)?.
#####

we can simulate how this all works with another feature: callAsFunction.
https://nshipster.com/callable/
struct IsolatedAnyFunction<T> {
    let isolation: (any Actor)?
    let body: () async -> T

    func callAsFunction() async -> T {
        await body()
    }
}

let value = IsolatedAnyFunction(isolation: MainActor.shared, body: {
    // isolated work goes here
})

await value()

This analogy is certainly not perfect, but it’s close enough that it might help.

#####
2.
There is one other subtle change that @isolated(any) makes to a function that you should be aware of. 
Its whole purpose is to capture the isolation of a function.

Since that could be anything, callsites need an opportunity to switch. 
And that means an @isolated(any) function must be called with an await — even if it isn’t itself explicitly async.
#####
func dispatchResponder(_ responder: @isolated(any) () -> Void) async {
    await responder() // note the function is synchronous
}

This makes synchronous functions marked with @isolated(any) a little strange. 
They still must be called with await, yet they aren’t allowed to suspend internally?

As it turns out, there are some valid (if rare) situations where such an arrangement can make sense.


==================================================How @isolated(any) Affects Callers
All of the task creation APIs — Task initializers and TaskGroup — make use of @isolated(any).

Except for @isolated(any), which is the opposite. It doesn’t affect callers at all.


==================================================Scheduling
when you should be thinking about using @isolated(any), I’m going to quote the proposal:
https://github.com/swiftlang/swift-evolution/blob/main/proposals/0431-isolated-any-functions.md
#####
This allows the API to make more intelligent scheduling decisions about the function.
#####

“intelligent scheduling”, this is the key component of @isolated(any).
The attribute gives you access to the isolation of a function argument.

Did you know that, before Swift 6, the ordering of the following code was undefined?

@MainActor
func threeAlarmFire() {
    Task { print("🚒 Truck A reporting!") }
    Task { print("🚒 Truck B checking in!") }
    Task { print("🚒 Truck C on the case!") }
}
Ordering turns out to be a very tricky topic when working with unstructured tasks.
And while it will always require care, Swift 6.0 did improve the situation. 
We now have some stronger guarantees about scheduling work on the MainActor, and @isolated(any) was needed to make that possible.


Anytime you use Task, think about when that work will start and how that could matter.
@MainActor
func sendAmbulance() {
    print("🚑 WEE-OOO WEE-OOO!")
}

nonisolated func dispatchResponders() {// 当你从非 @MainActor 的上下文调用 @MainActor 方法时，Swift 会安排任务（enqueue）到主线程的执行队列。
    // synchronously enqueued
    Task { @MainActor in
        sendAmbulance()
    }

    // synchronously enqueued
    Task(operation: sendAmbulance) 

    // not synchronously enqueued! (用了 await)
    Task {
        await sendAmbulance()
    }

    /*
    Task 需要传入一个 isolated(any)，即任意隔离域的闭包

    第一个传的是一个包含 sendAmbulance 的 MainActor 的闭包， { @MainActor in sendAmbulance() }
    第二个传的就是 sendAmbulance 的 MainActor 的闭包，就是 @MainActor func sendAmbulance()
    第三个传的是个继承 nonisolated 的 包含 sendAmbulance 的闭包，{ await sendAmbulance() }
    */
}
These are three ways to achieve the same goal. 
But, there is a subtle difference is how the last form is scheduled.
#####
Task takes an @isolated(any) function so it can look at its isolation and synchronously submit it to an actor.
This is how ordering can be preserved!
But, it cannot do that in the last case.
That closure passed into Task isn’t actually itself MainActor — it has inherited nonisolated from the enclosing function. // 传递给 Task 的闭包实际上本身并不是 MainActor——它从封装函数中继承了 nonisolated 函数。
#####

I think it might help to translate this into GCD.
func dispatchResponders() {
    // synchronously enqueued
    DispatchQueue.main.async {
        sendAmbulance()
    }

    // synchronously enqueued
    DispatchQueue.main.async(execute: sendAmbulance)

    // not synchronously enqueued!
    DispatchQueue.global().async {
        DispatchQueue.main.async {
            sendAmbulance()
        }
    }
}
#####
Look really closely at that last one! What we are doing there is introducing a new async closure that then calls our MainActor function.

And if you need to precisely schedule asynchronous work, @isolated(any) can help.
#####


#####
@isolated(any)：表示可以在调用方所在的 actor 上运行（也就是说，它会跟随调用方的 actor 隔离性，而不是被固定到一个特定的 actor）。

isolated(any)
It’s surprising that this attribute requires an argument, yet permits only one possible value.
The concrete actor type that this isolation property returns is always (any Actor)?. 
This is the most generic type for isolation and matches the #isolation macro.
Today, there is no way to constrain a function to only specific actor types, such as @isolated(MyActor).
The any keyword here was chosen to mirror how protocols handle this.
But accepting an argument leaves the door open to more sophisticated features in the future.


Because you’ll see it in many foundational concurrency APIs, it’s very natural to feel like you must understand @isolated(any). 
I’m 100% behind technical curiosity! But, in this case, it is not required. 
For the most part, you can just ignore this attribute. You will rarely, if ever, need to use it yourself.


But if you ever find yourself capturing isolated functions and passing them along to other APIs that use @isolated(any), 
you should consider adopting it. It could prove useful. It’s even a source-compatible change to add or remove this attribute from an async function.
#####