https://nshipster.com/isolated-any/?utm_source=fatbobman%20weekly%20issue%2097&utm_medium=web


åŸºäº Swift version 6.0


To understand why @isolated(any) was introduced, we need to take a look at async functions.
let respondToEmergency: () async -> Void

A variable with this type must always be invoked with await.
await respondToEmergency()

All async functions have been called with await. But! Consider this:
let sendAmbulance: @MainActor () -> Void = {
    print("ğŸš‘ WEE-OOO WEE-OOO!")
}

let respondToEmergency: () async -> Void = sendAmbulance

await respondToEmergency()

The explicit types are there to help make whatâ€™s going on clear.
We first define a synchronous function that must run on the MainActor.
And then we assign that to a plain old, non-MainActor async function.
Weâ€™ve changed so much that you might find it surprising this even compiles.


#####
Remember what await actually does. 
It allows the current task to suspend. 
That doesnâ€™t just let the task wait for future work to complete. 
It also is an opportunity to change isolation. // å®ƒè¿˜æ˜¯ä¸€ä¸ªæ”¹å˜éš”ç¦»æ€§çš„æœºä¼š
This makes async functions very flexible!
#####

#####
Just like a dispatcher doesnâ€™t sit there doing nothing while waiting for the ambulance to arrive, 
a suspended task doesnâ€™t block its thread. // æš‚åœçš„ä»»åŠ¡ä¹Ÿä¸ä¼šé˜»å¡å…¶çº¿ç¨‹
#####
When the dispatcher puts you on hold to coordinate with the ambulance team, 
thatâ€™s the isolation switch - theyâ€™re transferring your request to a different department that specializes in that type of work.

==================================================

func dispatchResponder(_ responder: () async -> Void) async {
    await responder()
}

await dispatchResponder {
    // no explicit isolation => nonisolated
    print("ğŸš’ HONK HOOOOONK!")
    await airSupport()
    print("ğŸš SOI SOI SOI SOI SOI!")
}

await dispatchResponder { @MainActor in
    print("ğŸš‘ WEE-OOO WEE-OOO!")
}

We now have a function that accepts other functions as arguments. 
Itâ€™s possible to pass in lots of different kinds of functions to dispatchResponder.
#####
They could be async functions themselves, or even be synchronous.
#####
And they can be isolated to any actor. 
All thanks to the power of await.


Except thereâ€™s a little problem now. Have a look at dispatchResponder on its own:
func dispatchResponder(_ responder: () async -> Void) async {
    await responder()
}
The type of responder fully describes everything about this function, except for one thing.
#####
We have no way to know its isolation.
That information is only available at callsites.
The isolation is still present, so the right thing happens at runtime.
Itâ€™s just not possible to inspect it statically or even programmatically.
#####
If youâ€™ve encountered type erasure before, this should seem familiar. 
The flexibility of async has come with a price - a loss of information.

This is where @isolated(any) comes in.


==================================================Using @isolated(any)

We can change the definition of dispatchResponder to fix this.

func dispatchResponder(_ responder: @isolated(any) () async -> Void) async {
    print("responder isolation:", responder.isolation)

    await responder()
}

#####
When you apply @isolated(any) to a function type, it does two things.

1.
Most importantly, it gives you access to a special isolation property.
You can use this property to inspect the isolation of the function.
The isolation could be an actor. Or it could be non-isolated. 
This is expressible in the type system with (any Actor)?.
#####

we can simulate how this all works with another feature: callAsFunction.
https://nshipster.com/callable/
struct IsolatedAnyFunction<T> {
    let isolation: (any Actor)?
    let body: () async -> T

    func callAsFunction() async -> T {
        await body()
    }
}

let value = IsolatedAnyFunction(isolation: MainActor.shared, body: {
    // isolated work goes here
})

await value()

This analogy is certainly not perfect, but itâ€™s close enough that it might help.

#####
2.
There is one other subtle change that @isolated(any) makes to a function that you should be aware of. 
Its whole purpose is to capture the isolation of a function.

Since that could be anything, callsites need an opportunity to switch. 
And that means an @isolated(any) function must be called with an await â€” even if it isnâ€™t itself explicitly async.
#####
func dispatchResponder(_ responder: @isolated(any) () -> Void) async {
    await responder() // note the function is synchronous
}

This makes synchronous functions marked with @isolated(any) a little strange. 
They still must be called with await, yet they arenâ€™t allowed to suspend internally?

As it turns out, there are some valid (if rare) situations where such an arrangement can make sense.


==================================================How @isolated(any) Affects Callers
All of the task creation APIs â€” Task initializers and TaskGroup â€” make use of @isolated(any).

Except for @isolated(any), which is the opposite. It doesnâ€™t affect callers at all.


==================================================Scheduling
when you should be thinking about using @isolated(any), Iâ€™m going to quote the proposal:
https://github.com/swiftlang/swift-evolution/blob/main/proposals/0431-isolated-any-functions.md
#####
This allows the API to make more intelligent scheduling decisions about the function.
#####

â€œintelligent schedulingâ€, this is the key component of @isolated(any).
The attribute gives you access to the isolation of a function argument.

Did you know that, before Swift 6, the ordering of the following code was undefined?

@MainActor
func threeAlarmFire() {
    Task { print("ğŸš’ Truck A reporting!") }
    Task { print("ğŸš’ Truck B checking in!") }
    Task { print("ğŸš’ Truck C on the case!") }
}
Ordering turns out to be a very tricky topic when working with unstructured tasks.
And while it will always require care, Swift 6.0 did improve the situation. 
We now have some stronger guarantees about scheduling work on the MainActor, and @isolated(any) was needed to make that possible.


Anytime you use Task, think about when that work will start and how that could matter.
@MainActor
func sendAmbulance() {
    print("ğŸš‘ WEE-OOO WEE-OOO!")
}

nonisolated func dispatchResponders() {// å½“ä½ ä»é @MainActor çš„ä¸Šä¸‹æ–‡è°ƒç”¨ @MainActor æ–¹æ³•æ—¶ï¼ŒSwift ä¼šå®‰æ’ä»»åŠ¡ï¼ˆenqueueï¼‰åˆ°ä¸»çº¿ç¨‹çš„æ‰§è¡Œé˜Ÿåˆ—ã€‚
    // synchronously enqueued
    Task { @MainActor in
        sendAmbulance()
    }

    // synchronously enqueued
    Task(operation: sendAmbulance) 

    // not synchronously enqueued! (ç”¨äº† await)
    Task {
        await sendAmbulance()
    }

    /*
    Task éœ€è¦ä¼ å…¥ä¸€ä¸ª isolated(any)ï¼Œå³ä»»æ„éš”ç¦»åŸŸçš„é—­åŒ…

    ç¬¬ä¸€ä¸ªä¼ çš„æ˜¯ä¸€ä¸ªåŒ…å« sendAmbulance çš„ MainActor çš„é—­åŒ…ï¼Œ { @MainActor in sendAmbulance() }
    ç¬¬äºŒä¸ªä¼ çš„å°±æ˜¯ sendAmbulance çš„ MainActor çš„é—­åŒ…ï¼Œå°±æ˜¯ @MainActor func sendAmbulance()
    ç¬¬ä¸‰ä¸ªä¼ çš„æ˜¯ä¸ªç»§æ‰¿ nonisolated çš„ åŒ…å« sendAmbulance çš„é—­åŒ…ï¼Œ{ await sendAmbulance() }
    */
}
These are three ways to achieve the same goal. 
But, there is a subtle difference is how the last form is scheduled.
#####
Task takes an @isolated(any) function so it can look at its isolation and synchronously submit it to an actor.
This is how ordering can be preserved!
But, it cannot do that in the last case.
That closure passed into Task isnâ€™t actually itself MainActor â€” it has inherited nonisolated from the enclosing function. // ä¼ é€’ç»™ Task çš„é—­åŒ…å®é™…ä¸Šæœ¬èº«å¹¶ä¸æ˜¯ MainActorâ€”â€”å®ƒä»å°è£…å‡½æ•°ä¸­ç»§æ‰¿äº† nonisolated å‡½æ•°ã€‚
#####

I think it might help to translate this into GCD.
func dispatchResponders() {
    // synchronously enqueued
    DispatchQueue.main.async {
        sendAmbulance()
    }

    // synchronously enqueued
    DispatchQueue.main.async(execute: sendAmbulance)

    // not synchronously enqueued!
    DispatchQueue.global().async {
        DispatchQueue.main.async {
            sendAmbulance()
        }
    }
}
#####
Look really closely at that last one! What we are doing there is introducing a new async closure that then calls our MainActor function.

And if you need to precisely schedule asynchronous work, @isolated(any) can help.
#####


#####
@isolated(any)ï¼šè¡¨ç¤ºå¯ä»¥åœ¨è°ƒç”¨æ–¹æ‰€åœ¨çš„ actor ä¸Šè¿è¡Œï¼ˆä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒä¼šè·Ÿéšè°ƒç”¨æ–¹çš„ actor éš”ç¦»æ€§ï¼Œè€Œä¸æ˜¯è¢«å›ºå®šåˆ°ä¸€ä¸ªç‰¹å®šçš„ actorï¼‰ã€‚

isolated(any)
Itâ€™s surprising that this attribute requires an argument, yet permits only one possible value.
The concrete actor type that this isolation property returns is always (any Actor)?. 
This is the most generic type for isolation and matches the #isolation macro.
Today, there is no way to constrain a function to only specific actor types, such as @isolated(MyActor).
The any keyword here was chosen to mirror how protocols handle this.
But accepting an argument leaves the door open to more sophisticated features in the future.


Because youâ€™ll see it in many foundational concurrency APIs, itâ€™s very natural to feel like you must understand @isolated(any). 
Iâ€™m 100% behind technical curiosity! But, in this case, it is not required. 
For the most part, you can just ignore this attribute. You will rarely, if ever, need to use it yourself.


But if you ever find yourself capturing isolated functions and passing them along to other APIs that use @isolated(any), 
you should consider adopting it. It could prove useful. Itâ€™s even a source-compatible change to add or remove this attribute from an async function.
#####