https://www.swift.org/migration/documentation/swift-6-concurrency-migration-guide/commonproblems


==================================================Crossing Isolation Boundaries
#####
The compiler will only permit a value to move from one isolation domain to another when it can prove it will not introduce data races. 
#####


1. Implicitly-Sendable Types
Many value types consist entirely of Sendable properties. 
The compiler will treat types like this as implicitly Sendable, but only when they are non-public.

public struct ColorComponents {
    public let red: Float
    public let green: Float
    public let blue: Float
}


@MainActor
func applyBackground(_ color: ColorComponents) {
}


func updateStyle(backgroundColor: ColorComponents) async {
    await applyBackground(backgroundColor)
}

Because ColorComponents is marked public, it will not implicitly conform to Sendable. This will result in the following error:
6 | 
7 | func updateStyle(backgroundColor: ColorComponents) async {
8 |     await applyBackground(backgroundColor)
|           |- error: sending 'backgroundColor' risks causing data races
|           `- note: sending task-isolated 'backgroundColor' to main actor-isolated global function 'applyBackground' risks causing data races between main actor-isolated and task-isolated uses
9 | }
10 | 

A straightforward solution is to make the type’s Sendable conformance explicit:

public struct ColorComponents: Sendable {
    // ...
}

Remember that Sendable is a guarantee of thread-safety and removing the conformance is an API-breaking change.


2. Preconcurrency Import
Even if the type in another module is actually Sendable, it is not always possible to modify its definition. 
In this case, you can use a @preconcurrency import to downgrade diagnostics until the library is updated.

// ColorComponents defined here
@preconcurrency import UnmigratedModule


func updateStyle(backgroundColor: ColorComponents) async {
    // crossing an isolation domain here
    await applyBackground(backgroundColor)
}

With the addition of this @preconcurrency import, ColorComponents remains non-Sendable. 
However, the compiler’s behavior will be altered. When using the Swift 6 language mode, the error produced here will be downgraded to a warning. 
The Swift 5 language mode will produce no diagnostics at all.


3. Latent Isolation
Sometimes the apparent need for a Sendable type can actually be the symptom of a more fundamental isolation problem.
The only reason a type needs to be Sendable is to cross isolation boundaries.
If you can avoid crossing boundaries altogether, the result can often be both simpler and a better reflection of the true nature of your system.

@MainActor
func applyBackground(_ color: ColorComponents) {
}


func updateStyle(backgroundColor: ColorComponents) async {
    await applyBackground(backgroundColor)
}

#####
The updateStyle(backgroundColor:) function is non-isolated. This means that its non-Sendable parameter is also non-isolated. 
The implementation crosses immediately from this non-isolated domain to the MainActor when applyBackground(_:) is called.
#####

Since updateStyle(backgroundColor:) is working directly with MainActor-isolated functions and non-Sendable types, just applying MainActor isolation may be more appropriate.

@MainActor
func updateStyle(backgroundColor: ColorComponents) async {
    applyBackground(backgroundColor)
}
Now, there is no longer an isolation boundary for the non-Sendable type to cross. 
And in this case, not only does this resolve the problem, it also removes the need for an asynchronous call.

Lack of MainActor isolation like this is, by far, the most common form of latent isolation. 
It is also very common for developers to hesitate to use this as a solution. 
It is completely normal for programs with a user interface to have a large set of MainActor-isolated state. 
Concerns around long-running synchronous work can often be addressed with just a handful of targeted nonisolated functions.


4. #####Computed Value#####
Instead of trying to pass a non-Sendable type across a boundary, it may be possible to use a Sendable function that creates the needed values.
func updateStyle(backgroundColorProvider: @Sendable () -> ColorComponents) async {
    await applyBackground(using: backgroundColorProvider)
}
Here, it does not matter than ColorComponents is not Sendable. 
By using @Sendable function that can compute the value, the lack of sendability is side-stepped entirely.

class ColorComponents {
    let red: Float
    let green: Float
    let blue: Float

    init(red: Float, green: Float, blue: Float) {
        self.red = red
        self.green = green
        self.blue = blue
    }
}

func updateStyle(backgroundColorProvider: @Sendable () -> ColorComponents) async {
    let color = backgroundColorProvider()  // ✅ 在当前 actor 执行，安全
    await applyBackground(using: color)
}

// 调用者
await updateStyle {
    ColorComponents(red: 0.5, green: 0.5, blue: 1.0)
}

错误示例：闭包捕获了非 Sendable 的变量
let state = NotSendableClass()
await updateStyle {
    state.makeColorComponents()  // ❌ 错误：捕获了非 Sendable 的对象
}
闭包捕获 vs. 闭包内部构造
**捕获（Capture）**指的是闭包 引用 了闭包外部的变量（比如局部变量、实例属性等）。
这里的闭包体内只是 直接构造了一个新的 ColorComponents 实例，没有引用外部已经存在的那个实例。
为什么捕获会限制 Sendable？
捕获的变量是闭包外已有的对象，
如果这个对象不是 Sendable，闭包就不是 Sendable。


5. Sending Argument
The compiler will permit non-Sendable values to cross an isolation boundary if the compiler can prove it can be done safely. 
Functions that explicitly state they require this can use the values within their implementations with less restrictions.
func updateStyle(backgroundColor: sending ColorComponents) async {
    // this boundary crossing can now be proven safe in all cases
    await applyBackground(backgroundColor)
}
A sending argument does impose some restrictions at call sites. 
But, this can still be easier or more appropriate than adding a Sendable conformance. 
This technique also works for types you do not control.

“我保证这个参数即使不是 Sendable，跨越 actor 隔离边界也不会导致数据竞争，因为我只在安全的上下文中使用它。”
// 假设 ColorComponents 不是 Sendable
class ColorComponents {
    var red: Float
    var green: Float
    var blue: Float

    init(red: Float, green: Float, blue: Float) {
        self.red = red
        self.green = green
        self.blue = blue
    }
}

// 带 sending 修饰符的参数，表示传入这里的值跨隔离边界是安全的
func updateStyle(backgroundColor: sending ColorComponents) async {
    await applyBackground(backgroundColor)
}

// 调用者必须遵守限制，确保安全调用
func caller() async {
    let color = ColorComponents(red: 1, green: 0, blue: 0)
    await updateStyle(backgroundColor: color)  // 允许，不强制 color 是 Sendable
}

可能某些类型是“表面上非 Sendable”，但程序逻辑保证它只会在单线程环境下访问，或者调用时上下文保证安全。
这种情况下，用 sending 让调用更灵活，无需强制给类型加 Sendable 协议。


6. Sendable Conformance
When encountering problems related to crossing isolation domains, a very natural reaction is to just try to add a conformance to Sendable. You can make a type Sendable in four ways.
(1)Global Isolation
Adding global isolation to any type will make it implicitly Sendable.
@MainActor
public struct ColorComponents {
    // ...
}
By isolating this type to the MainActor, any accesses from other isolation domains must be done asynchronously. 
This makes it possible to safely pass instances around across domains.


(2)Actors
Actors have an implicit Sendable conformance because their properties are protected by actor isolation.
actor Style {
    private var background: ColorComponents
}
In addition to gaining a Sendable conformance, actors receive their own isolation domain. 
This allows them to work freely with other non-Sendable types internally. 
This can be a major advantage, but does come with trade-offs.

Because an actor’s isolated methods must all be asynchronous, sites that access the type may require an async context. 
This alone is a reason to make such a change with care. But further, data that is passed into or out of the actor may itself need to cross the isolation boundary. 
This can result in the need for yet more Sendable types.

actor Style {
    private var background: ColorComponents


    func applyBackground(_ color: ColorComponents) {
        // make use of non-Sendable data here
    }
}
By moving both the non-Sendable data and operations on that data into the actor, no isolation boundaries need to be crossed. 
This provides a Sendable interface to those operations that can be freely accessed from any asynchronous context.


(3)Manual Synchronization
If you have a type that is already doing manual synchronization, you can express this to the compiler by marking your Sendable conformance as unchecked.
class Style: @unchecked Sendable {
    private var background: ColorComponents
    private let queue: DispatchQueue
}
You should not feel compelled to remove the use of queues, locks, or other forms of manual synchronization to integrate with Swift’s concurrency system.
However, most types are not inherently thread-safe. 
As a general rule, if a type isn’t already thread-safe, attempting to make it Sendable should not be your first approach. 
It is often easier to try other techniques first, falling back to manual synchronization only when truly necessary.


(4)Retroactive Sendable Conformance
extension ColorComponents: @retroactive @unchecked Sendable {
}
Because Sendable is a marker protocol, a retroactive conformance does not have direct binary compatibility issues.
https://github.com/swiftlang/swift-evolution/blob/main/proposals/0364-retroactive-conformance-warning.md


(5)Sendable Reference Types
It is possible for reference types to be validated as Sendable without the unchecked qualifier, but this is only done under very specific circumstances.
To allow a checked Sendable conformance, a class:
Must be final
Cannot inherit from another class other than NSObject
Cannot have any non-isolated mutable properties
public struct ColorComponents: Sendable {
    // ...
}


final class Style: Sendable {
    private let background: ColorComponents
}
A reference type that conforms to Sendable is sometimes a sign that a value type would be preferable. 
But there are circumstances where reference semantics need to be preserved, or where compatibility with a mixed Swift/Objective-C code base is required.


(6)Using Composition
You do not need to select one single technique for making a reference type Sendable. 
One type can use many techniques internally.
final class Style: Sendable {
    private nonisolated(unsafe) var background: ColorComponents
    private let queue: DispatchQueue


    @MainActor
    private var foreground: ColorComponents
}
The background property is protected by manual synchronization, while the foreground property uses actor isolation. 
Combining these two techniques results in a type that better describes its internal semantics. 
By doing this, the type continues to take advantage of the compiler’s automated isolation checking.


7. Non-Isolated Initialization
#####
Actor-isolated types can present a problem when they are initialized in a non-isolated context. 
#####
This frequently occurs when the type is used in a default value expression or as a property initializer.

Note
These problems could also be a symptom of latent isolation or an under-specified protocol.
https://www.swift.org/migration/documentation/swift-6-concurrency-migration-guide/commonproblems/#Latent-Isolation
https://www.swift.org/migration/documentation/swift-6-concurrency-migration-guide/commonproblems/#Under-Specified-Protocol

Here the non-isolated Stylers type is making a call to a MainActor-isolated initializer.
@MainActor
class WindowStyler {
    init() {
    }
}


struct Stylers {
    static let window = WindowStyler()
}
This code results in the following error:
 7 | 
 8 | struct Stylers {
 9 |     static let window = WindowStyler()
   |                `- error: main actor-isolated default value in a nonisolated context
10 | }
11 | 

Globally-isolated types sometimes don’t actually need to reference any global actor state in their initializers. 
By making the init method nonisolated, it is free to be called from any isolation domain. 
This remains safe as the compiler still guarantees that any state that is isolated will only be accessible from the MainActor.
@MainActor
class WindowStyler {
    private var viewStyler = ViewStyler()
    private var primaryStyleName: String


    nonisolated init(name: String) {
        self.primaryStyleName = name
        // type is fully-initialized here
    }
}
All Sendable properties can still be safely accessed in this init method. 
And while any non-Sendable properties cannot, they can still be initialized by using default expressions.


8. Non-Isolated Deinitialization
Even if a type has actor isolation, deinitializers are always non-isolated.
actor BackgroundStyler {
    // another actor-isolated type
    private let store = StyleStore()


    deinit {
        // this is non-isolated
        store.stopNotifications()
    }
}
This code produces the error:
error: call to actor-isolated instance method 'stopNotifications()' in a synchronous nonisolated context
 5 |     deinit {
 6 |         // this is non-isolated
 7 |         store.stopNotifications()
   |               `- error: call to actor-isolated instance method 'stopNotifications()' in a synchronous nonisolated context
 8 |     }
 9 | }

While this might feel surprising, given that this type is an actor, this is not a new constraint. 
The thread that executes a deinitializer has never been guaranteed and Swift’s data isolation is now just surfacing that fact.

Often, the work being done within the deinit does not need to be synchronous. 
A solution is to use an unstructured Task to first capture and then operate on the isolated values. 
When using this technique, it is critical to ensure you do not capture self, even implicitly.

actor BackgroundStyler {
    // another actor-isolated type
    private let store = StyleStore()


    deinit {
        // no actor isolation here, so none will be inherited by the task
        Task { [store] in
            await store.stopNotifications()
        }
    }
}

Important
Never extend the life-time of self from within deinit. Doing so will crash at runtime.


==================================================nonisolated
开发者常常担心把整个类标记为 @MainActor 会让长时间运行的同步逻辑卡住主线程。
但其实你只需要把这些有性能风险的函数单独标记为 nonisolated，就可以很安全地处理这种情况，其他函数照样主线程安全执行。

@MainActor
class ImageProcessor {
    var image: UIImage?

    // 这是个耗时同步操作，我们不想在主线程执行它
    nonisolated func heavyProcessing(_ data: Data) -> UIImage {
        // 大量 CPU 计算
    }

    func applyFilter() {
        let processed = heavyProcessing(imageData)  // ✅ 这是合法的
        self.image = processed
    }
}

ImageProcessor 是主 actor 隔离的
大多数函数（如 UI 状态修改）都是主线程安全的
唯一担心的是 heavyProcessing 可能卡主线程
所以我们 只把它标记为 nonisolated，它就可能在后台线程运行
#####
nonisolated 并不会让函数“自动在后台线程运行”，它只是允许你在任何线程调用它，不会触发 actor 跳转。

@MainActor：要求方法必须在主线程（MainActor）执行，调用时会被强制调度过去。
nonisolated：表示方法不属于任何 actor，因此不会触发跳 actor 行为，你可以从任意线程直接调用。

但 是否真的运行在后台线程，取决于你从哪调用的。
它不会自动后台调度。
#####
@MainActor
class ImageProcessor {
    var image: UIImage?

    nonisolated func heavyProcessing(_ data: Data) -> UIImage {
        // 大量 CPU 计算
    }

    func applyFilter() {
        let processed = heavyProcessing(imageData)  // ✅ 合法
        self.image = processed
    }
}
applyFilter() 是主 actor 方法，它是在主线程上运行的。
applyFilter() 调用 heavyProcessing(...)，即使这个函数是 nonisolated，但它是被主线程调用的。
所以 heavyProcessing 仍然会在 主线程同步运行，并不会自动跳到后台线程！

nonisolated 只让你有能力“在后台线程调用它”，但不是说“系统就会自动安排在后台线程跑它”。
那要怎么让它真正跑在后台线程？
你要自己调度，比如这样：
@MainActor
func applyFilter() {
    Task.detached {
        let result = heavyProcessing(imageData)  // ⬅️ 在后台线程调用 nonisolated 函数
        await MainActor.run {
            self.image = result
        }
    }
}
Task.detached：在后台线程中执行（脱离 actor）
heavyProcessing 是 nonisolated，所以可以在后台线程调用它
再通过 MainActor.run 回到主线程更新 UI 状态


nonisolated 是 Swift 并发系统中的一个关键修饰符，它的作用是：
#####
标记某个方法或属性“不会受到 actor 或 global actor 隔离的限制”，可以在任何线程/actor 上安全调用。
#####

nonisolated 表示“我保证这个方法不依赖 actor 的内部状态，你可以在任何线程/actor 中直接调用它，无需 await、无需跳 actor”。

为什么需要 nonisolated？
Swift 中，如果你把一个类型标记为 @MainActor 或一个 actor 类型，那么所有方法默认都只能在那个 actor 上被调用。
@MainActor
class Logger {
    func log(_ message: String) {
        print(message)
    }
}

func test() {
    let logger = Logger()
    logger.log("Hello")  // 编译错误
}

但如果你这么写：
@MainActor
class Logger {
    nonisolated func log(_ message: String) {
        print(message)
    }
}
你就可以在任何地方直接调用它：
let logger = Logger()
logger.log("Hello")// 任何线程都能用
因为你告诉编译器：这个方法不访问主线程的数据，不需要跳 actor 调度。

你可以把它当作：“我这个方法不属于 actor 的运行时隔离域。”


nonisolated(unsafe) 是什么？
nonisolated(unsafe) func foo() { ... }
暂时绕过 actor 隔离，但编译器不会强制检查是否线程安全。
你自己负责安全性。
官方不推荐常用，适合非常特殊的场景（如与 C 互操作、低层系统库）

nonisolated 是你告诉编译器：“这个方法跟 actor 的状态无关，任何线程都能安全调用它”。


==================================================Actor 模型
actor 模型并不是 Swift 的创新，它是一个在计算机科学中存在多年的并发编程模型，Swift 是在语言层面将其引入并“现代化”了。
Actor 是一种 并发模型（Concurrency Model）
主要思想是：
每个 actor 拥有自己的私有状态，通过消息发送（message passing）来通信，不共享状态，从而避免数据竞争和并发冲突。