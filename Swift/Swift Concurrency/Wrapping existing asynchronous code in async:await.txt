https://www.donnywals.com/wrapping-existing-asynchronous-code-in-async-await-in-swift/



#if DEBUG
func withSmartContinuation<T>(
    _ body: @escaping (CheckedContinuation<T, Never>) -> Void
) async -> T {
    return await withCheckedContinuation { continuation in
        body(continuation)
    }
}
#else
func withSmartContinuation<T>(
    _ body: @escaping (UnsafeContinuation<T, Never>) -> Void
) async -> T {
    return await withUnsafeContinuation { continuation in
        body(continuation)
    }
}
#endif





import Foundation

enum ContinuationUtils {
    
    /// 自动选择使用 Checked 还是 Unsafe Continuation
    static func asyncify<T>(
        _ body: @escaping (@escaping (Result<T, Error>) -> Void) -> Void
    ) async throws -> T {
#if DEBUG
        return try await withCheckedContinuation { continuation in
            body { result in
                switch result {
                case .success(let value):
                    continuation.resume(returning: value)
                case .failure(let error):
                    continuation.resume(throwing: error)
                }
            }
        }
#else
        return try await withUnsafeContinuation { continuation in
            body { result in
                switch result {
                case .success(let value):
                    continuation.resume(returning: value)
                case .failure(let error):
                    continuation.resume(throwing: error)
                }
            }
        }
#endif
    }
}
