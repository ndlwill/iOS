https://www.swift.org/migration/documentation/swift-6-concurrency-migration-guide/incrementaladoption/#Dynamic-Isolation


Dynamic Isolation:
Dynamic isolation provides runtime mechanisms you can use as a fallback for describing data isolation. 
It can be an essential tool for interfacing a Swift 6 component with another that has not yet been updated, 
even if these components are within the same module.


Internal-Only Isolation:
Suppose you have determined that a reference type within your project can be best described with MainActor static isolation.
@MainActor
class WindowStyler {
    private var backgroundColor: ColorComponents


    func applyStyle() {
        // ...
    }
}

This MainActor isolation may be logically correct. 
But if this type is used in other unmigrated locations, adding static isolation here could require many additional changes.
An alternative is to use dynamic isolation to help control the scope.
class WindowStyler {
    @MainActor
    private var backgroundColor: ColorComponents


    func applyStyle() {
        MainActor.assumeIsolated {
            // use and interact with other `MainActor` state
        }
    }
}

