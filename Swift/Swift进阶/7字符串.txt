swiftä¸­String æ˜¯ä¸€ä¸ªç»“æ„ä½“ æˆ‘ä»¬ä¸»è¦ä½¿ç”¨String.Charactersï¼Œ å®ƒæ˜¯Characterçš„é›†åˆï¼Œæœ‰ç€ç±»ä¼¼Arrayçš„ç‰¹æ€§ã€‚


ç”¨ä¸¤ç§Unicodeçš„æ–¹å¼è¡¨ç¤ºå­—ç¬¦Ã©
str1 = \u{00E9}
str2 = \u{0065}\u{0301}

.utf8 ä»ç¼–ç å•å…ƒåˆ†æ:
str1.utf8.elementsEqual(str2.utf8)//false


Swift Character:
A single extended grapheme cluster that approximates a user-perceived character.
The Character type represents a character made up of one or more Unicode scalar values, grouped by a Unicode boundary algorithm.
Because each character in a string can be made up of one or more Unicode scalar values, the number of characters in a string may not match the length of the Unicode scalar value representation or the length of the string in a particular binary representation.
###
For example, a countryâ€™s Unicode flag character is made up of two regional indicator scalar values that correspond to that countryâ€™s ISO 3166-1 alpha-2 code. The alpha-2 code for The United States is â€œUSâ€, so its flag character is made up of the Unicode scalar values "\u{1F1FA}" (REGIONAL INDICATOR SYMBOL LETTER U) and "\u{1F1F8}" (REGIONAL INDICATOR SYMBOL LETTER S). When placed next to each other in a string literal, these two scalar values are combined into a single grapheme cluster, represented by a Character instance in Swift.
###
let usFlag: Character = "\u{1F1FA}\u{1F1F8}"
print(usFlag)
// Prints "ğŸ‡ºğŸ‡¸"




Characters and Grapheme Clusters(å›¾å½¢é›†ç°‡ï¼Œå­—ç¬¦è”Ÿï¼‰:
https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html
NSString objects are conceptually UTF-16 with platform endianness. 


In many writing systems, a single character may be composed of a base letter plus an accent or other decoration.
The number of possible letters and accents precludes Unicode from representing each combination as a single code point, 
so in general such combinations are represented by a base character followed by one or more combining marks. 
For compatibility reasons, Unicode does have single code points for a number of the most common combinations

In general, these combinationsâ€”surrogate pairs, base characters plus combining marks, Hangul jamo, and Indic consonant clustersâ€”are referred to as grapheme clusters.
In order to take them into account, you can use NSStringâ€™s rangeOfComposedCharacterSequencesForRange: or rangeOfComposedCharacterSequenceAtIndex: methods, or CFStringGetRangeOfComposedCharactersAtIndex.
These can be used to adjust string indexes or substring ranges so that they fall on grapheme cluster boundaries, taking into account all of the constraints mentioned above. 

å­—ç¬¦è”Ÿï¼š Character ä¸­çš„ç¼–ç ç‚¹ç»„åˆåœ¨ä¸€èµ·å¯ä»¥ç»„æˆå•ä¸ªå­—ç¬¦è”Ÿ

æ ‡å‡†ç­‰ä»·ï¼šä¸ç®¡æ˜¯ä½•ç§æ–¹å¼ç”Ÿæˆçš„Ã©ï¼Œåªçœ‹ä¸¤ä¸ªéƒ½æ˜¯æ˜¾ç¤ºä¸ºÃ©ï¼Œ åœ¨ Unicodeçš„è§„èŒƒä¸­æŠŠè¿™ä¸ªå°±å«åšâ€œæ ‡å‡†ç­‰ä»·â€

OCå­—ç¬¦ä¸²çš„æ¯”è¾ƒæ›´æ¨èç”¨compareæ–¹æ³•ï¼Œ isEqualæ–¹æ³•ç”¨ä¸Šé¢çš„ä¸åŒç”Ÿæˆæ–¹æ³•æ¯”è¾ƒå°±ä¼šå¾—åˆ°falseçš„ç»“æœ


é¿å…ç»™Stringæ·»åŠ åƒStr[i] çš„ç´¢å¼•çš„ç±»æ‰©å±•ï¼Œ è¿™æ ·ä½æ•ˆ


åœ¨arrayä¸Šåšåˆ‡ç‰‡æ“ä½œè¿”å›çš„ä¸æ˜¯arrayï¼Œè€Œæ˜¯arraySlice

String(â€œabcâ€) å’Œ â€œabcâ€æ˜¯ä¸åŒçš„ã€‚â€œabcâ€æ˜¯å­—ç¬¦ä¸²å­—é¢é‡


ExpressibleByStringLiteralæœ‰ä»€ä¹ˆç”¨ï¼Ÿ é€šè¿‡å­—é¢æ„æ€ï¼ˆå­—ç¬¦ä¸²ï¼‰å®ä¾‹åŒ–æŒ‡å®šç±»ã€‚
éœ€è¦åˆ›å»ºä¸€ä¸ªURLåº”è¯¥å¦‚ä¸‹
let urls = URL(string: "https://www.liaoworking.com")
æˆ‘ä»¬å¯ä»¥é€šè¿‡ExpressibleByStringLiteral æ¥ç”¨ä¸€ç§æ„æƒ³ä¸åˆ°çš„æ–¹å¼å»åˆ›å»ºä¸€ä¸ªURL
extension URL: ExpressibleByStringLiteral {

public init(stringLiteral value: String) 
{
	guard let url = URL(string: "\(value)") else {
    	preconditionFailure("This url: \(value) is not invalid")
	}
	self = url
}
ä¸‹ä¸€æ¬¡å½“ä½ åˆ›å»ºURLçš„æ—¶å€™å¯ä»¥è¿™æ · 
let url: URL = "https://www.liaoworking.com"


åˆ©ç”¨ExpressibleByStringLiteral åè®®æ¥æ›´æ–¹ä¾¿çš„æŠŠString è½¬åŒ–æˆDate å¦‚ä¸‹
let date: Date = â€œ2020-05-26 23:32:15â€ 


emojiåœ¨ä¸åŒçš„ç¼–ç å•å…ƒï¼ˆutf8ï¼Œutf16ï¼‰ä¸­é•¿åº¦ä¸åŒã€‚
let flag = "ğŸ‡µğŸ‡·"
print(flag.count)
// Prints "1"
print(flag.unicodeScalars.count)
// Prints "2"
print(flag.utf16.count)
// Prints "4"
print(flag.utf8.count)
// Prints "8"


ä¸€ä¸ªå­—ç¬¦ä¸²Stringå°±æ˜¯ä¸€ä¸ªå­—ç¬¦åºåˆ—
å•å­—èŠ‚Unicodeå­—ç¬¦ï¼Œ\xnnï¼Œå…¶ä¸­nnæ˜¯ä¸¤ä¸ªåå…­è¿›åˆ¶æ•°
åŒå­—èŠ‚Unicodeå­—ç¬¦ï¼Œ\unnnnï¼Œå…¶ä¸­nnnnæ˜¯å››ä¸ªåå…­è¿›åˆ¶æ•°
å››å­—èŠ‚Unicodeå­—ç¬¦ï¼Œ\Unnnnnnnnï¼Œå…¶ä¸­nnnnnnnnæ˜¯å…«ä¸ªåå…­è¿›åˆ¶æ•°

let dollarSign = "\x24" // $, Unicode scalar U+0024  
let blackHeart = "\u2665" // â™¥, Unicode scalar U+2665  
let sparklingHeart = "\U0001F496" // , Unicode scalar U+1F496 


Swiftçš„å­—ç¬¦ä¸²Stringå°±æ˜¯ç”±å­—ç¬¦Characterç»„æˆçš„ï¼Œæ¯ä¸€ä¸ªCharacteréƒ½ä»£è¡¨äº†ä¸€ä¸ªç‰¹å®šçš„Unicodeå­—ç¬¦ã€‚é€šè¿‡for-inå¾ªç¯ï¼Œå¯ä»¥éå†å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸€ä¸ªå­—ç¬¦ï¼š
//public typealias Element = Character
for character: String.Element in "Dog!ğŸ‡ºğŸ‡¸" {// è¡¨ç¤ºStringæ˜¯é›†åˆ
    print(character)
}  
// D  
// o  
// g  
// !  
// ğŸ‡ºğŸ‡¸


// public typealias Element = Unicode.Scalar
for character: String.UnicodeScalarView.Element in "Dog!ğŸ‡ºğŸ‡¸".unicodeScalars {
    print(character)
}
D
o
g
!
ğŸ‡º
ğŸ‡¸
æˆ‘ä»¬å¯ä»¥ä½¿ç”¨unicodeScalarså±æ€§éå†ä¸€ä¸ªUnicodeæ ‡é‡ç¼–ç çš„å­—ç¬¦ä¸²ã€‚
è¿™ä¸ªå±æ€§æ˜¯ UnicodeScalarsViewç±»å‹ï¼ŒUnicodeScalarsViewæ˜¯ä¸€ä¸ªUnicodeScalarç±»å‹çš„é›†åˆã€‚æ¯ä¸€ä¸ªUnicodeæ ‡ é‡éƒ½æ˜¯ä¸€ä¸ªä»»æ„21ä½Unicodeç ä½ã€‚

for character in "Dog!ğŸ‡ºğŸ‡¸".utf8 {
    print(character)
}
68
111
103
33
240
159
135
186
240
159
135
184

let yenSign: Character = "ï¿¥"  



Unicodeæ˜¯ç¼–ç å’Œè¡¨ç¤ºæ–‡æœ¬çš„å›½é™…æ ‡å‡†ã€‚å®ƒå‡ ä¹å¯ä»¥æ˜¾ç¤ºæ‰€æœ‰è¯­è¨€çš„æ‰€æœ‰å­—ç¬¦çš„æ ‡å‡†å½¢æ€ã€‚
Unicodeæœ¯è¯­
æ¯ä¸€ä¸ªUnicodeå­—ç¬¦éƒ½èƒ½è¢«ç¼–ç ä¸ºä¸€ä¸ªæˆ–å¤šä¸ªunicode scalarã€‚
ä¸€ä¸ªunicode scalaræ˜¯ä¸€ä¸ªå”¯ä¸€çš„21ä½æ•°ï¼ˆæˆ–è€…åç§°ï¼‰ï¼Œå¯¹åº”ç€ä¸€ä¸ªå­—ç¬¦æˆ–è€…æ ‡è¯†ã€‚ä¾‹å¦‚ U+0061æ˜¯ä¸€ä¸ªå°å†™çš„A (â€œaâ€), æˆ–è€…U+1F425æ˜¯ä¸€ä¸ªé¢å‘æˆ‘ä»¬çš„é»„è‰²å°é¸¡
å½“ä¸€ä¸ªUnicodeå­—ç¬¦ä¸²å†™å…¥æ–‡æœ¬æˆ–è€…å…¶ä»–å‚¨å­˜æ—¶ï¼Œunicode scalarä¼šæ ¹æ®Unicodeå®šä¹‰çš„æ ¼å¼æ¥ç¼–ç ã€‚æ¯ä¸€ä¸ªæ ¼å¼åŒ–ç¼–ç å­—ç¬¦éƒ½æ˜¯å°çš„ä»£ç å—ï¼Œç§°æˆä¸ºcode units.ä»–åŒ…å«UTF-8æ ¼å¼(æ¯ä¸€ä¸ªå­—ç¬¦ä¸²ç”±8ä½çš„code unitsç»„æˆ)ã€‚å’ŒUTF-16æ ¼å¼ï¼ˆæ¯ä¸€ä¸ªå­—ç¬¦ä¸²ç”±16ä½çš„code unitsç»„æˆ)

Unicodeå­—ç¬¦ä¸²
Swift æ”¯æŒå¤šç§ä¸åŒçš„æ–¹å¼å–å¾—Unicodeå­—ç¬¦ä¸².
ä½ å¯ä»¥ä½¿ç”¨for-inè¯­å¥éå†å­—ç¬¦ä¸²ï¼Œæ¥è·å¾—æ¯ä¸€ä¸ªå­—ç¬¦çš„Unicodeç¼–ç å€¼ã€‚
UTF-8å­—ç¬¦ç¼–ç å•å…ƒé›†åˆä½¿ç”¨Stringç±»å‹çš„utf-8å±æ€§
UTF-16å­—ç¬¦ç¼–ç å•å…ƒé›†åˆä½¿ç”¨Stringç±»å‹çš„utf-16å±æ€§
21ä½Unicodeæ ‡é‡é›†åˆä½¿ç”¨Stringç±»å‹çš„unicodeScalarså±æ€§

ä¸‹é¢çš„æ¯ä¸€ä¸ªä¾‹å­å±•ç¤ºäº†ä¸åŒç¼–ç æ˜¾ç¤ºç”± D , o , g , !ï¼ˆDOG FACE, æˆ–è€…Unicodeæ ‡é‡ U+1F436ï¼‰å­—ç¬¦ç»„æˆçš„å­—ç¬¦ä¸²
UTF-8
ä½ å¯ä»¥ä½¿ç”¨Stringç±»å‹çš„utf8å±æ€§éå†ä¸€ä¸ªUTF-8ç¼–ç çš„å­—ç¬¦ä¸²ã€‚è¿™ä¸ªå±æ€§æ˜¯UTF8Viewç±»å‹ï¼ŒUTF8Viewæ˜¯ä¸€ä¸ª8ä½æ— ç¬¦å·æ•´å½¢(UInt8)çš„é›†åˆ,é›†åˆä¸­çš„æ¯ä¸€ä¸ªå­—èŠ‚éƒ½æ˜¯UTF-8ç¼–ç ã€‚
for codeUnit in dogString.utf8 {  
print("\(codeUnit) ")  
}  
print("\n")  
// 68 111 103 33 240 159 144 182
åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œå‰4ä¸ªåè¿›åˆ¶codeunitå€¼ï¼ˆ68,111,103,33ï¼‰æ˜¾ç¤ºä¸ºå­—ç¬¦ä¸² D , o ,g å’Œ ! ï¼Œå’Œä»–ä»¬çš„ASCIIç¼–ç ç›¸åŒä¸€æ ·ã€‚åé¢4ä¸ªcodeunitçš„å€¼ï¼ˆ240,159,144,182ï¼‰æ˜¯DOG FACEå­—ç¬¦çš„4å­—èŠ‚UTF-8ç¼–ç ã€‚

UTF-16
ä½ å¯ä»¥ä½¿ç”¨Stringç±»å‹çš„utf16å±æ€§éå†ä¸€ä¸ªUTF-16ç¼–ç çš„å­—ç¬¦ä¸²ã€‚è¿™ä¸ªå±æ€§æ˜¯UTF16Viewç±»å‹ï¼ŒUTF16Viewæ˜¯ä¸€ä¸ª16ä½æ— ç¬¦å·æ•´å½¢(UInt16)çš„é›†åˆ,é›†åˆä¸­çš„æ¯ä¸€ä¸ªå­—èŠ‚éƒ½æ˜¯UTF-16ç¼–ç ã€‚
for codeUnit in dogString.utf16 {  
print("\(codeUnit) ")  
}  
print("\n")  
// 68 111 103 33 55357 56374
å‰4ä¸ªåè¿›åˆ¶codeunitå€¼ï¼ˆ68,111,103,33ï¼‰æ˜¾ç¤ºä¸ºå­—ç¬¦ä¸² D , o ,g å’Œ ! ï¼Œä»–ä»¬çš„UTF-16 çš„codeunitå’Œä»–ä»¬UTF-8çš„ç¼–ç å€¼ç›¸åŒã€‚
ç¬¬5å’Œç¬¬6ä¸ªcodeunitå€¼ï¼ˆ55357å’Œ56374ï¼‰æ˜¯DOG FACEå­—ç¬¦çš„UTF-16çš„ä»£ç†å¯¹ç¼–ç ã€‚ä»–ä»¬çš„å€¼æ˜¯ç”±å€¼ä¸ºU+D83Dï¼ˆåè¿›åˆ¶55357ï¼‰çš„é«˜ä½ä»£ç†(lead surrogate)å’Œå€¼ä¸ºU+DC36 (åè¿›åˆ¶56374)çš„ä½ä½ä»£ç†ï¼ˆtrail surrogateï¼‰ç»„æˆã€‚

Unicodeæ ‡é‡
ä½ å¯ä»¥ä½¿ç”¨Stringç±»å‹çš„unicodeScalarså±æ€§éå†ä¸€ä¸ªUnicodeæ ‡é‡ç¼–ç çš„å­—ç¬¦ä¸²ã€‚è¿™ä¸ªå±æ€§æ˜¯ UnicodeScalarsViewç±»å‹ï¼ŒUnicodeScalarsViewæ˜¯ä¸€ä¸ªUnicodeScalarç±»å‹çš„é›†åˆã€‚æ¯ä¸€ä¸ªUnicodeæ ‡ é‡éƒ½æ˜¯ä¸€ä¸ªä»»æ„21ä½Unicodeç ä½ï¼Œæ²¡æœ‰é«˜ä½ä»£ç†ï¼Œä¹Ÿæ²¡æœ‰ä½ä½ä»£ç†ã€‚
æ¯ä¸€ä¸ªUnicodeScalarä½¿ç”¨valueå±æ€§ï¼Œè¿”å›æ ‡é‡çš„21ä½å€¼ï¼Œæ¯ä¸€ä½éƒ½æ˜¯32ä½æ— ç¬¦å·æ•´å½¢(UInt32)çš„å€¼
for scalar in dogString.unicodeScalars {  
print("\(scalar.value) ")  
}  
print("\n")  
// 68 111 103 33 128054
valueå±æ€§åœ¨å‰4ä¸ªUnicodeScalarå€¼ï¼ˆ68,111,103,33ï¼‰å†ä¸€æ¬¡å±•ç¤ºç¼–ç äº†å­—ç¬¦ D , o , g å’Œ ï¼ ã€‚ç¬¬äº”ä¸ªä¹Ÿæ˜¯æœ€åä¸€ä¸ªUnicodeScalar æ˜¯DOG FACEå­—ç¬¦ï¼Œåè¿›åˆ¶ä¸º128054ï¼Œç­‰ä»·äº16è¿›åˆ¶çš„1F436ï¼Œç›¸å½“äºUnicodeæ ‡é‡çš„U+1F436ã€‚

æ¯ä¸€ä¸ªUnicodeScalarå¯ä»¥è¢«æ„é€ æˆä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²æ¥ä»£æ›¿è¯»å–ä»–ä»¬çš„valueå±æ€§
for scalar in dogString.unicodeScalars { println("\(scalar) ") }  



CustomStringConvertible å’Œ CustomDebugStringConvertible:
è¿™ä¸¤ä¸ªåè®®ä¸»è¦å°±æ˜¯ç±»ä¼¼äºObjective-Cä¸­çš„é‡å†™descriptionæ–¹æ³•
ç»§æ‰¿åè®® å®ç°description å’Œ debugDescription å±æ€§ å³å¯æ‰“å°å‡ºæƒ³è¦çš„æ•°æ®å†…å®¹

struct Person:CustomStringConvertible,CustomDebugStringConvertible {
    var age: Int
    var name: String
    var job: String

    var description: String {
        return "\(age) \(name) \(job)"
    }

    var debugDescription: String {
        return "\(name) \(age) \(job)"
    }
  }

  let meetings = Person(age: 18, name: "liaoWorking", job: "iOSDeveloper")
  print(meetings)
  /**
   *  "18 liaoWorking iOSDeveloper\n"
   */
  debugPrint(meetings)
  /**
   *  "liaoWorking 18 iOSDeveloper\n"
   */
}


Swift Stringä¸­æœ‰å¾ˆå¤šå­—ç¬¦ç±»å‹çš„å±æ€§ å¦‚utf16(utf16Viewç±»å‹),utf8(utf8Viewç±»å‹),unicodeScalars(UnicodeScalarsViewç±»å‹)
ä¸ºä»€ä¹ˆæ˜¯ä»¥Viewç»“å°¾çš„ï¼Ÿ
åœ¨apiæ–‡æ¡£ä¸­å¯¹ä»–ä»¬çš„ä»‹ç»æ˜¯ï¼šå­—ç¬¦ä¸²æ‰€åŒ…å«çš„ç¼–ç å•å…ƒçš„è§†å›¾ (A view of a string's contents as a collection of code units. )


TextOutputStream åè®®:
å®ç°TextOutputStreamåè®®åªéœ€è¦å®ç°å…¶writeæ–¹æ³•ã€‚ è°ƒç”¨print(â€œâ€, to: &æ‰“å°è½¬æ¢çš„å®ä¾‹å¯¹è±¡)è¿™ä¸ªæ–¹æ³•å³å¯ã€‚
/// The `ASCIILogger` type's `write(_:)` method processes its string input by
/// escaping each Unicode scalar, with the exception of `"\n"` line returns.
/// By sending the output of the `print(_:to:)` function to an instance of
/// `ASCIILogger`, you invoke its `write(_:)` method.
///
///     let s = "Hearts â™¡ and Diamonds â™¢"
///     print(s)
///     // Prints "Hearts â™¡ and Diamonds â™¢"
///
///     var asciiLogger = ASCIILogger()
///     print(s, to: &asciiLogger)
///     // Prints "Hearts \u{2661} and Diamonds \u{2662}"
public protocol TextOutputStream {

    /// Appends the given string to the stream.
    mutating func write(_ string: String)
}

struct ASCIILogger: TextOutputStream {
    mutating func write(_ string: String) {
        let ascii = string.unicodeScalars.lazy.map { scalar in
            scalar == "\n"
              ? "\n"
              : scalar.escaped(asASCII: true)
        }
        print(ascii.joined(separator: ""), terminator: "")
    }
}