https://lldb.llvm.org/use/map.html

LLDB断点命令:
设置断点
给指定内存地址下断点： br set -a 0x00000000
给某方法下断点：b -n "[ClassName methodName]"

查看断点
br list 全拼: breakpoint list

删除断点
br del n 这里的n是上一步br list列出的断点的序号
当然你也可以直接br del，然后lldb会问你是否要删除全部断点


如何定位函数地址:
为了降低被黑客攻击的风险，操作系统大都采用ASLR(地址空间布局随机化) 技术
https://www.jianshu.com/p/33c9883b647a
进程每一次启动时，地址空间都会被简单地随机化：进行整体的地址偏移
通过内核将整个进程的内存空间“平移”某个随机数，进程的基本内存布局如程序文本、数据、库等相对位置仍然是一样的，但其具体的地址都不同了。
ASLR会在进程启动时候随机一个基地址
在lldb中的查看命令是image list 或image list -o -f
不加参数，它打印的就是每个image（镜像）的虚拟内存地址
加了-o参数，打印的就是image的偏移量

http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/
image list 打印的基地址： 0x102a94000
image list -o -f的地址： 0x002a94000
相差0x 1 0000 0000
4GB = 232,用二进制表示就是：第32+1位为1，剩下的32位为0。而4位二进制位可以表示一个十六进制位，所以十六进制表示就是：0x 1 0000 0000。这样就满足了64位进程至少4GB的最小偏移范围了。

main()调用之前会调用exec()，exec() 是一个系统调用。系统内核把应用映射到新的地址空间，且每次起始位置都是随机的（因为使用 ASLR）。

操作系统将我们（程序猿）跟物理内存划分了一个安全界限，我们程序猿只需要用虚拟内存跟操作系统打交道即可，操作系统调用底层硬件api，跟物理内存打交道。
如果程序猿直接跟物理内存交流，恐怕不是那么安全的
基地址有了，在前面ASLR技术中我们提到内核将整个进程的内存“平移”，所以数据段、代码段等等内存的偏移量其实是固定的，他们相对于mach-o header部分的偏移量是个常亮

虚拟地址 = 基地址 + 偏移地址

读内存命令：x 0x102a94000 全拼是：memory read 0x102a94000
反汇编命令：dis -s 0x102a94000 dis是dissamble的简写

《汇编语言第3版》王爽著