==========Mirroråå°„
Mirror(åå°„)ï¼šå¯ä»¥åŠ¨æ€è·å–ç±»å‹ã€æˆå‘˜ä¿¡æ¯ï¼Œåœ¨è¿â¾æ—¶å¯ä»¥è°ƒâ½¤â½…æ³•ã€å±æ€§ç­‰â¾ä¸ºçš„ç‰¹æ€§ã€‚
å¯¹äºâ¼€ä¸ªçº¯Swiftç±»æ¥è¯´ï¼Œå¹¶ä¸â½€æŒç›´æ¥åƒOCé‚£æ ·ä½¿ç”¨Runtimeæ“ä½œã€‚ä½†Swiftæ ‡å‡†åº“ä¾ç„¶æä¾›äº†åå°„æœºåˆ¶ï¼Œç”¨æ¥è®¿é—®æˆå‘˜ä¿¡æ¯ã€‚

è®¿é—®æˆå‘˜ä¿¡æ¯:
class LGTeacher {
    var age: Int = 18
    var name: String = "Zang"
}

var t = LGTeacher()

let mirror = Mirror(reflecting: t)

for pro in mirror.children{
    print("\(pro.label):\(pro.value)")
}

//è¾“å‡ºä»¥ä¸‹å†…å®¹ï¼š
//Optional("age"):18
//Optional("name"):Zang

Mirroråå°„çš„æ˜¯å®ä¾‹å¯¹è±¡çš„æˆå‘˜ä¿¡æ¯ï¼Œä¼ å…¥çš„å‚æ•°å¿…é¡»æ˜¯å®ä¾‹å¯¹è±¡
ä¼ å…¥ä¸€ä¸ªç±»å¯¹è±¡Mirror(reflecting: LGTeacher)ï¼Œç¼–è¯‘æŠ¥é”™
ä¼ å…¥ä¸€ä¸ªç±»çš„ç±»å‹Mirror(reflecting: LGTeacher.self)ï¼Œè·å–ä¸åˆ°ä»»ä½•æˆå‘˜ä¿¡æ¯

æŸ¥çœ‹Mirrorå®šä¹‰:
Mirroræ˜¯ä¸€ä¸ªç»“æ„ä½“
Mirrorçš„initæ–¹æ³•ï¼Œæ¥æ”¶ä¸€ä¸ªAnyç±»å‹å‚æ•°
Childrenæ˜¯ä¸€ä¸ªAnyCollectionï¼Œæ¥æ”¶ä¸€ä¸ªæ³›å‹Mirror.Child
Mirror.Childæ˜¯ä¸€ä¸ªå…ƒç»„ç±»å‹

JSONè§£æ:
class LGTeacher {
    var age: Int = 18
    var name: String = "Zang"
}

func test(_ obj : Any) -> Any {
    
    let mirror = Mirror(reflecting: obj)
    
    guard !mirror.children.isEmpty else {
        return obj
    }
    
    var keyValue: [String: Any] = [:]
    
    for children in mirror.children {
        
        if let keyName = children.label {
            keyValue[keyName] = test(children.value)
        }
        else {
            print("children.label ä¸ºç©º")
        }
    }
    
    return keyValue
}

var t = LGTeacher()
print(test(t))

//è¾“å‡ºä»¥ä¸‹å†…å®¹ï¼š
//["name": "Zang", "age": 18]

æˆåŠŸçš„å°†å®ä¾‹å¯¹è±¡tè½¬ä¸ºå­—å…¸å¹¶è¾“å‡ºï¼Œä½†åœ¨å®é™…å¼€å‘ä¸­ï¼Œè¿™æ ·çš„ä»£ç å†™çš„ç›¸å¯¹ä¸‘é™‹ï¼Œä¸‹é¢å°±æ¥å¯¹å®ƒåšä¸€ä¸ªç®€å•çš„å°è£…
æŠ½å–åè®®:
æˆ‘ä»¬é¢„æœŸåœ¨æ¯ä¸€ä¸ªå±æ€§ä¸‹éƒ½èƒ½è°ƒç”¨JSONè§£æçš„æ–¹æ³•ï¼Œæ‰€ä»¥å¯ä»¥å°†å®ƒæŠ½å–æˆä¸€ä¸ªåè®®ï¼Œç„¶åæä¾›ä¸€ä¸ªé»˜è®¤å®ç°ï¼Œè®©ç±»éµå®ˆåè®®

protocol CustomJSONMap {
    func jsonMap() -> Any
}

extension CustomJSONMap{
    func jsonMap() -> Any{

        let mirror = Mirror(reflecting: self)
    
        guard !mirror.children.isEmpty else {
            return self
        }
    
        var keyValue: [String: Any] = [:]
    
        for children in mirror.children {
    
            if let value = children.value as? CustomJSONMap {
                
                if let keyName = children.label {
                    keyValue[keyName] = value.jsonMap()
                }
                else {
                    print("keyæ˜¯nil")
                }
            }
            else {
                print("å½“å‰-\(children.value)-æ²¡æœ‰éµå®ˆåè®®")
            }
        }
    
        return keyValue
    }
}

class LGTeacher : CustomJSONMap {
    var age: Int = 18
    var name: String = "Zang"
}

var t = LGTeacher()
print(t.jsonMap())

//è¾“å‡ºä»¥ä¸‹å†…å®¹ï¼š
//å½“å‰-18-æ²¡æœ‰éµå®ˆåè®®
//å½“å‰-Zang-æ²¡æœ‰éµå®ˆåè®®
//[:]

ä¸Šè¿°ä»£ç ä¸­ï¼Œå› ä¸ºageå’Œnameåˆ†åˆ«ä¸ºIntå’ŒStringç±»å‹ï¼Œè¿™äº›ç±»å¹¶æ²¡æœ‰éµå®ˆCustomJSONMapåè®®ï¼Œæ‰€ä»¥æ— æ³•è¾“å‡ºæ­£ç¡®ç»“æœ

extension Int: CustomJSONMap{}
extension String: CustomJSONMap{}

class LGTeacher: CustomJSONMap {
    var age: Int = 18
    var name: String = "Zang"
}

var t = LGTeacher()
print(t.jsonMap())

//è¾“å‡ºä»¥ä¸‹å†…å®¹ï¼š
//["age": 18, "name": "Zang"]

==========é”™è¯¯å¤„ç†
Erroråè®®
Swiftæä¾›Erroråè®®æ¥æ ‡è¯†å½“å‰åº”â½¤ç¨‹åºå‘â½£é”™è¯¯çš„æƒ…å†µï¼Œä¸ç®¡æ˜¯structã€Classã€enuméƒ½å¯ä»¥é€šè¿‡éµå¾ªè¿™ä¸ªåè®®æ¥è¡¨ç¤ºâ¼€ä¸ªé”™è¯¯ã€‚Errorçš„å®šä¹‰å¦‚ä¸‹:

ä¸Šè¿°JSONè§£ææ¡ˆä¾‹ä¸­ï¼Œæœ‰ä¸¤ä¸ªprintåˆ†åˆ«æ‰“å°æœªéµå®ˆåè®®å’Œkeyæ˜¯nilï¼Œä¸‹é¢æ¼”ç¤ºå¦‚ä½•é€šè¿‡Erroråè®®å¤„ç†è¿™ä¸¤ç§å¼‚å¸¸æƒ…å†µ
ä¸Šè¿°ä»£ç ä¸­ï¼Œå°†JSONMapError.emptyKeyå’ŒJSONMapError.notConformProtocolè¿›è¡Œreturn
ä»¥æ­¤ä»£æ›¿ä¹‹å‰ä¸¤ä¸ªprintã€‚ä½†å¯¹äºjsonMapæ–¹æ³•æ¥è¯´ï¼Œç”±äºè¿”å›å€¼æ˜¯Anyç±»å‹ï¼Œæ•…æ­¤æˆ‘ä»¬æ— æ³•åŒºåˆ†è¿”å›ç»“æœæ˜¯è§£ææˆåŠŸçš„å­—å…¸ï¼Œè¿˜æ˜¯é”™è¯¯çš„æšä¸¾

å¯¹äºå¼‚å¸¸æƒ…å†µï¼Œå¯ä»¥ä½¿ç”¨throwå…³é”®å­—å°†é”™è¯¯æŠ›å‡ºï¼Œå°†ä»£ç ä¸­çš„returnæ”¹ä¸ºthrow
ä½¿ç”¨throwç¼–è¯‘æŠ¥é”™ï¼Œå› ä¸ºæ–¹æ³•è¿˜æ²¡æœ‰å£°æ˜æˆthrowsã€‚éœ€è¦åœ¨æ–¹æ³•è¿”å›å€¼å‰é¢å¢åŠ throwså…³é”®å­—ï¼Œå‘Šè¯‰æ–¹æ³•æœ‰é”™è¯¯æŠ›å‡º

æ–¹æ³•ä½¿ç”¨throwså…³é”®å­—ä¿®é¥°ï¼Œè°ƒç”¨è¯¥æ–¹æ³•çš„ä»£ç ç¼–è¯‘æŠ¥é”™ã€‚å¯¹äºæœ‰é”™è¯¯æŠ›å‡ºçš„æ–¹æ³•ï¼Œéœ€è¦åœ¨è°ƒç”¨æ–¹æ³•å‰ä½¿ç”¨tryå…³é”®å­—
enum JSONMapError: Error{
    case emptyKey
    case notConformProtocol
}

protocol CustomJSONMap {
    func jsonMap() throws-> Any
}

extension CustomJSONMap{
    func jsonMap() throws-> Any{

        let mirror = Mirror(reflecting: self)
    
        guard !mirror.children.isEmpty else {
            return self
        }
    
        var keyValue: [String: Any] = [:]
    
        for children in mirror.children {
    
            if let value = children.value as? CustomJSONMap {
                
                if let keyName = children.label {
                    keyValue[keyName] = try value.jsonMap()
                }
                else {
                    throw JSONMapError.emptyKey
                }
            }
            else {
                throw JSONMapError.notConformProtocol
            }
        }
    
        return keyValue
    }
}

extension Int : CustomJSONMap{}
extension String : CustomJSONMap{}

class LGTeacher : CustomJSONMap {
    var age: Int = 18
    var name: String = "Zang"
}

var t = LGTeacher()
print(try t.jsonMap())
åˆ°è¿™â¾¥ä¸€ä¸ªå®Œæ•´çš„Swifté”™è¯¯è¡¨è¾¾â½…å¼å°±å®Œæˆäº†


tryå…³é”®å­—
ä½¿â½¤tryå…³é”®å­—æ˜¯Swiftä¸­é”™è¯¯å¤„ç†æœ€ç®€ä¾¿çš„æ–¹å¼ï¼Œç›¸å½“äºå¸…é”…ã€‚å°†å¼‚å¸¸å‘ä¸ŠæŠ›å‡ºï¼ŒæŠ›ç»™ä¸Šå±‚å‡½æ•°ã€‚ä½¿â½¤tryå…³é”®å­—æœ‰ä¸¤ä¸ªæ³¨æ„ç‚¹ï¼š

try?ï¼šè¿”å›â¼€ä¸ªå¯é€‰ç±»å‹ï¼Œè¿™â¾¥çš„ç»“æœè¦ä¹ˆæ˜¯æˆåŠŸï¼Œè¿”å›å…·ä½“ç»“æœã€‚è¦ä¹ˆæ˜¯é”™è¯¯ï¼Œè¿”å›nilã€‚è¿™ç§æ–¹å¼æˆ‘ä»¬ä¸å…³å¿ƒå…·ä½“æ˜¯å“ªâ¼€ç±»é”™è¯¯ï¼Œç»Ÿâ¼€è¿”å›nil
try!ï¼šè¡¨ç¤ºä½ å¯¹è¿™æ®µä»£ç æœ‰ç»å¯¹çš„â¾ƒä¿¡ï¼Œè¿™â¾ä»£ç ç»å¯¹ä¸ä¼šå‘â½£é”™è¯¯

ä½¿ç”¨try t.jsonMap()ï¼Œå°†å¼‚å¸¸æŠ›ç»™ä¸Šå±‚å‡½æ•°ï¼Œå¦‚æœå…¨ç¨‹æ²¡æœ‰å‡½æ•°å¤„ç†å¼‚å¸¸ï¼Œæœ€ç»ˆæŠ›ç»™mainå‡½æ•°ä¹Ÿæ²¡åŠæ³•å¤„ç†ï¼Œç¨‹åºç›´æ¥é—ªé€€


do...catch
Swiftä¸­do...catchæ˜¯é”™è¯¯å¤„ç†çš„å¦ä¸€ç§æ–¹å¼
//extension Int : CustomJSONMap{}
//extension String : CustomJSONMap{}

class LGTeacher : CustomJSONMap {
    var age: Int = 18
    var name: String = "Zang"
}

var t = LGTeacher()

do{
    try t.jsonMap()
}catch{
    print(error)
}

//è¾“å‡ºä»¥ä¸‹å†…å®¹ï¼š
//notConformProtocol

é€šè¿‡doä½œç”¨åŸŸæ•è·å¼‚å¸¸ï¼Œé€šè¿‡catchä½œç”¨åŸŸå¤„ç†å¼‚å¸¸ï¼Œæœ€ç»ˆæ‰“å°å‡ºé”™è¯¯ç±»å‹notConformProtocol

==========LocalErroråè®®
å¦‚æœä½¿â½¤Erroråè®®ä¸èƒ½è¯¦å°½è¡¨è¾¾é”™è¯¯ä¿¡æ¯ï¼Œå¯ä»¥ä½¿â½¤LocalErroråè®®ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š

public protocol LocalizedError : Error {

    //é”™è¯¯çš„æè¿°
    /// A localized message describing what error occurred.
    var errorDescription: String? { get }

    //å¤±è´¥çš„åŸå› 
    /// A localized message describing the reason for the failure.
    var failureReason: String? { get }

    //æ¢å¤çš„å»ºè®®
    /// A localized message describing how one might recover from the failure.
    var recoverySuggestion: String? { get }

    //ç»™å¼€å‘è€…çš„å¸®åŠ©
    /// A localized message providing "help" text if the user requests help.
    var helpAnchor: String? { get }
}

ä¿®æ”¹JSONè§£ææ¡ˆä¾‹ï¼Œä½¿ç”¨LocalizedErroråè®®ï¼Œæ‰“å°å…·ä½“çš„é”™è¯¯æè¿°

enum JSONMapError: Error{
    case emptyKey
    case notConformProtocol
}

extension JSONMapError: LocalizedError{
    var errorDescription: String?{
        switch self {
            case .emptyKey:
                return "keyä¸ºç©º"
            case .notConformProtocol:
                return "æ²¡æœ‰éµå®ˆåè®®"
        }
    }
}

//extension Int : CustomJSONMap{}
//extension String : CustomJSONMap{}

class LGTeacher : CustomJSONMap {
    var age: Int = 18
    var name: String = "Zang"
}

var t = LGTeacher()

do{
    try t.jsonMap()
}catch{
    print(error.localizedDescription)
}

//è¾“å‡ºä»¥ä¸‹å†…å®¹ï¼š
//æ²¡æœ‰éµå®ˆåè®®
ä¸ºJSONMapErrorå¢åŠ extensionæ‰©å±•ï¼Œå¹¶éµå®ˆLocalizedErroråè®®ï¼Œåœ¨catchä½œç”¨åŸŸä¸­æ‰“å°error.localizedDescriptionï¼Œæœ€ç»ˆè¾“å‡ºé”™è¯¯æè¿°ï¼šæ²¡æœ‰éµå®ˆåè®®


==========CustomErroråè®®
CustomNSErrorç›¸å½“äºOCä¸­çš„NSErrorï¼Œæœ‰ä¸‰ä¸ªé»˜è®¤å±æ€§ï¼š

public protocol CustomNSError : Error {

    /// The domain of the error.
    static var errorDomain: String { get }

    /// The error code within the given domain.
    var errorCode: Int { get }

    /// The user-info dictionary.
    var errorUserInfo: [String : Any] { get }
}

ä¿®æ”¹JSONè§£ææ¡ˆä¾‹ï¼Œä½¿ç”¨CustomNSErroråè®®ï¼Œæ‰“å°é”™è¯¯ç 
enum JSONMapError: Error{
    case emptyKey
    case notConformProtocol
}

extension JSONMapError: CustomNSError{
    var errorCode: Int{
        switch self {
        case .emptyKey:
            return -1
        case .notConformProtocol:
            return -2
        }
    }
}

//extension Int : CustomJSONMap{}
//extension String : CustomJSONMap{}

class LGTeacher : CustomJSONMap {
    var age: Int = 18
    var name: String = "Zang"
}

var t = LGTeacher()

do{
    try t.jsonMap()
}catch{
    print("\(String(describing: (error as? CustomNSError)?.errorCode))")
}

//è¾“å‡ºä»¥ä¸‹å†…å®¹ï¼š
//Optional(-2)

ä¸ºJSONMapErrorå¢åŠ extensionæ‰©å±•ï¼Œå¹¶éµå®ˆCustomNSErroråè®®ï¼Œåœ¨catchä½œç”¨åŸŸä¸­ä½¿ç”¨as?å…³é”®å­—å°†errorå¼ºè½¬ä¸ºCustomNSErrorç±»å‹ï¼Œå¹¶æ‰“å°errorCodeï¼Œæœ€ç»ˆè¾“å‡ºé”™è¯¯ç ï¼šOptional(-2)

==========Mirroræºç è§£æ
@_silgen_nameå…³é”®å­—
@_silgen_nameå…³é”®å­—ç”¨æ¥æ”¹å˜å½“å‰æ–¹æ³•çš„è°ƒç”¨æ–¹å¼

åœ¨swifté¡¹ç›®ä¸­ï¼Œåˆ›å»ºtest.cï¼Œé‡Œé¢å£°æ˜lg_addå‡½æ•°ï¼Œä¼ å…¥ä¸¤ä¸ªå‚æ•°ï¼Œè¿”å›å‚æ•°ç›¸åŠ çš„ç»“æœ

åœ¨main.swiftä¸­ï¼Œå®šä¹‰swift_lg_addæ–¹æ³•ï¼Œå‚æ•°ã€è¿”å›å€¼å’Œtest.cçš„lg_addä¸€è‡´ï¼Œå¹¶åŠ å…¥@_silgen_name("lg_add")å…³é”®å­—å£°æ˜ï¼Œå°è¯•è°ƒç”¨swift_lg_addæ–¹æ³•ï¼Œå‘ç°æœ€ç»ˆä¼šè°ƒç”¨lg_add

æºç è§£æï¼š
æ‰“å¼€Mirror.swiftï¼Œå¯ä»¥çœ‹åˆ°Mirroræ˜¯ä¸€ä¸ªç»“æ„ä½“ç±»å‹

åŸç†è§£æï¼š
struct LGTeacher{
    var age = 18
    var name = "Zang"
}

å®šä¹‰StructMetadataç»“æ„ä½“ï¼Œç›¸å½“äºTargetStructMetadata
struct StructMetadata{
    var kind: Int
    var typeDescriptor: UnsafeMutablePointer<StructDescriptor>
}

å®šä¹‰StructDescriptorç»“æ„ä½“ï¼Œç›¸å½“äºTargetValueTypeDescription
struct StructDescriptor {
    let flags: Int32
    let parent: Int32
    var name: RelativePointer<CChar>
    var AccessFunctionPtr: RelativePointer<UnsafeRawPointer>
    var Fields: RelativePointer<FieldDescriptor>
    var NumFields: Int32
    var FieldOffsetVectorOffset: Int32
}

å®šä¹‰FieldDescriptorç»“æ„ä½“ï¼Œç›¸å½“äºFieldDescriptor
struct FieldDescriptor {
    var MangledTypeName: RelativePointer<CChar>
    var Superclass: RelativePointer<CChar>
    var kind: UInt16
    var fieldRecordSize: Int16
    var numFields: Int32
    //è¿ç»­çš„å­˜å‚¨ç©ºé—´
    var fields: FieldRecordT<FieldRecord>
}

å®šä¹‰FieldRecordç»“æ„ä½“ï¼Œç›¸å½“äºFieldRecord
struct FieldRecord {
    var Flags: Int32
    var MangledTypeName: RelativePointer<CChar>
    var FieldName: RelativePointer<CChar>
}

å®šä¹‰RelativePointerç»“æ„ä½“ï¼Œä»¿ç…§RelativeDirectPointerImplçš„getæ–¹æ³•ï¼Œå®ç°å½“å‰æŒ‡é’ˆçš„åç§»
struct RelativePointer<T> {
    var offset: Int32

    mutating func get() -> UnsafeMutablePointer<T>{
        let offset = self.offset

        return withUnsafePointer(to: &self) { p in
            return UnsafeMutablePointer(mutating: UnsafeRawPointer(p).advanced(by: numericCast(offset)).assumingMemoryBound(to: T.self))
        }
    }
}
offsetï¼šåç§»åœ°å€
UnsafeMutablePointerï¼šè½¬æ¢ä¸ºUnsafeMutablePointerç±»å‹æŒ‡é’ˆ
UnsafeRawPointer(p)ï¼šå½“å‰this
advancedï¼šç§»åŠ¨æ­¥é•¿
numericCastï¼šä½çš„å¼ºè½¬
assumingMemoryBoundï¼šå‡å®šå†…å­˜ç»‘å®šä¸ºTçš„ç±»å‹

å®šä¹‰FieldRecordTç»“æ„ä½“ï¼Œå®ç°ç±»ä¼¼getFiledAtæ–¹æ³•ï¼Œåœ¨è¿ç»­å†…å­˜ç©ºé—´ä¸­ï¼Œç§»åŠ¨æ­¥é•¿ï¼Œæ‹¿åˆ°æ¯ä¸€ä¸ªFieldRecord
struct FieldRecordT<Element> {
    var element: Element
    mutating func element(at i: Int) -> UnsafeMutablePointer<Element> {
        return withUnsafePointer(to: &self) { p in
            return UnsafeMutablePointer(mutating:  UnsafeRawPointer(p).assumingMemoryBound(to: Element.self).advanced(by: i))
        }
    }
}




ä½¿ç”¨unsafeBitCastå†…å­˜æŒ‰ä½è½¬æ¢ï¼Œå°†LGTeacherçš„ç±»å‹ç»‘å®šåˆ°StructMetadata
let ptr = unsafeBitCast(LGTeacher.self as Any.Type, to: UnsafeMutablePointer<StructMetadata>.self)

è·å–ç±»å‹ï¼š
let namePtr = ptr.pointee.typeDescriptor.pointee.name.get()
print("ç±»å‹ï¼š\(String(cString: namePtr))")

//è¾“å‡ºä»¥ä¸‹ç»“æœï¼š
//ç±»å‹ï¼šLGTeacher

è·å–å±æ€§å¤§å°ï¼š
let fieldDescriptorPtr = ptr.pointee.typeDescriptor.pointee.Fields.get()
print("å±æ€§å¤§å°ï¼š\(ptr.pointee.typeDescriptor.pointee.NumFields)")

//è¾“å‡ºä»¥ä¸‹ç»“æœï¼š
//å±æ€§å¤§å°ï¼š2

éå†å‡ºæ‰€æœ‰å±æ€§åç§°ï¼š
for index in 0..<ptr.pointee.typeDescriptor.pointee.NumFields {
    
    let recordPtr = fieldDescriptorPtr.pointee.fields.element(at: Int(index))
    let valOffset=recordPtr.pointee.FieldName.get().pointee

    print("å±æ€§\(index)ï¼š\(String(cString: recordPtr.pointee.FieldName.get()))")
}

//è¾“å‡ºä»¥ä¸‹ç»“æœï¼š
//å±æ€§0ï¼šage
//å±æ€§1ï¼šname

unsafeBitCastæ˜¯å¿½ç•¥æ•°æ®ç±»å‹çš„å¼ºåˆ¶è½¬æ¢ï¼Œä¸ä¼šå› ä¸ºæ•°æ®ç±»å‹çš„å˜åŒ–è€Œæ”¹å˜åŸæ¥çš„å†…å­˜æ•°æ®

==========numericCast
public func numericCast<T : BinaryInteger, U : BinaryInteger>(_ x: T) -> U {
  return U(x)
}
å½“ä½ å°†ä¸€ä¸ªæ•´æ•°å€¼è½¬æ¢ä¸ºå¦ä¸€ä¸ªç±»å‹æ—¶ï¼Œå¦ä¸€ä¸ªç±»å‹æœ‰å¯èƒ½æ— æ³•è¡¨ç¤ºè¿™ä¸ªå€¼ã€‚
è¿™ä¼šå‘ç”Ÿåœ¨ä½ å°è¯•å°†ä¸€ä¸ªæœ‰ç¬¦å·æ•´æ•°è½¬æ¢æˆä¸€ä¸ªæ— ç¬¦å·æ•´æ•°æ—¶ï¼ˆæ¯”å¦‚å°† -42 è½¬æ¢ä¸º UIntï¼‰æˆ–è€…æ•°å€¼è¶…è¿‡äº†ç›®æ ‡ç±»å‹æ‰€èƒ½è¡¨ç¤ºçš„èŒƒå›´æ—¶ï¼ˆæ¯”å¦‚ UInt8 åªèƒ½è¡¨ç¤º 0 åˆ° 255 ä¹‹é—´çš„æ•°å­—ï¼‰ã€‚


BinaryInteger ä¸ºæ•´æ•°ç±»å‹è½¬æ¢å®šä¹‰äº†å››ç§ç­–ç•¥ï¼Œæ¯ä¸€ç§åœ¨å¤„ç†è¶…å‡ºèŒƒå›´çš„å€¼æ—¶éƒ½æœ‰ä¸åŒè¡Œä¸ºï¼š
èŒƒå›´æ£€æŸ¥è½¬æ¢ï¼ˆinit(_:)ï¼‰ï¼š é‡åˆ°è¶…å‡ºèŒƒå›´çš„å€¼æ—¶è§¦å‘è¿è¡Œæ—¶é”™è¯¯
å‡†ç¡®è½¬æ¢ï¼ˆinit?(exactly:)ï¼‰ï¼š é‡åˆ°è¶…å‡ºèŒƒå›´çš„å€¼æ—¶è¿”å› nil
é’³åˆ¶è½¬æ¢ï¼ˆinit(clamping:)ï¼‰ï¼š é‡åˆ°è¶…å‡ºèŒƒå›´çš„å€¼æ—¶ä½¿ç”¨æœ€è¿‘å¯è¡¨ç¤ºçš„å€¼
ä½æ¨¡å¼è½¬æ¢ï¼ˆinit(truncatingIfNeeded:)ï¼‰ï¼š æˆªæ–­è‡³ç›®æ ‡æ•´æ•°ç±»å‹å®½åº¦


æœ‰ç¬¦å·æ•´å‹æ•°ç»„å’Œæ— ç¬¦å·æ•´å‹æ•°ç»„ä½¿ç”¨åŒæ ·çš„å­—é¢é‡åˆå§‹åŒ–ï¼š
let arrayOfInt: [Int] = [1, 2, 3]
let arrayOfUInt: [UInt] = [1, 2, 3]

å°½ç®¡å®ƒä»¬å¥½åƒæ˜¯ç›¸ç­‰çš„ï¼Œä½†æˆ‘ä»¬ä¸èƒ½åšä¸‹é¢ä¾‹å­ä¸­çš„äº‹æƒ…ï¼š
arrayOfInt as [UInt] // Error: Cannot convert value of type '[Int]' to type '[UInt]' in coercion

è§£å†³è¿™ä¸ªé—®é¢˜çš„ä¸€ç§æ–¹å¼æ˜¯ï¼Œå°† numericCast å‡½æ•°ä½œä¸ºå‚æ•°ä¼ å…¥ map(_:)ï¼š
arrayOfInt.map(numericCast) as [UInt]
è¿™æ ·ç­‰åŒäºç›´æ¥ä¼ å…¥ UInt èŒƒå›´æ£€æŸ¥æ„é€ å™¨ï¼š
arrayOfInt.map(UInt.init)

let arrayOfNegativeInt: [Int] = [-1, -2, -3]
arrayOfNegativeInt.map(numericCast) as [UInt] // ğŸ§â€ Fatal error: Negative value is not representable
numericCast(_:) æ›´åƒæ˜¯ as! è€Œä¸æ˜¯ as æˆ– as?ã€‚

å°†è¿™ä¸ªå’Œä¼ å…¥ç²¾ç¡®è½¬æ¢æ„é€ å™¨ init?(exactly:) çš„ç»“æœç›¸æ¯”ï¼š
let arrayOfNegativeInt: [Int] = [-1, -2, -3]
arrayOfNegativeInt.map(UInt.init(exactly:)) // [nil, nil, nil]


