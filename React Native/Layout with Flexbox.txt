Layout with Flexbox // Flexbox（弹性盒布局），是一种可以让你轻松地在一个方向上（水平或垂直）排列子元素，并自动处理元素的尺寸、间距、对齐等问题的布局系统。

A component can specify the layout of its children using the Flexbox algorithm. 
Flexbox is designed to provide a consistent layout on different screen sizes.

You will normally use a combination of flexDirection, alignItems, and justifyContent to achieve the right layout.

caution
Flexbox works the same way in React Native as it does in CSS on the web, with a few exceptions.
The defaults are different, with flexDirection defaulting to column instead of row, 
alignContent defaulting to flex-start instead of stretch, 
flexShrink defaulting to 0 instead of 1, the flex parameter only supporting a single number.


==================================================Flex
https://reactnative.dev/docs/layout-props#flex

flex will define how your items are going to “fill” over the available space along your main axis. 
Space will be divided according to each element's flex property.


==================================================Flex Direction
https://reactnative.dev/docs/layout-props#flexdirection

flexDirection controls the direction in which the children of a node are laid out. This is also referred to as the main axis. 
The cross axis is the axis perpendicular to the main axis, or the axis which the wrapping lines are laid out in.

column (default value) Align children from top to bottom. 
If wrapping is enabled, then the next line will start to the right of the first item on the top of the container.

row Align children from left to right. 
If wrapping is enabled, then the next line will start under the first item on the left of the container.

column-reverse Align children from bottom to top. 
If wrapping is enabled, then the next line will start to the right of the first item on the bottom of the container.

row-reverse Align children from right to left. 
If wrapping is enabled, then the next line will start under the first item on the right of the container.

https://www.yogalayout.dev/docs/styling/flex-direction


import React, {useState} from 'react';
import {StyleSheet, Text, TouchableOpacity, View} from 'react-native';

const FlexDirectionBasics = () => {
  const [flexDirection, setflexDirection] = useState('column');

  return (
    <PreviewLayout
      label="flexDirection"
      values={['column', 'row', 'column-reverse', 'row-reverse']}
      selectedValue={flexDirection}
      setSelectedValue={setflexDirection}>
      <View style={[styles.box, {backgroundColor: 'powderblue'}]} />
      <View style={[styles.box, {backgroundColor: 'skyblue'}]} />
      <View style={[styles.box, {backgroundColor: 'steelblue'}]} />
    </PreviewLayout>
  );
};

const PreviewLayout = ({
  label,
  children,
  values,
  selectedValue,
  setSelectedValue,
}) => (
  <View style={{padding: 10, flex: 1}}>
    <Text style={styles.label}>{label}</Text>
    <View style={styles.row}>
      {values.map(value => (
        <TouchableOpacity
          key={value}
          onPress={() => setSelectedValue(value)}
          style={[styles.button, selectedValue === value && styles.selected]}> // 这是 React Native 允许你传入多个样式的方式，数组形式传递多个样式对象。style={[style1, style2, style3]}
          <Text
            style={[
              styles.buttonLabel,
              selectedValue === value && styles.selectedLabel,
            ]}>
            {value}
          </Text>
        </TouchableOpacity>
      ))}
    </View>
    <View style={[styles.container, {[label]: selectedValue}]}>{children}</View>
  </View>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    marginTop: 8,
    backgroundColor: 'aliceblue',
  },
  box: {
    width: 50,
    height: 50,
  },
  row: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  button: {
    paddingHorizontal: 8,
    paddingVertical: 6,
    borderRadius: 4,
    backgroundColor: 'oldlace',
    alignSelf: 'flex-start',
    marginHorizontal: '1%',
    marginBottom: 6,
    minWidth: '48%',
    textAlign: 'center',
  },
  selected: {
    backgroundColor: 'coral',
    borderWidth: 0,
  },
  buttonLabel: {
    fontSize: 12,
    fontWeight: '500',
    color: 'coral',
  },
  selectedLabel: {
    color: 'white',
  },
  label: {
    textAlign: 'center',
    marginBottom: 10,
    fontSize: 24,
    backgroundColor: 'red',
  },
});

export default FlexDirectionBasics;

如果 selectedValue === value 为 true，就返回 styles.selected
如果为 false，就返回 false（或 undefined）

JSX 中，组件标签包裹的子元素会自动作为该组件的 props.children 被传入。

因为你点击 <TouchableOpacity> 后，调用了 setSelectedValue，触发了 父组件的重新渲染，从而导致这个 <View style={styles.row}> 以及它里面的内容 重新执行并重新构建了 React 元素树。
你点击了某个按钮：
onPress={() => setSelectedValue(value)}
它修改了 selectedValue —— 这是一个 状态值。
这个状态定义在父组件 FlexDirectionBasics 中：
调用 setflexDirection(value) 之后，React 会做两件事：
把 flexDirection 的值更新；
触发整个 FlexDirectionBasics 函数重新执行一次。

React 函数组件的核心机制：
React 函数组件并不是“局部更新”，而是：
每次状态变化时，整个函数会重新执行，返回一个新的 Virtual DOM 树，然后 React 会做 diff 和渲染。
<PreviewLayout> 是 FlexDirectionBasics 中调用的；
它的 props 之一 selectedValue 变化了；
整个 PreviewLayout(...) 这次又被重新执行；

React 会执行一次 Virtual DOM diff —— 如果 TouchableOpacity 和子项的 props 没变，
那么 React 会“复用”之前的组件，不会导致真实原生控件重建（即：不会完全卸载和重新挂载），只是做了一次 判断和可能的更新。
#####
组件重新执行、元素重新生成，不等于真正重建了原生视图。React 会自动 diff，只更新真正需要的部分。

React 函数组件的机制就是：每次都从头执行一次函数，然后通过 Virtual DOM 对比决定哪些要真正更新。
#####

<Text style={styles.label}>{label}</Text> 这行代码在 React Native 中是否会更新？
如果 label 没有变化，那这行 <Text> 会重新执行 JSX 生成、参与 Virtual DOM diff，但 React 最终不会更新这段真实 UI。
每次你点击一个按钮，flexDirection 会变化：setflexDirection('row');
但 label="flexDirection" 始终没变。

于是：
PreviewLayout 重新执行；

<Text style={styles.label}>{label}</Text> 再次执行，生成了一个新的 Virtual DOM 节点；

React 会用“前一个 Virtual DOM 节点”做 diff，发现：
type 还是 Text
props.style 没变
children（即 "flexDirection"）没变

所以 React 的 diff 算法判断：这个 View 没变，直接复用即可，不需要更新原生视图。


怎么验证？
1. 可以手动给这个组件加一个 useEffect：
useEffect(() => {
  console.log('label Text render!');
}, []);

2. 
<Text style={styles.label}>
  {console.log('render label'), label} // JavaScript 中的 逗号运算符（Comma Operator）
</Text>
逗号运算符 会依次执行多个表达式，并返回最后一个表达式的值。

你可以把它理解成：
const tmp = console.log('render label');
const result = label;
return result;

这种写法常用于 调试 JSX 渲染顺序


==================================================Layout Direction
https://reactnative.dev/docs/layout-props#direction

Layout direction specifies the direction in which children and text in a hierarchy should be laid out. Layout direction also affects what edge start and end refer to. 
By default, React Native lays out with LTR layout direction. In this mode start refers to left and end refers to right.

LTR (default value) Text and children are laid out from left to right. 
Margin and padding applied to the start of an element are applied on the left side.

RTL Text and children are laid out from right to left. 
Margin and padding applied to the start of an element are applied on the right side.


==================================================Justify Content
https://reactnative.dev/docs/layout-props#justifycontent

justifyContent describes how to align children within the main axis of their container. 
For example, you can use this property to center a child horizontally within a container with flexDirection set to row or vertically within a container with flexDirection set to column.

flex-start(default value) Align children of a container to the start of the container's main axis.

flex-end Align children of a container to the end of the container's main axis.

center Align children of a container in the center of the container's main axis.

space-between Evenly space off children across the container's main axis, distributing the remaining space between the children.

space-around Evenly space off children across the container's main axis, distributing the remaining space around the children. Compared to space-between, using space-around will result in space being distributed to the beginning of the first child and end of the last child.

space-evenly Evenly distribute children within the alignment container along the main axis. The spacing between each pair of adjacent items, the main-start edge and the first item, and the main-end edge and the last item, are all exactly the same.


{ [label]: selectedValue }
是 JavaScript 的「计算属性名（也叫 动态 key）（Computed Property Name）」语法。
const label = 'flexDirection';
const selectedValue = 'row';

const obj = {
  [label]: selectedValue // [] 表示用变量的值作为对象的键名，而不是把变量名当成字符串。
};

// 实际等价于：
const obj2 = {
  flexDirection: 'row'
};


==================================================Align Items
https://reactnative.dev/docs/layout-props#alignitems

alignItems describes how to align children along the cross axis of their container. 
It is very similar to justifyContent but instead of applying to the main axis, alignItems applies to the cross axis.

stretch (default value) Stretch children of a container to match the height of the container's cross axis.

flex-start Align children of a container to the start of the container's cross axis.

flex-end Align children of a container to the end of the container's cross axis.

center Align children of a container in the center of the container's cross axis.

baseline Align children of a container along a common baseline. Individual children can be set to be the reference baseline for their parents.

info
For stretch to have an effect, children must not have a fixed dimension along the secondary axis. 
setting alignItems: stretch does nothing until the width: 50 is removed from the children.


==================================================Align Self
https://reactnative.dev/docs/layout-props#alignself

alignSelf has the same options and effect as alignItems but instead of affecting the children within a container, 
you can apply this property to a single child to change its alignment within its parent. 
alignSelf overrides any option set by the parent with alignItems.

['stretch', 'flex-start', 'flex-end', 'center', 'baseline']


==================================================Align Content
https://reactnative.dev/docs/layout-props#aligncontent

alignContent defines the distribution of lines along the cross-axis. 
This only has effect when items are wrapped to multiple lines using flexWrap.

flex-start (default value) Align wrapped lines to the start of the container's cross axis.

flex-end Align wrapped lines to the end of the container's cross axis.

stretch (default value when using Yoga on the web) Stretch wrapped lines to match the height of the container's cross axis.

center Align wrapped lines in the center of the container's cross axis.

space-between Evenly space wrapped lines across the container's cross axis, distributing the remaining space between the lines.

space-around Evenly space wrapped lines across the container's cross axis, distributing the remaining space around the lines. Each end of the container has a half-sized space compared to the space between items.

space-evenly Evenly space wrapped lines across the container's cross axis, distributing the remaining space around the lines. Each space is the same size.


==================================================Flex Wrap
https://reactnative.dev/docs/layout-props#flexwrap

The flexWrap property is set on containers and it controls what happens when children overflow the size of the container along the main axis.
By default, children are forced into a single line (which can shrink elements). 
If wrapping is allowed, items are wrapped into multiple lines along the main axis if needed.

When wrapping lines, alignContent can be used to specify how the lines are placed in the container.

['wrap', 'nowrap']


==================================================Flex Basis, Grow, and Shrink
https://reactnative.dev/docs/layout-props

flexBasis is an axis-independent way of providing the default size of an item along the main axis. 
Setting the flexBasis of a child is similar to setting the width of that child if its parent is a container with flexDirection: row or setting the height of a child if its parent is a container with flexDirection: column. 
The flexBasis of an item is the default size of that item, the size of the item before any flexGrow and flexShrink calculations are performed.
基础尺寸：未分配空间前，元素的默认尺寸


flexGrow describes how much space within a container should be distributed among its children along the main axis. After laying out its children, 
a container will distribute any remaining space according to the flex grow values specified by its children.

flexGrow accepts any floating point value >= 0, with 0 being the default value. 
A container will distribute any remaining space among its children weighted by the children’s flexGrow values.
默认值是 0（不增长），>0 参与分配，值越大分得越多。放大比例：分配多余空间

flexGrow: 有剩余空间时的扩展比例
如果所有子元素的 flexBasis 加起来 小于 容器尺寸，剩下的空间就会按照 flexGrow 分配。
<View style={{ flexDirection: 'row', width: 400 }}>
  <View style={{ flexBasis: 100, flexGrow: 1 }} />
  <View style={{ flexBasis: 100, flexGrow: 2 }} />
</View>
容器宽度 400，两个子元素基础宽度都是 100，总共占了 200，还剩 200 空间：
第一个子元素会获得 200 * 1 / (1 + 2) = 66.6px
第二个获得 200 * 2 / (1 + 2) = 133.3px
所以最终宽度是：166.6 和 233.3。


flexShrink describes how to shrink children along the main axis in the case in which the total size of the children overflows the size of the container on the main axis. 
flexShrink is very similar to flexGrow and can be thought of in the same way if any overflowing size is considered to be negative remaining space. 
These two properties also work well together by allowing children to grow and shrink as needed.
flexShrink accepts any floating point value >= 0, with 0 being the default value (on the web, the default is 1). 
A container will shrink its children weighted by the children’s flexShrink values.

缩小比例：空间不足时谁缩得多
lexShrink: 空间不足时的收缩比例
如果 flexBasis 总和大于容器尺寸，空间不够，就根据 flexShrink 收缩。
<View style={{ flexDirection: 'row', width: 300 }}>
  <View style={{ flexBasis: 200, flexShrink: 1 }} />
  <View style={{ flexBasis: 200, flexShrink: 2 }} />
</View>
基础总宽度 400，实际容器只有 300，多出 100，要压缩：
第一个子 View 被压缩约 33.3px
第二个被压缩约 66.6px


==================================================Row Gap, Column Gap and Gap
https://reactnative.dev/docs/layout-props#rowgap

rowGap sets the size of the gap (gutter) between an element's rows.

columnGap sets the size of the gap (gutter) between an element's columns.

gap sets the size of the gap (gutter) between rows and columns. It is a shorthand for rowGap and columnGap.

You can use flexWrap and alignContent along with gap to add consistent spacing between items.


style={[
  styles.container,         // 一个预定义的样式对象
  { rowGap, columnGap }     // 一个“动态对象”，等价于 { rowGap: rowGap, columnGap: columnGap } // 对象字面量的属性简写（Property shorthand）ES6（ES2015） 引入的。在 JavaScript 中，如果变量名和对象属性名一致，可以只写一次
]} 
是 JavaScript 中的数组 + 对象字面量语法，是 React Native 常见写法之一。


==================================================Width and Height
The width property specifies the width of an element's content area. 
Similarly, the height property specifies the height of an element's content area.

Both width and height can take the following values:
auto (default value) React Native calculates the width/height for the element based on its content, whether that is other children, text, or an image.

pixels Defines the width/height in absolute pixels. Depending on other styles set on the component, this may or may not be the final dimension of the node.

percentage Defines the width or height in percentage of its parent's width or height, respectively.


import React, {useState} from 'react';
import {View, TouchableOpacity, Text, StyleSheet} from 'react-native';
import {SafeAreaView, SafeAreaProvider} from 'react-native-safe-area-context';

const WidthHeightBasics = () => {
  const [widthType, setWidthType] = useState('auto');
  const [heightType, setHeightType] = useState('auto');

  return (
    <PreviewLayout
      widthType={widthType}
      heightType={heightType}
      widthValues={['auto', 300, '80%']}
      heightValues={['auto', 200, '60%']}
      setWidthType={setWidthType}
      setHeightType={setHeightType}>
      <View
        style={{
          backgroundColor: 'red',
          height: heightType,
          width: widthType,
          padding: 15,
        }}>
        <View style={[styles.box, {backgroundColor: 'powderblue'}]} />
        <View style={[styles.box, {backgroundColor: 'skyblue'}]} />
        <View style={[styles.box, {backgroundColor: 'steelblue'}]} />
      </View>
    </PreviewLayout>
  );
};

const PreviewLayout = ({
  children,
  widthType,
  heightType,
  widthValues,
  heightValues,
  setWidthType,
  setHeightType,
}) => (
  <SafeAreaProvider>
    <SafeAreaView style={{flex: 1, padding: 10}}>
      <View style={styles.row}>
        <Text style={styles.label}>width </Text>
        {widthValues.map(value => (
          <TouchableOpacity
            key={value}
            onPress={() => setWidthType(value)}
            style={[styles.button, widthType === value && styles.selected]}>
            <Text
              style={[
                styles.buttonLabel,
                widthType === value && styles.selectedLabel,
              ]}>
              {value}
            </Text>
          </TouchableOpacity>
        ))}
      </View>
      <View style={styles.row}>
        <Text style={styles.label}>height </Text>
        {heightValues.map(value => (
          <TouchableOpacity
            key={value}
            onPress={() => setHeightType(value)}
            style={[styles.button, heightType === value && styles.selected]}>
            <Text
              style={[
                styles.buttonLabel,
                heightType === value && styles.selectedLabel,
              ]}>
              {value}
            </Text>
          </TouchableOpacity>
        ))}
      </View>
      {children}
    </SafeAreaView>
  </SafeAreaProvider>
);

const styles = StyleSheet.create({
  box: {
    width: 50,
    height: 50,
  },
  row: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  button: {
    padding: 8,
    borderRadius: 4,
    backgroundColor: 'oldlace',
    alignSelf: 'flex-start',
    marginRight: 10,
    marginBottom: 10,
  },
  selected: {
    backgroundColor: 'coral',
    shadowOpacity: 0,
    borderWidth: 0,
  },
  buttonLabel: {
    fontSize: 12,
    fontWeight: '500',
    color: 'coral',
  },
  selectedLabel: {
    color: 'white',
  },
  label: {
    textAlign: 'center',
    marginBottom: 10,
    fontSize: 24,
  },
});

export default WidthHeightBasics;

alignSelf: 'flex-start'
不必须写，但写了会影响布局效果
不写 alignSelf: 'flex-start' 时，默认会继承 alignItems: 'stretch'，会让它在交叉轴上拉伸填满

在 Flexbox 规范中，当你创建一个 flex 容器时，如果你没有手动设置 alignItems 属性，默认行为是：
alignItems: 'stretch'
子元素会在 交叉轴（cross axis） 上被拉伸（stretch），填满父容器的尺寸


#####
即使你只写了 flex: 1，父容器其实还隐含使用了很多 Flexbox 的默认值，这些默认值一开始就生效了。
#####


==================================================Position
The position type of an element defines how it is positioned relative to either itself, its parent, or its containing block.

relative (default value) By default, an element is positioned relatively. 
This means an element is positioned according to the normal flow of the layout, 
and then offset relative to that position based on the values of top, right, bottom, and left. 
The offset does not affect the position of any sibling or parent elements.

absolute When positioned absolutely, an element doesn't take part in the normal layout flow. 
It is instead laid out independent of its siblings. 
The position is determined based on the top, right, bottom, and left values. 
These values will position the element relative to its containing block.

static When positioned statically, an element is positioned according to the normal flow of layout, 
and will ignore the top, right, bottom, and left values. 
This position will also cause the element to not form a containing block for absolute descendants, 
unless some other superceding style prop is present (e.g. transform). 
This allows absolute elements to be positioned to something that is not their parent. Note that static is only available on the New Architecture.

normal layout flow（正常文档流），也叫 标准流 / 普通流 / 常规布局流
正常流就是：元素按照 HTML 出现的顺序从上往下、从左往右排列

什么是“脱离正常流”？
position: absolute	脱离文档流，使用定位坐标
position: fixed	相对于视口固定，不参与正常排列
float	浮动，偏离标准流并环绕文字
display: none	不显示，也不占用任何空间


==================================================The Containing Block
how they work on the web:
Layout and the containing block:
https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_display/Containing_block
The size and position of an element are often impacted by its containing block.
###
Most often, the containing block is the content area of an element's nearest block-level ancestor, but this is not always the case.

When a user agent (such as your browser) lays out a document, it generates a box for every element. Each box is divided into four areas:
Content area
Padding area
Border area
Margin area
###



The containing block of an element is an ancestor element which controls its position and size.
The way containing blocks work in React Native is very similar to how they work on the web, 
with some simplifications due to the lack of some web features.


The top, right, bottom, and left values of an absolutely positioned element will be relative to its containing block.

Percentage lengths (e.g.: width: '50%' or padding: '10%') applied to absolutely positioned elements will be calculated relatively to the size of its containing block. 
For example, if the containing block is 100 points wide, 
then width: 50% on an absolutely positioned element will cause it to be 50 points wide.

The following list will help you determine the containing block of any given element:
1. If that element has a position type of relative or static, then its containing block is its parent.
2. If that element has a position type of absolute, then its containing block is the nearest ancestor in which one of the following is true:
(1)It has a position type other than static
(2)It has a transform


==================================================Going Deeper
Check out the interactive yoga playground that you can use to get a better understanding of flexbox.
https://www.yogalayout.dev/playground
Yoga 是 Facebook 开源的跨平台 Flexbox 布局引擎，React Native 的布局系统底层就是 Yoga 实现的。


The full list of props that control layout is documented here.
https://reactnative.dev/docs/layout-props


see some examples from Wix Engineers
https://medium.com/wix-engineering/the-full-react-native-layout-cheat-sheet-a4147802405c


React Native 官方文档（带示例代码）
https://reactnative.dev/docs/components-and-apis
Expo Snack：在线运行 React Native 代码
https://snack.expo.dev/