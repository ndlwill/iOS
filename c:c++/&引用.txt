https://www.cnblogs.com/Mr-xu/archive/2012/08/07/2626973.html

引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。


数组引用：
int (&ref)[3] = array;


引用的声明方法：类型标识符 &引用名=目标变量名；
int a; int &ra=a; //定义引用ra,它是变量a的引用，即别名

（1）&在此不是求地址运算，而是起标识作用。
（2）类型标识符是指目标变量的类型。
（3）声明引用时，必须同时对其进行初始化。
（4）引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。
ra=1; 等价于 a=1;
（5）声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。故：对引用求地址，就是对目标变量求地址。&ra与&a相等。
（6）不能建立数组的引用。因为数组是一个由若干个元素所组成的集合，所以无法建立一个数组的别名。

在定义的时候就必须初始化,引用初始化之后不能改变,即:一旦指向了某个变量，就不可以再改变，“从一而终”
不能返回局部变量的引用
函数（有返回值）当左值，必须返回引用

C++主张用引用传递取代地址传递的方式，因为引用语法容易且不易出错。

引用的本质:
引用的本质在C++内部实现是一个指针常量.
Type& ref = val; // Type* const ref = &val;
一个引用占用一个指针的大小

指针引用：
int a = 10;
int* p = &a;     // p 是指向 int 类型的指针
int*& ref = p;   // ref 是指向 int* 类型的引用（即指针引用）
使用指针引用可以：
修改指针本身，使其指向不同的对象。
在函数内部直接操作原指针，避免了指针传递的副本。

常量引用：
字面量不能赋给引用，但是可以赋给const引用
int &ref = 100;// 错误
const int &ref = 100;


###
引用只能指向变量，不能是常量，除非使用常引用
引用本质上是某个变量的别名，它是通过指针的方式进行实现的，但与指针不同的是，引用在初始化时必须与某个对象（变量）绑定，并且在之后的生命周期内始终指向该对象。
引用允许你通过不同的名字来访问同一个对象。
###


1、引用作为参数
引用的一个重要作用就是作为函数的参数。以前的C语言中函数参数传递是值传递，如果有大块数据作为参数传递的时候，采用的方案往往是指针，
因为 这样可以避免将整块数据全部压栈，可以提高程序的效率。但是现在（C++中）又增加了一种同样有效率的选择（在某些特殊情况下又是必须的选择），就是引 用。
（1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。
（2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给 形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效 率和所占空间都好。
（3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的 形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。

如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。
2、常引用
常引用声明方式：const 类型标识符 &引用名=目标变量名；
用这种方式声明的引用，不能通过引用对目标变量的值进行修改,从而使引用的目标成为const，达到了引用的安全性。

如果希望实参随着形参的改变而改变，那么使用一般的引用，如果不希望实参随着形参改变，那么使用常引用

int a ;
const int &ra=a;
ra=1; //错误，###目的是不让引用对目标变量的值进行修改###
a=1; //正确

下面的表达式将是非法的：
bar(foo( ));
bar("hello world");
原因在于foo( )和"hello world"串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。
引用型参数应该在能被定义为const的情况下，尽量定义为const 。

const引用使用场景:
常量引用主要用在函数的形参，尤其是类的拷贝/复制构造函数。

引用作为函数参数
当引用被用作函数参数的时，在函数内对任何引用的修改，将对还函数外的参数产生改变。
当然，可以通过传递一个指针来做相同的事情，但引用具有更清晰的语法。

3、引用作为返回值
要以引用返回函数值，则函数定义时要按以下格式：
类型标识符 &函数名（形参列表及类型说明）{函数体}

（1）以引用返回函数值，定义函数时需要在函数名前加&
（2）用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。

当函数返回值时，引用关联的内存一定要存在

#include <iostream.h>
float temp; //定义全局变量temp
float fn1(float r); //声明函数fn1
float &fn2(float r); //声明函数fn2
float fn1(float r) //定义函数fn1，它以返回值的方法返回函数值
{
　temp=(float)(r*r*3.14);
　return temp;
}
float &fn2(float r) //定义函数fn2，它以引用方式返回函数值
{
　temp=(float)(r*r*3.14);
　return temp;
}
void main() //主函数
{
　float a=fn1(10.0); //第1种情况，系统生成要返回值的副本（即临时变量）
　float &b=fn1(10.0); //第2种情况，可能会出错（不同 C++系统有不同规定）
　//不能从被调函数中返回一个临时变量或局部变量的引用
　float c=fn2(10.0); //第3种情况，系统不生成返回值的副本
　//可以从被调函数中返回一个全局变量的引用
　float &d=fn2(10.0); //第4种情况，系统不生成返回值的副本
　//可以从被调函数中返回一个全局变量的引用
　cout<<a<<c<<d;
}


###用返回引用的函数值作为赋值表达式的左值###
#include <iostream.h>
int &put(int n);
int vals[10];
int error=-1;
void main()
{
put(0)=10; //以put(0)函数值作为左值，等价于vals[0]=10;
put(9)=20; //以put(9)函数值作为左值，等价于vals[9]=20;
cout<<vals[0];
cout<<vals[9];
}
int &put(int n)
{
if (n>=0 && n<=9 ) return vals[n];
else { cout<<"subscript error"; return error; }
}

4、引用和多态
引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。
class 　A;
class 　B：public A{……};
B 　b;
A 　&Ref = b; // 用派生类对象初始化基类对象的引用

Ref 只能用来访问派生类对象中从基类继承下来的成员，是基类引用指向派生类。如果A类中定义有虚函数，并且在B类中重写了这个虚函数，就可以通过Ref产生多态效果。

引用总结:
（1）在引用的使用中，单纯给某个变量取个别名是毫无意义的，引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。
（2）用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性。
（3）引用与指针的区别是，指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。
（4）使用引用的时机。流操作符<<和>>、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。

==============================C语言指针变量作为函数参数
在C语言中，函数的参数不仅可以是整数、小数、字符等具体的数据，还可以是指向它们的指针。
用指针变量作函数参数可以将函数外部的地址传递到函数内部，使得在函数内部可以操作函数外部的数据，并且这些数据不会随着函数的结束而被销毁。

像数组、字符串、动态分配的内存等都是一系列数据的集合，没有办法通过一个参数全部传入函数内部，只能传递它们的指针，在函数内部通过指针来影响这些数据集合。
有的时候，对于整数、小数、字符等基本类型数据的操作也必须要借助指针，一个典型的例子就是交换两个变量的值。

用数组作函数参数:
数组是一系列数据的集合，无法通过参数将它们一次性传递到函数内部，如果希望在函数内部操作数组，必须传递数组指针。
#include <stdio.h>
int max(int *intArr, int len){
    int i, maxValue = intArr[0];  //假设第0个元素是最大值
    for(i=1; i<len; i++){
        if(maxValue < intArr[i]){
            maxValue = intArr[i];
        }
    }
   
    return maxValue;
}
int main(){
    int nums[6], i;
    int len = sizeof(nums)/sizeof(int);
    //读取用户输入的数据并赋值给数组元素
    for(i=0; i<len; i++){
        scanf("%d", nums+i);
    }
    printf("Max value is %d!\n", max(nums, len));
    return 0;
}
参数 intArr 仅仅是一个数组指针，在函数内部无法通过这个指针获得数组长度，必须将数组长度作为函数参数传递到函数内部。
数组 nums 的每个元素都是整数，scanf() 在读取用户输入的整数时，要求给出存储它的内存的地址，nums+i就是第 i 个数组元素的地址。

用数组做函数参数时，参数也能够以“真正”的数组形式给出。例如对于上面的 max() 函数，它的参数可以写成下面的形式：
int max(int intArr[], int len){
    int i, maxValue = intArr[0];  //假设第0个元素是最大值
    for(i=1; i<len; i++){
        if(maxValue < intArr[i]){
            maxValue = intArr[i];
        }
    }
    return maxValue;
}
实际上这两种形式的数组定义都是假象，不管是int intArr[6]还是int intArr[]都不会创建一个数组出来，编译器也不会为它们分配内存，实际的数组是不存在的，它们最终还是会转换为int *intArr这样的指针。
这就意味着，两种形式都不能将数组的所有元素“一股脑”传递进来，大家还得规规矩矩使用数组指针。

==============================C++引用
参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上。

对于像 char、bool、int、float 等基本类型的数据，它们占用的内存往往只有几个字节，对它们进行内存拷贝非常快速。
而数组、结构体、对象是一系列数据的集合，数据的数量没有限制，可能很少，也可能成千上万，对它们进行频繁的内存拷贝可能会消耗很多时间，拖慢程序的执行效率。

C/C++ 禁止在函数调用时直接传递数组的内容，而是强制传递数组指针

而对于结构体和对象没有这种限制，调用函数时既可以传递指针，也可以直接传递内容；为了提高效率，我曾建议传递指针，这样做在大部分情况下并没有什么不妥
但是在 C++ 中，我们有了一种比指针更加便捷的传递聚合类型数据的方式，那就是引用（Reference）。

在 C/C++ 中，我们将 char、int、float 等由语言本身支持的类型称为基本类型，将数组、结构体、类（对象）等由基本类型组合而成的类型称为聚合类型

引用（Reference）是 C++ 相对于C语言的又一个扩充。引用可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据。

引用的定义方式类似于指针，只是用&取代了*，语法格式为：
type &name = data;

type 是被引用的数据的类型，name 是引用的名称，data 是被引用的数据。引用必须在定义的同时初始化，并且以后也要从一而终，不能再引用其它数据，这有点类似于常量（const 变量）。

如果读者不希望通过引用来修改原始的数据，那么可以在定义时添加 const 限制，形式为：
const type &name = value;
也可以是：
type const &name = value;
这种引用方式为常引用

C++引用作为函数参数:
在定义或声明函数时，我们可以将函数的形参指定为引用的形式，这样在调用函数时就会将实参和形参绑定在一起，让它们都指代同一份数据。如此一来，如果在函数体中修改了形参的数据，那么实参的数据也会被修改，从而拥有“在函数内部影响函数外部数据”的效果。

//传递指针
void swap2(int *p1, int *p2) {
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}
//按引用传参
void swap3(int &r1, int &r2) {
    int temp = r1;
    r1 = r2;
    r2 = temp;
}
swap2() 传递的是指针，能够达到交换两个数的值的目的。调用函数时，分别将 num1、num2 的指针传递给 p1、p2，此后 p1、p2 指向 a、b 所代表的数据，在函数内部可以通过指针间接地修改 a、b 的值。
swap3() 是按引用传递，能够达到交换两个数的值的目的。调用函数时，分别将 r1、r2 绑定到 num1、num2 所指代的数据，此后 r1 和 num1、r2 和 num2 就都代表同一份数据了，通过 r1 修改数据后会影响 num1，通过 r2 修改数据后也会影响 num2。

C++引用作为函数返回值:
#include <iostream>
using namespace std;
int &plus10(int &r) {
    r += 10;
    return r;
}
int main() {
    int num1 = 10;
    int num2 = plus10(num1);
    cout << num1 << " " << num2 << endl;
    return 0;
}
运行结果：
20 20

在将引用作为函数返回值时应该注意一个小问题，就是不能返回局部数据（例如局部变量、局部对象、局部数组等）的引用，因为当函数调用完成后局部数据就会被销毁，有可能在下次使用时数据就不存在了，C++ 编译器检测到该行为时也会给出警告。