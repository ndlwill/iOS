https://blog.csdn.net/windeal3203/article/month/2016/10

###
https://blog.csdn.net/motingqian/article/details/88953816

https://libevent.org/
git clone git://github.com/nmathewson/libevent-book.git
http://www.wangafu.net/~nickm/libevent-book/TOC.html

BUILDING AND INSTALLATION:
Autoconf
$ ./configure (./configure --disable-openssl --prefix=/Users/youdone-ndl/Desktop/Test/path)
$ make
$ make verify   # (optional)
$ sudo make install

或者

$ mkdir build && cd build
$ cmake .. # Default to Unix Makefiles  （cmake -DEVENT__DISABLE_OPENSSL=ON ..）
$ make
$ make verify # Optional


写程序大体步骤为：
1.用编辑器编写源代码，如.c文件。
2.用编译器编译代码生成目标文件，如.o。
3.用链接器连接目标代码生成可执行文件，如.exe。

但如果源文件太多，一个一个编译时就会特别麻烦，于是人们想到，为什么不设计一种类似批处理的程序，来批处理编译源文件呢，
于是就有了make工具，它是一个自动化编译工具，你可以使用一条命令实现完全编译。
但是你需要编写一个规则文件，make依据它来批处理编译，这个文件就是makefile

对于一个大工程，编写makefile实在是件复杂的事，于是人们又想，为什么不设计一个工具，读入所有源文件之后，自动生成makefile呢，
于是就出现了cmake工具，它能够输出各种各样的makefile或者project文件,从而帮助程序员减轻负担。
但是随之而来也就是编写cmakelist文件，它是cmake所依据的规则。

源码的安装一般由3个步骤组成：配置(configure)、编译(make)、安装(make install)。
configure文件是一个可执行的脚本文件，它有很多选项，在待安装的源码目录下使用命令./configure –help可以输出详细的选项列表。
其中--prefix选项是配置安装目录，如果不配置该选项，安装后可执行文件默认放在/usr /local/bin，库文件默认放在/usr/local/lib，配置文件默认放在/usr/local/etc，其它的资源文件放在/usr /local/share
如果配置了--prefix，如：
$ ./configure --prefix=/usr/local/test
安装后的所有资源文件都会被放在/usr/local/test目录中，不会分散到其他目录。
使用--prefix选项的另一个好处是方便卸载软件或移植软件；当某个安装的软件不再需要时，只须简单的删除该安装目录，就可以把软件卸载得干干净净；而移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统下）。
当然要卸载程序，也可以在原来的make目录下用一次make uninstall，但前提是Makefile文件有uninstall命令
###


阻塞IO:
调用会一直阻塞，不会返回，直到发生下面两种情况之一: 要么操作完成；要么经历相当长的时间，网络协议栈自己放弃。
比如，当在TCP连接上调用connect时，操作系统会发送SYN包到TCP的远端主机。connect会一直阻塞而不返回，直到它接收到了远端主机发来的SYN+ACK包，或者经历太长的时间而自己放弃。

Example:A simple blocking HTTP client
/* For  sockaddr_in */
#include  <netinet/in.h>
/* For socket functions */
#include <sys/socket.h>
/* For gethostbyname */
#include <netdb.h>

#include <unistd.h>
#include <string.h>
#include <stdio.h>

int main(int c,char **v)
{
   const char query[] =
        "GET / HTTP/1.0\r\n"
        "Host: www.google.com\r\n"
        "\r\n";
   const char hostname[] = "www.google.com";
   struct sockaddr_in sin;
   struct hostent *h;
   const char *cp;
   int fd;
    ssize_t n_written, remaining;
   char buf[1024];

    /* Look up the IP address for the hostname.   Watch out; this isn't
       threadsafe on most platforms. */
    h = gethostbyname(hostname);
   if (!h) {
        fprintf(stderr, "Couldn't lookup%s: %s", hostname, hstrerror(h_errno));
       return 1;
    }
   if (h->h_addrtype != AF_INET) {
        fprintf(stderr, "No ipv6 support,sorry.");
       return 1;
    }

    /* Allocate a new socket */
    fd = socket(AF_INET, SOCK_STREAM, 0);
   if (fd < 0) {
        perror("socket");
       return 1;
    }

    /* Connect to the remote host. */
    sin.sin_family = AF_INET;
    sin.sin_port = htons(80);
    sin.sin_addr = *(struct in_addr*)h->h_addr;
   if (connect(fd, (struct sockaddr*) &sin, sizeof(sin))) {
        perror("connect");
        close(fd);
       return 1;
    }

    /* Write the query. */
    /* XXX Can send succeed partially? */
    cp = query;
    remaining = strlen(query);
   while (remaining) {
      n_written = send(fd, cp, remaining, 0);
     if (n_written <= 0) {
        perror("send");
       return 1;
      }
      remaining -= n_written;
      cp += n_written;
    }

    /* Get an answer back. */
   while (1) {
        ssize_t result = recv(fd, buf,sizeof(buf), 0);
       if (result == 0) {
           break;
        }elseif (result < 0) {
            perror("recv");
            close(fd);
           return 1;
        }
        fwrite(buf, 1, result, stdout);
    }

    close(fd);
   return 0;
}

上面例子中，所有的网络调用都是阻塞的：｀gethostbyname｀直到成功或失败的解析了｀www.google.com｀才会返回
｀connect｀直到TCP建链成功了才会返回；
｀recv｀直到收到数据时才会返回；
｀send｀直到将输出flushed到内核的写缓冲区之后才会返回。
当然，阻塞IO并不总是无用的。如果应用程序在同一时刻不需要做其他事，那么阻塞IO同样会很好的工作。　


BadExample
/* This  won't work. */
charbuf[1024];
int i, n;
while(i_still_want_to_read()) {
    for (i=0; i<n_sockets; ++i) {
        n = recv(fd[i], buf, sizeof(buf), 0);
        if (n==0)
            handle_close(fd[i]);
        else if (n<0)
            handle_error(fd[i], errno);
        else
            handle_input(fd[i], buf, n);
    }
}

如果fd[2]上首先有数据到来，但是上面的代码只有在fd[0]和fd[1]上接收到数据之后，才能去处理fd[2]上的数据。
有时，可以通过多线程（进程）来处理这样的问题。一个最简单的方式就是每个链接用一个线程（进程）进行处理。这样每个链接都会有自己的线程（进程）处理，一个链接上的阻塞IO调用就不会影响到其他链接上的处理。

例子：在TCP的40713端口上进行监听的ROT13服务器，每次从输入中接收一行数据，经过简单的处理后进行输出。它使用fork产生新的进程来处理每个链接。
Example:Forking ROT13 server
/* For sockaddr_in */
#include  <netinet/in.h>
/* For socket functions */
#include <sys/socket.h>

#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#define MAX_LINE 16384

char rot13_char(char c)
{
    if ((c >= 'a' && c <= 'm') ||(c >= 'A' && c <= 'M'))
        return c + 13;
    else if ((c >= 'n' && c <='z') || (c >= 'N' && c <= 'Z'))
        return c - 13;
    else
        return c;
}

void child(int fd)
{
    char outbuf[MAX_LINE+1];
    size_t outbuf_used = 0;
    ssize_t result;

    while (1) 
    {
        char ch;
        result = recv(fd, &ch, 1, 0);
        if (result == 0) {
            break;
        } else if (result == -1) {
            perror("read");
            break;
        }

        /* We do this test to keep the userfrom overflowing the buffer. */
        if (outbuf_used < sizeof(outbuf)) {
            outbuf[outbuf_used++] = rot13_char(ch);
        }

        if (ch == '\n') {
            send(fd, outbuf, outbuf_used, 0);
            outbuf_used = 0;
            continue;
        }
    }
}

void run(void)
{
    int listener;
    struct sockaddr_in sin;

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(40713);

    listener = socket(AF_INET, SOCK_STREAM, 0);

#ifndef WIN32
    {
        int one = 1;
        setsockopt(listener, SOL_SOCKET,SO_REUSEADDR, &one, sizeof(one));
    }
#endif

    if (bind(listener, (struct sockaddr*)&sin, sizeof(sin)) < 0) {
        perror("bind");
        return;
    }

    if (listen(listener, 16)<0) {
        perror("listen");
        return;
    }



    while (1) {
        struct sockaddr_storage ss;
        socklen_t slen = sizeof(ss);
        int fd = accept(listener, (struct sockaddr*)&ss, &slen);
        if (fd < 0) {
            perror("accept");
        } else {
            if (fork() == 0) {
                child(fd);
                exit(0);
            }
        }
    }
}

int main(int c, char **v)
{
    run();
    return 0;
}

是否已经完美解决了同一时刻多连接的问题了呢？事实并非如此：
第一，某些平台上，创建新进程（甚至是线程）是十分昂贵的。当然在实际环境中，可以使用线程池，而不是每次都创建新线程。
第二，更重要的是，线程无法如你所愿的规模化使用。如果你的程序需要同时处理成千上万个链接的时候，处理成千上万个线程就不是那么高效的了。
如果线程不是处理多连接的答案，那什么才是呢？
在unix系统上，将socket设置为非阻塞:｀fcntl(fd, F_SETFL, O_NONBLOCK)｀。一旦将fd置为非阻塞，那么从此刻起，无论何时进行网络调用，该调用会立即返回，要么完成操作，返回成功，要么就是返回一个特定的错误码指出“当前无法完成任务，再试一次”。

BadExample: busy-polling all sockets
/* This will work, but the performance will beunforgivably bad. */
int i, n;
char buf[1024];
for (i=0;i < n_sockets; ++i)
    fcntl(fd[i], F_SETFL, O_NONBLOCK);

while(i_still_want_to_read()) {
    for (i=0; i < n_sockets; ++i) {
        n = recv(fd[i], buf, sizeof(buf), 0);
        if (n == 0) {
            handle_close(fd[i]);
        }else if (n < 0) {
            if (errno == EAGAIN)
                 ; /* The kernel didn't haveany data for us to read. */
            else
                 handle_error(fd[i], errno);
         } else {
            handle_input(fd[i], buf, n);
         }
    }
}

上面就是使用非阻塞sockets的例子，它虽然可以工作，但是效率却很差，
两个原因：第一，当每个链接都没有数据可读的时候，就会无限的轮训下去，用尽所有的CPU周期。
第二，如果需要处理多个链接，那么不管是否有数据可读，每个链接都会进行一次内核调用。

我们需要一种方法，可以告诉内核“一直等待，直到某个socket已经有准备好了，而且要告诉我那个socket准备好了”。
古老的解决方法是使用select，目前仍在使用。select使用三个socket fd集合（位数组）：可读、可写和异常。它会一直等待，直到集合中的某一个socket已经准备好了，而且，select返回时，会更改集合，使其只包含那些已经准备好了的socket fd。使用select的例子如下：
Example:Using select

/* If youonly have a couple dozen fds, this version won't be awful */
fd_setreadset;
int i, n;
charbuf[1024];

while (i_still_want_to_read()){
    int maxfd = -1;
    FD_ZERO(&readset);

    /* Add all of the interesting fds toreadset */
    for (i=0; i < n_sockets; ++i) {
         if (fd[i]>maxfd) maxfd = fd[i];
         FD_SET(fd[i], &readset);
    }

    /*Wait until one or more fds are ready to read */
    select(maxfd+1, &readset, NULL, NULL,NULL);

    /* Process all of the fds that are stillset in readset */
    for (i=0; i < n_sockets; ++i) {
        if (FD_ISSET(fd[i], &readset)) {
            n = recv(fd[i], buf, sizeof(buf),0);
            if (n == 0) {
                handle_close(fd[i]);
            } else if (n < 0) {
                if (errno == EAGAIN)
                     ; /* The kernel didn'thave any data for us to read. */
                else
                     handle_error(fd[i],errno);
             } else {
                handle_input(fd[i], buf, n);
             }
        }
    }
}

一个完整的使用select的ROT13的服务器例子如下：
/* Forsockaddr_in */
#include<netinet/in.h>
/* For socketfunctions */
#include<sys/socket.h>
/* Forfcntl */
#include<fcntl.h>
/* forselect */
#include<sys/select.h>

#include<assert.h>
#include<unistd.h>
#include<string.h>
#include<stdlib.h>
#include<stdio.h>
#include<errno.h>

#defineMAX_LINE 16384

char rot13_char(charc)
{
    /* We don't want to use isalpha here;setting the locale would change
     * which characters are consideredalphabetical. */
    if ((c >= 'a' && c <= 'm') ||(c >= 'A' && c <= 'M'))
        return c + 13;
    else if ((c >= 'n' && c <='z') || (c >= 'N' && c <= 'Z'))
        return c - 13;
    else
        return c;
}

structfd_state {
    char buffer[MAX_LINE];
    size_t buffer_used;

    int writing;
    size_t n_written;
    size_t write_upto;
};

structfd_state * alloc_fd_state(void)
{
    struct fd_state *state =malloc(sizeof(struct fd_state));
    if (!state)
        return NULL;
    state->buffer_used = state->n_written= state->writing =
        state->write_upto = 0;
    return state;
}

void free_fd_state(structfd_state *state)
{
    free(state);
}

void make_nonblocking(intfd)
{
    fcntl(fd, F_SETFL, O_NONBLOCK);
}

int do_read(intfd, struct fd_state *state)
{
    char buf[1024];
    int i;
    ssize_t result;
    while (1) {
        result = recv(fd, buf, sizeof(buf), 0);
        if (result <= 0)
            break;

        for (i=0; i < result; ++i)  {
            if (state->buffer_used <sizeof(state->buffer))
               state->buffer[state->buffer_used++] = rot13_char(buf[i]);
            if (buf[i] == '\n') {
                state->writing = 1;
                state->write_upto =state->buffer_used;
            }
        }
    }

    if (result == 0) {
        return 1;
    } else if (result < 0) {
        if (errno == EAGAIN)
            return 0;
        return -1;
    }

    return 0;
}

int do_write(intfd, struct fd_state *state)
{
    while (state->n_written <state->write_upto) {
        ssize_t result = send(fd,state->buffer + state->n_written,
                             state->write_upto - state->n_written, 0);
        if (result < 0) {
            if (errno == EAGAIN)
                return 0;
            return -1;
        }
        assert(result != 0);

        state->n_written += result;
    }

    if (state->n_written ==state->buffer_used)
        state->n_written =state->write_upto = state->buffer_used = 0;

    state->writing = 0;

    return 0;
}

void run(void)
{
    int listener;
    struct fd_state *state[FD_SETSIZE];
    struct sockaddr_in sin;
    int i, maxfd;
    fd_set readset, writeset, exset;

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(40713);

    for (i = 0; i < FD_SETSIZE; ++i)
        state[i] = NULL;

    listener = socket(AF_INET, SOCK_STREAM, 0);
    make_nonblocking(listener);

#ifndefWIN32
    {
        int one = 1;
        setsockopt(listener, SOL_SOCKET,SO_REUSEADDR, &one, sizeof(one));
    }
#endif

    if (bind(listener, (structsockaddr*)&sin, sizeof(sin)) < 0) {
        perror("bind");
        return;
    }

    if (listen(listener, 16)<0) {
        perror("listen");
        return;
    }

    FD_ZERO(&readset);
    FD_ZERO(&writeset);
    FD_ZERO(&exset);

    while (1) {
        maxfd = listener;

        FD_ZERO(&readset);
        FD_ZERO(&writeset);
        FD_ZERO(&exset);

        FD_SET(listener, &readset);

        for (i=0; i < FD_SETSIZE; ++i) {
            if (state[i]) {
                if (i > maxfd)
                    maxfd = i;
                FD_SET(i, &readset);
                if (state[i]->writing) {
                    FD_SET(i, &writeset);
                }
            }
        }

        if (select(maxfd+1, &readset,&writeset, &exset, NULL) < 0) {
            perror("select");
            return;
        }

        if (FD_ISSET(listener, &readset)) {
            struct sockaddr_storage ss;
            socklen_t slen = sizeof(ss);
            int fd = accept(listener, (structsockaddr*)&ss, &slen);
           if (fd < 0) {
                perror("accept");
            } else if (fd > FD_SETSIZE) {
                close(fd);
            } else {
                make_nonblocking(fd);
                state[fd] = alloc_fd_state();
                assert(state[fd]);/*XXX*/
            }
        }

        for (i=0; i < maxfd+1; ++i) {
            int r = 0;
            if (i == listener)
                continue;

            if (FD_ISSET(i, &readset)) {
                r = do_read(i, state[i]);
            }
            if (r == 0 && FD_ISSET(i,&writeset)) {
                r = do_write(i, state[i]);
            }
            if (r) {
                free_fd_state(state[i]);
                state[i] = NULL;
                close(i);
            }
        }
    }
}

int main(intc, char **v)
{
    setvbuf(stdout, NULL, _IONBF, 0);

    run();
    return 0;
}
但是问题还没有解决。因为产生和读取select的位数组耗费的时间与最大的socket fd数成正比，所以当socket fd数变得很大时，select调用的性能就会下降很多。

不同的操作系统都提供了不同的select替代函数。
包括poll,epoll,kqueue, evports和/dev/poll。所有这些接口都具有比select更好的性能，而且除了poll之外，他们在增加socket，删除socket，通知哪个socket准备好这些方面，都可以达到O(1)的性能。

不幸的是，所有这些不同的接口都没有形成标准。linux提供了epoll，BSDs提供了kqueue，Solaris提供了evports和/dev/poll，而且这些操作系统提供的接口相互独立。所以，当你需要编写一个可移植的、高性能异步应用时，你需要一个封装所有这些接口的抽象，而且提供那个最高效的接口。
这就是libeventAPI能提供的最底层的功能。它提供了一系列的select替代接口，并且使用当前操作系统所具有的，最高效的版本。
下面是另一个ROT13服务器的例子。该实例使用libevent2替代select。去除了fd_sets，而是使用event_base添加和删除事件，当然这是通过poll，epoll，kqueue等来实现的。

Example:A low-level ROT13 server with Libevent
/* Forsockaddr_in */
#include<netinet/in.h>
/* Forsocket functions */
#include<sys/socket.h>
/* Forfcntl */
#include<fcntl.h>

#include<event2/event.h>

#include<assert.h>
#include<unistd.h>
#include<string.h>
#include<stdlib.h>
#include<stdio.h>
#include<errno.h>

#define MAX_LINE16384

voiddo_read(evutil_socket_t fd, short events, void *arg);
voiddo_write(evutil_socket_t fd, short events, void *arg);

char
rot13_char(charc)
{
    /* We don't want to use isalpha here;setting the locale would change
     * which characters are consideredalphabetical. */
    if ((c >= 'a' && c <= 'm') ||(c >= 'A' && c <= 'M'))
        return c + 13;
    else if ((c >= 'n' && c <='z') || (c >= 'N' && c <= 'Z'))
        return c - 13;
    else
        return c;
}

structfd_state {
    char buffer[MAX_LINE];
    size_t buffer_used;

    size_t n_written;
    size_t write_upto;

    struct event *read_event;
    struct event *write_event;
};

structfd_state * alloc_fd_state(struct event_base *base, evutil_socket_t fd)
{
    struct fd_state *state =malloc(sizeof(struct fd_state));
    if (!state)
        return NULL;
    state->read_event = event_new(base, fd,EV_READ|EV_PERSIST, do_read, state);
    if (!state->read_event) {
        free(state);
        return NULL;
    }
    state->write_event = event_new(base, fd,EV_WRITE|EV_PERSIST, do_write, state);

    if (!state->write_event) {
        event_free(state->read_event);
        free(state);
        return NULL;
    }

    state->buffer_used = state->n_written= state->write_upto = 0;

    assert(state->write_event);
    return state;
}

void free_fd_state(structfd_state *state)
{
    event_free(state->read_event);
    event_free(state->write_event);
    free(state);
}

void do_read(evutil_socket_tfd, short events, void *arg)
{
    struct fd_state *state = arg;
    char buf[1024];
    int i;
    ssize_t result;
    while (1) {
        assert(state->write_event);
        result = recv(fd, buf, sizeof(buf), 0);
        if (result <= 0)
            break;

        for (i=0; i < result; ++i)  {
            if (state->buffer_used <sizeof(state->buffer))
               state->buffer[state->buffer_used++] = rot13_char(buf[i]);
            if (buf[i] == '\n') {
                assert(state->write_event);
                event_add(state->write_event,NULL);
                state->write_upto =state->buffer_used;
            }
        }
    }

    if (result == 0) {
        free_fd_state(state);
    } else if (result < 0) {
        if (errno == EAGAIN) // XXXX use evutilmacro
            return;
        perror("recv");
        free_fd_state(state);
    }
}

void do_write(evutil_socket_tfd, short events, void *arg)
{
    struct fd_state *state = arg;

    while (state->n_written <state->write_upto) {
        ssize_t result = send(fd,state->buffer + state->n_written,
                             state->write_upto - state->n_written, 0);
        if (result < 0) {
            if (errno == EAGAIN) // XXX useevutil macro
                return;
            free_fd_state(state);
            return;
        }
        assert(result != 0);

        state->n_written += result;
    }

    if (state->n_written ==state->buffer_used)
        state->n_written =state->write_upto = state->buffer_used = 1;

    event_del(state->write_event);
}

void do_accept(evutil_socket_tlistener, short event, void *arg)
{
    struct event_base *base = arg;
    struct sockaddr_storage ss;
    socklen_t slen = sizeof(ss);
    int fd = accept(listener, (structsockaddr*)&ss, &slen);
    if (fd < 0) { // XXXX eagain??
        perror("accept");
    } else if (fd > FD_SETSIZE) {
        close(fd); // XXX replace all closeswith EVUTIL_CLOSESOCKET */
    } else {
        struct fd_state *state;
        evutil_make_socket_nonblocking(fd);
        state = alloc_fd_state(base, fd);
        assert(state); /*XXX err*/
        assert(state->write_event);
        event_add(state->read_event, NULL);
    }
}

void run(void)
{
    evutil_socket_t listener;
    struct sockaddr_in sin;
    struct event_base *base;
    struct event *listener_event;

    base = event_base_new();
    if (!base)
        return; /*XXXerr*/

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(40713);

    listener = socket(AF_INET, SOCK_STREAM, 0);
    evutil_make_socket_nonblocking(listener);

#ifndefWIN32
    {
        int one = 1;
        setsockopt(listener, SOL_SOCKET,SO_REUSEADDR, &one, sizeof(one));
    }
#endif

    if (bind(listener, (structsockaddr*)&sin, sizeof(sin)) < 0) {
        perror("bind");
        return;
    }

    if (listen(listener, 16)<0) {
        perror("listen");
        return;
    }

    listener_event = event_new(base, listener,EV_READ|EV_PERSIST, do_accept, (void*)base);
    /*XXX check it */
    event_add(listener_event, NULL);

    event_base_dispatch(base);
}

int main(intc, char **v)
{
    setvbuf(stdout, NULL, _IONBF, 0);

    run();
    return 0;
}

上面的代码需要注意的是，使用evutil_socket_t，而不是int作为socket的类型；
使用evutil_make_socket_nonblocking而不是fcntl(O_NONBLOCK)，将socket转为非阻塞。
这些改变使得我们的代码可以兼容win32平台下的网络API。

使用libevent的上面的例子没有达到最佳的性能。在Windows上，高效的异步IO与并不是类似于select那样的机制，而是使用IOCP（IO Completion Ports）API。
与其他高效网络API不同的是，IOCP并不通知你的程序哪个socket已经准备好操作了，相反的，程序告诉windows网络栈开始一个网络操作，而IOCP告诉程序操作已经完成了。
幸运的是，libevent2的bufferevents接口可以解决上面的问题：它使得程序编写更加简单，而且可以在windows上、unix上都提供最高效的接口。下面是最后一个ROT13服务器的例子，它使用了bufferevents API：

Example:A simpler ROT13 server with Libevent
/* Forsockaddr_in */
#include<netinet/in.h>
/* Forsocket functions */
#include<sys/socket.h>
/* Forfcntl */
#include<fcntl.h>

#include<event2/event.h>
#include<event2/buffer.h>
#include<event2/bufferevent.h>

#include<assert.h>
#include<unistd.h>
#include<string.h>
#include<stdlib.h>
#include<stdio.h>
#include<errno.h>

#defineMAX_LINE 16384

void do_read(evutil_socket_tfd, short events, void *arg);
voiddo_write(evutil_socket_t fd, short events, void *arg);

char  rot13_char(char c)
{
    /* We don't want to use isalpha here;setting the locale would change
     * which characters are consideredalphabetical. */
    if ((c >= 'a' && c <= 'm') ||(c >= 'A' && c <= 'M'))
        return c + 13;
    else if ((c >= 'n' && c <='z') || (c >= 'N' && c <= 'Z'))
        return c - 13;
    else
        return c;
}

void  readcb(struct bufferevent *bev, void *ctx)
{
    struct evbuffer *input, *output;
    char *line;
    size_t n;
    int i;
    input = bufferevent_get_input(bev);
    output = bufferevent_get_output(bev);

    while ((line = evbuffer_readln(input, &n,EVBUFFER_EOL_LF))) {
        for (i = 0; i < n; ++i)
            line[i] = rot13_char(line[i]);
        evbuffer_add(output, line, n);
        evbuffer_add(output, "\n",1);
        free(line);
    }

    if (evbuffer_get_length(input) >=MAX_LINE) {
        /* Too long; just process what there isand go on so that the buffer
         * doesn't grow infinitely long. */
        char buf[1024];
        while (evbuffer_get_length(input)) {
            int n = evbuffer_remove(input, buf,sizeof(buf));
            for (i = 0; i < n; ++i)
                buf[i] = rot13_char(buf[i]);
            evbuffer_add(output, buf, n);
        }
        evbuffer_add(output, "\n",1);
    }
}

void  errorcb(struct bufferevent *bev, short error,void *ctx)
{
    if (error & BEV_EVENT_EOF) {
        /* connection has been closed, do anyclean up here */
        /* ... */
    } else if (error & BEV_EVENT_ERROR) {
        /* check errno to see what erroroccurred */
        /* ... */
    } else if (error & BEV_EVENT_TIMEOUT) {
        /* must be a timeout event handle,handle it */
        /* ... */
    }
    bufferevent_free(bev);
}

void  do_accept(evutil_socket_t listener, shortevent, void *arg)
{
    struct event_base *base = arg;
    struct sockaddr_storage ss;
    socklen_t slen = sizeof(ss);
    int fd = accept(listener, (structsockaddr*)&ss, &slen);
    if (fd < 0) {
        perror("accept");
    } else if (fd > FD_SETSIZE) {
        close(fd);
    } else {
        struct bufferevent *bev;
        evutil_make_socket_nonblocking(fd);
        bev = bufferevent_socket_new(base, fd,BEV_OPT_CLOSE_ON_FREE);
        bufferevent_setcb(bev, readcb, NULL,errorcb, NULL);
        bufferevent_setwatermark(bev, EV_READ,0, MAX_LINE);
        bufferevent_enable(bev,EV_READ|EV_WRITE);
    }
}

void run(void)
{
    evutil_socket_t listener;
    struct sockaddr_in sin;
    struct event_base *base;
    struct event *listener_event;

    base = event_base_new();
    if (!base)
        return; /*XXXerr*/

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(40713);

    listener = socket(AF_INET, SOCK_STREAM, 0);
    evutil_make_socket_nonblocking(listener);

#ifndefWIN32
    {
        int one = 1;
        setsockopt(listener, SOL_SOCKET,SO_REUSEADDR, &one, sizeof(one));
    }
#endif

    if (bind(listener, (structsockaddr*)&sin, sizeof(sin)) < 0) {
        perror("bind");
        return;
    }

    if (listen(listener, 16)<0) {
        perror("listen");
        return;
    }

    listener_event = event_new(base, listener,EV_READ|EV_PERSIST, do_accept, (void*)base);
    /*XXX check it */
    event_add(listener_event, NULL);

    event_base_dispatch(base);
}

int main(intc, char **v)
{
    setvbuf(stdout, NULL, _IONBF, 0);

    run();
    return 0;
}

==================================================通用结构体
IPv4: struct sockaddr_in, 16个字节
struct sockaddr_in {
       sa_family_t sin_family;             /* AF_INET */
       in_port_t sin_port;                 /* Port number.  */
       struct in_addr sin_addr;            /* Internet address.  */
  
       /* Pad to size of `struct sockaddr'.  */
       unsigned char sin_zero[sizeof (struct sockaddr) -
                              sizeof (sa_family_t) -
                              sizeof (in_port_t) -
                             sizeof (struct in_addr)];
};
typedef uint32_t in_addr_t;
struct in_addr  {
     in_addr_t s_addr;                    /* IPv4 address */
};


IPv6: struct sockaddr_in6, 28个字节
 struct sockaddr_in6 {
     sa_family_t sin6_family;    /* AF_INET6 */
     in_port_t sin6_port;        /* Transport layer port # */
     uint32_t sin6_flowinfo;     /* IPv6 flow information */
     struct in6_addr sin6_addr;  /* IPv6 address */
     uint32_t sin6_scope_id;     /* IPv6 scope-id */
 };
 struct in6_addr {
     union {
         uint8_t u6_addr8[16];
         uint16_t u6_addr16[8];
         uint32_t u6_addr32[4];
     } in6_u;
 
     #define s6_addr                 in6_u.u6_addr8
     #define s6_addr16               in6_u.u6_addr16
     #define s6_addr32               in6_u.u6_addr32
 };


通用结构体1: struct sockaddr, 16个字节
struct sockaddr { 
     sa_family_t sa_family;       /* Address family */
     char sa_data[14];            /* protocol-specific address */
};

通用结构体2: struct sockaddr_storage,128个字节
  /* Structure large enough to hold any socket address 
  (with the historical exception of AF_UNIX). 128 bytes reserved.  */
  
  #if ULONG_MAX > 0xffffffff
  # define __ss_aligntype __uint64_t
  #else
  # define __ss_aligntype __uint32_t
  #endif
  #define _SS_SIZE        128
 #define _SS_PADSIZE     (_SS_SIZE - (2 * sizeof (__ss_aligntype)))
 
 struct sockaddr_storage
 {
     sa_family_t ss_family;      /* Address family */
     __ss_aligntype __ss_align;  /* Force desired alignment.  */
     char __ss_padding[_SS_PADSIZE];
};


==================================================event_base
在使用任何libevent库函数之前，需要分配至少一个struct event_base的对象。每一个struct event_base对象都维护者一系列事件，并且能够轮询是是否有事件被激活。
struct event_base *event_base_new(void);
void event_base_free(struct event_base *base);

libevent是一个事件驱动库，它主要是封装了事件发生的通知机制。
一些常见的事件：
文件描述符已经可读、可写
文件描述符正在变得可读、可写（边沿触发）
超时
信号发生
用户触发的事件

libevent提供了事件的注册机制，让开发者将事件与事件处理函数关联在一起，并绑定到event_base中。

libevent是创建了一个struct event的对象。该对象与event_base、事件、回调函数关联到了一起。
#define EV_TIMEOUT      0x01
#define EV_READ         0x02
#define EV_WRITE        0x04
#define EV_SIGNAL       0x08
#define EV_PERSIST      0x10
#define EV_ET           0x20
typedef void (*event_callback_fn)(evutil_socket_t, short, void *);

struct event *event_new(struct event_base *base, evutil_socket_t fd,
    short what, event_callback_fn cb,
    void *arg);

void event_free(struct event *event);

fd：， 要关注的文件描述符，即我们关心的是哪个文件描述符上的事件。
what：表示关注的是哪一类事件，取值是上面定义的标志位：宏EV_TIMEOUT、EV_READ等。
当fd上what对应的事件发生时，回调函数cb就会被调用。 参数arg是需要传递给回调函数cb的参数。

那么怎么及时知道事件什么时候发生了。
libevent提供了将事件设置为pending状态的方式，（所谓pengding状态，指的是一旦触发事件发生的条件具备时，就通知程序事件发生了）。

int event_add(struct event *ev, const struct timeval *tv);  // makes event pending in its configured base
int event_del(struct event *ev);  //non-pending and non-active.

前面提到了一些flag宏， EV_TIMEOUT等都是用与指示监听的事件，但EV_PERSIST与EV_ET不太一样

+ EV_PERSIST:在默认情况下（不设置EV_PERSIST），事件发生，执行回调函数时，事件会自动变成non-pending状态，需要重新执行event_add()如果设置了EV_PERSIST标志，则事件会一直处于pending状态
+ EV_ET：表示边沿触发。

#define evtimer_new(base, callback, arg) \
    event_new((base), -1, 0, (callback), (arg))
#define evtimer_add(ev, tv) \
    event_add((ev),(tv))
#define evtimer_del(ev) \
    event_del(ev)
#define evtimer_pending(ev, tv_out) \
    event_pending((ev), EV_TIMEOUT, (tv_out))


#define evsignal_new(base, signum, cb, arg) \
    event_new(base, signum, EV_SIGNAL|EV_PERSIST, cb, arg)
#define evsignal_add(ev, tv) \
    event_add((ev),(tv))
#define evsignal_del(ev) \
    event_del(ev)
#define evsignal_pending(ev, what, tv_out) \
    event_pending((ev), (what), (tv_out))

==================================================event loop
一旦一些events在event_base注册之后，就可以使Libevent等待events，并且在events准备好时能够通知你。
默认情况下，event_base_loop()会在event_base上一直运行，直到其上已经没有注册的events了。

运行loop时，它会重复检查那些已经注册的events是否触发了（比如，一个读event的文件描述符变得可读，或者后一个超时event已经超时）。
一旦触发，该函数会将这些触发的events标记为active，并且开始运行回调函数。

#define EVLOOP_ONCE             0x01
#define EVLOOP_NONBLOCK         0x02
#define EVLOOP_NO_EXIT_ON_EMPTY 0x04

int event_base_loop(struct event_base *base, int flags);

可以通过设置一个或多个flag参数，来改变event_base_loop()函数的行为。
如果设置了EVLOOP_ONCE，那么loop将会一直等待，直到一些events变为active，然后运行这些激活的events的回调函数，直到运行完所有激活的events为止，最后函数返回。
如果设置了EVLOOP_NONBLOCK标志，则该函数不会等待events变为触发，它仅仅检查是否有事件准备好了，然后运行他们的回调函数，最后函数返回。

event_base_loop函数返回0表示正常退出，返回-1表示后端方法发生了错误。返回1表示已经没有pending或active状态的events了。

while(any events are registered with the loop,
        or EVLOOP_NO_EXIT_ON_EMPTY was set) {

    if (EVLOOP_NONBLOCK was set, or any eventsare already active)
        If any registered events have triggered, mark them active.
    else
        Wait until at least one event has triggered, and mark it active.

    for (p = 0; p < n_priorities; ++p) {
       if (any event with priority of p isactive) {
          Run all active events with priorityof p.
          break; /* Do not run any events of aless important priority */
       }
    }

    if (EVLOOP_ONCE was set or EVLOOP_NONBLOCKwas set)
       break;
}

便起见，也可以使用下面的接口：
intevent_base_dispatch(struct event_base *base);
该函数等价于无标志的event_base_loop()函数。
因此，直到没有注册的events，或者调用了event_base_loopbreak()、 event_base_loopexit()，该函数才会返回。


停止loop
如果希望在所有events移除之前，就停止event loop的运行，有两个略有不同的接口可以调用：
int event_base_loopexit(struct event_base *base,  const struct timeval *tv);
int event_base_loopbreak(struct event_base *base);

event_base_loopexit()函数，使得event_base在经过了给定的超时时间之后，停止运行loop。如果tv参数为NULL，则event_base会立即停止loop。如果event_base正在运行active events的回调函数，则只有在运行完所有的回调之后，才停止loop。
event_base_loopbreak()函数，使event_base立即退出loop。它与event_base_loopexit(base,NULL)不同之处在于，如果event_base当前正在运行任何激活events的回调函数，则会在当前的回调函数返回之后，就立即退出。

注意: 当event loop没有运行时，event_base_loopexit(base, NULL)和 event_base_loopbreak(base)的行为是不同的：loopexit使下一轮event loop在下一轮回调运行之后立即停止（就像设置了EVLOOP_ONCE一样），而loopbreak仅仅停止当前loop的运行，而且在event loop未运行时没有任何效果。
上述两个方法在成功是返回0， 失败时返回-1，

立即停止：
#include <event2/event.h>

/*Here's a callback function that calls loopbreak */
void cb(int sock, short what, void *arg)
{
    struct event_base *base = arg;
    event_base_loopbreak(base);
}

void main_loop(struct event_base *base, evutil_socket_t watchdog_fd)
{
    struct event *watchdog_event;

    /* Construct a new event to triggerwhenever there are any bytes to
       read from a watchdog socket.  When that happens, we'll call the
       cb function, which will make the loop exitimmediately without
       running any other active events at all.
     */
    watchdog_event = event_new(base, watchdog_fd, EV_READ, cb, base);

    event_add(watchdog_event, NULL);

    event_base_dispatch(base);
}

运行event loop10秒钟，然后退出：
#include <event2/event.h>

void run_base_with_ticks(struct event_base *base)
{
  struct timeval ten_sec;

  ten_sec.tv_sec = 10;
  ten_sec.tv_usec = 0;

  /* Now we run the event_base for a series of10-second intervals, printing
     "Tick" after each.  For a much better way to implement a10-second
     timer, see the section below aboutpersistent timer events. */
  while (1) {
     /* This schedules an exit ten seconds fromnow. */
     event_base_loopexit(base, &ten_sec);

     event_base_dispatch(base);
     puts("Tick");
  }
}

有些时候需要知道event_base_dispatch()或event_base_loop()的调用是正常退出，还是因为调用了event_base_loopexit()或event_base_break()而退出。可以使用下面的函数判断是否调用了loopexit或break：
int event_base_got_exit(struct event_base *base);
int event_base_got_break(structevent_base *base)

上述函数，如果loop的停止是因为调用了event_base_loopexit()或event_base_break() ，则会返回True。否则，会返回False。他们的值会在下次启动eventloop时被重置。


重新检查events:
一般情况下，Libevent会检查events，然后从高优先级的激活events开始运行，然后再次检查events。
有时，你可能希望在运行完当前运行的回调函数之后，告知Libevent重新检查events。与event_base_loopbreak()类似，这可以通过调用event_base_loopcontinue()实现。
int event_base_loopcontinue(struct event_base *);
如果当前没有运行events的回调函数的话，则该函数没有任何效果。

转储event_base状态
void event_base_dump_events(struct event_base *base, FILE *f);
为了调试程序的方便，有时会需要得到所有关联到event_base的events的列表以及他们的状态。调用event_base_dump_events()可以讲该列表输出到文件f中。
得到的列表格式是人可读的形式，将来版本 的Libevent可能会改变其格式。

==================================================events
Libevents的基本操作单元是event，每一个event代表了一些条件的集合，这些条件包括：
文件描述符已经准备好读或写
文件描述符正在变为就绪，准备好读或写（仅限于边沿触发）
超时事件
信号发生
用户触发事件

events都有类似的生命周期。一旦调用Libevent函数创建好event，并将其关联到一个event_base之后，他就是“已初始化”状态（initialized）。
这种状态下，可以进行add操作，将其状态变为base中的“挂起”状态（pending），处于“挂起”状态的event，
如果触发事件的条件发生了（比如，文件描述符的状态发生变化，或者超时了），那么event的状态变为“激活”状态（active）,然后它的回调函数（用户提供）开始运行。
如果该event配置了“持久”属性（persistent），那么它的状态依然保持为“挂起”，否则，在回调函数运行时，它的状态就不再是“挂起”（“非挂起”状态）。
可以通过delete操作，将一个“挂起”状态的event变为“非挂起”状态（non-pending），或者通过add操作，将“非挂起”的event变为“挂起”状态。

构建event对象：
#define EV_TIMEOUT      0x01
#define EV_READ         0x02
#define EV_WRITE        0x04
#define EV_SIGNAL       0x08
#define EV_PERSIST      0x10
#define EV_ET           0x20

typedef void  (*event_callback_fn)(evutil_socket_t,  short,  void*);

struct event * event_new(struct  event_base *base,  evutil_socket_t  fd,
                                                    short what,  event_callback_fn  cb,
                                                    void* arg);

void  event_free(struct  event * event);

event_new函数分配并且创建一个新的event对象，并与base进行关联。what参数是上面列出标志的集合，它们的具体意义见下方。
如果fd是非负的整数，则它代表了我们需要观察可读或可写事件的文件。
当event变为激活时，Libevent就会调用回调函数cb，将文件描述符参数fd，所有触发事件的标志位域，以及event_new的最后一个参数：arg传递给cb。

如果发生了内部错误，或者参数非法，则event_new返回NULL。
所有新的events都是“已初始化”和“非挂起”状态，可以调用event_add函数将这样的event变为“挂起”状态。

调用event_free可以销毁event。对“挂起”或“激活”状态的event调用event_free也是安全的：在销毁它之前，会将其变为“非挂起”以及“非激活”状态。


event标志：
EV_TIMEOUT：
该标志表明，超时时间过后，该event变为“激活”状态。（注意：在构建event时，EV_TIMEOUT标志是被忽略的：当add event时可以设置超时时间，也可以不设置。当超时发生时，回调函数的what参数将会设置该标志。）
EV_READ：
该标志表明，当文件描述符准备好读时，event将会变为“激活”
EV_WRITE：
该标志表明，当文件描述符准备好写时，event将会变为“激活”
EV_SIGNAL：
用来实现信号探测
EV_PERSIST：
标志该event具有“持久”属性
EV_ET：
指明如果event_base的底层方法支持边沿触发的话，那么该event应该是边沿触发的。这将会影响到EV_READ和EV_WRITE

Examples：
#include <event2/event.h>

void  cb_func(evutil_socket_t  fd,  short what,  void * arg)
{
        const char *data = arg;
        printf("Got an event on socket %d:%s%s%s%s [%s]",
            (int) fd,
            (what&EV_TIMEOUT) ? " timeout" : "",
            (what&EV_READ)    ? " read" : "",
            (what&EV_WRITE)   ? " write" : "",
            (what&EV_SIGNAL)  ? " signal" : "",
            data);
}

void  main_loop(evutil_socket_t  fd1,  evutil_socket_t fd2)
{
        struct  event *ev1, *ev2;
        struct  timeval  five_seconds = {5,0};
        struct  event_base * base = event_base_new();

        /* The caller has already set up fd1,fd2 somehow, and make them
           nonblocking. */

        ev1 = event_new(base,  fd1,  EV_TIMEOUT|EV_READ|EV_PERSIST,  cb_func,
           (char*)"Reading event");
        ev2 = event_new(base,  fd2,  EV_WRITE|EV_PERSIST,  cb_func,
           (char*)"Writing event");

        event_add(ev1,  &five_seconds);
        event_add(ev2,  NULL);
        event_base_dispatch(base);
}


事件持久性 EV_PERSIST：
默认情况下，当一个“挂起”的event变为“激活”时（要么是因为fd准备好读或写，要么是超时时间到），那么在它的回调函数执行之后，它就会变为“非挂起”状态。
因此，如果希望再次使event变为“挂起”状态，可以在回调函数内部再次调用event_add函数。
如果event设置了EV_PERSIST标志，那么event就是“持久”的。这意味着event在回调函数激活的时候，依然保持“挂起”状态。如果希望在回调函数中将event变为“非挂起”状态，则可以调用event_del函数。

当event的回调函数运行时，“持久”event的超时时间就会被重置。因此，如果某个event标志为EV_READ|EV_PERSIST，并且将超时时间设置为5秒，则该event在下面的条件发生时，会变为“激活”：当该socket准备好读时； 距离上次event变为激活状态后，又过了5秒钟.


创建一个可以将自身作为回调函数参数的的event：
经常可能会希望创建这样一个event，它本身就是是回调函数的参数之一。不能仅仅传递一个指向event的指针作为event_new的参数，因为彼时它还没有创建。此时，可以通过调用event_self_cbarg函数解决这样的问题。
void*event_self_cbarg();
该函数返回一个“魔术”指针，使得event_new创建一个本身就能作为回调函数参数的event。

#include <event2/event.h>

static int  n_calls = 0;

void  cb_func(evutil_socket_t  fd,  short what,  void * arg)
{
    struct  event *me = arg;

    printf("cb_func  called  %d times  so far.\n",  ++n_calls);

    if (n_calls > 100)
       event_del(me);
}

void  run(struct  event_base * base)
{
    struct  timeval  one_sec = { 1, 0 };
    struct  event *ev;
    /* We're going to set up a repeating timerto get called 100 times. */
   ev = event_new(base,  -1,  EV_PERSIST, cb_func,  event_self_cbarg());
    event_add(ev,  &one_sec);
    event_base_dispatch(base);
}

该函数还可以与函数event_new,evtimer_new, evsignal_new, event_assign, evtimer_assign和evsignal_assign一起使用。然而对于非event来说，他不会作为回调函数的参数。


纯超时events：
Libevent提供了一系列以evtimer_开头的宏，这些宏可以代替event_*函数，来分配和操作纯超时events。使用这些宏仅能提高代码的清晰度而已。
#define evtimer_new(base,  callback,  arg)   event_new((base), -1, 0, (callback), (arg))
#define evtimer_add(ev,  tv)                              event_add((ev),(tv))
#define evtimer_del(ev)                                                            event_del(ev)
#define evtimer_pending(ev,  tv_out)   event_pending((ev), EV_TIMEOUT, (tv_out))

构造信号事件：
Libevent也可以监控POSIX类的信号。构建一个信号处理函数，可以使用下面的接口：
#define evsignal_new(base,  signum,  cb,  arg)\
    event_new(base,  signum,  EV_SIGNAL|EV_PERSIST,  cb,  arg)

除了提供一个代表信号值的整数，而不是一个文件描述符之外。它的参数与event_new是一样的。
struct event * hup_event;
struct event_base  *base = event_base_new();

/*call sighup_function on a HUP signal */
hup_event= evsignal_new(base,  SIGHUP,  sighup_function,  NULL);

注意：信号回调函数是在信号发生之后，在eventloop中调用的。所以，它们可以调用那些，对于普通POSIX信号处理函数来说不是信号安全的函数。
注意：不要在一个信号event上设置超时，不支持这样做。

#define evsignal_add(ev,  tv)                             event_add((ev), (tv))
#define evsignal_del(ev)                                        event_del(ev)
#define evsignal_pending(ev,  what,  tv_out)  event_pending((ev), (what), (tv_out))


不在堆中分配event：
出于性能或者其他原因的考虑，一些人喜欢将event作为一个大的结构体的一部分进行分配。对于这样的event，它节省了：

内存分配器在堆上分配小对象的开销；
event指针的解引用的时间开销；
如果event没有在缓存中，缓存不命中的时间开销。

这些开销都非常小，对于大多数应用来说是无关紧要的。除非确定知道，应用程序因为使用堆分配的event而存在严重的性能损失，否则应该坚持实用event_new。
int  event_assign(struct  event * event, struct  event_base * base,
                                 evutil_socket_t fd,  short  what,
                                 void(*callback)(evutil_socket_t,  short,  void *),  void * arg);
event_assign的参数与event_new相同，除了event参数，该参数指针必须指向一个未初始化的event。该函数成功时返回0，失败时返回-1.

#include <event2/event.h>
/*Watch out! Including event_struct.h means that your code willnot
 * be binary-compatible with future versions ofLibevent. */
#include <event2/event_struct.h>
#include <stdlib.h>

struct event_pair {
         evutil_socket_t  fd;
         struct event  read_event;
         struct event  write_event;
};
void  readcb(evutil_socket_t,  short,  void*);
void  writecb(evutil_socket_t,  short,  void*);
struct event_pair * event_pair_new(struct  event_base * base,  evutil_socket_t  fd)
{
        struct  event_pair  *p = malloc(sizeof(struct  event_pair));
        if (!p) return NULL;
        p->fd = fd;
        event_assign(&p->read_event,  base,  fd, EV_READ|EV_PERSIST,  readcb,  p);
        event_assign(&p->write_event,  base,  fd,  EV_WRITE|EV_PERSIST,writecb, p);
        return  p;
}

同样可以使用event_assign来初始化栈或者静态存储区中的events。

警告：对于已经在event_base中处于“挂起”状态的event，永远不要调用event_assign。
如果event已经初始化，并且处于“挂起”状态，那么在调用event_assign之前应该先调用event_del。

对于使用event_assign分配的纯超时event或者信号event，同样有方便的宏可以使用：
#define evtimer_assign(event,  base,  callback, arg) \
              event_assign(event, base,  -1,  0,  callback,  arg)
#define evsignal_assign(event,  base,  signum, callback,  arg) \
              event_assign(event, base,  signum,  EV_SIGNAL|EV_PERSIST,  callback,  arg)

如果需要在与未来版本的Libevent保持二进制兼容性的同时，使用event_assign，可以调用Libevent中的函数，得到运行时的event结构大小：
size_t event_get_struct_event_size(void);


将events置为“挂起”或者“非挂起”：
刚创建的一个event，实际上不能做任何事，直到通过调用event_add进行adding操作，将其置为“挂起”状态。
int event_add(struct event *ev, const struct timeval *tv);
在“非挂起”状态的events上执行event_add操作，则会使得该event在配置的event_base上变为“挂起”状态。该函数返回0表示成功，返回-1表示失败。如果tv为NULL，则该event没有超时时间。否则，tv以秒和毫妙表示超时时间。


如果在已经是“挂起”状态的event进行event_add操作，则会保持其“挂起”状态，并且会重置其超时时间。
如果event已经是“挂起”状态，而且以NULL为超时时间对其进行re-add操作，则event_add没有任何作用。

注意：不要设置tv为希望超时事件执行的时间，比如如果置tv->tv_sec=time(NULL)+10
int  event_del(struct event *ev);
在已经初始化状态的event上调用event_del，则会将其状态变为“非挂起”以及“非激活”状态。如果event的当前状态不是“挂起”或“激活”状态，则该函数没有任何作用。该函数返回0表示成功，返回-1表示失败。
注意，如果在event刚变为“激活”状态，但是它的回调函数还没有执行时，调用event_del函数，则该操作使得它的回调函数不会执行。


int event_remove_timer(struct event *ev);
最后，可以在不删除event上的IO事件或信号事件的情况下，删除一个“挂起”状态的event上的超时事件。
如果该event没有超时事件，则event_remove_timer没有作用。
如果event没有IO事件或信号事件，只有超时事件的话，则event_remove_timer等同于event_del。该函数返回0表示成功，-1表示失败。


事件的优先级：
当多个事件在同一时间触发时，Libevent对于他们回调函数的调用顺序是没有定义的。可以通过优先级，定义某些“更重要”的events。
每一个event_base都有一个或多个优先级的值。在event初始化之后，添加到event_base之前，可以设置该event的优先级。
int event_priority_set(struct event *event, int priority);
event的优先级数必须是位于0到event_base优先级-1这个区间内。该函数返回0表示成功，返回-1表示失败。

当具有多种优先级的多个events同时激活的时候，低优先级的events不会运行。Libevent会只运行高优先级的events，然后重新检查events。只有当没有高优先级的events激活时，才会运行低优先级的events。
#include <event2/event.h>

void  read_cb(evutil_socket_t,  short,  void*);
void  write_cb(evutil_socket_t,  short,  void*);

voidmain_loop(evutil_socket_t  fd)
{
  struct  event  *important,  *unimportant;
  struct  event_base  *base;

  base = event_base_new();
 event_base_priority_init(base, 2);
  /* Now base has priority 0, and priority 1 */
  important = event_new(base,  fd,  EV_WRITE|EV_PERSIST,  write_cb,  NULL);
  unimportant = event_new(base,  fd,  EV_READ|EV_PERSIST, read_cb,  NULL);
  event_priority_set(important, 0);
  event_priority_set(unimportant, 1);

  /*Now, whenever the fd is ready for writing, the write callback will
     happen before the read callback.  The read callback won't happen at
     all until the write callback is no longeractive.*/
}

如果没有设置一个event的优先级，则它的默认优先级是“event_base队列长度”除以2


检查event状态：
有时可能希望知道event是否已经添加了（处于“挂起”状态），或者检查他关联到哪个event_base等。
int  event_pending(const struct  event *ev,  short  what,  struct timeval  *tv_out);

#define event_get_signal(ev) /* ... */
evutil_socket_t event_get_fd(const  struct  event *ev);
struct event_base *event_get_base(const  struct event  *ev);
short event_get_events(const  struct  event  *ev);
event_callback_fn event_get_callback(const  struct event *ev);
void*event_get_callback_arg(const  struct  event  *ev);
int  event_get_priority(const struct  event *ev);

void  event_get_assignment(const struct event*event,
        struct  event_base  **base_out,
        evutil_socket_t  *fd_out,
        short  *events_out,
        event_callback_fn  *callback_out,
        void  **arg_out);

event_pending函数检查给定的event是否处于“挂起”或“激活”状态。如果确实如此，并且在what参数中设置了任何EV_READ, EV_WRITE, EV_SIGNAL或EV_TIMEOUT标志的话，则该函数返回所有该event当前正在“挂起”或“激活”的标志。
如果提供了tv_out参数，且在what参数中设置了EV_TIMEOUT参数，并且当前event确实在超时事件上“挂起”或者“激活”，则tv_out就会设置为event的超时时间。

event_get_fd和event_get_signal函数返回event上配置的文件描述符或者信号值。
event_get_base()返回其配置的event_base。
event_get_events()返回event上配置的事件标志（EV_READ,EV_WRITE等）。
event_get_callback函数和event_get_callback_arg函数返回event的回调函数和参数指针。
event_get_priority函数返回event的当前优先级。

event_get_assignment函数在提供的参数指针中返回event的所有成分，如果参数指针为NULL，则该成分被忽略。
#include <event2/event.h>
#include <stdio.h>

/*Change the callback and callback_arg of 'ev', which must not be pending. */
int  replace_callback(struct  event *ev,  event_callback_fn  new_callback,
     void* new_callback_arg)
{
    struct  event_base  *base;
    evutil_socket_t  fd;
    short  events;

    int  pending;
    pending = event_pending(ev, EV_READ|EV_WRITE|EV_SIGNAL|EV_TIMEOUT, NULL);
    if (pending) {
        /*We want to catch this here so that we do notre-assign a
         * pending event.  That would be very very bad.*/
       fprintf(stderr, "Error! replace_callbackcalled on a pending event!\n");
        return -1;
    }

    event_get_assignment(ev,  &base, &fd,  &events,
                         NULL /* ignore oldcallback */ ,
                         NULL /* ignore oldcallback argument */);

   event_assign(ev,  base,  fd,  events,new_callback,  new_callback_arg);
    return 0;
}



找到当前正在运行的event：
在调试程序时，可以得到当前正在运行的event的指针。
struct event * event_base_get_running_event(struct event_base * base);
注意，只有在base的loop中调用该函数，该函数才有意义。在其他线程调用时不支持的，而且会导致未定义的行为。


配置一次性的events：
如果不需要对一个event进行多次添加，或者对一个非持久的event，在add之后就会delete，则可以使用event_base_once函数。
int event_base_once(struct event_base *,  evutil_socket_t,  short,
                   void (*) (evutil_socket_t,  short,  void*),  void *,  const struct timeval *);

该函数的参数与event_new一样，不同的是它不支持EV_SIGNAL或EV_PERSIST标志。
得到的内部event会以默认的优先级添加到event_base中并运行。当它的回调函数执行完成之后，Libevent将会释放该内部event。该函数成功时返回0，失败是返回-1.

通过event_base_once插入的event不能被删除或者手动激活。如果希望可以取消一个event，则需要通过常规的event_new或event_assign接口创建event。



手动激活event：
某些极少的情况下，你可能希望在条件未被触发的情况下就激活event；
void event_active(struct event *ev, int what, short ncalls);
该接口使得event变为“激活”状态，激活标志在what中传入（EV_READ, EV_WRITE和EV_TIMEOUT的组合）。该event之前的状态不一定非得要是“挂起”状态，而且将其激活不会使其状态变为“挂起”状态。


struct event *ev;
struct timeval tv;

static void  cb(int  sock,short  which,  void *arg) {
   if (!evtimer_pending(ev, NULL)) {
       event_del(ev);
       evtimer_add(ev, &tv);
   }
}

int  main(int  argc,  char**argv) {
   struct  event_base  *base = event_base_new();
   tv.tv_sec = 0;
   tv.tv_usec = 0;

   ev = evtimer_new(base,  cb,  NULL);
   evtimer_add(ev, &tv);
   event_base_loop(base, 0);
   return 0;
}

==================================================通用函数
头文件<event2/util.h> 定义了许多能够帮助我们利用libevent 实现可移植应用程序的函数。libevent会在库内部使用这些函数。

----------基础类型：
evutil_socket_t
在除Windows之外的大多数地方，套接字是个整数，操作系统按照数值次序进行处理。然而，使用Windows套接字API时，socket具有类型SOCKET，它实际上是个类似指针的句柄，收到这个句柄的次序是未定义的。在Windows中，libevent定义evutil_socket_t类型为整型指针，可以处理socket()或者accept()的输出，而没有指针截断的风险。
#ifdef WIN32
#define evutil_socket_t intptr_t
#else
#define evutil_socket_t int
#endif

标准整数类型:
libevent定义了来自于stdint.h的、位宽度确定（bit-width-specific）的整数类型:
ev_XintX_t

各种兼容性类型:
在有ssize_t（有符号的size_t）类型的平台上，ev_ssize_t定义为ssize_t；
而在没有的平台上，则定义为某合理的默认类型。ev_ssize_t类型的最大可能值是EV_SSIZE_MAX；最小可能值是EV_SSIZE_MIN。（在平台没有定义SIZE_MAX的时候，size_t类型的最大可能值是EV_SIZE_MAX）

ev_off_t用于代表文件或者内存块中的偏移量。在有合理off_t类型定义的平台，它被定义为off_t；在Windows上则定义为ev_int64_t。

某些套接字API定义了socklen_t长度类型，有些则没有定义。在有这个类型定义的平台中，ev_socklen_t定义为socklen_t，在没有的平台上则定义为合理的默认类型。

ev_intptr_t是一个有符号整数类型，足够容纳指针类型而不会产生截断；而ev_uintptr_t则是相应的无符号类型。

----------可移植的定时器函数:
不是每个平台都定义了标准timeval操作函数，所以libevent也提供了自己的实现。
#define evutil_timeradd(tvp, uvp, vvp) /*  */
#define evutil_timersub(tvp, uvp, vvp) /*  */
这些宏分别对前两个参数进行加或者减运算，将结果存放到第三个参数中。


#define evutil_timerclear(tvp) /*  */
#define evutil_timerisset(tvp) /*  */
清除timeval会将其值设置为0。evutil_timerisset宏检查timeval是否已经设置，如果已经设置为非零值，返回ture，否则返回false。


#define evutil_timercmp(tvp, uvp, cmp)
evutil_timercmp宏比较两个timeval，如果其关系满足cmp关系运算符，返回true。
比如说，evutil_timercmp(t1,t2,<=)的意思是“是否t1<=t2？”。注意：与某些操作系统版本不同的是，libevent的时间比较支持所有C关系运算符（也就是<、>、==、!=、<=和>=）


int evutil_gettimeofday(struct timeval *tv, struct timezone *tz);
evutil_gettimeofday()函数设置tv为当前时间，tz参数未使用。

struct timeval tv1, tv2, tv3;

/* Set tv1 = 5.5 seconds */
tv1.tv_sec = 5; tv1.tv_usec = 500*1000;

/* Set tv2 = now */
evutil_gettimeofday(&tv2, NULL);

/* Set tv3 = 5.5 seconds in the future */
evutil_timeradd(&tv1, &tv2, &tv3);

/* all 3 should print true */
if (evutil_timercmp(&tv1, &tv1, ==))  /* == "If tv1 == tv1" */
   puts("5.5 sec == 5.5 sec");
if (evutil_timercmp(&tv3, &tv2, >=))  /* == "If tv3 >= tv2" */
   puts("The future is after the present.");
if (evutil_timercmp(&tv1, &tv2, <))   /* == "If tv1 < tv2" */
   puts("It is no longer the past.");

----------套接字API兼容性:
由于历史原因而存在：Windows从来没有以良好兼容的方式实现Berkeley(伯克利)套接字API。 下面是一些用户使其兼容的函数接口

int evutil_closesocket(evutil_socket_t s);
#define EVUTIL_CLOSESOCKET(s) evutil_closesocket(s)

这个接口用于关闭socket套接字。在Unix中，它是close()的别名；在Windows中，它调用closesocket()。（在Windows中不能将close()用于套接字，也没有其他系统定义了closesocket()）

#define EVUTIL_SOCKET_ERROR()
#define EVUTIL_SET_SOCKET_ERROR(errcode)
#define evutil_socket_geterror(sock)
#define evutil_socket_error_to_string(errcode)

这些宏用于访问和操作套接字错误代码。
EVUTIL_SOCKET_ERROR()返回本线程最后一次套接字操作的全局错误号，evutil_socket_geterror()则返回某特定套接字的错误号。
（在类Unix系统中都是errno）EVUTIL_SET_SOCKET_ERROR()修改当前套接字错误号（与设置Unix中的errno类似），evutil_socket_error_to_string()返回代表某给定套接字错误号的字符串（与Unix中的strerror()类似）。
（因为对于来自套接字函数的错误，Windows不使用errno，而是使用WSAGetLastError()，所以需要这些函数。）


int evutil_make_socket_nonblocking(evutil_socket_t sock);


这个函数确保关闭监听套接字后，它使用的地址可以立即被另一个套接字使用。（在Unix中它设置SO_REUSEADDR标志，在Windows中则不做任何操作。不能在Windows中使用SO_REUSEADDR标志：它有另外不同的含义（译者注：多个套接字绑定到相同地址））


int evutil_make_socket_closeonexec(evutil_socket_t sock);
这个函数告诉操作系统，如果调用了exec()，应该关闭指定的套接字。在Unix中函数设置FD_CLOEXEC标志，在Windows上则没有操作。


int evutil_socketpair(int family, int type, int protocol, evutil_socket_t sv[2]);
这个函数的行为跟Unix的socketpair()调用相同：创建两个相互连接起来的套接字，可对其使用普通套接字IO调用。函数将两个套接字存储在sv[0]和sv[1]中，成功时返回0，失败时返回-1。
在Windows中，这个函数仅能支持AF_INET协议族、SOCK_STREAM类型和0协议的套接字。注意：在防火墙软件明确阻止127.0.0.1，禁止主机与自身通话的情况下，函数可能失败。


----------可移植的字符串函数:
ev_int64_t evutil_strtoll(const char *s, char **endptr, int base);
这个函数与strtol行为相同，只是用于64位整数。在某些平台上，仅支持十进制。


int evutil_snprintf(char *buf, size_t buflen, const char *format, );
int evutil_vsnprintf(char *buf, size_t buflen, const char *format, va_list ap);
这些snprintf替代函数的行为与标准snprintf和vsnprintf接口相同。
函数返回在缓冲区足够长的情况下将写入的字节数，不包括结尾的NULL字节。（这个行为遵循C99的snprintf()标准，但与Windows的_snprintf()相反：如果字符串无法放入缓冲区，_snprintf()会返回负数）

----------IPv6辅助和兼容性函数:
/*
1.把ip地址转化为用于网络传输的二进制数值
int inet_aton(const char *cp, struct in_addr *inp);
inet_aton() 转换网络主机地址ip(如192.168.1.10)为二进制数值，并存储在struct in_addr结构中，即第二个参数*inp,函数返回非0表示cp主机有地有效，返回0表示主机地址无效。（这个转换完后不能用于网络传输，还需要调用htons或htonl函数才能将主机字节顺序转化为网络字节顺序）

in_addr_t inet_addr(const char *cp);
inet_addr函数转换网络主机地址（如192.168.1.10)为网络字节序二进制值，如果参数char *cp无效，函数返回-1(INADDR_NONE),这个函数在处理地址为255.255.255.255时也返回－1,255.255.255.255是一个有效的地址，不过inet_addr无法处理

2.将网络传输的二进制数值转化为成点分十进制的ip地址

char *inet_ntoa(struct in_addr in);
inet_ntoa 函数转换网络字节排序的地址为标准的ASCII以点分开的地址,该函数返回指向点分开的字符串地址（如192.168.1.10)的指针，该字符串的空间为静态分配的，这意味着在第二次调用该函数时，上一次调用将会被重写（复盖），所以如果需要保存该串最后复制出来自己管理


输出一个点分十进制的IP?
#include <stdio.h>   
#include <sys/socket.h>   
#include <netinet/in.h>   
#include <arpa/inet.h>   
#include <string.h>   
int main()   
{   
	struct in_addr addr1,addr2;   
	ulong l1,l2;   
	l1= inet_addr("192.168.0.74");   
	l2 = inet_addr("211.100.21.179");   
	memcpy(&addr1, &l1, 4);   
	memcpy(&addr2, &l2, 4);   
	printf("%s : %s\n", inet_ntoa(addr1), inet_ntoa(addr2)); //注意这一句的运行结果   
	printf("%s\n", inet_ntoa(addr1));   
	printf("%s\n", inet_ntoa(addr2));  
	return 0;   
}   
实际运行结果如下：　
192.168.0.74 : 192.168.0.74          //从这里可以看出,printf里的inet_ntoa只运行了一次。　　

192.168.0.74　　

211.100.21.179　　

inet_ntoa返回一个char *,而这个char *的空间是在inet_ntoa里面静态分配的，所以inet_ntoa后面的调用会覆盖上一次的调用。第一句printf的结果只能说明在printf里面的可变参数的求值是从右到左的


3.新型网路地址转化函数inet_pton和inet_ntop
这两个函数是随IPv6出现的函数，对于IPv4地址和IPv6地址都适用，函数中p和n分别代表表达（presentation)和数值（numeric)。地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构的二进制值。

#include <arpe/inet.h>
int inet_pton(int family, const char *strptr, void *addrptr);     //将点分十进制的ip地址转化为用于网络传输的数值格式
        返回值：若成功则为1，若输入不是有效的表达式则为0，若出错则为-1
 
const char * inet_ntop(int family, const void *addrptr, char *strptr, size_t len);     //将数值格式转化为点分十进制的ip地址格式
        返回值：若成功则为指向结构的指针，若出错则为NULL

（1）这两个函数的family参数既可以是AF_INET（ipv4）也可以是AF_INET6（ipv6）。如果，以不被支持的地址族作为family参数，这两个函数都返回一个错误，并将errno置为EAFNOSUPPORT.
（2）第一个函数尝试转换由strptr指针所指向的字符串，并通过addrptr指针存放二进制结果，若成功则返回值为1，否则如果所指定的family而言输入字符串不是有效的表达式格式，那么返回值为0.
（3）inet_ntop进行相反的转换，从数值格式（addrptr）转换到表达式（strptr)。inet_ntop函数的strptr参数不可以是一个空指针。调用者必须为目标存储单元分配内存并指定其大小，调用成功时，这个指针就是该函数的返回值。len参数是目标存储单元的大小，以免该函数溢出其调用者的缓冲区。如果len太小，不足以容纳表达式结果，那么返回一个空指针，并置为errno为ENOSPC。

inet_pton(AF_INET, ip, &foo.sin_addr);   //  代替 foo.sin_addr.addr=inet_addr(ip);
 
char str[INET_ADDRSTRLEN];
char *ptr = inet_ntop(AF_INET,&foo.sin_addr, str, sizeof(str));      // 代替 ptr = inet_ntoa(foo.sin_addr)

*/

const char *evutil_inet_ntop(int af, const void *src, char *dst, size_t len);
int evutil_inet_pton(int af, const char *src, void *dst);

这些函数根据RFC 3493的规定解析和格式化IPv4与IPv6地址，与标准inet_ntop()和inet_pton()函数行为相同。
要格式化IPv4地址，调用evutil_inet_ntop()，设置af为AF_INET，src指向in_addr结构体，dst指向大小为len的字符缓冲区。
对于IPv6地址，af应该是AF_INET6，src则指向in6_addr结构体。

要解析IP地址，调用evutil_inet_pton()，设置af为AF_INET或者AF_INET6，src指向要解析的字符串，dst指向一个in_addr或者in_addr6结构体。
失败时evutil_inet_ntop()返回NULL，成功时返回到dst的指针。成功时evutil_inet_pton()返回0，失败时返回-1。

int evutil_parse_sockaddr_port(const char *str, struct sockaddr *out, int *outlen);
这个接口解析来自str的地址，将结果写入到out中。outlen参数应该指向一个表示out中可用字节数的整数；函数返回时这个整数将表示实际使用了的字节数。成功时函数返回0，失败时返回-1
函数识别下列地址格式：
+ [ipv6]:端口号（如[ffff::]:80）
+ ipv6（如ffff::）
+ [ipv6]（如[ffff::]）
+ ipv4:端口号（如1.2.3.4:80）
+ ipv4（如1.2.3.4）
如果没有给出端口号，结果中的端口号将被设置为0。

int evutil_sockaddr_cmp(const struct sockaddr *sa1, const struct sockaddr *sa2, int include_port);
evutil_sockaddr_cmp()函数比较两个地址，如果sa1在sa2前面，返回负数；如果二者相等，则返回0；如果sa2在sa1前面，则返回正数。
函数可用于AF_INET和AF_INET6地址
如果两个地址只有端口号不同，只有在include_port参数为false，它们被认为是相等的。
否则，具有不同端口号的地址被认为是不等的。

----------结构体可移植性函数:
#define evutil_offsetof(type, field) /*  */
跟标准offsetof宏一样，这个宏返回从type类型开始处到field字段的字节数。

----------安全随机数生成器:
void evutil_secure_rng_get_bytes(void *buf, size_t n);
这个函数用随机数据填充buf处的n个字节。
如果所在平台提供了arc4random()，libevent会使用这个函数。否则，libevent会使用自己的arc4random()实现，种子则来自操作系统的熵池（entropy pool）（Windows中的CryptGenRandom，其他平台中的/dev/urandom）

int evutil_secure_rng_init(void);
void evutil_secure_rng_add_bytes(const char *dat, size_t datlen);
不需要手动初始化安全随机数发生器，但是如果要确认已经成功初始化，可以调用evutil_secure_rng_init()。
函数会播种RNG（如果没有播种过），并在成功时返回0。函数返回-1则表示libevent无法在操作系统中找到合适的熵源（source of entropy），如果不自己初始化RNG，就无法安全使用RNG了。

==================================================Bufferevents
struct bufferevent {
	/** Event base for which this bufferevent was created. */
	struct event_base *ev_base;
	/** Pointer to a table of function pointers to set up how this
	    bufferevent behaves. */
	const struct bufferevent_ops *be_ops;

	/** A read event that triggers when a timeout has happened or a socket
	    is ready to read data.  Only used by some subtypes of
	    bufferevent. */
	struct event ev_read;
	/** A write event that triggers when a timeout has happened or a socket
	    is ready to write data.  Only used by some subtypes of
	    bufferevent. */
	struct event ev_write;

	/** An input buffer. Only the bufferevent is allowed to add data to
	    this buffer, though the user is allowed to drain it. */
        // 输入缓冲区。只允许bufferevent向该缓冲区添加数据，但允许用户将数据耗尽
	struct evbuffer *input;

	/** An input buffer. Only the bufferevent is allowed to drain data
	    from this buffer, though the user is allowed to add it. */
        // 输入缓冲区。虽然允许用户添加数据，但仅允许bufferevent从该缓冲区中排出数据。
	struct evbuffer *output;

	struct event_watermark wm_read;
	struct event_watermark wm_write;

	bufferevent_data_cb readcb;
	bufferevent_data_cb writecb;
	/* This should be called 'eventcb', but renaming it would break
	 * backward compatibility */
	bufferevent_event_cb errorcb;
	void *cbarg;

	struct timeval timeout_read;
	struct timeval timeout_write;

	/** Events that are currently enabled: currently EV_READ and EV_WRITE
	    are supported. */
	short enabled;
};


大多数时候，应用程序除了响应请求外，还需要处理数据（及其缓存）。当我们想要写数据是，通常会有以下步骤

决定要向连接中写入什么数据， 把这些数据放入缓存
等待连接可写
写入尽可能多的数据
记住写入了多少数据，如果还有数据没写完。等待连接再次变为可写状态。
这样的I/O缓冲方式很常见，因而libevent为此提供了一种通用机制。
“bufferevent”由一个底层传输系统（比如socket），一个读缓冲区和一个写缓冲区组成。
对于普通的events， 当底层传输系统可读或者可写时，调用回调方式； 而bufferevent提供了一种替代方式：它在已经写入、或者读出数据的时候才调用回调函数。

基于socket的bufferevent：
在底层流式socket上发送和接收数据，使用event_*接口作为其后端。
异步IO的bufferevent：
过滤型的bufferevent：
成对的bufferevent：

bufferevent目前仅能工作在流式协议上，比如TCP。


bufferevent和evbuffers:
###
每一个bufferevent 都有一个输入缓冲区和输出缓冲区， 这些缓冲区（buffer）都是struct evbuffer 类型。 
当你有数据要写入bufferevent， 你要先把数据填入output buffer，； 当bufferevent上有数据需要读取时，则可以从input buffer中抽取出来。
###

回调函数和水位数:
每一个bufferevent都有两个数据相关的回到函数， 一个 读回调和一个写回调。 默认情况下，当有数据从底层传输读取时，读回调函数就会被调用； 当ouput buffer想底层传输写入足够多的数据时， 写回调函数就会被调用。
通过调整bufferevent的读取和写入“水位线”（watermarks），可以改变这些函数的默认行为。
每个bufferevent都有4个水位线：
读 低水位：
当bufferevent的输入缓冲区的数据量到达该水位线或者更高时，bufferevent的读回调函数就会被调用。该水位线默认为0，所以每一次读取操作都会导致读回调函数被调用。
读 高水位：
如果bufferevent的输入缓冲区的数据量到达该水位线时，那么bufferevent就会停止读取，直到输入缓冲区中足够多的数据被抽走，从而数据量再次低于该水位线。默认情况下该水位线是无限制的，所以从来不会因为输入缓冲区的大小而停止读取操作。
写 低水位：
当写操作使得输出缓冲区的数据量达到或者低于该水位线时，才调用写回调函数。默认情况下，该值为0，所以输出缓冲区被清空时才调用写回调函数。
写 高水位：
并非由bufferevent直接使用，对于bufferevent作为其他bufferevent底层传输系统的时候，该水位线才有特殊意义。

bufferevent还提供了error 或者event 的回调函数，用来通知应用程序关于非数据相关的事件。比如：关闭连接或者发生错误。 为此，定义了以下 event标志：
BEV_EVENT_READING：读操作期间发生了事件。
BEV_EVENT_WRITING：写操作期间发生了事件。
BEV_EVENT_ERROR：在bufferevent操作期间发生了错误，可以调用EVUTIL_SOCKET_ERROR函数来得到更多的错误信息。
BEV_EVENT_TIMEOUT： bufferevent上发生了超时
BEV_EVENT_EOF： bufferevent上遇到了EOF标志
BEV_EVENT_CONNECTED：在bufferevent上请求的连接已经完成


延期回调:
默认情况下， bufferevent的回调函数在响应的条件满足时会立即执行（evbuffer 回调函数也是如此)
当依赖关系比较复杂时， 这种立即执行 的机制会导致一些问题。比如说， 假设 有一个回调函数 是用于在evbuffer A为空时向其填入数据， 而另一个回调函数则在evbuffer A为满时 从中取出数据进行处理。如果所有这些调用都发生在栈上的话，在依赖关系足够复杂的时候，有栈溢出的风险。

为了解决这个问题，你可以告诉bufferevent（或evbuffer）它的回调函数应该被延迟执行。
当延迟回调函数 的对应条件满足时， 延迟回调函数不会立即执行，而是加入到event_loop()调用队列中。然后在常规的event回调之后执行。 


bufferevent 的选项标志:
BEV_OPT_CLOSE_ON_FREE： 当释放bufferevent时，关闭底层的传输系统。 这将关闭底层套接字，释放底层bufferevent等。
BEV_OPT_THREADSAFE： 自动为bufferevent分配锁， 从而在多线程中可以安全使用。
BEV_OPT_DEFER_CALLBACKS： bufferevent会将其所有回调函数进行延迟调用设置。
BEV_OPT_UNLOCK_CALLBACKS： 默认情况下， 当设置bufferevent为线程安全的时候，任何用户提供的回调函数调用时都会锁住bufferevent的锁， 设置改标志可以在提供的回调函数被调用时不锁住bufferevent的锁。


基于socket 的bufferevent:
基于socket的bufferevent使用Libevent底层event机制探测底层网络socket何时准备好读和写，而且使用底层网络调用（比如readv，writev，WSASend或WSARecv）进行传送和接受数据。


创建 基于socket 的bufferevent:
使用bufferevent_socket_new() 可以创建一个基于socket的bufferevent。
struct bufferevent *bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, enum bufferevent_options options);

base:表示event_base
options:是bufferevent选项的位掩（BEV_OPT_CLOSE_ON_FREE等）。
fd:参数是一个可选的socket文件描述符。如果希望以后再设置socket文件描述符，可以将fd置为-1。

要确保提供给bufferevent_socket_new的socket是非阻塞模式。Libevent提供了便于使用的evutil_make_socket_nonblocking来设置非阻塞模式。
bufferevent_socket_new成功时返回一个bufferevent，失败时返回NULL。


在基于socket的bufferevent上发送连接:
如果bufferevent上的socket还没有建立连接， 我们可以发送一个新的连接
int bufferevent_socket_connect(struct bufferevent *bev, struct sockaddr *address, int addrlen);
address和addrlen参数类似于标准的connect函数。如果该bufferevent尚未设置socket，则调用该函数为该bufferevent会分配一个新的流类型的socket，并且置其为非阻塞的。
如果bufferevent已经设置了一个socket，则调用数bufferevent_socket_connect会告知Libevent该socket尚未建立连接，在建立连接成功之前，不应该在其上进行读写操作。
在建立连接成功之前，向输出缓冲区添加数据是可以的。
该函数如果在建链成功时，返回0，如果发生错误，则返回-1.
#include <event2/event.h>
#include <event2/bufferevent.h>
#include <sys/socket.h>
#include <string.h>

void eventcb(struct bufferevent *bev, short events, void *ptr)
{
    if (events & BEV_EVENT_CONNECTED) {
         /* We're connected to 127.0.0.1:8080.   Ordinarily we'd do
            something here, like start reading or writing. */
    } else if (events & BEV_EVENT_ERROR) {
         /* An error occured while connecting. */
    }
}

int main_loop(void)
{
    struct event_base *base;
    struct bufferevent *bev;
    struct sockaddr_in sin;

    base = event_base_new();

    memset(&sin, 0, sizeof(sin));
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = htonl(0x7f000001); /* 127.0.0.1 */
    sin.sin_port = htons(8080); /* Port 8080 */

    bev = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE);

    bufferevent_setcb(bev, NULL, NULL, eventcb, NULL);

    if (bufferevent_socket_connect(bev,
        (struct sockaddr *)&sin, sizeof(sin)) < 0) {
        /* Error starting connection */
        bufferevent_free(bev);
        return -1;
    }

    event_base_dispatch(base);
    return 0;
}

注意：如果使用bufferevent_socket_connect进行连接的话，会得到BEV_EVENT_CONNECTED事件。如果自己手动调用connect()，则会得到write事件。
如果在手动调用connect()的情况下，仍然想在连接成功的时候得到BEV_EVENT_CONNECTED事件，可以在connect()返回-1，并且errno为EAGAIN或EINPROGRESS之后，调用bufferevent_socket_connect(bev, NULL, 0)函数。


通过hostname发射连接:
你可能希望将解析主机名和建立连接操作合成一个单独的操作，这时可以使用下面的接口
int bufferevent_socket_connect_hostname(struct bufferevent *bev, struct evdns_base *dns_base, int family, const char *hostname, int port);
int bufferevent_socket_get_dns_error(struct bufferevent *bev);
该函数解析DNS名字hostname，查找family类型的地址（family的类型可以是AF_INET, AF_INET6和AF_UNSPEC）。如果解析主机名失败，会以error event调用回调函数。如果成功了，则会像 bufferevent_connect一样，接着进行建立连接。
dns_base参数是可选的。如果该参数为空，则Libevent会一直阻塞，等待主机名解析完成，一般情况下不会这么做。如果提供了该参数，则Libevent使用它进行异步的主机名解析。参考:
Libevent和DNS解析:
https://blog.csdn.net/windeal3203/article/details/52868911
类似于bufferevent_socket_connect，该函数会告知Libevent，bufferevent上已存在的socket尚未建立连接，在解析完成，并且连接建立成功之前，不应该在其上进行读写操作。
如果发生了错误，有可能是DNS解析错误。可以通过调用函数bufferevent_socket_get_dns_error函数得到最近发生的错误信息。如果该函数返回的错误码为0，则表明没有检查到任何DNS错误。
/* Don't actually copy this code: it is a poor way to implement an
   HTTP client.  Have a look at evhttp instead.
*/
#include <event2/dns.h>
#include <event2/bufferevent.h>
#include <event2/buffer.h>
#include <event2/util.h>
#include <event2/event.h>

#include <stdio.h>

void readcb(struct bufferevent *bev, void *ptr)
{
    char buf[1024];
    int n;
    struct evbuffer *input = bufferevent_get_input(bev);
    while ((n = evbuffer_remove(input, buf, sizeof(buf))) > 0) {
        fwrite(buf, 1, n, stdout);
    }
}

void eventcb(struct bufferevent *bev, short events, void *ptr)
{
    if (events & BEV_EVENT_CONNECTED) {
         printf("Connect okay.\n");
    } else if (events & (BEV_EVENT_ERROR|BEV_EVENT_EOF)) {
         struct event_base *base = ptr;
         if (events & BEV_EVENT_ERROR) {
                 int err = bufferevent_socket_get_dns_error(bev);
                 if (err)
                         printf("DNS error: %s\n", evutil_gai_strerror(err));
         }
         printf("Closing\n");
         bufferevent_free(bev);
         event_base_loopexit(base, NULL);
    }
}

int main(int argc, char **argv)
{
    struct event_base *base;
    struct evdns_base *dns_base;
    struct bufferevent *bev;

    if (argc != 3) {
        printf("Trivial HTTP 0.x client\n"
               "Syntax: %s [hostname] [resource]\n"
               "Example: %s www.google.com /\n",argv[0],argv[0]);
        return 1;
    }

    base = event_base_new();
    dns_base = evdns_base_new(base, 1);

    bev = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE);
    bufferevent_setcb(bev, readcb, NULL, eventcb, base);
    bufferevent_enable(bev, EV_READ|EV_WRITE);
    evbuffer_add_printf(bufferevent_get_output(bev), "GET %s\r\n", argv[2]);
    bufferevent_socket_connect_hostname(
        bev, dns_base, AF_UNSPEC, argv[1], 80);
    event_base_dispatch(base);
    return 0;
}


通用的bufferevent操作:
释放bufferevent:
void  bufferevent_free(struct  bufferevent *bev);
该函数释放bufferevent。bufferevent在内部具有引用计数，所以即使当释放bufferevent时，如果bufferevent还有未决的延迟回调，那该bufferevent在该回调完成之前也不会删除
bufferevent_free函数会尽快释放bufferevent。然而，如果bufferevent的输出缓冲区中尚有残留数据要写，该函数也不会在释放bufferevent之前对缓冲区进行flush。
如果设置了BEV_OPT_CLOSE_ON_FREE标志，并且该bufferevent有socket或者使用了其他底层bufferevent作为其传输系统，则在释放该bufferevent时，会关闭对应的传输系统。


回调函数、水位线、使能操作:
typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx);
typedef void (*bufferevent_event_cb)(struct bufferevent *bev,
    short events, void *ctx);

void bufferevent_setcb(struct bufferevent *bufev,
    bufferevent_data_cb readcb, bufferevent_data_cb writecb,
    bufferevent_event_cb eventcb, void *cbarg);

void bufferevent_getcb(struct bufferevent *bufev,
    bufferevent_data_cb *readcb_ptr,
    bufferevent_data_cb *writecb_ptr,
    bufferevent_event_cb *eventcb_ptr,
    void **cbarg_ptr);
函数bufferevent_setcb() 可以改变bufferevent的回调函数。readcb、writecb和eventcb函数 分别在 有足够数据可读、有足够数据可写、有event时间发生时被调用。
这些回调函数的第一个参数就是发生了events的bufferevent； 而最后一个参数则是由用户提供的bufferevent_setcb的cbarg参数；用户可以通过event回调函数的events参数是event标志的位掩码：
我们可以通过向bufferevent_setcb() 传递NULL参数来禁用一些回调函数。需要注意的是，cbarg 参数是针对所有回调函数的。
我们可以通过向bufferevent_getcb 传递指针来获取当前的回调函数。该函数会将*readcb_ptr设置为当前的读回调函数，*writecb_ptr设置为写回调函数，*eventcb_ptr设置为当前的event回调函数，并且*cbarg_ptr设置为当前回调函数的参数。对于被设置为NULL 的指针，则会忽略它。

void bufferevent_enable(struct bufferevent *bufev, short events);
void bufferevent_disable(struct bufferevent *bufev, short events);
short bufferevent_get_enabled(struct bufferevent *bufev);
我们可以在bufferevent上enable或者disable事件 EV_READ, EV_WRITE, or EV_READ|EV_WRITE 。 当disable了读写操作，则bufferevent不会读取或写入数据
当output buffer 为空时，没必要disable写动作，bufferevent会自动禁止掉写动作。
类似的，当输入缓冲区达到它的高水位线的时候，没必要禁止读操作：bufferevent会自动停止读操作，而且在有空间读取的时候，又重新开启读操作。
默认情况下，新创建的bufferevent会enable写操作，而禁止读操作。
可以通过bufferevent_get_enabled() 来获取当前bufferevent中有那些events被enable了。


void bufferevent_setwatermark(struct bufferevent *bufev, short events, size_t lowmark, size_t highmark);
bufferevent_setwatermark调整一个bufferevent的读水位线，或写水位线，或两者一起调整。如果在events参数中设置了EV_READ参数，则会调整读水位线，如果设置了EV_WRITE标志，则会调整写水位线。将高水位线标志置为0，表示“无限制”。
#include <event2/event.h>
#include <event2/bufferevent.h>
#include <event2/buffer.h>
#include <event2/util.h>

#include <stdlib.h>
#include <errno.h>
#include <string.h>

struct info {
    const char *name;
    size_t total_drained;
};

void read_callback(struct bufferevent *bev, void *ctx)
{
    struct info *inf = ctx;
    struct evbuffer *input = bufferevent_get_input(bev);
    size_t len = evbuffer_get_length(input);
    if (len) {
        inf->total_drained += len;
        evbuffer_drain(input, len);
        printf("Drained %lu bytes from %s\n",
             (unsigned long) len, inf->name);
    }
}

void event_callback(struct bufferevent *bev, short events, void *ctx)
{
    struct info *inf = ctx;
    struct evbuffer *input = bufferevent_get_input(bev);
    int finished = 0;

    if (events & BEV_EVENT_EOF) {
        size_t len = evbuffer_get_length(input);
        printf("Got a close from %s.  We drained %lu bytes from it, "
            "and have %lu left.\n", inf->name,
            (unsigned long)inf->total_drained, (unsigned long)len);
        finished = 1;
    }
    if (events & BEV_EVENT_ERROR) {
        printf("Got an error from %s: %s\n",
            inf->name, evutil_socket_error_to_string(EVUTIL_SOCKET_ERROR()));
        finished = 1;
    }
    if (finished) {
        free(ctx);
        bufferevent_free(bev);
    }
}

struct bufferevent *setup_bufferevent(void)
{
    struct bufferevent *b1 = NULL;
    struct info *info1;

    info1 = malloc(sizeof(struct info));
    info1->name = "buffer 1";
    info1->total_drained = 0;

    /* ... Here we should set up the bufferevent and make sure it gets
       connected... */

    /* Trigger the read callback only whenever there is at least 128 bytes
       of data in the buffer. */
    bufferevent_setwatermark(b1, EV_READ, 128, 0);

    bufferevent_setcb(b1, read_callback, NULL, event_callback, info1);

    bufferevent_enable(b1, EV_READ); /* Start reading. */
    return b1;
}


bufferevent中的数据操作:
如果不能操作读写的数据，则从网络中读写数据没有任何意义。bufferevent提供函数可以操作读写的数据。
struct evbuffer *bufferevent_get_input(struct bufferevent *bufev);
struct evbuffer *bufferevent_get_output(struct bufferevent *bufev);
这两个函数功能非常强大，它们分别返回bufferevent的input buffer 和 output buffer. 在evbuffer类型上所能进行的所有操作
注意，应用程序只能从input buffer中移走（而不是添加）数据，而且只能向output buffer添加（而不是移走）数据。
如果bufferevent上的写操作因为数据太少而停滞（或者读操作因为数据太多而停滞），则向output buffer中添加数据（或者从input buffer中移走数据）可以自动重启写（读）操作。
int  bufferevent_write(struct  bufferevent *bufev,  const  void*data,  size_t  size);
int  bufferevent_write_buffer(struct  bufferevent *bufev,  struct  evbuffer*buf);
这些函数向bufferevent的output buffer中添加数据。调用bufferevent_write函数添加data中的size个字节的数据到输出缓冲区的末尾。调用 bufferevent_write_buffer函数则将buf中所有数据都移动到output buffer的末尾。这些函数返回0表示成功，返回-1表示发生了错误。
size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size);
int bufferevent_read_buffer(struct bufferevent *bufev, struct evbuffer *buf);
这两个函数从bufferevent的input buffer中移走数据。bufferevent_read函数从input buffer中移动size个字节到data中。它返回实际移动的字节数。bufferevent_read_buffer函数则移动输入缓冲区中的所有数据到buf中，该函数返回0表示成功，返回-1表示失败。
注意bufferevent_read函数中，data缓冲区必须有足够的空间保存size个字节。
#include <event2/bufferevent.h>
#include <event2/buffer.h>

#include <ctype.h>

void
read_callback_uppercase(struct bufferevent *bev, void *ctx)
{
        /* This callback removes the data from bev's input buffer 128
           bytes at a time, uppercases it, and starts sending it
           back.

           (Watch out!  In practice, you shouldn't use toupper to implement
           a network protocol, unless you know for a fact that the current
           locale is the one you want to be using.)
         */

        char tmp[128];
        size_t n;
        int i;
        while (1) {
                n = bufferevent_read(bev, tmp, sizeof(tmp));
                if (n <= 0)
                        break; /* No more data. */
                for (i=0; i<n; ++i)
                        tmp[i] = toupper(tmp[i]);
                bufferevent_write(bev, tmp, n);
        }
}

struct proxy_info {
        struct bufferevent *other_bev;
};
void
read_callback_proxy(struct bufferevent *bev, void *ctx)
{
        /* You might use a function like this if you're implementing
           a simple proxy: it will take data from one connection (on
           bev), and write it to another, copying as little as
           possible. */
        struct proxy_info *inf = ctx;

        bufferevent_read_buffer(bev,
            bufferevent_get_output(inf->other_bev));
}

struct count {
        unsigned long last_fib[2];
};

void
write_callback_fibonacci(struct bufferevent *bev, void *ctx)
{
        /* Here's a callback that adds some Fibonacci numbers to the
           output buffer of bev.  It stops once we have added 1k of
           data; once this data is drained, we'll add more. */
        struct count *c = ctx;

        struct evbuffer *tmp = evbuffer_new();
        while (evbuffer_get_length(tmp) < 1024) {
                 unsigned long next = c->last_fib[0] + c->last_fib[1];
                 c->last_fib[0] = c->last_fib[1];
                 c->last_fib[1] = next;

                 evbuffer_add_printf(tmp, "%lu", next);
        }

        /* Now we add the whole contents of tmp to bev. */
        bufferevent_write_buffer(bev, tmp);

        /* We don't need tmp any longer. */
        evbuffer_free(tmp);
}

读写 超时:
同其他events一样，可以设置timeout时间，当bufferevent在timeout时间消逝后还没有成功的读或写任何数据，则可以触发某个超时事件。
void bufferevent_set_timeouts(struct bufferevent *bufev, const struct timeval *timeout_read, const struct timeval *timeout_write);
将timeout设置为NULL，意味着移除超时时间
当bufferevent试图读取数据时，等待了timeout_read秒还没有数据，则读超时事件就会触发。当bufferevent试图写数据时，至少等待了timeout_write秒，则写超时事件就会触发。
注意，只有在bufferevent读或写的时候，才会对超时时间进行计时。换句话说，如果bufferevent上禁止了读操作，或者当输入缓冲区满（达到高水位线）时，则读超时时间不会使能。类似的，如果写操作未被使能，或者没有数据可写，则写超时时间也会被禁止。
当读或写超时发生的时候，则bufferevent上相应的读写操作就会被禁止。相应的event回调函数就会以BEV_EVENT_TIMEOUT|BEV_EVENT_READING或BEV_EVENT_TIMEOUT|BEV_EVENT_WRITING进行调用。


在bufferevent上进行flush:
int bufferevent_flush(struct bufferevent *bufev, short iotype, enum bufferevent_flush_mode state);
对一个bufferevent进行flush，可以强制bufferevent尽可能多的从底层传输系统上读取或者写入数据，而忽略其他可能阻止写入的限制条件。该函数的细节依赖于不同类型的bufferevent。
参数iotype 可以是EV_READ, EV_WRITE, EV_READ|EV_WRITE指明处理读操作、写操作，还是两者都处理. 参数state可以是BEV_NORMAL, BEV_FLUSH,BEV_FINISHED 之一. BEV_FINISHED 指明应该告诉另一端已经没有数据可以发送了;BEV_NORMAL 和 BEV_FLUSH 取决于bufferevent的类型。
bufferevent_flush函数返回-1表示失败，返回0表示没有任何数据被flush，返回1表示由数据被flush。


特定类型的bufferevent函数:
这些函数并非在所有bufferevent类型上都能使用
int  bufferevent_priority_set(struct  bufferevent *bufev,  int  pri);
int  bufferevent_get_priority(struct  bufferevent *bufev);
该函数将实现bufev的events的优先级调整为pri
返回0表示成功，返回-1表示失败，该函数只能工作在基于socket的bufferevent上。
int bufferevent_setfd(struct bufferevent *bufev, evutil_socket_t fd);
evutil_socket_t bufferevent_getfd(struct bufferevent *bufev);
该函数设置或者返回一个基于fd的event的文件描述符。只有基于socket的bufferevent支持setfd操作。这些函数返回-1表示失败，setfd返回0表示成功。
struct event_base *bufferevent_get_base(struct bufferevent *bev);
该函数返回bufferevent的event_base
struct bufferevent *bufferevent_get_underlying(struct bufferevent *bufev);
如果bufferevent作为其他bufferevent的底层传输系统的话，则该函数返回该底层bufferevent。参考过滤型bufferevent


对bufferevent手动加锁或者解锁:
类似于evbuffers，有时希望保证在bufferevent上的一系列操作是原子性的。Libevent提供了可以手动加锁和解锁bufferevent的函数。
void bufferevent_lock(struct bufferevent *bufev);
void bufferevent_unlock(struct bufferevent *bufev);
注意，如果一个bufferevent在创建时没有指定BEV_OPT_THREADSAFE 标志，或者Libevent的线程支持功能没有激活，则加锁一个bufferevent没有作用。
通过该函数对bufferevent进行加锁的同时，也会加锁evbuffers。这些函数都是递归的：对一个已经加锁的bufferevent再次加锁是安全的。当然，对于每次锁定都必须进行一次解锁。


Bufferevent 和 SSL:
bufferevent可以使用OpenSSL库实现SSL/TLS安全传输层。因为很多应用不需要或者不想链接OpenSSL，这部分功能在单独的libevent_openssl库中实现。

==================================================evbuffer结构体
https://blog.csdn.net/u010710458/article/details/80055667

对于任何网络库(模块)而言，一个缓冲模块都是必不可少的。缓冲模块主要用于缓冲从网络接收到的数据，以及用户提交的数据(用于发送)。
很多时候，我们还需要将网络模块层(非TCP层)的这些缓冲数据拷贝到用户层，而这些内存拷贝都会消耗时间。
为此Libevent提供了evbuffer用于处理缓冲网络IO的缓冲部分，为后续bufferevent的工作做准备。

缓冲区由evbuffer和evbuffer_chain组成，其中evbuffer_chain是真正存储数据的一块内存，通过链表将一个一个的evbuffer_chain连接在一起，组成内存池。而通过evbuffer结构体就可以管理这个内存池链表了。

//evbuffer-internal.h文件  
struct evbuffer_chain;  
struct evbuffer {  
    struct evbuffer_chain *first;  
    struct evbuffer_chain *last;  
    //这是一个二级指针。使用*last_with_datap时，指向的是链表中最后一个有数据的evbuffer_chain。  
    //所以last_with_datap存储的是倒数第二个evbuffer_chain的next成员地址。  
    //一开始buffer->last_with_datap = &buffer->first;此时first为NULL。所以当链表没有节点时  
    //*last_with_datap为NULL。当只有一个节点时*last_with_datap就是first。      
    struct evbuffer_chain **last_with_datap;  

    size_t total_len;//链表中所有chain的总字节数  

    ...  
};  
struct evbuffer_chain {  
    struct evbuffer_chain *next;  
    size_t buffer_len;//buffer的大小  

    //错开不使用的空间。该成员的值一般等于0  
    ev_off_t misalign;  

    //evbuffer_chain已存数据的字节数  
    //所以要从buffer + misalign + off的位置开始写入数据  
    size_t off;  

    ...  

    unsigned char *buffer;  
};  

Libevent有一个很独特的地方，就是那个evbuffer_chain结构体。
1、该结构体有misalign成员。该成员表示错开不用的buffer空间。也就是说buffer中真正的数据是从buffer + misalign开始。
2、evbuffer_chain结构体buffer是一个指针，按道理来说，应该单独调用malloc分配一个堆内存并让buffer指向之。但实际上buffer指向的内存和evbuffer_chain结构体本身的存储内存是一起分配的。

==================================================evbuffer：缓冲IO的实用功能
libevent的｀evbuffer｀实现了为向后面添加数据和从前面移除数据而优化的字节队列。
｀evbuffer｀用于处理缓冲网络IO的“缓冲”部分。它不提供调度IO或者当IO就绪时触发IO的功能：这是bufferevent的工作。


创建和释放evbuffer:
struct evbuffer *evbuffer_new(void);
void evbuffer_free(struct evbuffer *buf);
这两个函数的功能很简明：evbuffer_new()分配和返回一个新的空evbuffer；而evbuffer_free()释放evbuffer和其内容。


Evbuffers 和 线程安全:
int evbuffer_enable_locking(struct evbuffer *buf, void *lock);
void evbuffer_lock(struct evbuffer *buf);
void evbuffer_unlock(struct evbuffer *buf);
默认情况下，在多个线程中同时访问evbuffer是不安全的。如果需要这样的访问，可以在evbuffer 上调用evbuffer_enable_locking()。如果lock参数为NULL，libevent会使用evthread_set_lock_creation_callback提供的锁创建函数创建一个锁。否则，libevent将lock参数用作锁。
evbuffer_lock()和evbuffer_unlock()函数分别请求和释放evbuffer上的锁。可以使用这两个函数让一系列操作是原子的。如果evbuffer没有启用锁，这两个函数不做任何操作。
（注意：对于单个操作，不需要调用evbuffer_lock()和evbuffer_unlock()：如果evbuffer启用了锁，单个操作就已经是原子的。只有在需要多个操作连续执行，不让其他线程介入的时候，才需要手动锁定evbuffer)

检查evbuffer:
size_t evbuffer_get_length(const struct evbuffer *buf);
该函数返回在evbuffer中保存的字节数。
size_t evbuffer_get_contiguous_space(const struct evbuffer *buf);
这个函数返回连续地存储在evbuffer前面的字节数。evbuffer中的数据可能存储在多个分隔开的内存块中，这个函数返回当前第一个块中的字节数。


向evbuffer中添加数据：基础
int evbuffer_add(struct evbuffer *buf, const void *data, size_t datlen);
这个函数向buf 的末尾添加 datalen 字节的数据data 。 函数在成功时返回0， 失败时返回-1.
int evbuffer_add_printf(struct evbuffer *buf, const char *fmt, ...)
int evbuffer_add_vprintf(struct evbuffer *buf, const char *fmt, va_list ap);
这些函数添加格式化的数据到buf末尾。格式参数fmt和其他参数的处理分别与C库函数printf和vprintf相同。函数返回添加的字节数。
int evbuffer_expand(struct evbuffer *buf, size_t datlen);
这个函数修改缓冲区的最后一块，或者添加一个新的块，使得缓冲区足以容纳datlen字节，而不需要更多的内存分配。
/* Here are two ways to add "Hello world 2.0.1" to a buffer. */
/* Directly: */
evbuffer_add(buf, "Hello world 2.0.1", 17);

/* Via printf: */
evbuffer_add_printf(buf, "Hello %s %d.%d.%d", "world", 2, 0, 1);

从一个evbuffer 向另一个evbuffer移动数据:
为提高效率，libevent具有将数据从一个evbuffer移动到另一个的优化函数。
int evbuffer_add_buffer(struct evbuffer *dst, struct evbuffer *src);
int evbuffer_remove_buffer(struct evbuffer *src, struct evbuffer *dst, size_t datlen);
函数evbuffer_add_buffer()将src中的所有数据移动到dst末尾，成功时返回0，失败时返回-1。
evbuffer_remove_buffer()函数从src中移动datlen字节到dst末尾，尽量少进行复制。如果字节数小于datlen，所有字节被移动。函数返回移动的字节数。


添加数据到evbuffer前面:
int evbuffer_prepend(struct evbuffer *buf, const void *data, size_t size);
int evbuffer_prepend_buffer(struct evbuffer *dst, struct evbuffer* src);
除了将数据移动到目标缓冲区前面不同外，这两个函数的行为分别与evbuffer_add()和evbuffer_add_buffer()相同。
使用这些函数时要当心，永远不要对与bufferevent共享的evbuffer使用。


重新排列evbuffer的内部布局:
有时候需要取出evbuffer前面的N字节，将其看作连续的字节数组。要做到这一点，首先必须确保缓冲区的前面确实是连续的。
unsigned char *evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size);
evbuffer_pullup()函数“线性化”buf前面的size字节，必要时将进行复制或者移动，以保证这些字节是连续的，占据相同的内存块。如果size是负的，函数会线性化整个缓冲区。如果size大于缓冲区中的字节数，函数返回NULL。否则，evbuffer_pullup()返回指向buf中首字节的指针。
调用evbuffer_pullup()时使用较大的size参数可能会非常慢，因为这可能需要复制整个缓冲区的内容。
#include <event2/buffer.h>
#include <event2/util.h>

#include <string.h>

int parse_socks4(struct evbuffer *buf, ev_uint16_t *port, ev_uint32_t *addr)
{
    /* Let's parse the start of a SOCKS4 request!  The format is easy:
     * 1 byte of version, 1 byte of command, 2 bytes destport, 4 bytes of
     * destip. */
    unsigned char *mem;

    mem = evbuffer_pullup(buf, 8);

    if (mem == NULL) {
        /* Not enough data in the buffer */
        return 0;
    } else if (mem[0] != 4 || mem[1] != 1) {
        /* Unrecognized protocol or command */
        return -1;
    } else {
        memcpy(port, mem+2, 2);
        memcpy(addr, mem+4, 4);
        *port = ntohs(*port);
        *addr = ntohl(*addr);
        /* Actually remove the data from the buffer now that we know we
           like it. */
        evbuffer_drain(buf, 8);
        return 1;
    }
}
使用 与 evbuffer_get_contiguous_space() 的返回值相等的大小 来调用evbuffer_pullup()不会导致任何数据复制或者移动。


从evbuffer中删除数据:
int evbuffer_drain(struct evbuffer *buf, size_t len);
int evbuffer_remove(struct evbuffer *buf, void *data, size_t datlen);
evbuffer_remove()函数从buf前面复制和移除datlen字节到data内存中。如果可用字节少于datlen，函数复制所有字节。函数失败时返回-1，否则返回复制了的字节数。
evbuffer_drain()函数的行为与evbuffer_remove()相同，只是它不进行数据复制：而只是将数据从缓冲区前面移除。成功时返回0，失败时返回-1。


从evbuffer中拷贝出数据:
有时候需要获取缓冲区前面数据的副本，而不清除数据。比如说，可能需要查看某特定类型的记录是否已经完整到达，而不清除任何数据（像evbuffer_remove那样），或者在内部重新排列缓冲区（像evbuffer_pullup那样）。
ev_ssize_t evbuffer_copyout(struct evbuffer *buf, void *data, size_t datlen);
ev_ssize_t evbuffer_copyout_from(struct evbuffer *buf, const struct evbuffer_ptr *pos, void *data_out, size_t datlen);
evbuffer_copyout()的行为与evbuffer_remove() 类似，但是它不从缓冲区移除任何数据。也就是说，它从buf前面复制datlen字节到data处的内存中。如果可用字节少于datlen，函数会复制所有字节。失败时返回-1，否则返回复制的字节数。
evbuffer_copyout_from()的行为与evbuffer_copyout()有些类似， 不同的是evbuffer_copyout_from() 从制定的位置pos 开始复制， 而不是buffer的起始位置。
如果从缓冲区复制数据太慢，可以使用evbuffer_peek()。
#include <event2/buffer.h>
#include <event2/util.h>
#include <stdlib.h>
#include <stdlib.h>

int get_record(struct evbuffer *buf, size_t *size_out, char **record_out)
{
    /* Let's assume that we're speaking some protocol where records
       contain a 4-byte size field in network order, followed by that
       number of bytes.  We will return 1 and set the 'out' fields if we
       have a whole record, return 0 if the record isn't here yet, and
       -1 on error.  */
    size_t buffer_len = evbuffer_get_length(buf);
    ev_uint32_t record_len;
    char *record;

    if (buffer_len < 4)
       return 0; /* The size field hasn't arrived. */

   /* We use evbuffer_copyout here so that the size field will stay on
       the buffer for now. */
    evbuffer_copyout(buf, &record_len, 4);
    /* Convert len_buf into host order. */
    record_len = ntohl(record_len);
    if (buffer_len < record_len + 4)
        return 0; /* The record hasn't arrived */

    /* Okay, _now_ we can remove the record. */
    record = malloc(record_len);
    if (record == NULL)
        return -1;

    evbuffer_drain(buf, 4);
    evbuffer_remove(buf, record, record_len);

    *record_out = record;
    *size_out = record_len;
    return 1;
}


面向行的输入:
enum evbuffer_eol_style {
        EVBUFFER_EOL_ANY,
        EVBUFFER_EOL_CRLF,
        EVBUFFER_EOL_CRLF_STRICT,
        EVBUFFER_EOL_LF,
        EVBUFFER_EOL_NUL
};
char *evbuffer_readln(struct evbuffer *buffer, size_t *n_read_out, enum evbuffer_eol_style eol_style);
很多互联网协议使用基于行的格式。evbuffer_readln()函数从evbuffer前面取出一行，用一个新分配的空字符结束的字符串返回这一行。如果n_read_out不是NULL，则它被设置为返回的字符串的字节数。如果没有整行供读取，函数返回空。返回的字符串不包括行结束符。
evbuffer_readln()理解4种行结束符号：
EVBUFFER_EOL_LF：
行尾是单个换行符（也就是\n，ASCII值是0x0A）
EVBUFFER_EOL_CRLF_STRICT：
行尾是一个回车符，后随一个换行符（也就是\r\n，ASCII值是0x0D 0x0A）
EVBUFFER_EOL_CRLF：
行尾是一个可选的回车，后随一个换行符（也就是说，可以是\r\n或者\n）。这种格式对于解析基于文本的互联网协议很有用，因为标准通常要求\r\n的行结束符，而不遵循标准的客户端有时候只使用\n。
EVBUFFER_EOL_ANY：
行尾是任意数量、任意次序的回车和换行符。这种格式不是特别有用。它的存在主要是为了向后兼容。
（注意，如果使用event_se_mem_functions()覆盖默认的malloc，则evbuffer_readln返回的字符串将由你指定的malloc替代函数分配）

char *request_line;
size_t len;

request_line = evbuffer_readln(buf, &len, EVBUFFER_EOL_CRLF);
if (!request_line) {
    /* The first line has not arrived yet. */
} else {
    if (!strncmp(request_line, "HTTP/1.0 ", 9)) {
        /* HTTP 1.0 detected ... */
    }
    free(request_line);
}


在evbuffer中搜索:
evbuffer_ptr结构体指示evbuffer中的一个位置，包含可用于在evbuffer中迭代的数据。
struct evbuffer_ptr {
        ev_ssize_t pos;
        struct {
                /* internal fields */
        } _internal;
};
pos是唯一的公有字段，用户代码不应该访问其他字段。pos指示evbuffer中的一个位置，以到开始处的偏移量表示。
struct evbuffer_ptr evbuffer_search(struct evbuffer *buffer,
    const char *what, size_t len, const struct evbuffer_ptr *start);
struct evbuffer_ptr evbuffer_search_range(struct evbuffer *buffer,
    const char *what, size_t len, const struct evbuffer_ptr *start,
    const struct evbuffer_ptr *end);
struct evbuffer_ptr evbuffer_search_eol(struct evbuffer *buffer,
    struct evbuffer_ptr *start, size_t *eol_len_out,
    enum evbuffer_eol_style eol_style);

evbuffer_search()函数在缓冲区中查找含有len个字符的字符串what。函数返回包含字符串位置的evbuffer_ptr结构体，或者在没有找到字符串时返回-1。如果提供了start参数，则从指定的位置开始搜索；否则，从开始处进行搜索。
evbuffer_search_range()函数和evbuffer_search行为类似，只是它只考虑在end之前出现的what
evbuffer_search_eol()函数像evbuffer_readln()一样检测行结束，但是不复制行，而是返回指向行结束符的evbuffer_ptr。如果eol_len_out非空，则它被设置为EOL字符串长度。

enum evbuffer_ptr_how {
        EVBUFFER_PTR_SET,
        EVBUFFER_PTR_ADD
};
int evbuffer_ptr_set(struct evbuffer *buffer, struct evbuffer_ptr *pos,
    size_t position, enum evbuffer_ptr_how how);
evbuffer_ptr_set()函数操作buffer中的位置pos。如果how等于EVBUFFER_PTR_SET,指针被移动到缓冲区中的绝对位置position；如果等于EVBUFFER_PTR_ADD，则向前移动position字节。函数成功时返回0，失败时返回-1。
#include <event2/buffer.h>
#include <string.h>

/* Count the total occurrences of 'str' in 'buf'. */
int count_instances(struct evbuffer *buf, const char *str)
{
    size_t len = strlen(str);
    int total = 0;
    struct evbuffer_ptr p;

    if (!len)
        /* Don't try to count the occurrences of a 0-length string. */
        return -1;

    evbuffer_ptr_set(buf, &p, 0, EVBUFFER_PTR_SET);

    while (1) {
         p = evbuffer_search(buf, str, len, &p);
         if (p.pos < 0)
             break;
         total++;
         evbuffer_ptr_set(buf, &p, 1, EVBUFFER_PTR_ADD);
    }

    return total;
}
任何修改evbuffer或者其布局的调用都会使得evbuffer_ptr失效，不能再安全地使用。


检测数据而不复制:
有时候需要读取evbuffer中的数据而不进行（像evbuffer_copyout()那样的）复制，也不重新排列内部内存布局（像evbuffer_pullup()那样）。有时候可能需要查看evbuffer中间的数据。
struct evbuffer_iovec {
        void *iov_base;
        size_t iov_len;
};

int evbuffer_peek(struct evbuffer *buffer, ev_ssize_t len, struct evbuffer_ptr *start_at, struct evbuffer_iovec *vec_out, int n_vec);
调用evbuffer_peek()的时候，通过vec_out给定一个evbuffer_iovec数组，数组的长度是n_vec。函数会让每个结构体包含指向evbuffer内部内存块的指针（iov_base)和块中数据长度。
如果len小于0，evbuffer_peek()会试图填充所有evbuffer_iovec结构体。否则，函数会进行填充，直到使用了所有结构体，或者见到len字节为止。如果函数可以给出所有请求的数据，则返回实际使用的结构体个数；否则，函数返回给出所有请求数据所需的结构体个数。
如果ptr为NULL，函数从缓冲区开始处进行搜索。否则，从ptr处开始搜索。
{
    /* Let's look at the first two chunks of buf, and write them to stderr. */
    int n, i;
    struct evbuffer_iovec v[2];
    n = evbuffer_peek(buf, -1, NULL, v, 2);
    for (i=0; i<n; ++i) { /* There might be less than two chunks available. */
        fwrite(v[i].iov_base, 1, v[i].iov_len, stderr);
    }
}

{
    /* Let's send the first 4906 bytes to stdout via write. */
    int n, i, r;
    struct evbuffer_iovec *v;
    size_t written = 0;

    /* determine how many chunks we need. */
    n = evbuffer_peek(buf, 4096, NULL, NULL, 0);
    /* Allocate space for the chunks.  This would be a good time to use
       alloca() if you have it. */
    v = malloc(sizeof(struct evbuffer_iovec)*n);
    /* Actually fill up v. */
    n = evbuffer_peek(buf, 4096, NULL, v, n);
    for (i=0; i<n; ++i) {
        size_t len = v[i].iov_len;
        if (written + len > 4096)
            len = 4096 - written;
        r = write(1 /* stdout */, v[i].iov_base, len);
        if (r<=0)
            break;
        /* We keep track of the bytes written separately; if we don't,
           we may write more than 4096 bytes if the last chunk puts
           us over the limit. */
        written += len;
    }
    free(v);
}

{
    /* Let's get the first 16K of data after the first occurrence of the
       string "start\n", and pass it to a consume() function. */
    struct evbuffer_ptr ptr;
    struct evbuffer_iovec v[1];
    const char s[] = "start\n";
    int n_written;

    ptr = evbuffer_search(buf, s, strlen(s), NULL);
    if (ptr.pos == -1)
        return; /* no start string found. */

    /* Advance the pointer past the start string. */
    if (evbuffer_ptr_set(buf, &ptr, strlen(s), EVBUFFER_PTR_ADD) < 0)
        return; /* off the end of the string. */

    while (n_written < 16*1024) {
        /* Peek at a single chunk. */
        if (evbuffer_peek(buf, -1, &ptr, v, 1) < 1)
            break;
        /* Pass the data to some user-defined consume function */
        consume(v[0].iov_base, v[0].iov_len);
        n_written += v[0].iov_len;

        /* Advance the pointer so we see the next chunk next time. */
        if (evbuffer_ptr_set(buf, &ptr, v[0].iov_len, EVBUFFER_PTR_ADD)<0)
            break;
    }
}

修改evbuffer_iovec所指的数据会导致不确定的行为
如果任何函数修改了evbuffer，则evbuffer_peek()返回的指针会失效
如果在多个线程中使用evbuffer，确保在调用evbuffer_peek()之前使用evbuffer_lock()，在使用完evbuffer_peek()给出的内容之后进行解锁


直接向evbuffer添加数据:
有时候需要能够直接向evbuffer添加数据，而不用先将数据写入到字符数组中，然后再使用evbuffer_add()进行复制。
有一对高级函数可以完成这种功能：evbuffer_reserve_space()和evbuffer_commit_space()。跟evbuffer_peek()一样，这两个函数使用evbuffer_iovec结构体来提供对evbuffer内部内存的直接访问。
int evbuffer_reserve_space(struct evbuffer *buf, ev_ssize_t size, struct evbuffer_iovec *vec, int n_vecs);
int evbuffer_commit_space(struct evbuffer *buf, struct evbuffer_iovec *vec, int n_vecs);

evbuffer_reserve_space()函数给出evbuffer内部空间的指针。
函数会扩展缓冲区以至少提供size字节的空间。到扩展空间的指针，以及其长度，会存储在通过vec传递的向量数组中，n_vec是数组的长度。
n_vec的值必须至少是1。如果只提供一个vector，libevent会确保请求的所有连续空间都在单个扩展区中，但是这可能要求重新排列缓冲区，或者浪费内存。为取得更好的性能，应该至少提供2个向量。函数返回提供请求的空间所需的向量数。
写入到向量中的数据不会是缓冲区的一部分，直到调用evbuffer_commit_space()，使得写入的数据进入缓冲区。如果需要提交少于请求的空间，可以减小任何evbuffer_iovec结构体的iov_len字段，也可以提供较少的向量。函数成功时返回0，失败时返回-1。
提示和警告:
调用任何重新排列evbuffer或者向其添加数据的函数都将使之前从evbuffer_reserve_space()获取的指针失效。
当前实现中，不论用户提供多少个向量，evbuffer_reserve_space()从不使用多于两个。这一点在未来版本可能会有变化。
如果在多个线程中使用evbuffer，确保在调用evbuffer_reserve_space()之前使用evbuffer_lock()进行锁定，然后在提交后解除锁定。
/* Suppose we want to fill a buffer with 2048 bytes of output from a
   generate_data() function, without copying. */
struct evbuffer_iovec v[2];
int n, i;
size_t n_to_add = 2048;

/* Reserve 2048 bytes.*/
n = evbuffer_reserve_space(buf, n_to_add, v, 2);
if (n<=0)
   return; /* Unable to reserve the space for some reason. */

for (i=0; i<n && n_to_add > 0; ++i) {
   size_t len = v[i].iov_len;
   if (len > n_to_add) /* Don't write more than n_to_add bytes. */
      len = n_to_add;
   if (generate_data(v[i].iov_base, len) < 0) {
      /* If there was a problem during data generation, we can just stop
         here; no data will be committed to the buffer. */
      return;
   }
   /* Set iov_len to the number of bytes we actually wrote, so we
      don't commit too much. */
   v[i].iov_len = len;
}

/* We commit the space here.  Note that we give it 'i' (the number of
   vectors we actually used) rather than 'n' (the number of vectors we
   had available. */
if (evbuffer_commit_space(buf, v, i) < 0)
   return; /* Error committing */



使用evbuffer的网络IO:
libevent中evbuffer的最常见使用场合是网络IO。将evbuffer用于网络IO的接口是：
int evbuffer_write(struct evbuffer *buffer, evutil_socket_t fd);
int evbuffer_write_atmost(struct evbuffer *buffer, evutil_socket_t fd,
        ev_ssize_t howmuch);
int evbuffer_read(struct evbuffer *buffer, evutil_socket_t fd, int howmuch);

evbuffer_read()函数从套接字fd读取至多howmuch字节到buffer末尾。函数成功时返回读取的字节数，0表示EOF，失败时返回-1。
注意，错误码可能指示非阻塞操作不能立即成功，应该检查错误码EAGAIN（或者Windows中的WSAWOULDBLOCK）。
如果howmuch为负，evbuffer_read() 会尝试猜测要读取多少数据。
evbuffer_write_atmost()函数试图将buffer前面至多howmuch字节写入到套接字fd中。成功时函数返回写入的字节数，失败时返回-1。跟evbuffer_read()一样，应该检查错误码，看是真的错误，还是仅仅指示非阻塞IO不能立即完成。如果为howmuch给出负值，函数会试图写入buffer的所有内容。
调用evbuffer_write()与使用负的howmuch参数调用evbuffer_write_atmost()一样：函数会试图尽量清空buffer的内容。
在Unix中，这些函数应该可以在任何支持read和write的文件描述符上正确工作。在Windows中，仅仅支持套接字。
###
注意，如果使用bufferevent，则不需要调用这些函数，bufferevent的代码已经为你调用了。
###


evbuffer和回调:
evbuffer的用户常常需要知道什么时候向evbuffer添加了数据，什么时候移除了数据。为支持这个，libevent为evbuffer提高了通用回调机制。
struct evbuffer_cb_info {
        size_t orig_size;
        size_t n_added;
        size_t n_deleted;
};

typedef void (*evbuffer_cb_func)(struct evbuffer *buffer, const struct evbuffer_cb_info *info, void *arg);
回调函数在 有数据被添加到evbuffer中，或者从中移除数据的时候，会被调用。
函数收到缓冲区指针、一个evbuffer_cb_info结构体指针，和用户提供的参数。evbuffer_cb_info结构体的orig_size字段指示缓冲区改变大小前的字节数，n_added字段指示向缓冲区添加了多少字节；n_deleted字段指示移除了多少字节。

struct evbuffer_cb_entry;
struct evbuffer_cb_entry *evbuffer_add_cb(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg);
evbuffer_add_cb()函数为evbuffer添加一个回调函数，返回一个不透明的指针，随后可用于代表这个特定的回调实例。
cb参数是将被调用的函数，cbarg是用户提供的将传给这个函数的指针。
可以为单个evbuffer设置多个回调，添加新的回调不会移除原来的回调。
#include <event2/buffer.h>
#include <stdio.h>
#include <stdlib.h>

/* Here's a callback that remembers how many bytes we have drained in
   total from the buffer, and prints a dot every time we hit a
   megabyte. */
struct total_processed {
    size_t n;
};
void count_megabytes_cb(struct evbuffer *buffer,
    const struct evbuffer_cb_info *info, void *arg)
{
    struct total_processed *tp = arg;
    size_t old_n = tp->n;
    int megabytes, i;
    tp->n += info->n_deleted;
    megabytes = ((tp->n) >> 20) - (old_n >> 20);
    for (i=0; i<megabytes; ++i)
        putc('.', stdout);
}

void operation_with_counted_bytes(void)
{
    struct total_processed *tp = malloc(sizeof(*tp));
    struct evbuffer *buf = evbuffer_new();
    tp->n = 0;
    evbuffer_add_cb(buf, count_megabytes_cb, tp);

    /* Use the evbuffer for a while.  When we're done: */
    evbuffer_free(buf);
    free(tp);
}
注意：释放非空evbuffer不会清空其数据，释放evbuffer也不会为回调释放用户提供的数据指针。
如果不想让缓冲区上的回调永远激活，可以移除或者禁用回调：
int evbuffer_remove_cb_entry(struct evbuffer *buffer,
    struct evbuffer_cb_entry *ent);
int evbuffer_remove_cb(struct evbuffer *buffer, evbuffer_cb_func cb,
    void *cbarg);

#define EVBUFFER_CB_ENABLED 1
int evbuffer_cb_set_flags(struct evbuffer *buffer,
                          struct evbuffer_cb_entry *cb,
                          ev_uint32_t flags);
int evbuffer_cb_clear_flags(struct evbuffer *buffer,
                          struct evbuffer_cb_entry *cb,
                          ev_uint32_t flags);
可以通过添加回调时候获取的evbuffer_cb_entry来移除回调，也可以通过回调函数和参数指针来移除。成功时函数返回0，失败时返回-1。
evbuffer_cb_set_flags()和evbuffer_cb_clear_flags()函数分别为回调函数设置或者清除给定的标志。当前只有一个标志是用户可见的：EVBUFFER_CB_ENABLED。这个标志默认是打开的。如果清除这个标志，对evbuffer的修改不会调用回调函数。
int evbuffer_defer_callbacks(struct evbuffer *buffer, struct event_base *base);
跟bufferevent回调一样，可以让evbuffer回调不在evbuffer被修改时立即运行，而是延迟到某event_base的事件循环中执行。
如果有多个evbuffer，它们的回调潜在地让数据添加到evbuffer中，或者从中移除，又要避免栈崩溃，延迟回调是很有用的。
如果回调被延迟，则最终执行时，它可能是多个操作结果的总和。
与bufferevent一样，evbuffer具有内部引用计数的，所以即使还有未执行的延迟回调，释放evbuffer也是安全的。


为基于evbuffer的IO避免数据复制:
真正高速的网络编程通常要求尽量少的数据复制，libevent为此提供了一些机制
typedef void (*evbuffer_ref_cleanup_cb)(const void *data, size_t datalen, void *extra);
int evbuffer_add_reference(struct evbuffer *outbuf, const void *data, size_t datlen, evbuffer_ref_cleanup_cb cleanupfn, void *extra);
这个函数通过引用向evbuffer末尾添加一段数据。不会进行复制：evbuffer只会存储一个到data处的datlen字节的指针。
因此，在evbuffer使用这个指针期间，必须保持指针是有效的。
evbuffer会在不再需要这部分数据的时候调用用户提供的cleanupfn函数，带有提供的data指针、datlen值和extra指针参数。函数成功时返回0，失败时返回-1。
#include <event2/buffer.h>
#include <stdlib.h>
#include <string.h>

/* In this example, we have a bunch of evbuffers that we want to use to
   spool a one-megabyte resource out to the network.  We do this
   without keeping any more copies of the resource in memory than
   necessary. */

#define HUGE_RESOURCE_SIZE (1024*1024)
struct huge_resource {
    /* We keep a count of the references that exist to this structure,
       so that we know when we can free it. */
    int reference_count;
    char data[HUGE_RESOURCE_SIZE];
};

struct huge_resource *new_resource(void) {
    struct huge_resource *hr = malloc(sizeof(struct huge_resource));
    hr->reference_count = 1;
    /* Here we should fill hr->data with something.  In real life,
       we'd probably load something or do a complex calculation.
       Here, we'll just fill it with EEs. */
    memset(hr->data, 0xEE, sizeof(hr->data));
    return hr;
}

void free_resource(struct huge_resource *hr) {
    --hr->reference_count;
    if (hr->reference_count == 0)
        free(hr);
}

static void cleanup(const void *data, size_t len, void *arg) {
    free_resource(arg);
}

/* This is the function that actually adds the resource to the
   buffer. */
void spool_resource_to_evbuffer(struct evbuffer *buf,
    struct huge_resource *hr)
{
    ++hr->reference_count;
    evbuffer_add_reference(buf, hr->data, HUGE_RESOURCE_SIZE,
        cleanup, hr);
}


向evbuffer添加文件:
一些操作系统提供了将文件写入到网络，而不需要将数据复制到用户空间的方法。
int evbuffer_add_file(struct evbuffer *output, int fd, ev_off_t offset, size_t length);
evbuffer_add_file()要求一个打开的可读文件描述符fd（注意：不是套接字）。函数将文件中offset处开始的length字节添加到output末尾。成功时函数返回0，失败时返回-1。


通过引用将evbuffer添加到另一个evbufer中:
也可以通过引用将evbuffer添加到另一个evbuffer中：而不是移动一个evbuffer中内容到另一个evbuffer中，当将evbuffer的引用添加到另一个evbuffer中时，它的行为就好像复制了所有字节一样。
int evbuffer_add_buffer_reference(struct evbuffer *outbuf, struct evbuffer *inbuf);
evbuffer_add_buffer_reference()函数的行为就好像你已经从 outbuf复制了所有字节到 inbuf, 但实际上并没有进行任何不必要的拷贝。 .函数在成功是返回0， 失败时返回-1.
注意，inbuf内容后续的变化将不会反馈到outbuf中：该函数是通过引用添加evbuffer当前的内容，而不是evbuffer本身。
注意，不能嵌套buffer的引用：如果一个evbuffer是evbuffer_add_buffer_reference函数中的outbuf，则其不能作为另一个的inbuf。


使一个evbuffer仅能添加或者仅能移除:
int evbuffer_freeze(struct evbuffer *buf, int at_front);
int evbuffer_unfreeze(struct evbuffer *buf, int at_front);
可以使用这些函数暂时性的禁止evbuffer前端或后端的改变。bufferevent会在内部使用这些函数，用来防止输出缓冲区前端，或者输入缓冲区后端的意外改变。


==================================================连接监听：接收TCP连接
libevent 提供了一种用于监听和接受TCP连接的便捷方式——evconnlistener机制

面接口用于创建和释放evconnlistener

struct evconnlistener *evconnlistener_new(struct event_base *base,
    evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,
    evutil_socket_t fd);
struct evconnlistener *evconnlistener_new_bind(struct event_base *base,
    evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,
    const struct sockaddr *sa, int socklen);
void evconnlistener_free(struct evconnlistener *lev);

函数evconnlistener_new和evconnlistener_new_bind都用于分配和返回一个新的用于监听连接的对象。 每个用于监听的对象都使用event_base来维护一个建立的连接。当有新的TCP 连接发生时，回调函数就会调用。

base： event_base对象。
cb： 回调函数， 当有新的TCP连接发生时，会唤醒回调函数。
ptr： 传递给回调函数的参数。
flags： 一些标志
backlog： 监听队列允许容纳的最大连接数。
fd： 函数evconnlistener_new假设我们已经绑定了套接字到要监听的端口上，fd参数就是我们已经绑定的socket套接字。
sa： evconnlistener_new_bind帮助我们绑定监听地址。sa就是传入的监听地址。
socklen： sa的长度。

如果使用的是evconnlistener_new，需要保证传入的socket套接字处于non-blocking模式，可以通过evutil_make_socket_nonblocking等方法进行设置

常用的flag值：
LEV_OPT_LEAVE_SOCKETS_BLOCKING：默认情况下listener会把接收到的连接设置为non-blocking模式。 这个flag则是将连接设置为blocking状态（少用）
LEV_OPT_CLOSE_ON_FREE：释放listener时，先关闭潜在的套接字
LEV_OPT_REUSEABLE：一些系统平台在默认情况下即使已经关闭了socket，也要等待一段时间才能使用对应的port， 而这个flag则设置成只要已关闭socket就是重新使用对应的port。


回调函数原型如下：
typedef void (*evconnlistener_cb)(struct evconnlistener *listener,
    evutil_socket_t sock, struct sockaddr *addr, int len, void *ptr);

listener： 即接受连接的lister
sock： 新连接创建的新套接字
addr： 连接发起者的地址
len： 地址长度
ptr： 从evconnlistener_new和evconnlistener_bind_new传来的参数。


listener允许临时关闭和重新开启监听
int evconnlistener_disable(struct evconnlistener *lev);
int evconnlistener_enable(struct evconnlistener *lev);


#include <event2/listener.h>
#include <event2/bufferevent.h>
#include <event2/buffer.h>

#include <arpa/inet.h>

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>

static void
echo_read_cb(struct bufferevent *bev, void *ctx)
{
        /* This callback is invoked when there is data to read on bev. */
        struct evbuffer *input = bufferevent_get_input(bev);
        struct evbuffer *output = bufferevent_get_output(bev);

        /* Copy all the data from the input buffer to the output buffer. */
        evbuffer_add_buffer(output, input);
}

static void
echo_event_cb(struct bufferevent *bev, short events, void *ctx)
{
        if (events & BEV_EVENT_ERROR)
                perror("Error from bufferevent");
        if (events & (BEV_EVENT_EOF | BEV_EVENT_ERROR)) {
                bufferevent_free(bev);
        }
}

static void
accept_conn_cb(struct evconnlistener *listener,
    evutil_socket_t fd, struct sockaddr *address, int socklen,
    void *ctx)
{
        /* We got a new connection! Set up a bufferevent for it. */
        struct event_base *base = evconnlistener_get_base(listener);
        struct bufferevent *bev = bufferevent_socket_new(
                base, fd, BEV_OPT_CLOSE_ON_FREE);

        bufferevent_setcb(bev, echo_read_cb, NULL, echo_event_cb, NULL);

        bufferevent_enable(bev, EV_READ|EV_WRITE);
}

static void
accept_error_cb(struct evconnlistener *listener, void *ctx)
{
        struct event_base *base = evconnlistener_get_base(listener);
        int err = EVUTIL_SOCKET_ERROR();
        fprintf(stderr, "Got an error %d (%s) on the listener. "
                "Shutting down.\n", err, evutil_socket_error_to_string(err));

        event_base_loopexit(base, NULL);
}

int
main(int argc, char **argv)
{
        struct event_base *base;
        struct evconnlistener *listener;
        struct sockaddr_in sin;

        int port = 9876;

        if (argc > 1) {
                port = atoi(argv[1]);
        }
        if (port<=0 || port>65535) {
                puts("Invalid port");
                return 1;
        }

        base = event_base_new();
        if (!base) {
                puts("Couldn't open event base");
                return 1;
        }

        /* Clear the sockaddr before using it, in case there are extra
         * platform-specific fields that can mess us up. */
        memset(&sin, 0, sizeof(sin));
        /* This is an INET address */
        sin.sin_family = AF_INET;
        /* Listen on 0.0.0.0 */
        sin.sin_addr.s_addr = htonl(0);
        /* Listen on the given port. */
        sin.sin_port = htons(port);

        listener = evconnlistener_new_bind(base, accept_conn_cb, NULL,
            LEV_OPT_CLOSE_ON_FREE|LEV_OPT_REUSEABLE, -1,
            (struct sockaddr*)&sin, sizeof(sin));
        if (!listener) {
                perror("Couldn't create listener");
                return 1;
        }
        evconnlistener_set_error_cb(listener, accept_error_cb);

        event_base_dispatch(base);
        return 0;
}