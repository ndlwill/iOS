右值引用只不过是一种新的 C++ 语法，真正理解起来有难度的是基于右值引用引申出的 2 种 C++ 编程技巧，分别为移动语义和完美转发。

C++左值和右值:
右值引用可以从字面意思上理解，指的是以引用传递（而非值传递）的方式使用 C++ 右值。
左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。
lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 "read value"，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。

1) 可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。举个例子：
int a = 5;
5 = a; //错误，5 不能为左值
其中，变量 a 就是一个左值，而字面量 5 就是一个右值。

C++ 中的左值也可以当做右值使用，例如：
int b = 10; // b 是一个左值
a = b; // a、b 都是左值，只不过将 b 可以当做右值使用
2) 有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。
以上面定义的变量 a、b 为例，a 和 b 是变量名，且通过 &a 和 &b 可以获得他们的存储地址，因此 a 和 b 都是左值；
反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。 

C++右值引用:
其实 C++98/03 标准中就有引用，使用 "&" 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：
int num = 10;
int &b = num; //正确
int &c = 10; //错误
如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。
虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：
int num = 10;
const int &b = num;
const int &c = 10;

右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。
C++11 标准新引入了另一种引用方式，称为右值引用，用 "&&" 表示。
和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化

int num = 10;
//int && a = num;  //右值引用不能初始化为左值
int && a = 10;
和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：
int && a = 10;
a = 100;
cout << a << endl;
程序输出结果为 100。

另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：
const int&& a = 10;//编译器不会报错
但这种定义出来的右值引用并无实际用处。

引用类型	可以引用的值类型	使用场景
        (非常量左值	常量左值	非常量右值	常量右值)
非常量左值引用	Y	N	N	N	无
常量左值引用	Y	Y	Y	Y	常用于类中构建拷贝构造函数
非常量右值引用	N	N	Y	N	移动语义、完美转发
常量右值引用	N	N	Y	Y	无实际用途