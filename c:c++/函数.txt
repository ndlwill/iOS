==================================================函数重载(overload)
在传统C语言中，函数名必须是唯一的，程序中不允许出现同名的函数。
在C++中是允许出现同名的函数，这种现象称为函数重载。

实现函数重载的条件：
同一个作用域
参数个数不同
参数类型不同
参数顺序不同

返回值不作为函数重载依据

注意: 函数重载和默认参数一起使用，需要额外注意二义性问题的产生。

函数重载实现原理:
void func();编译器可能会将函数名修饰成_func
当编译器碰到void func(int x),编译器可能将函数名修饰为_func_int
当编译器碰到void func(int x,char c),编译器可能会将函数名修饰为_func_int_char


==================================================extern “C”
在Linux下测试：
C函数: void MyFunc(){} ,被编译成函数: MyFunc
C++函数: void MyFunc(){},被编译成函数: _Z6Myfuncv
由于C++中需要支持函数重载，所以C和C++中对同一个函数经过编译后生成的函数名是不相同的

这就导致了一个问题，如果在C++中调用一个使用C语言编写模块中的某个函数，那么C++是根据C++的名称修饰方式来查找并链接这个函数，那么就会发生链接错误，
以上例，C++中调用MyFunc函数，在链接阶段会去找Z6Myfuncv，结果是没有找到的，因为这个MyFunc函数是C语言编写的，生成的符号是MyFunc
那么如果我想在C++调用C的函数怎么办？
extern"C"的主要作用就是为了实现C++代码能够调用其他c语言代码。
加上extern "C"后，这部分代码编译器按C语言的方式进行编译和链接，而不是按C++的方式。

#ifndef MYMODULE_H
#define MYMODULE_H 
    #include<stdio.h>
    #if __cplusplus
        extern "C"{
    #endif
            void func1();
            int func2(int a,int b);
    #if __cplusplus
        }
    #endif
#endif

被extern "C"修饰的代码会 按照C语言的方式去编译
由于C、C++编译规则的不同

在编写C语言代码中直接使用 extern “C” ，这样就可以直接被C++调用
通过使用宏__cplusplus来区分C、C++环境


==================================================#pragma once
#pragma once可以防止整个文件的内容被重复包含，是一种预处理指令

区别:
#ifndef、#define、#endif受C\C++标准的支持，不受编译器的任何限制
有些编译器不支持#pragma once（较老编译器不支持，如GCC 3.4版本之前），兼容性不够好


==================================================默认参数
函数调用汇编指令为call

函数重载、默认参数可能会产生冲突、二义性（建议优先选择使用默认参数）

如果函数同时有声明、实现，默认参数只能放在函数声明中


==================================================内联函数(inline function)
在C中我们经常把一些短并且执行频繁的计算写成宏，而不是函数，这样做的理由是为了执行效率，宏可以避免函数调用的开销，这些都由预处理来完成

但是在C++出现之后，使用预处理宏会出现两个问题：
第一个在C中也会出现，宏看起来像一个函数调用，但是会有隐藏一些难以发现的错误
第二个问题是C++特有的，预处理器不允许访问类的成员，也就是说预处理器宏不能用作类的成员函数

内联函数
为了保持预处理宏的效率又增加安全性，而且还能像一般成员函数那样可以在类里访问自如，C++引入了内联函数(inline function).
内联函数为了继承宏函数的效率，没有函数调用时开销，然后又可以像普通函数那样，可以进行参数，返回值类型的安全检查，又可以作为成员函数。

内联函数会在适当的地方像预定义宏一样展开，所以不需要函数调用的开销

在普通函数(非成员函数)函数前面加上inline关键字使之成为内联函数。
但是必须注意必须函数体和声明结合在一起，否则编译器将它作为普通函数来对待

内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用时候的压栈，跳转，返回的开销。
我们可以理解为内联函数是以空间换时间

类内部的内联函数：
为了定义内联函数，通常必须在函数定义前面放一个inline关键字
但是在类内部定义内联函数时并不是必须的。任何在类内部定义的函数自动成为内联函数

对于任何类型的函数，编译器会将函数类型(包括函数名字，参数类型，返回值类型)放入到符号表中。
同样，当编译器看到内联函数，并且对内联函数体进行分析没有发现错误时，也会将内联函数放入符号表。

编译器会将内联函数调用直接展开为函数体代码

内联函数和宏，都可以减少函数调用的开销
对比宏，内联函数多了语法检测和函数特性

尽量不要内联超过10行代码的函数
有些函数即使声明为inline，也不一定会被编译器内联，比如递归函数