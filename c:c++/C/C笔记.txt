==================================================函数

以下是函数声明：
int max(int num1, int num2);

在函数声明中，参数的名称并不重要，只有参数的类型是必需的
int max(int, int); 

标准C语言中，函数的定义顺序是有讲究的
默认情况下，只有后面定义的函数才可以调用前面定义过的函数

如果想把其他函数的定义写在main函数后面，而且main函数能正常调用这些函数，那就必须在main函数前面作一下函数的声明

在定义函数时，函数名后面的()中定义的变量称为形式参数(形参)；在调用函数时传入的值称为实际参数(实参)。
形参就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。


==================================================变量作用域
全局变量保存在内存的全局存储区中，占用静态的存储单元；
局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。

计算机中的内存是以字节为单位的存储空间
内存的每一个字节都有一个唯一的编号，这个编号就称为地址。
凡存放在内存中的程序和数据都有一个地址
也就是说，一个函数也有自己的内存地址。


==================================================数组
int a[4] = {2, 5};
当数组为整型时，初始化未确定初值的元素，默认为0，所以上面的a[2]、a[3]都为0

当对全部数组元素都赋初值时，可以省略元素个数
int a[] = {2, 5, 7};

int a[] = {2, 5, 7};
printf("%p\n", a);
printf("%p\n", &a[0]);
两个地址相同
数组名，代表着数组的地址


// b是test函数的形参(形式参数)
void test(int b[]) { // 也可以写int b[3]
    b[0] = 9;
}

int main() {
    int a[3];
    a[0] = 10;

    printf("函数调用前的a[0]：%d\n", a[0]);// 10

    test(a); // a是test函数的实参(实际参数)

    printf("函数调用后的a[0]：%d", a[0]);// 9
    return 0;
}
如果一维数组的名字作为函数实参，传递的是整个数组


二维数组
a = a[0] = &a[0][0]
a[1] = &a[1][0]


==================================================enum
enum 枚举名 {枚举元素1,枚举元素2,……};
第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。


==================================================字符与字符串
C语言中没有String这种类型。其实字符串就是字符序列，由多个字符组成，所以在C语言中，我们可以用字符数组来存储字符串。
字符串可以看做是一个特殊的字符数组，为了跟普通的字符数组区分开来，应该在字符串的尾部添加了一个结束标志'\0'。
'\0'是一个ASCII码值为0的字符，是一个空操作符，表示什么也不干。所以采用字符数组存放字符串，赋值时应包含结束标志'\0'。

在 C 语言中，字符串实际上是使用 null 字符'\0' 终止的一维字符数组。

由于在数组的末尾存储了空字符，所以字符数组的大小比单词 "Hello" 的字符数多一个
char ch[6] = {'H', 'e', 'l', 'l', 'o', '\0'}; 
简写模式:
char ch[6] = "Hello" 

您不需要把 null 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 '\0' 放在字符串的末尾。

strcpy(s1, s2); 复制字符串 s2 到字符串 s1
strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾
strlen(s1); 返回字符串 s1 的长度
strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0
strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置
strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置


==================================================指针
赋为 NULL 值的指针被称为空指针。

int *ptr = NULL;
ptr 的地址是： 0x0 
ptr 是空指针

函数指针是指向函数的指针变量
指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。

typedef int (*fun_ptr)(int,int)// 函数指针类型

函数指针（Pointer to a Function）
函数指针是一个指向函数的指针，允许你通过该指针调用函数。你可以将函数的地址赋值给一个指针变量，并通过指针间接调用该函数。
指针函数（Function that returns a pointer）
指针函数是一个返回指针的函数，即函数本身返回一个指向某种类型数据的指针。指针函数的返回类型是一个指针。


回调函数
函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数

回调函数是由别人的函数执行时调用你实现的函数


==================================================结构体
定义指向结构的指针
struct Books *struct_pointer; 
指针变量中存储结构变量的地址
为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符


struct Books2 {
    char title[50];
    char author[50];
    char subject[100];
    int book_id;
};
strcpy(Books2A.title, "C Plus");


==================================================位域
有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。
例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。
为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为"位域"或"位段"。

所谓"位域"是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。
每个域有一个域名，允许在程序中按域名进行操作。
这样就可以把几个不同的对象用一个字节的二进制位域来表示。

典型的实例：
用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。
读取外部文件格式——可以读取非标准的文件格式。

struct 位域结构名称{
  位域列表
}; 
位域列表的形式为:
类型说明符 位域名：位域长度 

struct bean {
  int a:8;
  int b:4;
  int c:4;
}data;

说明 data 为 bean类型的 变量，共占 2个字节。其中位域 a 占 8 位，位域 b 占 4 位，位域 c 占 4 位。
1个字节8个位置:0000 0000

一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始
struct bean{
  unsigned a:4;
  unsigned  :4;//空域
  unsigned b:4;//从下一个单元开始存放
  unsigned c:4;
} 
在这个位域定义中共占用 2 个字节，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。

由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。

位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的
struct k{
 int a:1;
 int  :2;    /* 该 2 位不能使用 */
 int b:3;
 int c:2;
};
位域在本质上就是一种结构类型，不过其成员是按二进位分配的


==================================================共用体
共用体 是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。
您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。

union [union tag]
{
member definition;
member definition;
...
member definition;
}[one or more union variables]; 

union tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f;
或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。

union Data
{
int i;
float f;
char str[20];
}
共用体占用的内存应足够存储共用体中最大的成员。
在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。

void main() {
    //1. 访问共同体 no
    data.i = 10;
    data.f = 1314.520;
    strcpy(data.str,"C/C++");
    printf( "data.i : %d\n", data.i);
    printf( "data.f : %f\n", data.f);
    printf( "data.str : %s\n", data.str);

    printf("\n\n\n");
    //2. 访问共同体   yes
    data.i = 10;
    printf( "data.i : %d\n", data.i);
    data.f = 1314.520;
    printf( "data.f : %f\n", data.f);
    strcpy(data.str,"C/C++");
    printf( "data.str : %s\n", data.str);
 
} 

data.i : 725823299
data.f : 0.000000
data.str : C/C++

data.i : 10
data.f : 1314.520020
data.str : C/C++

注释 1 共用体的 i 和 f 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 str 成员能够完好输出的原因。
注释 2 ，这次我们在同一时间只使用一个变量成员，所以都能完好输出。


==================================================预处理器
C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。
C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。
C 预处理器（C Preprocessor）
所有的预处理器命令都是以井号（#）开头

typedef 是由编译器执行解释的， #define 语句是由预编译器进行处理的。

#undef  FILE_SIZE
#define FILE_SIZE 42

#ifndef MESSAGE
   #define MESSAGE "You wish!"
#endif

#ifdef DEBUG
   /* Your debugging statements here */
#endif
这个指令告诉 CPP 如果定义了 DEBUG，则执行处理语句。在编译时，如果您向 gcc 编译器传递了 -DDEBUG 开关量，这个指令就非常有用。
它定义了 DEBUG，您可以在编译期间随时开启或关闭调试。
-D：是编译器的一个选项，用来在编译时定义一个宏


一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）
#define  message_for(a, b)  \
    printf(#a " and " #b ": We love you!\n") 


字符串常量化运算符(#):
在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。
#include <stdio.h>

#define  message_for(a, b)  \
    printf(#a " and " #b ": We love you!\n")

int main(void){
   message_for(Carole, Debra);// Carole and Debra: We love you!
   return 0;
}


标记粘贴运算符(##):
宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记
#include <stdio.h>

#define tokenpaster(n) printf ("token" #n " = %d", token##n)

int main(void)
{
   int token34 = 40;
   
   tokenpaster(34);// token34 = 40 
   return 0;
}

因为这个实例会从编译器产生下列的实际输出：
printf ("token34 = %d", token34); 


参数化的宏:
int square(int x) {
   return x * x;
} 

我们可以使用宏重写上面的代码，如下：
#define square(x) ((x) * (x)) 

在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。



引用头文件相当于复制头文件的内容
建议把所有的常量、宏、系统全局变量和函数原型写在头文件中


==================================================错误处理
C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。
在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。
您可以在 errno.h 头文件中找到各种各样的错误代码。

可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。

C 语言提供了 perror() 和 strerror() 函数来显示与 errno 相关的文本消息。
perror() 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。
strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。


==================================================斐波拉契数列
// 递归实现
int fibonaci(int i){
    if (i == 0){
        return 0;
    }
    if (i == 1){
        return 1;
    }
    return fibonaci(i - 1) + fibonaci(i -2);
}
void main(){
    for (int j = 0; j < 10; j++) {
        printf("%d\t\n", fibonaci(j));

    }
}


==================================================可变参数
int func(int, ... ) 
{

}
函数 func() 最后一个参数写成省略号，即三个点号（ ... ），省略号之前的那个参数是 int，代表了要传递的可变参数的总数。
为了使用这个功能，您需要使用 stdarg.h 头文件，该文件提供了实现可变参数功能的函数和宏

在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。
使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。
使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。
使用宏 va_end 来清理赋予 va_list 变量的内存。

double average(int num,...){
     va_list  vaList;
     double  sum = 0.0;
     int i ;
     //为 num 个参数初始化 valist
     va_start(vaList,num);
     //访问所有赋给 vaList 的参数
    for (int j = 0; j < num; j++) {
        sum += va_arg(vaList, int);
    }
    //清理为valist 保留的内存
    va_end(vaList);
    return sum/num;
}


==================================================内存管理
void *calloc(int num, int size)
在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。

void free(void address)
该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。

void malloc(int num)
在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。

void realloc(void address, int newsize)
该函数重新分配内存，把内存扩展到 newsize。

注意: void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。

动态分配内存
如果您预先不知道需要存储的文本长度
我们需要定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存

void main() {
    char name[100];
    char *description;

    //将字符串 copy 到 name 中
    strcpy(name, "迎娶白富美！");

    //开始动态分配内存
    description = (char *) malloc(200 * sizeof(char));
    if (description == NULL) {
        fprintf(stderr, "Error - unable to allocate required memory\n");
    } else {
        strcpy(description, "开始添加数据到 description 中");
    }
    printf("Name = %s\n", name );
    printf("Description: %s sizeOf 大小 ：%d\n", description , sizeof(description));
//     使用 free() 函数释放内存
    free(description);
}


==================================================命令行参数
执行程序时，可以从命令行传值给 C 程序。这些值被称为命令行参数
命令行参数是使用 main() 函数参数来处理的，其中，argc 是指传入参数的个数，argv[] 是一个指针数组，指向传递给程序的每个参数


char *argv[]
这是一个 指针数组。具体来说，argv 是一个数组，其中的每个元素是一个 char * 类型的指针
char argv[]
这是一个 字符数组，表示 argv 是一个数组，其中每个元素都是一个 char 类型的字符。

int main(int argc, char *argv[]) {
    // argv 是一个数组，数组元素是 char * 类型的指针
    // argv[0] 是一个指向字符数组的指针，即字符串
    printf("First argument: %s\n", argv[0]);
    return 0;
}

int main() {
    // argv 是一个 char 类型的数组（单个字符）
    char argv[] = "Hello";
    printf("%s\n", argv);  // 输出：Hello
    return 0;
}