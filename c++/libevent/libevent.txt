路由器的功能：在不同网段之间传递数据包
如果不在路由规则里，就会把数据传送到默认的网关里。
默认网关负责所有非本网络内的数据包的传送。

==================================================信号
SIGHUP信号
进程组：
进程组就是一系列相互关联的进程集合，系统中的每一个进程也必须从属于某一个进程组；
每个进程组中都会有一个唯一的 ID(process group id)，简称 PGID；
PGID 一般等同于进程组的创建进程的 Process ID，而这个进程一般也会被称为进程组先导(process group leader)，同一进程组中除了进程组先导外的其他进程都是其子进程；
进程组的存在，方便了系统对多个相关进程执行某些统一的操作，例如，我们可以一次性发送一个信号量给同一进程组中的所有进程。
会话：
会话（session）是一个若干进程组的集合，同样的，系统中每一个进程组也都必须从属于某一个会话；
一个会话只拥有最多一个控制终端（也可以没有），该终端为会话中所有进程组中的进程所共用。
一个会话中前台进程组只会有一个，只有其中的进程才可以和控制终端进行交互；除了前台进程组外的进程组，都是后台进程组；
和进程组先导类似，会话中也有会话先导(session leader)的概念，用来表示建立起到控制终端连接的进程。
在拥有控制终端的会话中，session leader 也被称为控制进程(controlling process)，一般来说控制进程也就是登入系统的 shell 进程(login shell)；

SIGHUP 信号在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业, 这时它们与控制终端不再关联. 
系统对SIGHUP信号的默认处理是终止收到该信号的进程。所以若程序中没有捕捉该信号，当收到该信号时，进程就会退出。

SIGPIPE
在网络编程中，SIGPIPE这个信号是很常见的。当往一个写端关闭的管道或socket连接中连续写入数据时会引发SIGPIPE信号,引发SIGPIPE信号的写操作将设置errno为EPIPE。在TCP通信中，当通信的双方中的一方close一个连接时，若另一方接着发数据，根据TCP协议的规定，会收到一个RST响应报文，若再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，告诉进程这个连接已经断开了，不能再写入数据。

server.c：

#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>

#define port 8888

void handle(int sig)
{
    printf("SIGPIPE : %d\n",sig);
}

void mysendmsg(int fd)
{

    // 写入第一条消息
    char* msg1 = "first msg"; 
    int n = write(fd, msg1, strlen(msg1));

    if(n > 0)  //成功写入第一条消息,server 接收到 client 发送的 RST
    {
        printf("success write %d bytes\n", n);
    }

    // 写入第二条消息,触发SIGPIPE
    char* msg2 = "second msg";
    n = write(fd, msg2, strlen(msg2));
    if(n < 0)
    {
        printf("write error: %s\n", strerror(errno));
    }
}
int main()
{
    signal(SIGPIPE , handle); //注册信号捕捉函数

    struct sockaddr_in server_addr;

    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(port);

    int listenfd = socket(AF_INET , SOCK_STREAM , 0);

    bind(listenfd, (struct sockaddr *)&server_addr, sizeof(server_addr));

    listen(listenfd, 128);

    int fd = accept(listenfd, NULL, NULL);
    if(fd < 0)
    {
        perror("accept");
        exit(1);
    }

    mysendmsg(fd);

    return 0;
}

client.c

#include<stdio.h>
#include<stdlib.h>
#include<errno.h>
#include<string.h>
#include<sys/types.h>
#include<netinet/in.h>
#include<sys/socket.h>
#include<sys/wait.h>
#include<arpa/inet.h>
#include<unistd.h>

#define PORT 8888
#define MAX 1024

int main()
{

    char buf[MAX] = {'0'};
    int sockfd;
    int n;
    socklen_t slen;
    slen = sizeof(struct sockaddr);
    struct sockaddr_in seraddr;

    bzero(&seraddr,sizeof(seraddr));
    seraddr.sin_family = AF_INET;
    seraddr.sin_port = htons(PORT);
    seraddr.sin_addr.s_addr = htonl(INADDR_ANY);


    //socket()
    if((sockfd = socket(AF_INET,SOCK_STREAM,0)) == -1)
    {
        perror("socket");
        exit(-1);
    }
    //connect()
    if(connect(sockfd,(struct sockaddr *)&seraddr,slen) == -1)
    {
        perror("connect");
        exit(-1);
    }

    int ret = shutdown(sockfd , SHUT_RDWR);
    if(ret < 0)
    {
        perror("shutdown perror");
    }

    return 0;
}

SIGURG：
带外数据
带外数据用于迅速告知对方本端发生的重要的事件。它比普通的数据（带内数据）拥有更高的优先级，不论发送缓冲区中是否有排队等待发送的数据，它总是被立即发送。带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接中。实际应用中，带外数据是使用很少见，有，telnet和ftp等远程非活跃程序。
UDP没有实现带外数据传输，TCP也没有真正的带外数据。不过TCP利用头部的紧急指针标志和紧急指针，为应用程序提供了一种紧急方式，含义和带外数据类似。TCP的紧急方式利用传输普通数据的连接来传输紧急数据。

内核通知应用程序带外数据到达的方式有两种：一种就是利用ＩＯ复用技术的系统调用（如select）在接受到带外数据时将返回，并向应用程序报告socket上的异常事件。

https://blog.csdn.net/u014470361/article/details/83591513?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-2&spm=1001.2101.3001.4242

==================================================Reactor
https://blog.csdn.net/bingxuesiyang/article/details/89888664

https://zhuanlan.zhihu.com/p/87443227

==================================================函数调用的原理
https://www.jianshu.com/p/e7a22923867f

一个由C/C++编译的程序占用的内存分为以下几个部分：
1、栈区（stack）：又编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构的栈。
2、堆区（heap）：一般是由程序员分配释放，若程序员不释放的话，程序结束时可能由OS回收，值得注意的是他与数据结构的堆是两回事，分配方式倒是类似于数据结构的链表。
3、全局区（static）：也叫静态数据内存空间，存储全局变量和静态变量，全局变量和静态变量的存储是放一块的，初始化的全局变量和静态变量放一块区域，没有初始化的在相邻的另一块区域，程序结束后由系统释放。
4、文字常量区：常量字符串就是放在这里，程序结束后由系统释放。
5、程序代码区：存放函数体的二进制代码。

什么是栈：
栈是一种LIFO形式的数据结构，所有的数据都是后进先出。这种形式的数据结构正好满足我们调用函数的方式：父函数调用子函数，父函数在前，子函数在后；返回时，子函数先返回，父函数后返回。
栈支持两种基本操作，push和pop。push将数据压入栈中，pop将栈中的数据弹出并存储到指定寄存器或者内存中。

栈的生长方向是从高地址到低地址的，这是因为在下文讲的栈帧中，栈就是向下生长的，因此这里也用这种形式的栈；
第二，pop操作后，栈中的数据并没有被清空，只是该数据我们无法直接访问。

函数栈：
1.栈帧
也就是stack frame，其本质就是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息（参数，返回地址，本地变量等）。
栈帧有栈顶和栈底之分，其中栈顶的地址最低，栈底的地址最高，SP(栈指针)就是一直指向栈顶的。
我们用 %ebp 指向栈底，也就是基址指针；用 %esp 指向栈顶，也就是栈指针。

一般来说，我们将 %ebp 到 %esp 之间区域当做栈帧（也有人认为该从函数参数开始，不过这不影响分析）。
并不是整个栈空间只有一个栈帧，每调用一个函数，就会生成一个新的栈帧。
在函数调用过程中，我们将调用函数的函数称为“调用者(caller)”，将被调用的函数称为“被调用者(callee)”。在这个过程中，
1）“调用者”需要知道在哪里获取“被调用者”返回的值；
2）“被调用者”需要知道传入的参数在哪里，
3）返回的地址在哪里。
同时，我们需要保证在“被调用者”返回后，%ebp, %esp 等寄存器的值应该和调用前一致。因此，我们需要使用栈来保存这些数据。

2.函数调用实例
这是一个有参数但没有调用任何函数的简单函数，我们假设它被其他函数调用。

int MyFunction(int x, int y, int z){ 
int a, b, c;
a = 10;
b = 5;
c = 2;
...
}

int TestFunction(){ 
int x = 1, y = 2, z = 3;
MyFunction1(1, 2, 3);
...
}

对于这个函数，当调用时，MyFunction() 的汇编代码大致如下：
_MyFunction:
push %ebp ; //保存%ebp的值
movl %esp, $ebp ; //将%esp的值赋给%ebp，使新的%ebp指向栈顶
movl -12(%esp), %esp ; //分配额外空间给本地变量
movl $10, -4(%ebp) ;
movl $5, -8(%ebp) ;
movl $2, -12(%ebp) ;

调用者做了两件事情：第一，将被调用函数的参数按照从右到左的顺序压入栈中。第二，将返回地址压入栈中。
这两件事都是调用者负责的，因此压入的栈应该属于调用者的栈帧。
我们再来看看被调用者，它也做了两件事情：第一，将老的（调用者的） %ebp 压入栈，此时 %esp 指向它。
第二，将 %esp 的值赋给 %ebp, %ebp 就有了新的值，它也指向存放老 %ebp 的栈空间。
这时，它成了是函数 MyFunction() 栈帧的栈底。
这样，我们就保存了“调用者”函数的 %ebp，并且建立了一个新的栈帧。

在 %ebp 更新后，我们先分配一块0x12字节的空间用于存放本地变量，这步一般都是用 sub 或者 mov 指令实现。
在这里使用的是 movl。通过使用 mov 配合 -4(%ebp), -8(%ebp) 和 -12(%ebp) 我们便可以给 a, b 和 c 赋值了。

3.函数的返回
上面讲的都是函数的调用过程，我们现在来看看函数是如何返回的。
和调用函数时正好相反。当函数完成自己的任务后，它会将 %esp 移到 %ebp 处，然后再弹出旧的 %ebp 的值到 %ebp。这样，%ebp 就恢复到了函数调用前的状态了。

int MyFunction( int x, int y, int z ){ int a, int b, int c;
... return;
}

其汇编大致如下：
_MyFunction:
push %ebp
movl %esp, %ebp
movl -12(%esp), %esp
...
mov %ebp, %esp
pop %ebp
ret

我们注意到最后有一个 ret 指令，这个指令相当于 pop + jum。它首先将数据（返回地址）弹出栈并保存到 %eip 中，然后处理器根据这个地址无条件地跳到相应位置获取新的指令。

函数的调用其实不难，只要搞懂了如何保存以及还原 %ebp 和 %esp，就能明白函数是如何通过栈帧进行调用和返回的了。

==================================================TAILQ 队列（尾队列）
TAILQ队列有HEAD和ENTRY两种基本的数据结构

#define    TAILQ_HEAD(name, type)                        \
struct name {                                \
    struct type *tqh_first;    /* first element */            \
    struct type **tqh_last;    /* addr of last next element */        \
}

#define TAILQ_ENTRY(type)                                            \
struct {                                                             \
    struct type *tqe_next;  /* next element */                       \
    struct type **tqe_prev;/* addr of previous next element*/        \
}   

数据结构中的filed都是type类型的指针(或者是二级指针)
这里的type是用户的队列元素类型，将ENTRY结构内嵌到用户的QUEUE_ITEM结构中：
struct QUEUE_ITEM{  
    int value;  
    TAILQ_ENTRY(QUEUE_ITEM) entries;  
};  

TAILQ_HEAD(headname,QUEUE_ITEM) queue_head; 

TAILQ队列中为什么tqh_prev和tqh_last要使用二级指针？
我们可以考虑如果不使用二级指针会怎么样？ 就像定义成下面这样。
#define    FAKE_TAILQ_HEAD(name, type)                        \
struct name {                                \
    struct type *tqh_first;    /* first element */            \
    struct type *tqh_last;    /* last element */        \
}

#define FAKE_TAILQ_ENTRY(type)                                            \
struct {                                                             \
    struct type *tqe_next;  /* next element */                       \
    struct type *tqe_prev;  /*   previous element*/        \
}   

如果我们想要删除队列的任意一个元素，对FAKE_TAILQ，我们需要特殊处理该元素是第一个元素的情况(第一个元素的tqe_prev指针为空)，而TAILQ就没有这个烦恼！

TAILQ队列的遍历性能
Linux中的list只将struct list_head作为用户元素的挂接点，因此在正向遍历链表时，需要使用container_of这类接口才能获取用户的数据，
而TAILQ由于tqe_next指针直接指向用户元素的类型，所以理论上，正向遍历TAILQ比list更快.但逆向遍历时,由于TAILQ的取用prev元素的操作比next麻烦的多，
因此逆向遍历是比正向慢的：

博客园==========================================================================================================================================================================================================================================================
==================================================Libevent源码分析—event, event_base
https://zhuanlan.zhihu.com/p/93612337
在处理web请求时，通常有两种体系结构，分别为：thread-based architecture（基于线程）、event-driven architecture（事件驱动）
thread-based architecture
基于线程的体系结构通常会使用多线程来处理客户端的请求，每当接收到一个请求，便开启一个独立的线程来处理。这种方式虽然是直观的，但是仅适用于并发访问量不大的场景，
因为线程需要占用一定的内存资源，且操作系统在线程之间的切换也需要一定的开销，当线程数过多时显然会降低web服务器的性能。并且，当线程在处理I/O操作，在等待输入的这段时间线程处于空闲的状态，
同样也会造成cpu资源的浪费。
event-driven architecture
事件驱动体系结构是目前比较广泛使用的一种。这种方式会定义一系列的事件处理器来响应事件的发生，并且将服务端接受连接与对事件的处理分离。
其中，事件是一种状态的改变。比如，tcp中socket的new incoming connection、ready for read、ready for write。

reactor:
reactor设计模式是event-driven architecture的一种实现方式，处理多个客户端并发的向服务端请求服务的场景。每种服务在服务端可能由多个方法组成。
reactor会解耦并发请求的服务并分发给对应的事件处理器来处理。目前，许多流行的开源框架都用到了reactor模式，如：netty、node.js等，包括java的nio。

Reactor:
The reactor design pattern is an event handling pattern for handling service requests delivered concurrently to a service handler by one or more inputs. 
The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers.
事件驱动（event handling）
可以处理一个或多个输入源（one or more inputs）
通过Service Handler同步的将输入事件（Event）采用多路复用分发给相应的Request Handler（多个）处理

为何要用Reactor:
常见的网络服务中，如果每一个客户端都维持一个与登陆服务器的连接。
那么服务器将维护多个和客户端的连接以出来和客户端的contnect 、read、write ，特别是对于长链接的服务，有多少个c端，就需要在s端维护同等的IO连接。
这对服务器来说是一个很大的开销。

event和event_base是libevent的两个核心结构体，分别是反应堆模式中的Event和Reactor。
1.event:
struct event {
        TAILQ_ENTRY (event) ev_next;  //I/O事件
        TAILQ_ENTRY (event) ev_active_next;  //所有激活事件的链表
        TAILQ_ENTRY (event) ev_signal_next;  //Signal事件
        //定时事件在小根堆中的索引
        unsigned int min_heap_idx;      /* for managing timeouts */
        struct event_base *ev_base; //event所属的Reactor
        int ev_fd; //IO事件：绑定的文件描述符；Signal事件：绑定的信号
        short ev_events;  //I/O、信号、定时器
        short ev_ncalls;  //调用回调函数的次数
        short *ev_pncalls; //指向ev_ncalls      /* Allows deletes in callback */
        struct timeval ev_timeout;  //定时事件的超时值
        int ev_pri; //event优先级               /* smaller numbers are higher priority */
        void (*ev_callback)(int, short, void *arg);  //回调函数:ev_fd, ev_events, ev_arg
        void *ev_arg;
        int ev_res;  //调用回调函数时，传递给回调函数，保存回调函数的返回值           /* result passed to event callback */
        int ev_flags;  //event的当前状态
};
从event这个结构体我们可以看到libevent将I/O、信号、定时器3种事件统一封装成一个event来对待。

其中ev_events取值有：
// event.ev_events
#define EV_TIMEOUT      0x01
#define EV_READ         0x02
#define EV_WRITE        0x04
#define EV_SIGNAL       0x08
//永久事件
#define EV_PERSIST      0x10    /* Persistant event */

ev_flags取值有：
// event.ev_flags
// event在time堆中
#define EVLIST_TIMEOUT  0x01
//event在已注册事件链表中
#define EVLIST_INSERTED 0x02
#define EVLIST_SIGNAL   0x04
//event在激活链表中
#define EVLIST_ACTIVE   0x08
#define EVLIST_INTERNAL 0x10
//event已被初始化
#define EVLIST_INIT     0x80
/* EVLIST_X_ Private space: 0x1000-0xf000 */
#define EVLIST_ALL      (0xf000 | 0x9f)

2.event_base:
struct event_base {
        const struct eventop *evsel;  //I/O多路复用机制的封装,eventops[]数组中一项
        void *evbase;  //I/O多路复用机制的一个实例，执行具体任务
        int event_count; //该event_base上的总的event            /* counts number of total events */
        int event_count_active;  //该event_base上的总的激活的event /* counts number of active events */
        int event_gotterm;              /* Set to terminate loop */
        int event_break;                /* Set to terminate loop immediately */
        /* active event management */
        struct event_list **activequeues; //指针数组，activequeues[priority]指向优先级为priority的链表
        int nactivequeues;
        /* signal handling info */
        struct evsignal_info sig;  //管理Signal事件
        struct event_list eventqueue; //链表，保存了所有注册事件event的指针
        struct timeval event_tv;  //时间管理
        struct min_heap timeheap;  //管理定时事件的小根堆
        struct timeval tv_cache;  //时间管理
};

其中eventop结构体和evbase是保存了I/O多路复用机制相关信息。evsel会调用init()去初始化evbase。
eventop结构体如下：
struct eventop {
        const char *name;
        void *(*init)(struct event_base *);  //初始化
        int (*add)(void *, struct event *);  //注册事件
        int (*del)(void *, struct event *);  //删除事件
        int (*dispatch)(struct event_base *, void *, struct timeval *);  //事件分发
        void (*dealloc)(struct event_base *, void *);  //注销，释放资源
        /* set if we need to reinitialize the event base */
        int need_reinit;
};

==================================================Libevent源码分析—event_init()
初始化event_base结构的相关函数
event_init()
首先调用event_init()初始化event_base结构体
struct event_base *
event_init(void)
{
    struct event_base *base = event_base_new();    //event_init()调用event_base_new()
    if (base != NULL)
        current_base = base;
    return (base);
}
我们发现event_init()工作量很少，只是调用event_base_new()函数，所以真正初始化event_base的工作是在event_base_new()函数内完成。

event_base_new():
struct event_base *
event_base_new(void)    //初始化libevent的event_base
{
    int i;
    struct event_base *base;
    if ((base = calloc(1, sizeof(struct event_base))) == NULL)    //在堆上分配内存存储event_base，所有字段初始化为0
        event_err(1, "%s: calloc", __func__);
    event_sigcb = NULL;
    event_gotsig = 0;
    detect_monotonic();    //设置use_monotonic变量
    gettime(base, &base->event_tv);    //base->tv_cache.tv_sec非0，则赋给base->event_tv
    
    min_heap_ctor(&base->timeheap);    //初始化定时事件的小根堆base->timeheap    min_heap.h
    TAILQ_INIT(&base->eventqueue);    //初始化注册事件链表base->eventqueue    sys/queue.h
    base->sig.ev_signal_pair[0] = -1;    //初始化信号base->sig
    base->sig.ev_signal_pair[1] = -1;
    
    base->evbase = NULL;    //初始化I/O多路复用 base->evbase
    //遍历全局数组eventops[]，初始化libevent的I/O多路复用机制
    for (i = 0; eventops[i] && !base->evbase; i++) {    //以NULL标志数组结尾，只选取一个I/O多路复用机制
        base->evsel = eventops[i];    //初始化base->evsel
        base->evbase = base->evsel->init(base);    //初始化base->evbase
    }
    if (base->evbase == NULL)    //没有I/O多路复用
        event_errx(1, "%s: no event mechanism available", __func__);
    if (evutil_getenv("EVENT_SHOW_METHOD")) //调用getenv()获取环境变量EVENT_SHOW_METHOD    evutil.c
        event_msgx("libevent using: %s\n",
               base->evsel->name);
    /* allocate a single active event queue */
    //event_base_new()内调用event_base_priority_init()
    event_base_priority_init(base, 1);    //设置优先级base->nactivequeues；分配数组base->activequeues。数组大小和优先级相同
    return (base);
}

其中由3点需要注意：
1.该函数调用calloc()在堆上分配内存来存储event_base；
2.使用全局数组eventops[]存储系统支持的I/O多路复用机制，然后遍历该数组，选取第1个I/O多路复用机制。
3.libevent支持event有优先级，所以又调用了event_base_priority_init()来完成优先级相关的设置。

event_base_priority_init()：
//设置不同event的优先级，值越小，优先级越高
//返回值：0，成功；-1，出错
int
event_base_priority_init(struct event_base *base, int npriorities)
{
    int i;
    if (base->event_count_active)    //当前base上有活跃的events则不能设置优先级，返回。
        return (-1);
    if (npriorities == base->nactivequeues)    //设置的优先级和当前优先级相同，则直接返回
        return (0);
    if (base->nactivequeues) {    //不同，则先释放原先的activequeues数组
        for (i = 0; i < base->nactivequeues; ++i) {
            free(base->activequeues[i]);
        }
        free(base->activequeues);
    }
    /* Allocate our priority queues */
    base->nactivequeues = npriorities;    //设置新的优先级
    base->activequeues = (struct event_list **)
        calloc(base->nactivequeues, sizeof(struct event_list *));    //设置和优先级值相同大小的event_list数组
    if (base->activequeues == NULL)
        event_err(1, "%s: calloc", __func__);
    for (i = 0; i < base->nactivequeues; ++i) {
        base->activequeues[i] = malloc(sizeof(struct event_list));    //初始化activequeues数组中每个元素
        if (base->activequeues[i] == NULL)
            event_err(1, "%s: malloc", __func__);
        TAILQ_INIT(base->activequeues[i]);
    }
    return (0);
}
该函数设置优先级，初始化了event_base的nactivequeues成员和activequeues成员。优先级值越小，优先级越高。在活跃事件链表中，优先级高的event先被处理。

==================================================Libevent源码分析—event_set()
初始化完event_base后，下面要初始化event，通过调用event_set()实现 。
event_set():
void
event_set(struct event *ev, int fd, short events,
      void (*callback)(int, short, void *), void *arg)
{
    /* Take the current base - caller needs to set the real base later */
    ev->ev_base = current_base;    //设置event属于当前base；current_base通过event_init()设置
    ev->ev_callback = callback;    //设置回调函数
    ev->ev_arg = arg;    //设置回调函数的3个参数
    ev->ev_fd = fd;
    ev->ev_events = events;
    ev->ev_res = 0;
    ev->ev_flags = EVLIST_INIT;    //设置event状态
    ev->ev_ncalls = 0;
    ev->ev_pncalls = NULL;
    min_heap_elem_init(ev);    //初始化event在小根堆中索引为-1    min_heap.h
    /* by default, we put new events into the middle priority */
    if(current_base)
        ev->ev_pri = current_base->nactivequeues/2;    //设置event优先级
}
通过传入的参数：fd, events, 回调函数,arg设置event的相应成员，并初始化event在小根堆中的索引为-1，以及设置event的优先级。

接下来调用event_base_set()设置event所属的event_base。
其实在event_set()中已经将event所属的event_base设置为当前的current_base，而current_base在event_init()中被赋值为新建的event_base。所以，如果要将一个新的event捆绑的event_base设置为新建的event_base，则可以不需要event_base_set()这步调用。
如果有多个event_base，则才需要这步；就一个event_base时，是不需要这步的，因为此时current_base就等于event_base。

event_base_set():
int
event_base_set(struct event_base *base, struct event *ev)
{
    /* Only innocent events may be assigned to a different base */
    if (ev->ev_flags != EVLIST_INIT)    //只能对新建的event设置其所属event_base
        return (-1);
    ev->ev_base = base;    //设置所属event_base
    ev->ev_pri = base->nactivequeues/2;    //设置优先级
    return (0);
}
只能对新建的状态为EVLIST_INIT的event设置所属event_base
event有优先级，我们还可以单独调用下面的函数来专门设置event的优先级，但要求不能对活跃的event设置。

event_priority_set():
int
event_priority_set(struct event *ev, int pri)
{
    if (ev->ev_flags & EVLIST_ACTIVE)    //不能对活跃的event设置优先级
        return (-1);
    if (pri < 0 || pri >= ev->ev_base->nactivequeues)
        return (-1);
    ev->ev_pri = pri;    //设置优先级
    return (0);
}

==================================================Libevent源码分析—event_add()
接下来就是将已经初始化的event注册到libevent的事件链表上，通过event_add()来实现，源码位于event.c中。
event_add()
这个函数主要完成了下面几件事：
1.将event注册到event_base的I/O多路复用要监听的事件中
2.将event注册到event_base的已注册事件链表中
3.如果传入了超时时间，则删除旧的超时时间，重新设置，并将event添加到event_base的小根堆中；如果没有传入超时时间，则不会添加到小根堆中。
只有步骤1成功，才会执行步骤2和3；否则什么都没做，直接返回，保证不会改变event的状态。

将event添加到已注册事件链表、添加到小根堆、从活跃事件链表移除、从小根堆中移除，都是通过两个函数完成的：event_queue_insert()、event_queue_remove()
int
event_add(struct event *ev, const struct timeval *tv)
{
    struct event_base *base = ev->ev_base;    //event所属的event_base
    const struct eventop *evsel = base->evsel;    //event_base的I/O多路复用机制
    void *evbase = base->evbase;    //event_base的I/O多路复用机制
    int res = 0;
    //DEBUG log.h
    event_debug((
         "event_add: event: %p, %s%s%scall %p",
         ev,
         ev->ev_events & EV_READ ? "EV_READ " : " ",
         ev->ev_events & EV_WRITE ? "EV_WRITE " : " ",
         tv ? "EV_TIMEOUT " : " ",
         ev->ev_callback));
    assert(!(ev->ev_flags & ~EVLIST_ALL));
    /*
     * prepare for timeout insertion further below, if we get a
     * failure on any step, we should not change any state.
     */
    //如果传入了超时时间并且event不再time小根堆上，则在小根堆上预留一个位置
    //以保证如果后面有步骤失败，不会改变初始状态，保证是个原子操作
    if (tv != NULL && !(ev->ev_flags & EVLIST_TIMEOUT)) {
        if (min_heap_reserve(&base->timeheap,    //min_heap.h
            1 + min_heap_size(&base->timeheap)) == -1)
            return (-1);  /* ENOMEM == errno */
    }
    //如果event不在已注册链表或活跃链表中，
    //则调用evsel->add()注册event事件到I/O多路复用监听的事件上
    if ((ev->ev_events & (EV_READ|EV_WRITE|EV_SIGNAL)) &&
        !(ev->ev_flags & (EVLIST_INSERTED|EVLIST_ACTIVE))) {
        res = evsel->add(evbase, ev);    //将event注册到监听事件上
        //注册监听事件成功，则将event注册到已注册事件链表上
        if (res != -1)
            event_queue_insert(base, ev, EVLIST_INSERTED);  //插入  
    }
    /* 
     * we should change the timout state only if the previous event
     * addition succeeded.
     */
    //前面操作都成功情况下，才能执行下面步骤
    //改变超时状态
    if (res != -1 && tv != NULL) {
        struct timeval now;
        /* 
         * we already reserved memory above for the case where we
         * are not replacing an exisiting timeout.
         */
        //EVLIST_TIMEOUT表明event已在定时器堆中
        //则删除旧的定时器
        if (ev->ev_flags & EVLIST_TIMEOUT)
            event_queue_remove(base, ev, EVLIST_TIMEOUT);  //移除
        /* Check if it is active due to a timeout.  Rescheduling
         * this timeout before the callback can be executed
         * removes it from the active list. */
        //如果事件是由于超时而变成活跃事件
        //则从活跃事件链表中删除
        if ((ev->ev_flags & EVLIST_ACTIVE) &&
            (ev->ev_res & EV_TIMEOUT)) {
            /* See if we are just active executing this
             * event in a loop
             */
            if (ev->ev_ncalls && ev->ev_pncalls) {
                /* Abort loop */
                *ev->ev_pncalls = 0;  //调用次数清0
            }
            //从活跃事件链表移除
            event_queue_remove(base, ev, EVLIST_ACTIVE);  //移除
        }
        gettime(base, &now);
        evutil_timeradd(&now, tv, &ev->ev_timeout);    //为event添加超时时间
        event_debug((
             "event_add: timeout in %ld seconds, call %p",
             tv->tv_sec, ev->ev_callback));
        //将event插入到小根堆中
        event_queue_insert(base, ev, EVLIST_TIMEOUT);  //插入
    }
    return (res);
}

event_queue_insert():
该函数根据不同的输入队列，即不同的事件，在不同的队列中插入，并增加相应的事件计数，更新event状态；
EVLIST_INSERTED：在已注册事件链表event_base.eventqueue插入
EVLIST_ACTIVE：根据event优先级，在活跃事件链表event_base.activequeues[event.ev_pri]插入
EVLIST_TIMEOUT：在小根堆event_base.timeheap中插入

void
event_queue_insert(struct event_base *base, struct event *ev, int queue)
{
    //如果event已经在活跃链表中，则返回；否则，出错
    if (ev->ev_flags & queue) {
        /* Double insertion is possible for active events */
        if (queue & EVLIST_ACTIVE)
            return;
        event_errx(1, "%s: %p(fd %d) already on queue %x", __func__,
               ev, ev->ev_fd, queue);
    }
    if (~ev->ev_flags & EVLIST_INTERNAL)
        base->event_count++;  //增加注册事件数
    ev->ev_flags |= queue;  //改变event状态
    switch (queue) {  //根据不同的输入参数队列，选择在不同的事件集合中插入
    case EVLIST_INSERTED:  //I/O或Signal事件
        TAILQ_INSERT_TAIL(&base->eventqueue, ev, ev_next);  //在已注册事件链表插入
        break;
    case EVLIST_ACTIVE:  //活跃事件
        base->event_count_active++;  //增加活跃事件数
        TAILQ_INSERT_TAIL(base->activequeues[ev->ev_pri],  //在活跃事件链表插入
            ev,ev_active_next);
        break;
    case EVLIST_TIMEOUT: {  //定时器事件
        min_heap_push(&base->timeheap, ev);  //在小根堆插入
        break;
    }
    default:
        event_errx(1, "%s: unknown queue %x", __func__, queue);
    }
}

event_queue_remove()：
和event_queue_insert()相对应，这个函数主要根据不同的输入参数，从不同的事件集合中删除事件。
void
event_queue_remove(struct event_base *base, struct event *ev, int queue)
{
    if (!(ev->ev_flags & queue))
        event_errx(1, "%s: %p(fd %d) not on queue %x", __func__,
               ev, ev->ev_fd, queue);
    if (~ev->ev_flags & EVLIST_INTERNAL)
        base->event_count--;
    ev->ev_flags &= ~queue;
    switch (queue) {
    case EVLIST_INSERTED:  //I/O、Signal事件
        TAILQ_REMOVE(&base->eventqueue, ev, ev_next);
        break;
    case EVLIST_ACTIVE:  //活跃事件
        base->event_count_active--;
        TAILQ_REMOVE(base->activequeues[ev->ev_pri],
            ev, ev_active_next);
        break;
    case EVLIST_TIMEOUT:  //定时器事件
        min_heap_erase(&base->timeheap, ev);
        break;
    default:
        event_errx(1, "%s: unknown queue %x", __func__, queue);
    }
}

event_del()：
libevent还提供了event_del()这个函数，该函数从直接删除event事件，该函数就是主要通过调用event_queue_remove()函数完成删除的功能。
另外，该函数还将event从I/O多路复用监听的事件中删除。
int
event_del(struct event *ev)
{
    struct event_base *base;
    const struct eventop *evsel;
    void *evbase;
    event_debug(("event_del: %p, callback %p",
         ev, ev->ev_callback));
    /* An event without a base has not been added */
    if (ev->ev_base == NULL)
        return (-1);
    base = ev->ev_base;
    evsel = base->evsel;
    evbase = base->evbase;
    assert(!(ev->ev_flags & ~EVLIST_ALL));
    /* See if we are just active executing this event in a loop */
    //计数清0
    if (ev->ev_ncalls && ev->ev_pncalls) {
        /* Abort loop */
        *ev->ev_pncalls = 0;
    }
    //根据event不同的状态，从相应的event集合中删除
    if (ev->ev_flags & EVLIST_TIMEOUT)
        event_queue_remove(base, ev, EVLIST_TIMEOUT);
    if (ev->ev_flags & EVLIST_ACTIVE)
        event_queue_remove(base, ev, EVLIST_ACTIVE);
    if (ev->ev_flags & EVLIST_INSERTED) {
        event_queue_remove(base, ev, EVLIST_INSERTED);
        return (evsel->del(evbase, ev));  //从I/O多路复用监听的事件中删除
    }
    return (0);
}

==================================================Libevent源码分析—event_base_dispatch()
libevent是一个Reactor模式的事件驱动的网络库。
在这个主循环中，是如何检测事件、分发事件、调用事件的回调函数的。
Reactor模式中的Event、Event Handler、Reactor目前都完成了，下面就剩Event Demultiplexer了。
这一步通过event_base_dispatch()完成
int
event_base_dispatch(struct event_base *event_base)
{
  return (event_base_loop(event_base, 0));  //调用event_base_loop()
}

event_base_loop()
该函数完成以下工作：
1.信号标记被设置，则调用信号的回调函数
2.根据定时器最小时间，设置I/O多路复用的最大等待时间，这样即使没有I/O事件发生，也能在最小定时器超时时返回。
3.调用I/O多路复用，监听事件，将活跃事件添加到活跃事件链表中
4.检查定时事件，将就绪的定时事件从小根堆中删除，插入到活跃事件链表中
5.对event_base的活跃事件链表中的事件，调用event_process_active(）函数，在该函数内调用event的回调函数，优先级高的event先处理。

该函数内部调用了eventop.dispatch()监听事件，event_sigcb函数指针处理信号事件，
timeout_process()将超时的定时事件加入到活跃事件链表中，event_process_active()处理活跃事件链表中的事件，调用相应的回调函数。

int
event_base_loop(struct event_base *base, int flags)
{
    const struct eventop *evsel = base->evsel;
    void *evbase = base->evbase;  //event_base的I/O多路复用
    struct timeval tv;
    struct timeval *tv_p;
    int res, done;
    /* clear time cache */
    //清空时间缓存
    base->tv_cache.tv_sec = 0;
    //处理Signal事件时，指定信号所属的event_base
    if (base->sig.ev_signal_added)
        evsignal_base = base;
    done = 0;
    while (!done) {  //进入事件主循环
        /* Terminate the loop if we have been asked to */
        //设置event_base的标记，以表明是否需要跳出循环
        if (base->event_gotterm) {  //event_loopexit_cb()可设置
            base->event_gotterm = 0;
            break;
        }
        if (base->event_break) {  //event_base_loopbreak()可设置
            base->event_break = 0;
            break;
        }
        /* You cannot use this interface for multi-threaded apps */
        //当event_gotsig被设置时，则event_sigcb就是信号处理的回调函数
        while (event_gotsig) {
            event_gotsig = 0;
            if (event_sigcb) {
                res = (*event_sigcb)();  //调用信号处理的回调函数
                if (res == -1) {
                    errno = EINTR;
                    return (-1);
                }
            }
        }
        timeout_correct(base, &tv);  //校准时间
        tv_p = &tv;
        //根据定时器堆中最小超时时间计算I/O多路复用的最大等待时间tv_p
        if (!base->event_count_active && !(flags & EVLOOP_NONBLOCK)) {
            timeout_next(base, &tv_p);
        } else {
            /* 
             * if we have active events, we just poll new events
             * without waiting.
             */
            evutil_timerclear(&tv);
        }
        
        /* If we have no events, we just exit */
        //没有注册事件，则退出
        if (!event_haveevents(base)) {
            event_debug(("%s: no events registered.", __func__));
            return (1);
        }
        /* update last old time */
        gettime(base, &base->event_tv);
        /* clear time cache */
        base->tv_cache.tv_sec = 0;
        //调用I/O多路复用，监听事件
        res = evsel->dispatch(base, evbase, tv_p);
        if (res == -1)
            return (-1);
        //将time cache赋值为当前系统时间
        gettime(base, &base->tv_cache);
        
        //检查定时事件，将就绪的定时事件从小根堆中删除，插入到活跃事件链表中
        timeout_process(base);
        if (base->event_count_active) {
            //处理event_base的活跃链表中的事件
            //调用event的回调函数，优先级高的event先处理
            event_process_active(base);  
            if (!base->event_count_active && (flags & EVLOOP_ONCE))
                done = 1;
        } else if (flags & EVLOOP_NONBLOCK)
            done = 1;
    }
    /* clear time cache */
    //循环结束，清空时间缓存
    base->tv_cache.tv_sec = 0;
    event_debug(("%s: asked to terminate loop.", __func__));
    return (0);
}

epoll_dispatch()
event_base_loop()中通过I/O多路复用的dispatch()函数完成监听事件功能。在之前的event_init()中我们看到，通过遍历eventops数组，从中选择一个I/O多路复用机制，所以不同的I/O多路复用机制有不同的eventop结构体，相应的也就有不同的dispatch()函数。

eventop结构体(event-internal.h)
struct eventop {
        const char *name;
        void *(*init)(struct event_base *);  //初始化
        int (*add)(void *, struct event *);  //注册事件
        int (*del)(void *, struct event *);  //删除事件
        int (*dispatch)(struct event_base *, void *, struct timeval *);  //事件分发
        void (*dealloc)(struct event_base *, void *);  //注销，释放资源
        /* set if we need to reinitialize the event base */
        int need_reinit;
};

在event_add()中通过add()成员函数注册event到监听事件中，现在在event_base_loop()中通过dispatch()成员函数监听事件。
libevent支持多种I/O多路复用机制，下面先看下epoll的eventop结构体(epoll.c)

const struct eventop epollops = {
    "epoll",
    epoll_init,
    epoll_add,
    epoll_del,
    epoll_dispatch,
    epoll_dealloc,
    1 /* need reinit */
};

然后看下epoll的dispatch()函数(epoll.c)
从下面源码可见，epoll_dispatch()的工作主要有：
1.调用epoll_wait()监听事件
2.如果有信号发生，调用evsignal_process()处理信号
3.将活跃的event根据其活跃的类型注册到活跃事件链表上
4.如果events数组大小不够，则重新分配为原来2倍大小

static int
epoll_dispatch(struct event_base *base, void *arg, struct timeval *tv)
{
    struct epollop *epollop = arg;
    struct epoll_event *events = epollop->events;
    struct evepoll *evep;
    int i, res, timeout = -1;
    if (tv != NULL)
        timeout = tv->tv_sec * 1000 + (tv->tv_usec + 999) / 1000;  //转换为微米
    if (timeout > MAX_EPOLL_TIMEOUT_MSEC) {  //设置最大超时时间
        /* Linux kernels can wait forever if the timeout is too big;
         * see comment on MAX_EPOLL_TIMEOUT_MSEC. */
        timeout = MAX_EPOLL_TIMEOUT_MSEC;
    }
    res = epoll_wait(epollop->epfd, events, epollop->nevents, timeout);  //监听事件发生
    if (res == -1) {
        if (errno != EINTR) {
            event_warn("epoll_wait");
            return (-1);
        }
        evsignal_process(base);  //由于Signal事件发生中断，处理Signal事件
        return (0);
    } else if (base->sig.evsignal_caught) {
        evsignal_process(base);  //有Signal事件发生，处理Signal事件
    }
    event_debug(("%s: epoll_wait reports %d", __func__, res));
    for (i = 0; i < res; i++) {  //处理活跃事件
        int what = events[i].events;  //活跃类型
        struct event *evread = NULL, *evwrite = NULL;
        int fd = events[i].data.fd;  //event的文件描述符
        if (fd < 0 || fd >= epollop->nfds)
            continue;
        evep = &epollop->fds[fd];
        if (what & (EPOLLHUP|EPOLLERR)) {  //判断epoll的events类型，并找到注册的event
            evread = evep->evread;
            evwrite = evep->evwrite;
        } else {
            if (what & EPOLLIN) {
                evread = evep->evread;
            }
            if (what & EPOLLOUT) {
                evwrite = evep->evwrite;
            }
        }
        if (!(evread||evwrite))
            continue;
        
        //添加event到活跃事件链表中
        if (evread != NULL)
            event_active(evread, EV_READ, 1);
        if (evwrite != NULL)
            event_active(evwrite, EV_WRITE, 1);
    }
    //如果注册的事件全部变为活跃，则增大events数组为原来两倍
    if (res == epollop->nevents && epollop->nevents < MAX_NEVENTS) {
        /* We used all of the event space this time.  We should
           be ready for more events next time. */
        int new_nevents = epollop->nevents * 2;
        struct epoll_event *new_events;
        new_events = realloc(epollop->events,
            new_nevents * sizeof(struct epoll_event));
        if (new_events) {
            epollop->events = new_events;
            epollop->nevents = new_nevents;
        }
    }
    return (0);
}

event_process_active()：
现在活跃的I/O事件、定时器事件已经全部添加到活跃事件链表中了。
下面就开始调用这些event的回调函数进行处理了，这步是在event_base_loop()中调用event_process_active()来完成的。
该函数从event_base的activequeueus链表数组上取出一个链表；对该链表上的event调用回调函数；优先调用优先级值最小的event

/*
 * Active events are stored in priority queues.  Lower priorities are always
 * process before higher priorities.  Low priority events can starve high
 * priority ones.
 */
static void
event_process_active(struct event_base *base)
{
    struct event *ev;
    struct event_list *activeq = NULL;
    int i;
    short ncalls;
    for (i = 0; i < base->nactivequeues; ++i) {  //取出第一个活跃链表
        if (TAILQ_FIRST(base->activequeues[i]) != NULL) {
            activeq = base->activequeues[i];
            break;
        }
    }
    assert(activeq != NULL);

    //优先处理优先级值最小的event
    for (ev = TAILQ_FIRST(activeq); ev; ev = TAILQ_FIRST(activeq)) {
        if (ev->ev_events & EV_PERSIST)
            event_queue_remove(base, ev, EVLIST_ACTIVE);  //是持久事件，则从活跃链表移除
        else
            event_del(ev);  //不是持久事件，则直接删除该事件
        
        /* Allows deletes to work */
        ncalls = ev->ev_ncalls;
        ev->ev_pncalls = &ncalls;
        while (ncalls) {
            ncalls--;
            ev->ev_ncalls = ncalls;
            //调用该event的回调函数，event.ev_res保存返回值
            (*ev->ev_callback)((int)ev->ev_fd, ev->ev_res, ev->ev_arg);  
            if (event_gotsig || base->event_break) {
                  ev->ev_pncalls = NULL;
                return;
            }
        }
        ev->ev_pncalls = NULL;
    }
}

==================================================Libevent源码分析—从使用Libevent库开始
练习libevent库的使用，主要是几个API的调用顺序。根据event.h的开头注释部分可知，要使用libevent库，主要的几个API及调用顺序为：
event_base()初始化event_base
event_set()初始化event
event_base_set()将event绑定到指定的event_base上
event_add()将event添加到事件链表上，注册事件
event_base_dispatch()循环、检测、分发事件

每隔1s打印一条信息:
#include <stdio.h>
#include <event.h>
#include <time.h>

struct event ev;
struct timeval tv;

void timer_cb(int fd, short event, void *arg)    //回调函数
{
        printf("callback function\n");
        event_add(&ev, &tv);    //重新注册
}

int main()
{
        struct event_base *base = event_init();  //初始化libevent库
        tv.tv_sec = 1;
        tv.tv_usec = 0;

        event_set(&ev, -1, 0, timer_cb, NULL);  //初始化event结构中成员
        event_base_set(base, &ev);
        event_add(&ev, &tv);  //将event添加到events事件链表，注册事件
        event_base_dispatch(base);  //循环、分发事件

        return 0;
}

==========================================================================================================================================================================================================================================================
==================================================libevent快速入门
(1)初始化事件根基
struct event_base *event_base_new(void);
struct event_base *event_init(void);
event_base_new()函数分配并且返回一个新的具有默认设置的event_base.
event_init() 会调用event_base_new()创建一个event_base,并以此初始化一个全局的变量current_base .
例：
struct event_base *base = event_init();

(2)初始化事件event，设置回调函数和关注的事件，并关联对应的事件根基event_base
typedef void (*event_callback_fn)(evutil_socket_t, short, void*);

struct event *event_new(struct event_base *, evutil_socket_t, short, 
                        event_callback_fn, void *);

int event_assign(struct event *, struct event_base *, evutil_socket_t, short, event_callback_fn, void *);

void event_set(struct event *ev, int fd, short events, 
               event_callback_fn, void *arg);
void event_base_set(struct event_base *,struct event*);

event_assign（）的作用就是把给定的event类型对象的每一个成员赋予一个指定的值。
event_new（）的实现其实是间接的调用的event_assign（），首先调用mm_malloc分配一块内存，然后调用event_assign来给event类型的对象各个成员赋值。
event_set()　使用指定的句柄、关注的事件、事件发生时的回调函数、回调函数的额外参数，初始化设置struct event结构对象，绑定到全局current_base，设置此event结构对象的优先级，默认为current_base中总有限级数的一半
event_base_set() 将事件绑定到事件根基,即设置event从属的event_base,指明event注册到哪个event_base实例上

例：
//SIGINT 信号事件初始化
//假定已创建事件根基struct event_base *base　
//方式一：
struct event sigint_ev;
event_assign(&sigint_ev,base,SIGINT, EV_SIGNAL | EV_PERSIST,sigint_cb,NULL);
//方式二：
struct event sigint_ev ;
event_set(&sigint_ev, SIGINT, EV_SIGNAL | EV_PERSIST, sigint_cb, NULL);
event_base_set(base, &sigint_ev);
//方式三：
struct event *sigint_ev;
sigint_ev = event_new(base,SIGINT,EV_SIGNAL | EV_PERSIST, sigint_cb, NULL);
//方式四：
struct event* sigint_ev = (struct event*)malloc(sizeof(struct event));
//sigint_ev检测非空和置零后，用event_assign 或者event_set + event_base_set 初始化事件．

定时器事件：
#define evtimer_set(ev, cb, arg)    event_set(ev, -1, 0, cb, arg)

信号事件：
#define evsignal_new(base,signum,cb,arg) \
	event_new(base,signum,EV_SIGNAL|EV_PERSIST,cb,arg)

(3)添加事件，将事件变成未决态，即，将event加入到event_base中，等待监听
void event_add(struct event* ,struct timeval *);

(4)程序进入无限循环，事件根基event_base开始工作，对注册的event进行监听．若注册的事件的对应事件类型触发，或者超时，会自动触发event对应的回调函数执行
void event_base_dispatch(struct event_base *);
void event_base_loop(struct event_base *,int );

入门例子：
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <event.h>
#include <sys/time.h>
#include <signal.h>
#include <string.h>
#define BUF_SIZE 1024

typedef struct{
	struct event *ev;
	char *buf;
	struct timeval *tv;
}rw_st;

void wr_cb(int fd, short event, void *arg);
void rd_cb(int fd, short event, void *arg);

struct event_base *base = NULL;
//定时事件
struct timeval tv;
struct event time_ev;
void time_cb(int fd, short event, void *arg)
{
	printf("time_cb : 5s timer wakeup\n");
	event_add(&time_ev,&tv);
}

//标准输入 读事件
//输入一行，把读事件删掉,添加写事件
void rd_cb(int fd,short event, void *arg)
{
	if(event & EV_TIMEOUT){
		printf("io read time out(2s)!\n");
		return ;
	}
	rw_st* rd_st = (rw_st*)arg;
	int len = read(fd, rd_st->buf, BUF_SIZE);
	rd_st->buf[len-1] = '\0';
	printf("rd_cb (stdin): %s \n",rd_st->buf);
	
	event_del(rd_st->ev);
	event_set(rd_st->ev, STDOUT_FILENO,  EV_WRITE | EV_PERSIST,
					wr_cb,(void*)rd_st);
	event_add(rd_st->ev,NULL);
}

//标准输出 写事件
//输出,把写事件删掉,添加读事件,边写边读
void wr_cb(int fd, short event, void *arg)
{
	rw_st *wr_st = (rw_st*)arg;
	printf("wr_cb (stdout): %s\n",wr_st->buf);
	memset(wr_st->buf,0,BUF_SIZE);
	event_del(wr_st->ev);
	event_set(wr_st->ev, STDIN_FILENO, EV_READ | EV_PERSIST,
					rd_cb, (void*)wr_st);
	event_add(wr_st->ev,wr_st->tv);
}

//SIGINT 信号事件
void sigint_cb(int fd, short event, void *arg)
{
	struct timeval tv_1s = {1,0};
	printf("SIGINT : EXIT IN 1s\n");
	event_base_loopexit(base,&tv_1s);
}

//SIGHUB 信号事件
void sighup_cb(int fd, short event, void *arg)
{
	printf("SIGHUP: EXIT AT ONCE\n");
	event_base_loopbreak(base);
}

int main()
{
	printf("pid = %ld\n",getpid());
	base = event_init();
	//定时器
	tv.tv_sec = 5;
	tv.tv_usec = 0;
	evtimer_set(&time_ev, time_cb, NULL);//一次性,默认全局的current_base
//　event_set(&time_ev,-1,0,time_cb,NULL);

//	event_base_set(base, &time_ev);  //可省，在这里current_base等同base
	event_add(&time_ev,&tv);

	//io 读事件  指针 event_new
	char buf[1024] = {0};
	struct timeval io_tv = {2,0};
	rw_st *rd_st = (rw_st*)malloc(sizeof(rw_st));
	memset(rd_st,0,sizeof(rw_st));

	struct event *io_ev = (struct event*)malloc(sizeof(struct event));
	memset(io_ev,0,sizeof(struct event));
	
	rd_st->ev = io_ev;
	rd_st->buf = buf;
	rd_st->tv = &io_tv;
	event_assign(rd_st->ev,base,STDIN_FILENO,
					EV_TIMEOUT | EV_READ | EV_PERSIST,rd_cb,(void*)rd_st);
	event_add(rd_st->ev,rd_st->tv);

	//SIGINT 信号事件
	struct event sigint_ev;

	event_assign(&sigint_ev,base,SIGINT, EV_SIGNAL | EV_PERSIST,sigint_cb,NULL);
//	event_set(&sigint_ev, SIGINT, EV_SIGNAL | EV_PERSIST, 
//											sigint_cb, NULL);
	//event_base_set(base, &sigint_ev);
	event_add(&sigint_ev,NULL);
  
//	struct event *sigint_ev = event_new(base,SIGINT,
//			 EV_SIGNAL | EV_PERSIST, sigint_cb, NULL);
//	event_add(sigint_ev,NULL);

	//SIGHUP 信号事件  
	//测试: $ kill -SIGHUP pid
	struct event *sighup_ev;
	sighup_ev = evsignal_new(base, SIGHUP, sighup_cb, NULL);	
	event_add(sighup_ev,NULL);

	event_base_dispatch(base);
	//event_base_loop(base,0);
	
	event_free(sighup_ev);
	event_base_free(base);
	free(rd_st);

	printf("EXIT\n");
	return 0;
}

libevent从入门到掌握==========================================================================================================================================================================================================================================================
https://www.zhihu.com/column/c_1051625776130146304
==================================================libevent1
poll 轮询

Libevent 是一个用C语言编写的、轻量级的开源高性能事件通知库，主要有以下几个亮点：事件驱动（ event-driven），高性能; 
轻量级，专注于网络，不如 ACE 那么臃肿庞大；源代码相当精炼、易读；跨平台，支持 Windows、 Linux、 *BSD 和 Mac Os；
支持多种 I/O 多路复用技术， epoll、 poll、 dev/poll、 select 和 kqueue 等；支持 I/O，定时器和信号等事件；注册事件优先级。
Libevent 已经被广泛的应用，作为底层的网络库；

libevent的特点和优势:
事件驱动，高性能；
轻量级，专注于网络；
跨平台，支持 Windows、Linux、Mac Os等；
支持多种 I/O多路复用技术， epoll、poll、dev/poll、select 和kqueue 等；
支持 I/O，定时器和信号等事件；

libevent的组成：
事件管理包括各种IO（socket）、定时器、信号等事件，也是libevent应用最广的模块；
缓存管理是指evbuffer功能；
DNS是libevent提供的一个异步DNS查询功能；
HTTP是libevent的一个轻量级http实现，包括服务器和客户端

API及调用顺序为：
event_base()初始化event_base
event_set()初始化event
event_base_set()将event绑定到指定的event_base上
event_add()将event添加到事件链表上，注册事件
event_base_dispatch()循环、检测、分发事件


#include <stdio.h>
#include <event.h>
#include <time.h>

struct event ev;
/*
tv_sec 代表多少秒
tv_usec 代表多少微秒 1000000 微秒 = 1秒
*/
struct timeval tv;

void timer_cb(int fd, short event, void *arg)    //回调函数
{
        printf("timer_cb\n");
        event_add(&ev, &tv);    //重新注册
}

int main()
{
        struct event_base *base = event_init();  //初始化libevent库
        tv.tv_sec = 1;
        tv.tv_usec = 0;

        event_set(&ev, -1, 0, timer_cb, NULL);  //初始化event结构中成员
        event_base_set(base, &ev);
        event_add(&ev, &tv);  //将event添加到events事件链表，注册事件
        event_base_dispatch(base);  //循环、分发事件

        return 0;
}

timer_cb
timer_cb
timer_cb
timer_cb
timer_cb
timer_cb
timer_cb
timer_cb
timer_cb

==================================================libevent2 源码介绍
malloc()函数有一个参数，即要分配的内存空间的大小:
void *malloc(size_t size);
calloc()函数有两个参数，分别为元素的数目和每个元素的大小，这两个参数的乘积就是要分配的内存空间的大小。
void *calloc(size_t numElements, size_t sizeOfElement);
如果调用成功，函数malloc()和函数calloc()都将返回所分配的内存空间的首地址。

如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0；反之，如果这部分内存曾经被分配过，则其中可能遗留有各种各样的数据。
也就是说，使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常进行，但经过一段时间(内存空间还已经被重新分配)可能会出现问题。
函数calloc()会将所分配的内存空间中的每一位都初始化为零，也就是说，如果你是为字符类型或整数类型的元素分配内存，那么这些元素将保证会被初始化为0；
如果你是为指针类型的元素分配内存，那么这些元素通常会被初始化为空指针；如果你为实型数据分配内存,则这些元素会被初始化为浮点型的零。

event_base_new()函数分配并且返回一个新的具有默认设置的event_base.
event_init() 会调用event_base_new()创建一个event_base,并以此初始化一个全局的变量current_base .

1.event_init()

struct event_base *
event_init(void)
{
struct event_base *base = event_base_new();

if (base != NULL)
current_base = base;

return (base);
}
event_init()函数主要调用event_base_new()函数，返回event_base结构体；
其实，到后面会发现，我们直接调用event_base_new()函数也是可以的；

2.event_base_new()
struct event_base *
event_base_new(void)
{
int i;
struct event_base *base;

//用calloc而不用malloc的原因?
//calloc动态分配完内存后，自动初始化该内存为零
if ((base = calloc(1, sizeof(struct event_base))) == NULL)
event_err(1, "%s: calloc", __func__);

event_sigcb = NULL;
event_gotsig = 0;

detect_monotonic();//设置use_monotonic
gettime(base, &base->event_tv);
//初始化定时事件的小根堆
min_heap_ctor(&base->timeheap);
//初始化事件链表，头 ==   尾
TAILQ_INIT(&base->eventqueue);
//初始化信号
base->sig.ev_signal_pair[0] = -1;
base->sig.ev_signal_pair[1] = -1;
//初始化IO多路复用机制
base->evbase = NULL;
//选取以NULL 结尾，初始化
for (i = 0; eventops[i] && !base->evbase; i++) {
base->evsel = eventops[i];

base->evbase = base->evsel->init(base);
}
//如果没有IO多路复用

if (base->evbase == NULL)
event_errx(1, "%s: no event mechanism available", __func__);

if (evutil_getenv("EVENT_SHOW_METHOD")) 
event_msgx("libevent using: %s\n",
   base->evsel->name);

/* allocate a single active event queue */
//设置优先级
//活跃事件链表中，优先级值越小，越优先
event_base_priority_init(base, 1);

return (base);
}

event_base_new()做的工作主要就是对结构体event_base的初始化的作用，设置一些参数这类的；

3.event_set
void
event_set(struct event *ev, int fd, short events,
  void (*callback)(int, short, void *), void *arg)
{
/* Take the current base - caller needs to set the real base later */
//初始化中event_init()
ev->ev_base = current_base;// 设置event属于当前base；current_base通过event_init()设置

ev->ev_callback = callback;//设置回调函数
ev->ev_arg = arg;//设置回调函数的3个参数
ev->ev_fd = fd;
ev->ev_events = events;
ev->ev_res = 0;
//设置event状态
ev->ev_flags = EVLIST_INIT;//设置event状态
ev->ev_ncalls = 0;
ev->ev_pncalls = NULL;
//初始化小根堆索引-1 //初始化event在小根堆中索引为-1
min_heap_elem_init(ev);

/* by default, we put new events into the middle priority */
if(current_base)
ev->ev_pri = current_base->nactivequeues/2;//设置event优先级
}
​
根据初始化参数，设置event参数；

4.event_base_set():
int
event_base_set(struct event_base *base, struct event *ev)
{
    /* Only innocent events may be assigned to a different base */
    if (ev->ev_flags != EVLIST_INIT)    //只能对新建的event设置其所属event_base
        return (-1);
    ev->ev_base = base;    //设置所属event_base
    ev->ev_pri = base->nactivequeues/2;    //设置优先级
    return (0);
}
将event_base_set()将event绑定到指定的event_base上

其实在event_set()中已经将event所属的event_base设置为当前的current_base，而current_base在event_init()中被赋值为新建的event_base。
所以，如果要将一个新的event捆绑的event_base设置为新建的event_base，则可以不需要event_base_set()这步调用。
如果有多个event_base，则才需要这步；就一个event_base时，是不需要这步的，因为此时current_base就等于event_base。

###只能对新建的状态为EVLIST_INIT的event设置所属event_base###

event有优先级，我们还可以单独调用下面的函数来专门设置event的优先级，但要求不能对活跃的event设置。
event_priority_set():
int
event_priority_set(struct event *ev, int pri)
{
    if (ev->ev_flags & EVLIST_ACTIVE)    //不能对活跃的event设置优先级
        return (-1);
    if (pri < 0 || pri >= ev->ev_base->nactivequeues)
        return (-1);
    ev->ev_pri = pri;    //设置优先级
    return (0);
}

5.event_add()
int
event_add(struct event *ev, const struct timeval *tv)
{
struct event_base *base = ev->ev_base;
const struct eventop *evsel = base->evsel;
void *evbase = base->evbase;
int res = 0;

event_debug((
"event_add: event: %p, %s%s%scall %p",
ev,
ev->ev_events & EV_READ ? "EV_READ " : " ",
ev->ev_events & EV_WRITE ? "EV_WRITE " : " ",
tv ? "EV_TIMEOUT " : " ",
ev->ev_callback));

assert(!(ev->ev_flags & ~EVLIST_ALL));

/*
* prepare for timeout insertion further below, if we get a
* failure on any step, we should not change any state.
*/
if (tv != NULL && !(ev->ev_flags & EVLIST_TIMEOUT)) {
if (min_heap_reserve(&base->timeheap,
1 + min_heap_size(&base->timeheap)) == -1)
return (-1);  /* ENOMEM == errno */
}

if ((ev->ev_events & (EV_READ|EV_WRITE|EV_SIGNAL)) &&
    !(ev->ev_flags & (EVLIST_INSERTED|EVLIST_ACTIVE))) {
res = evsel->add(evbase, ev);
if (res != -1)
event_queue_insert(base, ev, EVLIST_INSERTED);
}

/* 
* we should change the timout state only if the previous event
* addition succeeded.
*/
if (res != -1 && tv != NULL) {
struct timeval now;

/* 
* we already reserved memory above for the case where we
* are not replacing an exisiting timeout.
*/
if (ev->ev_flags & EVLIST_TIMEOUT)
event_queue_remove(base, ev, EVLIST_TIMEOUT);

/* Check if it is active due to a timeout.  Rescheduling
* this timeout before the callback can be executed
* removes it from the active list. */
if ((ev->ev_flags & EVLIST_ACTIVE) &&
    (ev->ev_res & EV_TIMEOUT)) {
/* See if we are just active executing this
* event in a loop
*/
if (ev->ev_ncalls && ev->ev_pncalls) {
/* Abort loop */
*ev->ev_pncalls = 0;
}
event_queue_remove(base, ev, EVLIST_ACTIVE);
}

gettime(base, &now);
evutil_timeradd(&now, tv, &ev->ev_timeout);

event_debug((
"event_add: timeout in %ld seconds, call %p",
tv->tv_sec, ev->ev_callback));

event_queue_insert(base, ev, EVLIST_TIMEOUT);
}

return (res);
}

根据时间类型添加到不同的列表中：
1.将event注册到event_base的I/O多路复用要监听的事件链表中
2.将event注册到event_base的已注册事件链表中
3.如果传入了超时时间，则删除旧的超时时间，重新设置，并将event添加到event_base的小根堆中；
如果没有传入超时时间，则不会添加到小根堆中。
函数内添加到I/O多路复用监听事件链表、已注册事件链表、小根堆中都是通过event_queue_insert()完成的，
相应的删除工作都是通过event_queue_remove()完成的。

6.event_base_dispatch()
int
event_base_dispatch(struct event_base *event_base)
{
  return (event_base_loop(event_base, 0));
}
​
event_base_dispatch什么也没有做，调用了event_base_loop函数;


7.event_base_loop()
int
event_base_loop(struct event_base *base, int flags)
{
//IO复用方式
const struct eventop *evsel = base->evsel;
void *evbase = base->evbase;
struct timeval tv;
struct timeval *tv_p;
int res, done;

/* clear time cache */
base->tv_cache.tv_sec = 0;

if (base->sig.ev_signal_added)
evsignal_base = base;
done = 0;
while (!done) {
/* Terminate the loop if we have been asked to */
if (base->event_gotterm) {
//设置中止循环
base->event_gotterm = 0;
break;
}

if (base->event_break) {
base->event_break = 0;
break;
}

/* You cannot use this interface for multi-threaded apps */
while (event_gotsig) {
event_gotsig = 0;
if (event_sigcb) {
res = (*event_sigcb)();
if (res == -1) {
errno = EINTR;
return (-1);
}
}
}

timeout_correct(base, &tv);

tv_p = &tv;
if (!base->event_count_active && !(flags & EVLOOP_NONBLOCK)) {
timeout_next(base, &tv_p);
} else {
/* 
* if we have active events, we just poll new events
* without waiting.
*/
evutil_timerclear(&tv);
}
/* If we have no events, we just exit */
if (!event_haveevents(base)) {
event_debug(("%s: no events registered.", __func__));
return (1);
}

/* update last old time */
gettime(base, &base->event_tv);

/* clear time cache */
base->tv_cache.tv_sec = 0;

res = evsel->dispatch(base, evbase, tv_p);

if (res == -1)
return (-1);
gettime(base, &base->tv_cache);

timeout_process(base);
//有就绪事件则调用事件注册的回调函数
if (base->event_count_active) {
event_process_active(base);
if (!base->event_count_active && (flags & EVLOOP_ONCE))
done = 1;
} else if (flags & EVLOOP_NONBLOCK)
done = 1;
}

/* clear time cache */
base->tv_cache.tv_sec = 0;

event_debug(("%s: asked to terminate loop.", __func__));
return (0);
}

event_base_loop()主要就是循环、检测、分发事件
按照代码流程：
1.信号标记被设置，则调用信号的回调函数
2.根据定时器最小时间，设置I/O多路复用的最大等待时间，这样即使没有I/O事件发生，也能在最小定时器超时时返回。
3.调用I/O多路复用，监听事件，将活跃事件添加到活跃事件链表中
4.检查定时事件，将就绪的定时事件从小根堆中删除，插入到活跃事件链表中

libevent的核心就event_base_loop()；在这其中检测和分发通过I/O多路复用来完成

==================================================libevent3 socket通信
cli.cpp:

#include<iostream>
#include<sys/types.h>
#include<sys/socket.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<errno.h>
#include<unistd.h>
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<event.h>
#include<event2/util.h>
 
using namespace std;
 
typedef struct sockaddr cli;
 
void send_msg_cb(int fd, short events, void* arg)
{
    char msg[1024] = {};

    int ret = read(fd, msg, sizeof(msg));
    if( ret <= 0 )
    {
        perror("read fail ");
        exit(1);
    }
//cout<<"msg:"<<msg<<endl;
    int sockfd = *((int*)arg);
 
    write(sockfd, msg, ret);
cout<<"write:"<<msg<<endl;
}
 
 
void read_msg_cb(int fd, short events, void *arg)
{
    char msg1[1024];
 
    int len = read(fd, msg1, sizeof(msg1)-1);
    if( len <= 0 )
    {
        perror("read error!!!");
        exit(1);
    }
    msg1[len] = '\0';
 
    cout<<"read is ok,msg:"<<msg1<<endl;
}
 
 
 

int connect_ser(const char* server_ip, const int port)
{
    int sockfd, status;
    struct sockaddr_in sock;
 
    memset(&sock, 0, sizeof(sock) );
 
    sock.sin_family = AF_INET;
    sock.sin_port = htons(port);
    status = inet_aton(server_ip, &sock.sin_addr);
 
    if( status == 0 )
    {
        errno = EINVAL;
        return -1;
    }
//创建套接字
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if( -1 == sockfd )
{
perror("socket is error");
exit(-1);
} 
 
    status = connect(sockfd, (cli*)&sock, sizeof(sock) );
 
    if( status == -1 )
    {
perror("connect");
        close(sockfd);
        return -1;
    }
 
    evutil_make_socket_nonblocking(sockfd);
 
    return sockfd;
}
 
int main(int argc, char** argv)
{
    if( argc < 3 )
    {
        cout<<"please input two param:"<<endl;
        return -1;
    }

    int sockfd = connect_ser(argv[1], atoi(argv[2]));
    if( sockfd == -1)
    {
cout<<"connect is error"<<endl;
        return -1;
    }
//初始化base
    struct event_base* base = event_base_new();
 
    struct event *ev1 = event_new(base, sockfd,
                                        EV_READ | EV_PERSIST,
                                        read_msg_cb, NULL);
    event_add(ev1, NULL);
//键盘输入
    struct event* ev2 = event_new(base, STDIN_FILENO,
                                      EV_READ | EV_PERSIST, send_msg_cb,
                                      (void*)&sockfd);
 
 
    event_add(ev2, NULL);
 
    event_base_dispatch(base);
 
    cout<<"ending>>>>>"<<endl;
    return 0;
}



ser.cpp



#include<stdio.h>
#include<string.h>
#include<errno.h>
#include<iostream>
#include<unistd.h>
#include<event.h>
 
using namespace std;

void accept_cb(int fd, short events, void* arg)
{
    evutil_socket_t sockfd;
 
    struct sockaddr_in client;
    socklen_t len = sizeof(cli);
 
    sockfd = accept(fd, (struct sockaddr*)&cli, &len );
    evutil_make_socket_nonblocking(sockfd);
 
    printf("accept a cli %d\n", sockfd);
 
    struct event_base* base = (event_base*)arg;
 
    //仅仅是为了动态创建一个event结构体
    struct event *ev = event_new(NULL, -1, 0, NULL, NULL);
    //将动态创建的结构体作为event的回调参数
    event_assign(ev, base, sockfd, EV_READ | EV_PERSIST,
                 socket_read_cb, (void*)ev);
 
    event_add(ev, NULL);
}
 
 
void socket_read_cb(int fd, short events, void *arg)
{
    char msg[4096];
    struct event *ev = (struct event*)arg;
    int len = read(fd, msg, sizeof(msg) - 1);
 
 
 
    if( len <= 0 )
    {
        printf("some error happen when read\n");
        event_free(ev);
        close(fd);
        return ;
    }
 
    msg[len] = '\0';
    printf("recv the cli msg: %s", msg);
 
    char reply_msg[4096] = "I have recvieced the msg: ";
    strcat(reply_msg + strlen(reply_msg), msg);
 
    write(fd, reply_msg, strlen(reply_msg) );
}
 
 
 
typedef struct sockaddr SA;
int tcp_server_init(int port, int listen_num)
{
    int errno_save;
    evutil_socket_t listener;
 
    listener = socket(AF_INET, SOCK_STREAM, 0);
    if( listener == -1 )
        return -1;
 
    //允许多次绑定同一个地址。要用在socket和bind之间
    evutil_make_listen_socket_reuseable(listener);
 
    struct sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(port);
 
    if( ::bind(listener, (SA*)&sin, sizeof(sin)) < 0 )
        goto error;
 
    if( ::listen(listener, listen_num) < 0)
        goto error;
 
 
    //跨平台统一接口，将套接字设置为非阻塞状态
    evutil_make_socket_nonblocking(listener);
 
    return listener;
 
    error:
        errno_save = errno;
        evutil_closesocket(listener);
        errno = errno_save;
 
        return -1;
}

int main(int argc, char** argv)
{
 
    int listener = tcp_server_init(9999, 10);
    if( listener == -1 )
    {
        perror(" tcp_server_init error ");
        return -1;
    }
 
    struct event_base* base = event_base_new();
 
    //添加监听客户端请求连接事件
    struct event* ev_listen = event_new(base, listener, EV_READ | EV_PERSIST,
                                        accept_cb, base);
    event_add(ev_listen, NULL);
 
 
    event_base_dispatch(base);
 
    return 0;
}



makefile:
all:ser1 cli1

ser1:ser1.cpp
g++ ser1.cpp -o ser1 -levent

cli1:cli1.cpp
g++ cli1.cpp -o cli1 -levent

clean:
rm -f ser1 cli1

这两断代码主要就是使用了前面的event事件进行通信；和之前socket通信是一样的，只是增加的注册函数event，不需要循环检测消息的到来，这些工作被event替代了

==================================================libevent4 数据缓冲Bufferevent
很多时候,除了响应事件之外,应用还希望做一定的数据缓冲。比如说,写入数据的时候 ,通常的运行模式是:
决定要向连接写入一些数据,把数据放入到缓冲区中
等待连接可以写入
写入尽量多的数据
记住写入了多少数据,如果还有更多数据要写入,等待连接再次可以写入
这种缓冲 IO 模式很通用,libevent 为此提供了一种通用机制,即bufferevent。

bufferevent 由一个底层的传输端口(如套接字 ),一个读取缓冲区和一个写入缓冲区组成。与通常的事件在底层传输端口已经就绪,
可以读取或者写入的时候执行回调不同的是,bufferevent 在读取或者写入了足够量的数据之后调用用户提供的回调。

bufferevent和evbuffer:
每个 bufferevent 都有一个输入缓冲区和一个输出缓冲区 ,它们的类型都是“struct evbuffer”。 
有数据要写入到 bufferevent 时,添加数据到输出缓冲区 ;bufferevent 中有数据供读取的时候,从输入缓冲区抽取(drain)数据。

回调和水位：
每个 bufferevent 有两个数据相关的回调:一个读取回调和一个写入回调。
默认情况下,从底层传输端口读取了任意量的数据之后会调用读取回调 ;
输出缓冲区中足够量的数据被清空到底层传输端口后写入回调会被调用。
通过调整 bufferevent 的读取和写入 “水位 (watermarks )”可以覆盖这些函数的默认行为。

每个 bufferevent 有四个水位:
读取低水位 :读取操作使得输入缓冲区的数据量在此级别或者更高时 ,读取回调将被调用。默认值为 0,所以每个读取操作都会导致读取回调被调用。
读取高水位 :输入缓冲区中的数据量达到此级别后, bufferevent 将停止读取,直到输入缓冲区中足够量的数据被抽取 ,使得数据量低于此级别 。默认值是无限 ,所以永远不会因为输入缓冲区的大小而停止读取。
写入低水位 :写入操作使得输出缓冲区的数据量达到或者低于此级别时 ,写入回调将被调用。默认值是 0,所以只有输出缓冲区空的时候才会调用写入回调。
写入高水位 :bufferevent 没有直接使用这个水位。

bufferevent 接口：
1.bufferevent_socket_new()
struct bufferevent *bufferevent_socket_new(
struct event_base *base,
evutil_socket_t fd,
enum bufferevent_options options);

enum bufferevent_options options：
BEV_OPT_CLOSE_ON_FREE :释放 bufferevent 时关闭底层传输端口。这将关闭底层套接字,释放底层 bufferevent 等。
BEV_OPT_THREADSAFE :自动为 bufferevent 分配锁,这样就可以安全地在多个线程中使用 bufferevent。
BEV_OPT_DEFER_CALLBACKS :设置这个标志时, bufferevent 延迟所有回调,如上所述。
BEV_OPT_UNLOCK_CALLBACKS :默认情况下,如果设置 bufferevent 为线程安全 的,则 bufferevent 会在调用用户提供的回调时进行锁定。设置这个选项会让 libevent 在执行回调的时候不进行锁定。
用于创建基于套接字的 bufferevent。

2.bufferevent_socket_connect()
int bufferevent_socket_connect(struct bufferevent *bev,
    struct sockaddr *address, int addrlen);
address 和 addrlen 参数跟标准调用 connect()的参数相同。如果还没有为 bufferevent 设置套接字,调用函数将为其分配一个新的流套接字,并且设置为非阻塞的。

3.bufferevent_free()
void bufferevent_free(struct bufferevent *bev);
这个函数释放 bufferevent。bufferevent 内部具有引用计数,所以,如果释放 时还有未决的延迟回调,则在回调完成之前 bufferevent 不会被删除。
如果设置了 BEV_OPT_CLOSE_ON_FREE 标志,并且 bufferevent 有一个套接字或者底层 bufferevent 作为其传输端口,则释放 bufferevent 将关闭这个传输端口。

4.bufferevent_setcb()
typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx);
typedef void (*bufferevent_event_cb)(struct bufferevent *bev,
short events, void *ctx);

void bufferevent_setcb(struct bufferevent *bufev,
bufferevent_data_cb readcb, bufferevent_data_cb writecb,
bufferevent_event_cb eventcb, void *cbarg);

void bufferevent_getcb(struct bufferevent *bufev,
bufferevent_data_cb *readcb_ptr,
bufferevent_data_cb *writecb_ptr,
bufferevent_event_cb *eventcb_ptr,
void **cbarg_ptr);

bufferevent_setcb()函数修改 bufferevent 的一个或者多个回调 。readcb、writecb和eventcb函数将分别在已经读取足够的数据 、已经写入足够的数据 ,或者发生错误时被调用 。
每个回调函数的第一个参数都是发生了事件的bufferevent ,最后一个参数都是调用bufferevent_setcb()时用户提供的 cbarg 参数:可以通过它向回调传递数据。事件回调 的 events 参数是一个表示事件标志的位掩码

5.bufferevent_enable()
void bufferevent_enable(struct bufferevent *bufev, short events);
void bufferevent_disable(struct bufferevent *bufev, short events);
short bufferevent_get_enabled(struct bufferevent *bufev);

可以启用或者禁用 bufferevent 上的 EV_READ、EV_WRITE 或者 EV_READ | EV_WRITE 事件。没有启用读取或者写入事件时, bufferevent 将不会试图进行数据读取或者写入。
没有必要在输出缓冲区空时禁用写入事件: bufferevent 将自动停止写入,然后在有数据等 待写入时重新开始。

类似地,没有必要在输入缓冲区高于高水位时禁用读取事件 :bufferevent 将自动停止读取, 然后在有空间用于读取时重新开始读取。

默认情况下,新创建的 bufferevent 的写入是启用的,但是读取没有启用。 可以调用 bufferevent_get_enabled()确定 bufferevent 上当前启用的事件。

6.通过bufferevent得到evbuffer
如果只是通过网络读取或者写入数据 ,而不能观察操作过程,是没什么好处的。bufferevent 提供了下列函数用于观察要写入或者读取的数据。
struct evbuffer *bufferevent_get_input(struct bufferevent *bufev);
struct evbuffer *bufferevent_get_output(struct bufferevent *bufev);
这两个函数提供了非常强大的基础 :它们分别返回输入和输出缓冲区 。

如果写入操作因为数据量太少而停止(或者读取操作因为太多数据而停止 ),则向输出缓冲 区添加数据(或者从输入缓冲区移除数据)将自动重启操作。

7.向bufferevent的输出缓冲区添加数据
int bufferevent_write(struct bufferevent *bufev,
const void *data, size_t size);
int bufferevent_write_buffer(struct bufferevent *bufev,
struct evbuffer *buf);

这些函数向 bufferevent 的输出缓冲区添加数据。 
bufferevent_write()将内存中从 data 处开 始的 size 字节数据添加到输出缓冲区的末尾 。
bufferevent_write_buffer()移除 buf 的所有内 容,将其放置到输出缓冲区的末尾。成功时这些函数都返回 0,发生错误时则返回-1。

8.从bufferevent的输入缓冲区移除数据
size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size);
int bufferevent_read_buffer(struct bufferevent *bufev,
struct evbuffer *buf);

这些函数从 bufferevent 的输入缓冲区移除数据。bufferevent_read()至多从输入缓冲区移除 size 字节的数据,将其存储到内存中 data 处。函数返回实际移除的字节数。 bufferevent_read_buffer()函数抽空输入缓冲区的所有内容,将其放置到 buf 中,成功时返 回0,失败时返回 -1。
注意,对于 bufferevent_read(),data 处的内存块必须有足够的空间容纳 size 字节数据。

9.bufferevent的清空操作
int bufferevent_flush(struct bufferevent *bufev,
short iotype, enum bufferevent_flush_mode state);

清空 bufferevent 要求 bufferevent 强制从底层传输端口读取或者写入尽可能多的数据 ,而忽略其他可能保持数据不被写入的限制条件 。函数的细节功能依赖于 bufferevent 的具体类型。
otype 参数应该是 EV_READ、EV_WRITE 或者 EV_READ | EV_WRITE,用于指示应该处 理读取、写入,还是二者都处理。 state 参数可以是 BEV_NORMAL、BEV_FLUSH 或者 BEV_FINISHED。BEV_FINISHED 指示应该告知另一端,没有更多数据需要发送了; 而 BEV_NORMAL 和 BEV_FLUSH 的区别依赖于具体的 bufferevent 类型。

失败时 bufferevent_flush()返回-1,如果没有数据被清空则返回 0,有数据被清空则返回 1。


一般操作流程：(服务端)
socket->bind->listen->event_base_new()->event_new()->accept->bufferevent_socket_new()->bufferevent_setcb()->bufferevent_enable()->event_add->event_base_dispatch

案例：
cli.cpp:


#include<sys/types.h>
#include<sys/socket.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<errno.h>
#include<unistd.h>

#include<stdio.h>
#include<string.h>
#include<stdlib.h>

#include<event.h>
#include<event2/bufferevent.h>
#include<event2/buffer.h>
#include<event2/util.h>




int tcp_connect_server(const char* server_ip, int port);


void cmd_msg_cb(int fd, short events, void* arg);
void server_msg_cb(struct bufferevent* bev, void* arg);
void event_cb(struct bufferevent *bev, short event, void *arg);

int main(int argc, char** argv)
{
    if( argc < 3 )
    {
        printf("please input 2 parameter\n");
        return -1;
    }


    //两个参数依次是服务器端的IP地址、端口号
    int sockfd = tcp_connect_server(argv[1], atoi(argv[2]));
    if( sockfd == -1)
    {
        perror("tcp_connect error ");
        return -1;
    }

    printf("connect to server successful\n");

    struct event_base* base = event_base_new();

    struct bufferevent* bev = bufferevent_socket_new(base, sockfd,
                                                     BEV_OPT_CLOSE_ON_FREE);

    //监听终端输入事件
    struct event* ev_cmd = event_new(base, STDIN_FILENO,
                                      EV_READ | EV_PERSIST, cmd_msg_cb,
                                      (void*)bev);
    event_add(ev_cmd, NULL);

    //当socket关闭时会用到回调参数
    bufferevent_setcb(bev, server_msg_cb, NULL, event_cb, (void*)ev_cmd);
    bufferevent_enable(bev, EV_READ | EV_PERSIST);


    event_base_dispatch(base);

    printf("finished \n");
    return 0;
}






void cmd_msg_cb(int fd, short events, void* arg)
{
    char msg[1024];

    int ret = read(fd, msg, sizeof(msg));
    if( ret < 0 )
    {
        perror("read fail ");
        exit(1);
    }

    struct bufferevent* bev = (struct bufferevent*)arg;

    //把终端的消息发送给服务器端
    bufferevent_write(bev, msg, ret);
}


void server_msg_cb(struct bufferevent* bev, void* arg)
{
    char msg[1024];

    size_t len = bufferevent_read(bev, msg, sizeof(msg));
    msg[len] = '\0';

    printf("recv %s from server\n", msg);
}


void event_cb(struct bufferevent *bev, short event, void *arg)
{

    if (event & BEV_EVENT_EOF)
        printf("connection closed\n");
    else if (event & BEV_EVENT_ERROR)
        printf("some other error\n");

    //这将自动close套接字和free读写缓冲区
    bufferevent_free(bev);

    struct event *ev = (struct event*)arg;
    //因为socket已经没有，所以这个event也没有存在的必要了
    event_free(ev);
}


typedef struct sockaddr SA;
int tcp_connect_server(const char* server_ip, int port)
{
    int sockfd, status, save_errno;
    struct sockaddr_in server_addr;

    memset(&server_addr, 0, sizeof(server_addr) );

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port);
    status = inet_aton(server_ip, &server_addr.sin_addr);

    if( status == 0 ) //the server_ip is not valid value
    {
        errno = EINVAL;
        return -1;
    }

    sockfd = ::socket(PF_INET, SOCK_STREAM, 0);
    if( sockfd == -1 )
        return sockfd;


    status = ::connect(sockfd, (SA*)&server_addr, sizeof(server_addr) );

    if( status == -1 )
    {
        save_errno = errno;
        ::close(sockfd);
        errno = save_errno; //the close may be error
        return -1;
    }

    evutil_make_socket_nonblocking(sockfd);

    return sockfd;
}

ser.cpp:

#include<stdio.h>
#include<string.h>
#include<errno.h>

#include<event.h>
#include<event2/bufferevent.h>



void accept_cb(int fd, short events, void* arg);
void socket_read_cb(bufferevent* bev, void* arg);
void event_cb(struct bufferevent *bev, short event, void *arg);
int tcp_server_init(int port, int listen_num);

int main(int argc, char** argv)
{

    int listener = tcp_server_init(9999, 10);
    if( listener == -1 )
    {
        perror(" tcp_server_init error ");
        return -1;
    }

    struct event_base* base = event_base_new();

    //添加监听客户端请求连接事件
    struct event* ev_listen = event_new(base, listener, EV_READ | EV_PERSIST,
                                        accept_cb, base);
    event_add(ev_listen, NULL);


    event_base_dispatch(base);
    event_base_free(base);


    return 0;
}



void accept_cb(int fd, short events, void* arg)
{
    evutil_socket_t sockfd;

    struct sockaddr_in client;
    socklen_t len = sizeof(client);

    sockfd = ::accept(fd, (struct sockaddr*)&client, &len );
    evutil_make_socket_nonblocking(sockfd);

    printf("accept a client %d\n", sockfd);

    struct event_base* base = (event_base*)arg;

    bufferevent* bev = bufferevent_socket_new(base, sockfd, BEV_OPT_CLOSE_ON_FREE);
    bufferevent_setcb(bev, socket_read_cb, NULL, event_cb, arg);

    bufferevent_enable(bev, EV_READ | EV_PERSIST);
}



void socket_read_cb(bufferevent* bev, void* arg)
{
    char msg[4096];

    size_t len = bufferevent_read(bev, msg, sizeof(msg));

    msg[len] = '\0';
    printf("recv the client msg: %s", msg);


    char reply_msg[4096] = "I have recvieced the msg: ";

    strcat(reply_msg + strlen(reply_msg), msg);
    bufferevent_write(bev, reply_msg, strlen(reply_msg));
}



void event_cb(struct bufferevent *bev, short event, void *arg)
{

    if (event & BEV_EVENT_EOF)
        printf("connection closed\n");
    else if (event & BEV_EVENT_ERROR)
        printf("some other error\n");

    //这将自动close套接字和free读写缓冲区
    bufferevent_free(bev);
}


typedef struct sockaddr SA;
int tcp_server_init(int port, int listen_num)
{
    int errno_save;
    evutil_socket_t listener;

    listener = ::socket(AF_INET, SOCK_STREAM, 0);
    if( listener == -1 )
        return -1;

    //允许多次绑定同一个地址。要用在socket和bind之间
    evutil_make_listen_socket_reuseable(listener);

    struct sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(port);

    if( ::bind(listener, (SA*)&sin, sizeof(sin)) < 0 )
        goto error;

    if( ::listen(listener, listen_num) < 0)
        goto error;


    //跨平台统一接口，将套接字设置为非阻塞状态
    evutil_make_socket_nonblocking(listener);

    return listener;

    error:
        errno_save = errno;
        evutil_closesocket(listener);
        errno = errno_save;

        return -1;
}

==================================================libevent5 链接监听器evconnlistener
evconnlistener 机制提供了监听和接受 TCP 连接的方法

创建和释放evconnlistener:
struct evconnlistener *
evconnlistener_new(struct event_base *base,
    evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,
    evutil_socket_t fd);

struct evconnlistener *
evconnlistener_new_bind(struct event_base *base,
    evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,
    const struct sockaddr *sa, int socklen);

void evconnlistener_free(struct evconnlistener *lev);

两个 evconnlistener_new*()函数都分配和返回一个新的连接监听器对象。连接监听器使 用 event_base 来得知什么时候在给定的监听套接字上有新的 TCP 连接。
新连接到达时,监听 器调用你给出的回调函数。
两个函数中,base参数都是监听器用于监听连接的 event_base。cb是收到新连接时要调 用的回调函数;
如果 cb 为 NULL,则监听器是禁用的,直到设置了回调函数为止。
ptr 指针将传递给回调函数。
flags 参数控制回调函数的行为
backlog 是任何 时刻网络栈允许处于还未接受状态的最大未决连接数。

如果 backlog 是负的,libevent 会试图挑选一个较好的值 ; 如果为0,libevent 认为已 经对提供的套接字调用了listen()。
两个函数的不同在于如何建立监听套接字。 evconnlistener_new()函数假定已经将套接字绑定到要监听的端口,然后通过 fd 传入这个套接字。
如果要 libevent 分配和绑定套接字,可以调用 evconnlistener_new_bind() ,传输要绑定到的地址和地址长度。

要释放连接监听器,调用 evconnlistener_free()。

可识别的标志:
可以给 evconnlistener_new() 函数的 flags 参数传入一些标志。可以用或 (OR)运算任意连接 下述标志:
LEV_OPT_LEAVE_SOCKETS_BLOCKING
默认情况下,连接监听器接收新套接字后,会将其设置为非阻塞的,以便将其用于 libevent。如果不想要这种行为,可以设置这个标志。

LEV_OPT_CLOSE_ON_FREE
如果设置了这个选项,释放连接监听器会关闭底层套接字。

LEV_OPT_CLOSE_ON_EXEC
如果设置了这个选项,连接监听器会为底层套接字设置 close-on-exec 标志。更多信息请查 看 fcntl 和 FD_CLOEXEC 的平台文档。

LEV_OPT_REUSEABLE
某些平台在默认情况下 ,关闭某监听套接字后 ,要过一会儿其他套接字才可以绑定到同一个 端口。设置这个标志会让 libevent 标记套接字是可重用的,这样一旦关闭,可以立即打开其 他套接字,在相同端口进行监听。

LEV_OPT_THREADSAFE
为监听器分配锁,这样就可以在多个线程中安全地使用了。


链接监听器回调:
typedef void (*evconnlistener_cb)(struct evconnlistener *listener,
    evutil_socket_t sock, struct sockaddr *addr, int len, void *ptr);
接收到新连接会调用提供的回调函数:
listener 参数是接收连接的连接监听器 。
sock 参数是 新接收的套接字。
addr 和 len 参数是接收连接的地址和地址长度。
ptr 是调 用 evconnlistener_new() 时用户提供的指针。

启用和禁用 evconnlistener:
int evconnlistener_disable(struct evconnlistener *lev);
int evconnlistener_enable(struct evconnlistener *lev);
这两个函数暂时禁止或者重新允许监听新连接。

调整 evconnlistener 的回调函数:
void evconnlistener_set_cb(struct evconnlistener *lev,
    evconnlistener_cb cb, void *arg);
函数调整 evconnlistener 的回调函数和其参数。

==================================================libevent6 在libevent中，封装了http模块
创建http方式有很多种，这里只是一种简单的方式；
http程序创建步骤：
1、初始化event模块
2、启动http服务端
3、设置事件处理函数
4、监听事件

接口说明：
1、event_init()

2、evhttp_start()
/*
 * Start a web server on the specified address and port.
 */

struct evhttp *
evhttp_start(const char *address, ev_uint16_t port)
{
struct evhttp *http = NULL;
//初始化结构体evhttp
http = evhttp_new_object();
if (http == NULL)
return (NULL);
//绑定监听地址和端口
if (evhttp_bind_socket(http, address, port) == -1) {
mm_free(http);
return (NULL);
}

return (http);
}



static struct evhttp*
evhttp_new_object(void)
{
struct evhttp *http = NULL;
//申请内存
if ((http = mm_calloc(1, sizeof(struct evhttp))) == NULL) {
event_warn("%s: calloc", __func__);
return (NULL);
}
//清空时间延时
evutil_timerclear(&http->timeout_read);
evutil_timerclear(&http->timeout_write);
//设置包头和包体的最大值
evhttp_set_max_headers_size(http, EV_SIZE_MAX);
evhttp_set_max_body_size(http, EV_SIZE_MAX);
evhttp_set_default_content_type(http, "text/html; charset=ISO-8859-1");
//设置支持的操作类型
evhttp_set_allowed_methods(http,
    EVHTTP_REQ_GET |
    EVHTTP_REQ_POST |
    EVHTTP_REQ_HEAD |
    EVHTTP_REQ_PUT |
    EVHTTP_REQ_DELETE);

TAILQ_INIT(&http->sockets);
TAILQ_INIT(&http->callbacks);
TAILQ_INIT(&http->connections);
TAILQ_INIT(&http->virtualhosts);
TAILQ_INIT(&http->aliases);

return (http);
}

struct evhttp *
evhttp_new(struct event_base *base)
{
struct evhttp *http = NULL;

http = evhttp_new_object();
if (http == NULL)
return (NULL);
http->base = base;

return (http);
}



struct evhttp *
evhttp_new(struct event_base *base)
{
struct evhttp *http = NULL;

http = evhttp_new_object();
if (http == NULL)
return (NULL);
http->base = base;

return (http);
}

开启服务中，最后一步是绑定和监听IP和端口：
int
evhttp_bind_socket(struct evhttp *http, const char *address, ev_uint16_t port)
{
//什么也没做，直接调用了evhttp_bind_socket_with_handle()函数
struct evhttp_bound_socket *bound =
evhttp_bind_socket_with_handle(http, address, port);
if (bound == NULL)
return (-1);
return (0);
}

struct evhttp_bound_socket *
evhttp_bind_socket_with_handle(struct evhttp *http, const char *address, ev_uint16_t port)
{
evutil_socket_t fd;
struct evhttp_bound_socket *bound;
int serrno;
//申请socket,bind,绑定端口
if ((fd = bind_socket(address, port, 1 /*reuse*/)) == -1)
return (NULL);

if (listen(fd, 128) == -1) {
serrno = EVUTIL_SOCKET_ERROR();
event_sock_warn(fd, "%s: listen", __func__);
evutil_closesocket(fd);
EVUTIL_SET_SOCKET_ERROR(serrno);
return (NULL);
}
//accept 处理
bound = evhttp_accept_socket_with_handle(http, fd);

if (bound != NULL) {
event_debug(("Bound to port %d - Awaiting connections ... ",
port));
return (bound);
}

return (NULL);
}


3、evhttp_set_timeout()
void
evhttp_set_timeout(struct evhttp* http, int timeout)
{
//设置读超时
evhttp_set_timeout_(&http->timeout_read,  timeout, -1);
//设置写超时
evhttp_set_timeout_(&http->timeout_write, timeout, -1);
}


4、evhttp_set_cb()
int
evhttp_set_cb(struct evhttp *http, const char *uri,
    void (*cb)(struct evhttp_request *, void *), void *cbarg)
{
struct evhttp_cb *http_cb;

TAILQ_FOREACH(http_cb, &http->callbacks, next) {
if (strcmp(http_cb->what, uri) == 0)
return (-1);
}
//申请内存
if ((http_cb = mm_calloc(1, sizeof(struct evhttp_cb))) == NULL) {
event_warn("%s: calloc", __func__);
return (-2);
}

http_cb->what = mm_strdup(uri);
if (http_cb->what == NULL) {
event_warn("%s: strdup", __func__);
mm_free(http_cb);
return (-3);
}
http_cb->cb = cb;
http_cb->cbarg = cbarg;
//插入事件列表中
TAILQ_INSERT_TAIL(&http->callbacks, http_cb, next);

return (0);
}


5、event_dispatch()
int
event_dispatch(void)
{
//调用event_loop
return (event_loop(0));
}

int
event_loop(int flags)
{
//调用event_base_loop
return event_base_loop(current_base, flags);
}


简单案例：
#include <stdio.h>
#include <stdlib.h>
#include <evhttp.h>
#include <event.h>
#include <string.h>
#include "event2/http.h"
#include "event2/event.h"
#include "event2/buffer.h"
#include "event2/bufferevent.h"
#include "event2/bufferevent_compat.h"
#include "event2/http_struct.h"
#include "event2/http_compat.h"
#include "event2/util.h"
#include "event2/listener.h"


void Test_Get(struct evhttp_request *req,void *arg)
{
{
//解析头，进行处理
//这里只做了回复
}
struct evbuffer* retbuff = evbuffer_new();
if(NULL == retbuff)
{
printf("retbuff is NULL\n");
return ;
}
evbuffer_add_printf(retbuff,"Test_Get is OK!");
evhttp_send_reply(req,HTTP_OK,"Client is OK",retbuff);
evbuffer_free(retbuff);
}
void Test_Post(struct evhttp_request *req,void *arg)
{
{
//获取数据，然后进行处理
//evbuffer_pullup()获取数据接口
}
//只做回复
struct evbuffer* retbuff = evbuffer_new();
if(NULL == retbuff)
{
printf("retbuff is NULL\n");
return ;
}
evbuffer_add_printf(retbuff,"Test_post is OK!");
evhttp_send_reply(req,HTTP_OK,"Client is OK",retbuff);
evbuffer_free(retbuff);
}

int main()
{
    short http_port = 8081;
    char *http_addr = "127.0.0.1";

    //初始化
    event_init();
    //启动http服务端
    struct evhttp *http_server = evhttp_start(http_addr,http_port);
    if(http_server == NULL)
    {
        printf("====line:%d,%s\n",__LINE__,"http server start failed.");
        return -1;
    }

    //设置请求超时时间(s)
    evhttp_set_timeout(http_server,5);
    //设置事件处理函数，evhttp_set_cb针对每一个事件(请求)注册一个处理函数，
    //区别于evhttp_set_gencb函数，是对所有请求设置一个统一的处理函数
    evhttp_set_cb(http_server,"/hello/post",Test_Post,NULL);
    evhttp_set_cb(http_server,"/hello/get",Test_Get,NULL);

    //循环监听
    event_dispatch();
    evhttp_free(http_server);

    return 0;
}

==================================================socket总结
1.1 nonblock socket
对应block，如果一个socket设置为nonblock，那么其相关的操作将变为非阻塞的。这里所说的非阻塞，并不是说异步回调什么的，例如，调用recv()函数：
#include <sys/types.h>
#include <sys/socket.h>
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
read = recv(sock, buf, len, 0);

如果是默认的block情形，这个函数将一直等待直到获取到数据，或者报错。在高并发中，这显然是悲剧的。
如果设置为noblock，同样的调用将直接返回。

下边详细描述一下的recv的情形：
连接失败
block：立即返回，返回值-1，同时设置errno := ENOTCONN
nonblock: 同上

缓冲区中有数据：
block: 立即返回，将缓冲区的数据写入buf，最多写入len字节，返回值为写入的字节数
nonblock: 同上

缓冲区无数据：
block：将阻塞等待缓冲区有数据
nonblock：立即返回，返回值-1，同时设置errno := EAGAIN
类似的，对于send(), connect(), bind(), accept()，均有类似一样的区别

设置：
有如下方式设置nonblock
新建 socket 时设置
在传入 socket type 时，同时置SOCK_NONBLOCK位为1
sock = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);

使用fcntl()设置
int flag = fcntl(sock, F_GETFL);
fcntl(sock, F_SETFL, flag | O_NONBLOCK); 

使用even2设置
#inlcude <event2/util.h>
int evutil_make_socket_nonblocking(evutil_socket_t sock);

1.2 reuseable socket
一个socket在系统中的表示如下
{<protocol>, <src addr>, <src port>, <dest addr>, <dest port>}
如果指定src addr为0.0.0.0，将不再表示某一个具体的地址，而是表示本地的所有的可用地址。

reuse有三个级别:
non-reuse: src addr和src port不能冲突(同一个protocol下), 0.0.0.0和其他IP视为冲突
reuse-addr: src addr和src port不能冲突(同一个protocol下), 0.0.0.0和其他IP视为不冲突
reuse-port: src addr和src port可以冲突


系统有两个网口，分别是192.168.0.101和10.0.0.101。
情形1：
sock1绑定了192.168.0.101:8080，sock2尝试绑定10.0.0.101:8080
non-reuse - 可以绑定成功，虽然端口一样，但是addr不同
reuse - 同上

情形2：
sock1绑定了0.0.0.0:8080, sock2尝试绑定192.168.0.101:8080
non-reuse - 不能绑定成功，系统认为0.0.0.0包含了所有的本地ip，发生冲突
reuse - 可以绑定成功，系统认为0.0.0.0和192.168.0.101不是一样的地址

情形3：
sock1绑定了192.168.0.101:8080,sock2尝试绑定0.0.0.0:8080
non-reuse - 不能绑定成功，系统认为0.0.0.0包含了所有的本地ip，发生冲突
reuse - 可以绑定成功，系统认为0.0.0.0和192.168.0.101不是一样的地址

情形4：
sock1绑定了0.0.0.0:8080,sock2尝试绑定0.0.0.0:8080
non-reuse - 不能绑定成功，系统认为0.0.0.0包含了所有的本地ip，发生冲突
reuse-addr - 不能绑定成功，系统认为0.0.0.0包含了所有的本地ip，发生冲突
reuse-port - 可以绑定成功

设置reuse
使用setsockopt()
必须设置所有相关的sock。

设置reuse-addr：
setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int));
设置reuse-port：
setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, &(int){1}, sizeof(int));
使用event2设置
#inlcude <event2/util.h>
int evutil_make_listen_socket_reuseable(evutil_socket_t sock);


2. 常用的系统API接口
新建一个socket：
#include <sys/socket.h>
int socket(int domain, int type, int protocol);
domain 一般设置为:
AF_UNIX - 本地socket
AF_INET - ipv4
AF_INET6 - ipv6
type 一般设置为:
SOCK_STREAM - TCP
SOCK_DGRAM - UDP

连接到远程端口：
#include <sys/socket.h>
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
对于不同协议，addr的类型不同，长度也不同，这里需要把不同的类型强转为struct sockaddr *，在强转中，addr的类型信息丢失，所以需要在addrlen中指定原有类型的长度。

绑定到本地端口：
#include <sys/socket.h>
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
addr类似connect()，这个函数常用语服务器端，但是实际上客户端也是可以使用的(然并卵一般没啥意义)

读写数据：
#include <sys/types.h>
#include <sys/socket.h>
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
读写数据涉及的问题较多，第一是失败时候返回-1而不是0，如果是0表示socket关闭。
第二就是读写不一定100%完成，计划读写512字节，但是读到256字节的时候发生了中断或者没有数据/空闲缓冲区都是是可能的，返回值表示实际读入和写出的字节数。

监听数据：
#include <sys/socket.h>
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
int listen(int sockfd, int backlog);
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
和主动发起连接不同，被动接收连接分为三个阶段，bind()用来设置本地端口，listen()表示socket开始接收到来的连接，而不会建立连接，要真正建立连接，使用accept()

关闭连接：
#include <unistd.h>
int close(int fd);

3. 常用的event2的接口
旧版libevent中，一般只能操作一个全局的event_base，而在新版libevent中，event_base交由用户来管理，用户可以创建删除event_base，也可以把event注册到不同的event_base上。

新建一个 event_base：
#include <event2/event.h>
struct event_base *event_base_new(void);

释放一个event_base：
#include <event2/event.h>
void event_base_free(struct event_base *eb);

用户自己创建的event是uninitialized的，需要使用event_assign()进行初始化，或者直接使用event_new()从无到有创建一个新的初始化了的event。在初始化时，完成了回调函数的绑定。
event的初始状态是non-pending，表示这个event不会被触发。

新建(并初始化)一个 event：
struct event *event_new(struct event_base *base, evutil_socket_t fd, short events,
event_callback_fn callback, void *callback_arg);

新建event需要给定event_base, evutil_socket_t与系统相兼容，在linux下实际就是int，与socket()返回的类型一致
#ifdef WIN32
#define evutil_socket_t intptr_t
#else
#define evutil_socket_t int
#endif

events是一组flag，用于表示要监视的事件类型，还会影响event的一些行为，包括：
EV_TIMEOUT - 监视超时的事件
需要说明的是，在调用event_new()时，这个flag是不用设置的，如果event发生超时，则必然会触发，无论设置与否
EV_READ - 监视可读的事件
EV_WRITE - 监视可写的事件
EV_SIGNAL - 监视信号量
EV_PERSIST - 永久生效，否则触发一次后就失效了
EV_ET - 设置边缘触发(edge-triggered)
callback和callback_arg是回调操作所需的

新建的event是non-pending状态的：
初始化一个event
int event_assign(struct event *ev,
                 struct event_base *base, evutil_socket_t fd, short events, 
                 event_callback_fn callback, void *callback_arg);
这个不会申请内存，其他同event_new()

释放一个event：
void event_free(struct event *ev);

判断event是否初始化/被释放：
int event_initialized(const struct event *ev);

将event置为pending状态：
int event_add(struct event *ev, const struct timeval *timeout);
其中timeout可以指定超时时间，超时和EV_TIMEOUT配合使用。如果timeout如果为NULL，则表示永不超时，struct timeval的结构为：
struct timeval {
    time_t      tv_sec;     /* seconds */
    suseconds_t tv_usec;    /* microseconds */
};

操作当前时间对应的timeval可以用：
#include <sys/time.h>
int gettimeofday(struct timeval *tv, struct timezone *tz);
int settimeofday(const struct timeval *tv, const struct timezone *tz);

将event置为non-pending状态：
int event_del(struct event *ev);

检查event是否为pending状态：
int event_pending(const struct event *ev, short events, struct timeval *tv);

不需要查询event是否为active状态，因为在active时，线程正在执行回调函数，其他函数需要等到回调执行完毕，而此时已经退出了active状态

将event置为active状态：
void event_active(struct event *ev, int res, short/* deprecated */);
`res`是要手动指派的flag


##################################################Libevent源码分析##################################################
https://blog.csdn.net/luotuo44/category_2435521.html

##################################################libevent编程疑难解答##################################################
https://blog.csdn.net/luotuo44/article/details/39547391

struct event_base* base = (event_base *)arg; 
对于C++来说关键字struct是不需要的，对于C语言中则是需要的。

socket函数的前面老是加::
调用全局函数，从socket库里调用socket函数，避免函数名字相同的冲突

##################################################Libevent使用例子，从简单到复杂##################################################
https://blog.csdn.net/luotuo44/article/details/39670221

==========初等
客户端代码：
#include<sys/types.h>  
#include<sys/socket.h>  
#include<netinet/in.h>  
#include<arpa/inet.h>  
#include<errno.h>  
#include<unistd.h>  
  
#include<stdio.h>  
#include<string.h>  
#include<stdlib.h>  
  
#include<event.h>  
#include<event2/util.h>  
  
int tcp_connect_server(const char* server_ip, int port);  
  
void cmd_msg_cb(int fd, short events, void* arg);  
void socket_read_cb(int fd, short events, void *arg);  
  
int main(int argc, char** argv)  
{  
    if( argc < 3 )  
    {  
        printf("please input 2 parameter\n");  
        return -1;  
    }  
  
  
    //两个参数依次是服务器端的IP地址、端口号  
    int sockfd = tcp_connect_server(argv[1], atoi(argv[2]));  
    if( sockfd == -1)  
    {  
        perror("tcp_connect error ");  
        return -1;  
    }  
  
    printf("connect to server successful\n");  
  
    struct event_base* base = event_base_new();  
  
    struct event *ev_sockfd = event_new(base, sockfd,  
                                        EV_READ | EV_PERSIST,  
                                        socket_read_cb, NULL);  
    event_add(ev_sockfd, NULL);  
  
    //监听终端输入事件  
    struct event* ev_cmd = event_new(base, STDIN_FILENO,  
                                      EV_READ | EV_PERSIST, cmd_msg_cb,  
                                      (void*)&sockfd);  
  
  
    event_add(ev_cmd, NULL);  
  
    event_base_dispatch(base);  
  
    printf("finished \n");  
    return 0;  
}  
  
void cmd_msg_cb(int fd, short events, void* arg)  
{  
    char msg[1024];  
  
    int ret = read(fd, msg, sizeof(msg));  
    if( ret <= 0 )  
    {  
        perror("read fail ");  
        exit(1);  
    }  
  
    int sockfd = *((int*)arg);  
  
    //把终端的消息发送给服务器端  
    //为了简单起见，不考虑写一半数据的情况  
    write(sockfd, msg, ret);  
}  
  
  
void socket_read_cb(int fd, short events, void *arg)  
{  
    char msg[1024];  
  
    //为了简单起见，不考虑读一半数据的情况  
    int len = read(fd, msg, sizeof(msg)-1);  
    if( len <= 0 )  
    {  
        perror("read fail ");  
        exit(1);  
    }  
  
    msg[len] = '\0';  
  
    printf("recv %s from server\n", msg);  
}  
  
typedef struct sockaddr SA;  
int tcp_connect_server(const char* server_ip, int port)  
{  
    int sockfd, status, save_errno;  
    struct sockaddr_in server_addr;  
  
    memset(&server_addr, 0, sizeof(server_addr) );  
  
    server_addr.sin_family = AF_INET;  
    server_addr.sin_port = htons(port);  
    status = inet_aton(server_ip, &server_addr.sin_addr);  
  
    if( status == 0 ) //the server_ip is not valid value  
    {  
        errno = EINVAL;  
        return -1;  
    }  
  
    sockfd = ::socket(PF_INET, SOCK_STREAM, 0);  
    if( sockfd == -1 )  
        return sockfd;  
  
  
    status = ::connect(sockfd, (SA*)&server_addr, sizeof(server_addr) );  
  
    if( status == -1 )  
    {  
        save_errno = errno;  
        ::close(sockfd);  
        errno = save_errno; //the close may be error  
        return -1;  
    }  
  
    evutil_make_socket_nonblocking(sockfd);  
  
    return sockfd;  
}

服务器端代码：
#include<stdio.h>  
#include<string.h>  
#include<errno.h>  
  
#include<unistd.h>  
#include<event.h>  
 
void accept_cb(int fd, short events, void* arg);  
void socket_read_cb(int fd, short events, void *arg);  
  
int tcp_server_init(int port, int listen_num);  
  
int main(int argc, char** argv)  
{  
  
    int listener = tcp_server_init(9999, 10);  
    if( listener == -1 )  
    {  
        perror(" tcp_server_init error ");  
        return -1;  
    }  
  
    struct event_base* base = event_base_new();  
  
    //添加监听客户端请求连接事件  
    struct event* ev_listen = event_new(base, listener, EV_READ | EV_PERSIST,  
                                        accept_cb, base);  
    event_add(ev_listen, NULL);  
  
  
    event_base_dispatch(base);  
  
    return 0;  
}  
void accept_cb(int fd, short events, void* arg)  
{  
    evutil_socket_t sockfd;  
  
    struct sockaddr_in client;  
    socklen_t len = sizeof(client);  
  
    sockfd = ::accept(fd, (struct sockaddr*)&client, &len );  
    evutil_make_socket_nonblocking(sockfd);  
  
    printf("accept a client %d\n", sockfd);  
  
    struct event_base* base = (event_base*)arg;  
  
    //仅仅是为了动态创建一个event结构体  
    struct event *ev = event_new(NULL, -1, 0, NULL, NULL);  
    //将动态创建的结构体作为event的回调参数  
    event_assign(ev, base, sockfd, EV_READ | EV_PERSIST,  
                 socket_read_cb, (void*)ev);  
  
    event_add(ev, NULL);  
}  
  
  
void socket_read_cb(int fd, short events, void *arg)  
{  
    char msg[4096];  
    struct event *ev = (struct event*)arg;  
    int len = read(fd, msg, sizeof(msg) - 1);  
  
  
  
    if( len <= 0 )  
    {  
        printf("some error happen when read\n");  
        event_free(ev);  
        close(fd);  
        return ;  
    }  
  
    msg[len] = '\0';  
    printf("recv the client msg: %s", msg);  
  
    char reply_msg[4096] = "I have recvieced the msg: ";  
    strcat(reply_msg + strlen(reply_msg), msg);  
  
    write(fd, reply_msg, strlen(reply_msg) );  
}  
  
  
  
typedef struct sockaddr SA;  
int tcp_server_init(int port, int listen_num)  
{  
    int errno_save;  
    evutil_socket_t listener;  
  
    listener = ::socket(AF_INET, SOCK_STREAM, 0);  
    if( listener == -1 )  
        return -1;  
  
    //允许多次绑定同一个地址。要用在socket和bind之间  
    evutil_make_listen_socket_reuseable(listener);  
  
    struct sockaddr_in sin;  
    sin.sin_family = AF_INET;  
    sin.sin_addr.s_addr = 0;  
    sin.sin_port = htons(port);  
  
    if( ::bind(listener, (SA*)&sin, sizeof(sin)) < 0 )  
        goto error;  
  
    if( ::listen(listener, listen_num) < 0)  
        goto error;  
  
  
    //跨平台统一接口，将套接字设置为非阻塞状态  
    evutil_make_socket_nonblocking(listener);  
  
    return listener;  
  
    error:  
        errno_save = errno;  
        evutil_closesocket(listener);  
        errno = errno_save;  
  
        return -1;  
}

==========中等
客户端代码：
#include<sys/types.h>  
#include<sys/socket.h>  
#include<netinet/in.h>  
#include<arpa/inet.h>  
#include<errno.h>  
#include<unistd.h>  
  
#include<stdio.h>  
#include<string.h>  
#include<stdlib.h>  
  
#include<event.h>  
#include<event2/bufferevent.h>  
#include<event2/buffer.h>  
#include<event2/util.h>  

int tcp_connect_server(const char* server_ip, int port);  
  
void cmd_msg_cb(int fd, short events, void* arg);  
void server_msg_cb(struct bufferevent* bev, void* arg);  
void event_cb(struct bufferevent *bev, short event, void *arg);  
  
int main(int argc, char** argv)  
{  
    if( argc < 3 )  
    {  
        printf("please input 2 parameter\n");  
        return -1;  
    }  
  
  
    //两个参数依次是服务器端的IP地址、端口号  
    int sockfd = tcp_connect_server(argv[1], atoi(argv[2]));  
    if( sockfd == -1)  
    {  
        perror("tcp_connect error ");  
        return -1;  
    }  
  
    printf("connect to server successful\n");  
  
    struct event_base* base = event_base_new();  
  
    struct bufferevent* bev = bufferevent_socket_new(base, sockfd,  
                                                     BEV_OPT_CLOSE_ON_FREE);  
  
    //监听终端输入事件  
    struct event* ev_cmd = event_new(base, STDIN_FILENO,  
                                      EV_READ | EV_PERSIST, cmd_msg_cb,  
                                      (void*)bev);  
    event_add(ev_cmd, NULL);  
  
    //当socket关闭时会用到回调参数  
    bufferevent_setcb(bev, server_msg_cb, NULL, event_cb, (void*)ev_cmd);  
    bufferevent_enable(bev, EV_READ | EV_PERSIST);  
  
  
    event_base_dispatch(base);  
  
    printf("finished \n");  
    return 0;  
} 
void cmd_msg_cb(int fd, short events, void* arg)  
{  
    char msg[1024];  
  
    int ret = read(fd, msg, sizeof(msg));  
    if( ret < 0 )  
    {  
        perror("read fail ");  
        exit(1);  
    }  
  
    struct bufferevent* bev = (struct bufferevent*)arg;  
  
    //把终端的消息发送给服务器端  
    bufferevent_write(bev, msg, ret);  
}  
void server_msg_cb(struct bufferevent* bev, void* arg)  
{  
    char msg[1024];  
  
    size_t len = bufferevent_read(bev, msg, sizeof(msg));  
    msg[len] = '\0';  
  
    printf("recv %s from server\n", msg);  
}  
  
  
void event_cb(struct bufferevent *bev, short event, void *arg)  
{  
  
    if (event & BEV_EVENT_EOF)  
        printf("connection closed\n");  
    else if (event & BEV_EVENT_ERROR)  
        printf("some other error\n");  
  
    //这将自动close套接字和free读写缓冲区  
    bufferevent_free(bev);  
  
    struct event *ev = (struct event*)arg;  
    //因为socket已经没有，所以这个event也没有存在的必要了  
    event_free(ev);  
}  

typedef struct sockaddr SA;  
int tcp_connect_server(const char* server_ip, int port)  
{  
    int sockfd, status, save_errno;  
    struct sockaddr_in server_addr;  
  
    memset(&server_addr, 0, sizeof(server_addr) );  
  
    server_addr.sin_family = AF_INET;  
    server_addr.sin_port = htons(port);  
    status = inet_aton(server_ip, &server_addr.sin_addr);  
  
    if( status == 0 ) //the server_ip is not valid value  
    {  
        errno = EINVAL;  
        return -1;  
    }  
  
    sockfd = ::socket(PF_INET, SOCK_STREAM, 0);  
    if( sockfd == -1 )  
        return sockfd;  
  
  
    status = ::connect(sockfd, (SA*)&server_addr, sizeof(server_addr) );  
  
    if( status == -1 )  
    {  
        save_errno = errno;  
        ::close(sockfd);  
        errno = save_errno; //the close may be error  
        return -1;  
    }  
  
    evutil_make_socket_nonblocking(sockfd);  
  
    return sockfd;  
}

服务器端代码：
#include<stdio.h>  
#include<string.h>  
#include<errno.h>  
  
#include<event.h>  
#include<event2/bufferevent.h>  

void accept_cb(int fd, short events, void* arg);  
void socket_read_cb(bufferevent* bev, void* arg);  
void event_cb(struct bufferevent *bev, short event, void *arg);  
int tcp_server_init(int port, int listen_num);  
  
int main(int argc, char** argv)  
{  
    int listener = tcp_server_init(9999, 10);  
    if( listener == -1 )  
    {  
        perror(" tcp_server_init error ");  
        return -1;  
    }  
  
    struct event_base* base = event_base_new();  
  
    //添加监听客户端请求连接事件  
    struct event* ev_listen = event_new(base, listener, EV_READ | EV_PERSIST,  
                                        accept_cb, base);  
    event_add(ev_listen, NULL);  
  
    event_base_dispatch(base);  
    event_base_free(base);  
  
    return 0;  
}  
void accept_cb(int fd, short events, void* arg)  
{  
    evutil_socket_t sockfd;  
  
    struct sockaddr_in client;  
    socklen_t len = sizeof(client);  
  
    sockfd = ::accept(fd, (struct sockaddr*)&client, &len );  
    evutil_make_socket_nonblocking(sockfd);  
  
    printf("accept a client %d\n", sockfd);  
  
    struct event_base* base = (event_base*)arg;  
  
    bufferevent* bev = bufferevent_socket_new(base, sockfd, BEV_OPT_CLOSE_ON_FREE);  
    bufferevent_setcb(bev, socket_read_cb, NULL, event_cb, arg);  
  
    bufferevent_enable(bev, EV_READ | EV_PERSIST);  
} 
void socket_read_cb(bufferevent* bev, void* arg)  
{  
    char msg[4096];  
  
    size_t len = bufferevent_read(bev, msg, sizeof(msg));  
  
    msg[len] = '\0';  
    printf("recv the client msg: %s", msg);  
  
  
    char reply_msg[4096] = "I have recvieced the msg: ";  
  
    strcat(reply_msg + strlen(reply_msg), msg);  
    bufferevent_write(bev, reply_msg, strlen(reply_msg));  
}  
void event_cb(struct bufferevent *bev, short event, void *arg)  
{  
  
    if (event & BEV_EVENT_EOF)  
        printf("connection closed\n");  
    else if (event & BEV_EVENT_ERROR)  
        printf("some other error\n");  
  
    //这将自动close套接字和free读写缓冲区  
    bufferevent_free(bev);  
}  
typedef struct sockaddr SA;  
int tcp_server_init(int port, int listen_num)  
{  
    int errno_save;  
    evutil_socket_t listener;  
  
    listener = ::socket(AF_INET, SOCK_STREAM, 0);  
    if( listener == -1 )  
        return -1;  
  
    //允许多次绑定同一个地址。要用在socket和bind之间  
    evutil_make_listen_socket_reuseable(listener);  
  
    struct sockaddr_in sin;  
    sin.sin_family = AF_INET;  
    sin.sin_addr.s_addr = 0;  
    sin.sin_port = htons(port);  
  
    if( ::bind(listener, (SA*)&sin, sizeof(sin)) < 0 )  
        goto error;  
  
    if( ::listen(listener, listen_num) < 0)  
        goto error;  
  
  
    //跨平台统一接口，将套接字设置为非阻塞状态  
    evutil_make_socket_nonblocking(listener);  
  
    return listener;  
  
    error:  
        errno_save = errno;  
        evutil_closesocket(listener);  
        errno = errno_save;  
  
        return -1;  
}

==========高等
客户端代码：
#include<sys/types.h>  
#include<sys/socket.h>  
#include<netinet/in.h>  
#include<arpa/inet.h>  
#include<errno.h>  
#include<unistd.h>  
  
#include<stdio.h>  
#include<string.h>  
#include<stdlib.h>  
  
#include<event.h>  
#include<event2/bufferevent.h>  
#include<event2/buffer.h>  
#include<event2/util.h>  
  
 
int tcp_connect_server(const char* server_ip, int port);  
  
void cmd_msg_cb(int fd, short events, void* arg);  
void server_msg_cb(struct bufferevent* bev, void* arg);  
void event_cb(struct bufferevent *bev, short event, void *arg);  
  
int main(int argc, char** argv)  
{  
    if( argc < 3 )  
    {  
        //两个参数依次是服务器端的IP地址、端口号  
        printf("please input 2 parameter\n");  
        return -1;  
    }  
  
    struct event_base *base = event_base_new();  
  
    struct bufferevent* bev = bufferevent_socket_new(base, -1,  
                                                     BEV_OPT_CLOSE_ON_FREE);  
  
    //监听终端输入事件  
    struct event* ev_cmd = event_new(base, STDIN_FILENO,  
                                     EV_READ | EV_PERSIST,  
                                     cmd_msg_cb, (void*)bev);  
    event_add(ev_cmd, NULL);  
  
    struct sockaddr_in server_addr;  
  
    memset(&server_addr, 0, sizeof(server_addr) );  
  
    server_addr.sin_family = AF_INET;  
    server_addr.sin_port = htons(atoi(argv[2]));  
    inet_aton(argv[1], &server_addr.sin_addr);  
  
    bufferevent_socket_connect(bev, (struct sockaddr *)&server_addr,  
                               sizeof(server_addr));  
  
  
    bufferevent_setcb(bev, server_msg_cb, NULL, event_cb, (void*)ev_cmd);  
    bufferevent_enable(bev, EV_READ | EV_PERSIST);  
  
  
    event_base_dispatch(base);  
  
    printf("finished \n");  
    return 0;  
}  
void cmd_msg_cb(int fd, short events, void* arg)  
{  
    char msg[1024];  
  
    int ret = read(fd, msg, sizeof(msg));  
    if( ret < 0 )  
    {  
        perror("read fail ");  
        exit(1);  
    }  
  
    struct bufferevent* bev = (struct bufferevent*)arg;  
  
    //把终端的消息发送给服务器端  
    bufferevent_write(bev, msg, ret);  
}  
  
  
void server_msg_cb(struct bufferevent* bev, void* arg)  
{  
    char msg[1024];  
  
    size_t len = bufferevent_read(bev, msg, sizeof(msg));  
    msg[len] = '\0';  
  
    printf("recv %s from server\n", msg);  
}  
  
void event_cb(struct bufferevent *bev, short event, void *arg)  
{  
  
    if (event & BEV_EVENT_EOF)  
        printf("connection closed\n");  
    else if (event & BEV_EVENT_ERROR)  
        printf("some other error\n");  
    else if( event & BEV_EVENT_CONNECTED)  
    {  
        printf("the client has connected to server\n");  
        return ;  
    }  
  
    //这将自动close套接字和free读写缓冲区  
    bufferevent_free(bev);  
  
    struct event *ev = (struct event*)arg;  
    event_free(ev);  
}

服务器端代码：
#include<netinet/in.h>    
#include<sys/socket.h>    
#include<unistd.h>    
    
#include<stdio.h>    
#include<string.h>    
    
#include<event.h>    
#include<listener.h>    
#include<bufferevent.h>    
#include<thread.h>    
    
void listener_cb(evconnlistener *listener, evutil_socket_t fd,    
                 struct sockaddr *sock, int socklen, void *arg);    
    
void socket_read_cb(bufferevent *bev, void *arg);    
void socket_event_cb(bufferevent *bev, short events, void *arg);    
    
int main()    
{    
    //evthread_use_pthreads();//enable threads    
    
    struct sockaddr_in sin;    
    memset(&sin, 0, sizeof(struct sockaddr_in));    
    sin.sin_family = AF_INET;    
    sin.sin_port = htons(9999);    
    
    event_base *base = event_base_new();    
    evconnlistener *listener    
            = evconnlistener_new_bind(base, listener_cb, base,    
                                      LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE,    
                                      10, (struct sockaddr*)&sin,    
                                      sizeof(struct sockaddr_in));    
    
    event_base_dispatch(base);    
    
    evconnlistener_free(listener);    
    event_base_free(base);    
    
    return 0;    
}    
//一个新客户端连接上服务器了    
//当此函数被调用时，libevent已经帮我们accept了这个客户端。该客户端的  
//文件描述符为fd  
void listener_cb(evconnlistener *listener, evutil_socket_t fd,    
                 struct sockaddr *sock, int socklen, void *arg)    
{    
    printf("accept a client %d\n", fd);    
    
    event_base *base = (event_base*)arg;    
    
    //为这个客户端分配一个bufferevent    
    bufferevent *bev =  bufferevent_socket_new(base, fd,    
                                               BEV_OPT_CLOSE_ON_FREE);    
    
    bufferevent_setcb(bev, socket_read_cb, NULL, socket_event_cb, NULL);    
    bufferevent_enable(bev, EV_READ | EV_PERSIST);    
}       
void socket_read_cb(bufferevent *bev, void *arg)    
{    
    char msg[4096];    
    
    size_t len = bufferevent_read(bev, msg, sizeof(msg)-1 );    
    
    msg[len] = '\0';    
    printf("server read the data %s\n", msg);    
    
    char reply[] = "I has read your data";    
    bufferevent_write(bev, reply, strlen(reply) );    
}     
void socket_event_cb(bufferevent *bev, short events, void *arg)    
{    
    if (events & BEV_EVENT_EOF)    
        printf("connection closed\n");    
    else if (events & BEV_EVENT_ERROR)    
        printf("some other error\n");    
    
    //这将自动close套接字和free读写缓冲区    
    bufferevent_free(bev);    
}