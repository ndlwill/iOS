std::move 并不会真正地移动对象，真正的移动操作是在移动构造函数、移动赋值函数等完成的，std::move 只是将参数转换为右值引用而已（相当于一个 static_cast）。

std::string str = "test";
string&& r = std::move(str);
中，其实只是定义了一个指向 str 的右值引用而已，str 并没有被移走。

随后执行
std::string t(r);

需要注意的是右值引用用于表达式中时会变为左值，所以这里调用的其实是复制构造函数,str 自然也不会被移走。


如果要移走的话还要加一次 std::move，比如
std::string t(std::move(r));
str 就能被移走了。


要了解move函数首先弄清左值引用和右值引用:
1.左值和右值的概念:
左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体；
右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。
一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。

2、引用
引用是C++语法做的优化，引用的本质还是靠指针来实现的。引用相当于变量的别名。
引用可以改变指针的指向，还可以改变指针所指向的值。
引用的基本规则：
声明引用的时候必须初始化，且一旦绑定，不可把引用绑定到其他对象；即引用必须初始化，不能对引用重定义；
对引用的一切操作，就相当于对原对象的操作。


3、左值引用和右值引用
3.1 左值引用
左值引用的基本语法：type &引用名 = 左值表达式；

3.2 右值引用
右值引用的基本语法type &&引用名 = 右值表达式；
右值引用在企业开发人员在代码优化方面会经常用到。

C++ 标准库使用比如vector::push_back 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 本来原意是想把参数push_back进去就行了,通过std::move，可以避免不必要的拷贝操作。
std::move是为性能而生。


int main()
{
    std::string str = "Hello";
    std::vector<std::string> v;
    //调用常规的拷贝构造函数，新建字符数组，拷贝数据
    v.push_back(str);
    std::cout << "After copy, str is \"" << str << "\"\n";
    //调用移动构造函数，掏空str，掏空后，最好不要使用str
    v.push_back(std::move(str));
    std::cout << "After move, str is \"" << str << "\"\n";
    std::cout << "The contents of the vector are \"" << v[0]
                                         << "\", \"" << v[1] << "\"\n";
}


After copy, str is "Hello"
After move, str is ""
The contents of the vector are "Hello", "Hello"


复制构造和移动构造
复制构造是这样的：
在对象被复制后临时对象和复制构造的对象各自占有不同的同样大小的堆内存，就是一个副本。

移动构造是这样的：
就是让这个临时对象它原本控制的内存的空间转移给构造出来的对象，这样就相当于把它移动过去了。