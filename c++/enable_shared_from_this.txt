#include <memory>
#include <iostream>
 
class A
{
public:
    A()
    {
        std::cout << "A()" << std::endl;
    }
 
    ~A()
    {
        std::cout << "~A()" << std::endl;
    }
 
    std::shared_ptr<A> getSharedPtr()
    {
        std::shared_ptr<A> ptr(this);
        return ptr;
    }
};
 
 
int main()
{
    std::shared_ptr<A> ptr1(new A());
    std::shared_ptr<A> ptr2 = ptr1->getSharedPtr();
 
    return 0;
}

A()
~A()
~A()


#include <memory>
#include <iostream>
 
class A
{
public:
    A(): mPtr(new int(10))
    {
        std::cout << "A(), *mPtr = " << *mPtr <<std::endl;
    }
 
    ~A()
    {
        std::cout << "~A()" << std::endl;
        delete mPtr;
        mPtr = nullptr;
    }
 
    std::shared_ptr<A> getSharedPtr()
    {
        std::shared_ptr<A> ptr(this);
        return ptr;
    }
private:
    int *mPtr;
};
 
 
int main()
{
    std::shared_ptr<A> ptr1(new A());
    std::shared_ptr<A> ptr2 = ptr1->getSharedPtr();
    return 0;
}
free 了无效的指针导致程序崩溃。我们应该能看到是重复释放的问题，这里我们将裸指针赋给了智能指针，这样做潜在的危险就是对象被多次释放。