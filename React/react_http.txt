https://zh-hans.reactjs.org/

https://zh-hans.react.dev/  ###最新

html-to-jsx:
https://transform.tools/html-to-jsx

React: 声明式编程
强调描述你希望程序做什么，而不是如何做

数据驱动：UI 的更新是基于 数据状态的变化，而不是手动操作 DOM。
响应式：React 都能自动响应数据变化并重新渲染 UI，开发者不需要关心底层的 DOM 更新逻辑。
模板/渲染函数：React 使用 JSX，它们的目标是让开发者更直观地声明 UI 结构。


命令式编程:
在命令式编程中，你需要告诉程序具体如何做每一件事。你描述的是每一个步骤的实现方式和流程。你会考虑到如何操作数据、如何更新状态、如何修改 DOM 等。
例如，在操作 DOM 时，你可能需要手动指定如何查找元素、修改元素的内容或改变样式

声明式编程:
在声明式编程中，你只描述你希望程序做什么，而不需要关心如何做。
你更关注结果，而不是操作的具体过程。框架会在背后自动处理数据更新、UI 渲染等细节。
你只需要声明界面应该如何显示，它会自动根据数据状态的变化来更新界面。
我们只是声明 UI 的最终状态，告诉 React：“我希望显示一个按钮，点击后会显示点击次数。”React 会自动根据 count 的变化来更新界面，而无需我们关心如何处理这些细节。


父子组件通信（Props 和回调）：

兄弟组件通信（提升状态 / 共享状态）：
“状态提升”（Lifting State Up）是 React（和很多组件化框架）里非常重要的设计思想，主要用来解决“多个组件需要共享同一份数据或状态”的问题。
把多个组件共有的状态，从它们各自的组件内部“提升”到它们的最近公共父组件中，由父组件统一管理，然后通过 props 传递给子组件。
假设有两个兄弟组件，它们都需要知道某个状态的值，如果各自维护，数据会不一致，难协调。
解决办法就是：
把这个状态放到它们共同的父组件里；
父组件通过 props 给两个子组件传数据和回调；
子组件通过回调通知父组件修改状态；
父组件更新后再把最新状态传给子组件。
这样，所有组件都用的是父组件的同一份数据，保证同步和一致。
function Parent() {
  const [text, setText] = React.useState('');

  return (
    <>
      <Input value={text} onChange={setText} />
      <Display text={text} />
    </>
  );
}

function Input({ value, onChange }) {
  return <input value={value} onChange={e => onChange(e.target.value)} />;
}

function Display({ text }) {
  return <div>输入内容是：{text}</div>;
}
状态 text 在父组件 Parent 里；
Input 和 Display 都通过 props 使用和展示这个状态；
Input 修改时调用 onChange 通知父组件，父组件更新状态，再传递给 Display。

通过 Context（跨层级组件通信）：
React 提供的 Context 用来跨越多层组件传递数据，避免层层传 props。

Ref 和回调引用：
父组件通过 ref 操控子组件或 DOM，适合调用子组件方法。
import React, { useRef, forwardRef, useImperativeHandle } from 'react';
import { View, Text, Button } from 'react-native';

// 子组件，使用 forwardRef 转发 ref
const Child = forwardRef((props, ref) => {
  // 定义要暴露给父组件的方法
  useImperativeHandle(ref, () => ({
    showAlert() {
      alert('子组件方法被调用啦！');
    }
  }));

  return (
    <View>
      <Text>我是子组件</Text>
    </View>
  );
});

export default function Parent() {
  const childRef = useRef();

  const onPress = () => {
    if (childRef.current) {
      childRef.current.showAlert();  // 调用子组件暴露的方法
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <Child ref={childRef} />
      <Button title="调用子组件方法" onPress={onPress} />
    </View>
  );
}
