大多数选择器都是在CSS 3中定义的，这是一个成熟的规范
https://www.w3.org/TR/selectors-3/

浏览器有时候也被称为 user agent

所有的标准 Web 技术 (HTML, CSS, JavaScript 等) 都被定义在一个巨大的文档中，称作 规范 specifications (或者简称为 "specs")

浏览器自带一个包含默认样式的样式表，默认对任何页面有效。

如果一个浏览器在解析你所书写的 CSS 规则的过程中遇到了无法理解的属性或者值，它会忽略这些并继续解析下面的 CSS 声明。在你书写了错误的 CSS 代码（或者误拼写），又或者当浏览器遇到对于它来说很新的还没有支持的 CSS 代码的时候上述的情况同样会发生（直接忽略）。
这一特点在你想使用一个很新的 CSS 特性但是不是所有浏览器都支持的时候（浏览器兼容）非常有用，举例来说，一些老的浏览器不接收calc()(calculate 的缩写，CSS3 新增，为元素指定动态宽度、长度等，注意此处的动态是计算之后得一个值) 作为一个值。
我可能使用它结合像素为一个元素设置了动态宽度，老式的浏览器由于无法解析忽略这一行；新式的浏览器则会把这一行解析成像素值，并且覆盖第一行指定的宽度。
.box {
  width: 500px;
  width: calc(100% - 50px);
}


选择器列表
h1, .special {
  color: blue;
}

类型、类和 ID 选择器
类型选择器有时也叫做标签名选择器或者是元素选择器
指向特定元素的类 span.highlight {}
ID 所指特定，会优先于大多数其他选择器

全局选择器，是由一个星号（*）代指的，它选中了文档中的所有内容

属性选择器

伪类和伪元素
伪类是选择器的一种，它用于选择处于特定状态的元素
一些伪类只会在用户以某种方式和文档交互的时候应用。这些用户行为伪类，有时叫做动态伪类，表现得就像是一个类在用户和元素交互的时候加到了元素上一样

伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号::

article p:first-child::first-line {}

关系选择器:
后代选择器
子代关系选择器（>）
邻接兄弟（+）
通用兄弟（~）

层叠与继承:
CSS 代表层叠样式表（Cascading Style Sheets）
层叠:
当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。

优先级:
一个元素选择器不是很具体，则会选择页面上该类型的所有元素，所以它的优先级就会低一些。
一个类选择器稍微具体点，则会选择该页面中有特定 class 属性值的元素，所以它的优先级就要高一点。

继承:
一些设置在父元素上的 CSS 属性是可以被子元素继承的，有些则不能。
控制继承
inherit
设置该属性会使子元素属性和父元素相同。实际上，就是“开启继承”。
initial
将应用于选定元素的属性值设置为该属性的初始值。
revert (en-US)
将应用于选定元素的属性值重置为浏览器的默认样式，而不是应用于该属性的默认值。在许多情况下，此值的作用类似于 unset。
revert-layer (en-US)
将应用于选定元素的属性值重置为在上一个层叠层中建立的值。
unset
将属性重置为自然值，也就是如果属性是自然继承那么就是 inherit，否则和 initial 一样
body {
    color: green;
}
          
.my-class-1 a {
    color: inherit;
}
          
.my-class-2 a {
    color: initial;
}
          
.my-class-3 a {
    color: unset;
}
<ul>
    <li>Default <a href="#">link</a> color</li>
    <li class="my-class-1">Inherit the <a href="#">link</a> color</li>
    <li class="my-class-2">Reset the <a href="#">link</a> color</li>
    <li class="my-class-3">Unset the <a href="#">link</a> color</li>
</ul>

重设所有属性值
CSS 的简写属性 all 可以用于同时将这些继承值中的一个应用于（几乎）所有属性。它的值可以是其中任意一个（inherit、initial、unset 或 revert）。这是一种撤销对样式所做更改的简便方法
blockquote {
    background-color: orange;
    border: 2px solid blue;
}
        
.fix-this {
    all: unset;
}
<blockquote>
    <p>This blockquote is styled</p>
</blockquote>

<blockquote class="fix-this">
    <p>This blockquote is not styled</p>
</blockquote>

一个选择器的优先级可以说是由三个不同的值（或分量）相加，可以认为是百（ID）十（类）个（元素）——三位数的三个位数：
ID：选择器中包含 ID 选择器则百位得一分。
类：选择器中包含类选择器、属性选择器或者伪类则十位得一分。
元素：选择器中包含元素、伪元素选择器则个位得一分。
通用选择器（*）、组合符（+、>、~、' '）和调整优先级的选择器（:where()）不会影响优先级。
否定（:not()）和任意匹配（:is()）伪类本身对优先级没有影响，但它们的参数则会带来影响。参数中，对优先级算法有贡献的参数的优先级的最大值将作为该伪类选择器的优先级。

选择器	ID	类	元素	优先级
h1	0	0	1	0-0-1
h1 + p::first-letter	0	0	3	0-0-3
li > a[href*="en-US"] > .inline-warning	0	2	2	0-2-2
#identifier	1	0	0	1-0-0
button:not(#mainBtn, .cta)	1	0	1	1-0-1

内联样式，即 style 属性内的样式声明，优先于所有普通的样式，无论其优先级如何
这样的声明没有选择器，但它们的优先级可以理解为 1-0-0-0；即无论选择器中有多少个 ID，它总是比其他任何优先级的权重都要高。

!important
有一个特殊的 CSS 可以用来覆盖所有上面所有优先级计算，不过需要很小心的使用——!important。用于修改特定属性的值，能够覆盖普通规则的层叠。
但是，强烈建议除了非常情况不要使用它。
覆盖 !important 唯一的办法就是另一个 !important 具有相同优先级而且顺序靠后，或者更高优先级。
在一种情况下，你可能不得不使用它：当你不能编辑核心的 CSS 模块，不能用任何其他方式覆盖，而你又真的想要覆盖一个样式时。但说真的，如果可以避免的话就不要用它。

级联层的顺序
在级联层中声明 CSS，优先级的顺序由声明层的顺序来决定
对于存在冲突的常规（没有 !important 声明）样式，后面的层比先前定义的层的优先级高。但对于带有 !important 标记的样式，其顺序相反——先前的层中的 important 样式比后面的层以及为在层中声明的 important 样式优先级要高。
但内联样式比所有作者定义的样式的优先级都要高，不受级联层规则的影响。
@layer firstLayer, secondLayer;

p { /* 0-0-1 */
  background-color: red;
  color: grey !important;
  border: 5px inset purple;
}
p#addSpecificity { /* 1-0-1 */
  border-style: solid !important;
}

@layer firstLayer {
  #addSpecificity { /* 1-0-0 */
    background-color: blue;
    color: white !important;
    border-width: 5px;
    border-style: dashed !important;
  }
}

@layer secondLayer {
  p#addSpecificity { /* 1-0-1 */
    background-color: green;
    color: orange !important;
    border-width: 10px;
    border-style: dotted !important;
  }
}     
<p id="addSpecificity">
  A paragraph with a border and background
</p>
如果你修改示例中 CSS 的第一行为 @layer secondLayer, firstLayer;，就会修改层声明的顺序，所有 firstLayer 中的 important 样式会被 secondLayer 中的冲突值覆盖。

layer间的优先级，比选择器优先级具有更高的权重
@layer base,application;

@layer application {
    em {
        color: red;
    }
}

@layer base {
    .item em {
        color: green;
    }
}
从选择器优先级的角度来看，.item em是比em这个标签选择器优先级高的，但是从layer来看，application优先级高于base，所以<em>的颜色最后是红色。

非 @layer 包裹的样式，就算写在其他layer之前，也拥有比 @layer 包裹样式更高的优先级。
匿名层指的是不声明layer名的级联层，它在级联层中的优先级，取决于layer声明次序

@layer A {
  @layer B{
    ...
  }
}
等价于
@layer A.B {
  ...
}

A 的优先级是高于 A.B 的:
{
    div {
        background: blue;
    }
    
    @layer B {
        div {
            background: red;
        }
    }
}

@layer A {
    div {
        background: blue;
    }
    @layer B {
        div {
        background: red;
        }
    }
}
@layer C {
    div {
        background: bisque;
    }
    @layer D {
        div {
        background: green;
        }
    }
}
优先级从高到低：@layer C > @layer C.D > @layer A > @layerA.B


==================================================
块级盒子 (block box) 和 内联盒子 (inline box):
这两种盒子会在页面流（page flow）和元素之间的关系方面表现出不同的行为

一个被定义成块级的（block）盒子会表现出以下行为:
盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽
每个盒子都会换行
width 和 height 属性可以发挥作用
内边距（padding）, 外边距（margin）和 边框（border）会将其他元素从当前盒子周围“推开”

如果一个盒子对外显示为 inline，那么他的行为如下:
盒子不会产生换行。
width 和 height 属性将不起作用。
垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开。
水平方向的内边距、外边距以及边框会被应用且会把其他处于 inline 状态的盒子推开。

我们通过对盒子display 属性的设置，比如 inline 或者 block ，来控制盒子的外部显示类型。

css 的 box 模型有一个外部显示类型，来决定盒子是块级还是内联。
同样盒模型还有内部显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照 **正常文档流 **布局，也意味着它们和其他块元素以及内联元素一样
我们可以通过使用类似 flex 的 display 属性值来更改内部显示类型。如果设置 display: flex，在一个元素上，外部显示类型是 block，但是内部显示类型修改为 flex。
盒子的所有直接子元素都会成为 flex 元素，会根据弹性盒子（Flexbox）规则进行布局

CSS 中组成一个块级盒子需要:
Content box: 这个区域是用来显示内容，大小可以通过设置 width 和 height.
Padding box: 包围在内容区域外部的空白区域；大小通过 padding 相关属性设置。
Border box: 边框盒包裹内容和内边距。大小通过 border 相关属性设置。
Margin box: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 margin 相关属性设置。

在标准模型中，如果你给盒设置 width 和 height，实际设置的是 content box。padding 和 border 再加上设置的宽高一起决定整个盒子的大小。

margin 不计入实际大小 —— 当然，它会影响盒子在页面所占空间，但是影响的是盒子外部空间。盒子的范围到边框为止 —— 不会延伸到 margin。

外边距折叠:
如果你有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小。

盒子模型和内联盒子:
在一个段落中使用了<span>，并对其应用了宽度、高度、边距、边框和内边距。可以看到，宽度和高度被忽略了。外边距、内边距和边框是生效的，但它们不会改变其他内容与内联盒子的关系，因此内边距和边框会与段落中的其他单词重叠。
span {
  margin: 20px;
  padding: 20px;
  width: 80px;
  height: 50px;
  background-color: lightblue;
  border: 2px solid blue;
}
<p>
    I am a paragraph and this is a <span>span</span> inside that paragraph. A span is an inline element and so does not respect width and height.
</p>     

display: inline-block
display 有一个特殊的值，它在内联和块之间提供了一个中间状态。这对于以下情况非常有用：您不希望一个项切换到新行，但希望它可以设定宽度和高度，并避免上面看到的重叠。
一个元素使用 display: inline-block，实现我们需要的块级的部分效果:
设置width 和height 属性会生效。
padding, margin, 以及border 会推开其他元素。

当您想要通过添加内边距使链接具有更大的命中区域时，这是很有用的。<a> 是像 <span> 一样的内联元素；你可以使用 display: inline-block 来设置内边距，让用户更容易点击链接。

==================================================