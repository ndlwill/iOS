TCP Segment（TCP 段）
TCP 层单位
由 TCP header + 数据(payload) 组成
TCP 会把应用层数据 拆分成多个 segment 发送，每个 segment 都有序号 (Sequence Number)
作用：可靠传输、流量控制、拥塞控制
特点：
不依赖 IP 分片
乱序到达时，TCP 可以根据序号重组
如果丢包，TCP 可以重传
类比：把一篇文章拆成一段段信件寄出去，每段都有编号


IP 分片（IP Fragmentation）
IP 层单位
当一个 IP 包大于 链路层 MTU 时，IP 层会把它拆成多个片 (fragment)
每个 fragment 都有 IP header + 部分 payload
作用：保证在不同链路上传输，不丢包
特点：
TCP segment 在 IP 层可能被拆成多个 fragment
接收端 IP 层重组，再交给 TCP 层
类比：信件太大，被邮局拆成小信封，每个小信封有序号，到达后再拼回完整信件


| 层级  | 单位          | 拆分原因        | 处理责任         |
| --- | ----------- | ----------- | ------------ |
| TCP | TCP Segment | 流量控制 & 拥塞控制 | TCP 栈重组 & 重传 |
| IP  | IP Fragment | 链路 MTU 限制   | IP 层重组       |


TCP segment：可能会乱序或丢失 → 你需要根据 TCP 序号重组
IP fragment：可能拆成多个 IP 包 → 你需要先把 IP 片段重组成完整 TCP segment

TCP 分片 = TCP segment（应用层拆分成段）
IP 分片 = IP layer 的 fragment（为了 MTU 拆分）


==================================================流程
应用层 → TCP
应用层传来的数据（比如 HTTP 请求 5KB）
TCP 栈会根据 最大报文段长度 (MSS, Maximum Segment Size) 拆分成若干 TCP segment
每个 segment 都有 TCP header + 部分数据

TCP → IP
TCP segment 被交给 IP 层
IP 层检查 MTU（链路最大传输单元）
如果 segment 太大，超过 MTU：
    IP 会把这个 segment 封装成 IP 包，然后 进一步拆成 IP fragment
每个 fragment 都有自己的 IP header，承载 segment 的一部分数据

接收端处理
IP 层：先把 IP fragment 重组为完整 IP 包
TCP 层：把 TCP segment 按序号重组为完整字节流
应用层：拿到完整应用数据


TCP Segment = TCP 层拆分的单元（逻辑拆分）
IP Fragment = IP 层拆分的单元（物理拆分，受 MTU 限制）
一个 TCP segment 可能会被拆成 多个 IP fragment 传输
接收端会先重组 IP fragment，再交给 TCP 栈按序号重组 TCP segment


类比：
写一封大信 → 分成几个信件段（TCP segment）
邮局发现信件太大 → 拆成小信封（IP fragment）
收信人先把小信封合并 → 再把信件段按顺序拼成完整信


==================================================拆分依据
TCP Segment 拆分依据
依赖参数：MSS (Maximum Segment Size)
作用：TCP 层为了控制每个 segment 的大小，以便高效可靠传输
计算方式：MSS ≈ MTU − IP header − TCP header
特点：
逻辑拆分应用层数据
受拥塞控制、流量控制影响
TCP segment 在 IP 层可能还是大于 MTU，需要 IP 分片

#####
计算方式：MSS ≈ MTU − IP header − TCP header
和
TCP segment 在 IP 层可能还是大于 MTU，需要 IP 分片
是否矛盾？

这里其实不是严格矛盾，而是 理论值 vs 实际情况的差异
1. MSS ≈ MTU − IP header − TCP header
MSS（Maximum Segment Size）是 TCP 在拆分应用层数据时建议的最大大小
TCP 会尝试让每个 segment 尽量 ≤ MSS
MSS 的计算公式：
MSS≈MTU−IP header−TCP header
目的是 避免 TCP segment 太大，超过链路 MTU，从而尽量避免 IP 层分片


2. TCP segment 在 IP 层可能还是 > MTU
为什么可能仍然超过 MTU？
（1）MSS 是端到端协商的值
如果两端没有正确协商 MSS，发送端可能用默认值或应用层给出的较大数据生成 segment
（2）路由路径 MTU 可能变化
TCP 发送端只知道自己链路 MTU，经过中间路由器的链路 MTU 更小 → IP 层仍然需要分片
（3）头部可变
TCP options 或 IP options 增加 header 长度，使 segment+header 超过 MTU

所以即便理论上 MSS ≈ MTU − IP header − TCP header，实际传输中仍有可能触发 IP 分片

结论：
MSS ≈ MTU − header 是 尽量避免 IP 分片的优化
但 TCP segment 在 IP 层可能 > MTU 是 实际网络中仍可能发生分片的情况
两者描述的是理论目标 vs 实际可能性，并不矛盾
#####



IP Fragment 拆分依据
依赖参数：MTU (Maximum Transmission Unit)
作用：链路层每个帧能承载的最大字节数
特点：
物理层限制导致的拆分
只关心 IP 层包大小
TCP segment 太大时，会拆成多个 IP fragment
接收端 IP 层负责重组 fragment

| 层级  | 单位       | 拆分依据 | 原因             |
| --- | -------- | ---- | -------------- |
| TCP | Segment  | MSS  | 流量控制、拥塞控制、可靠传输 |
| IP  | Fragment | MTU  | 链路层最大帧限制，保证能发送 |


MSS → TCP 逻辑拆分
MTU → IP 物理拆分
TCP segment 可能被 IP 分片（segment > MTU），但是 IP fragment 不会再由 TCP 拆分


==================================================IP 分片
IP 分片本质上就是一个 IP 包（IP packet），相当于就是一个原完整 IP packet 拆分后的一个 （分片 IP packet）

IP 分片的概念
当一个 IP 包的总长度超过链路 MTU 时，IP 层会把它拆成多个 fragment
每个 fragment 都是一个完整的 IP 包，包含：
IP 头部（version, src/dst, identification, fragment offset 等）
部分原始数据（payload）
注意：payload 可能只包含原 IP 包的一部分数据（如 TCP segment 的一部分）


假设原始 IP 包 3000 字节，MTU = 1500：
| Fragment | IP Header | Payload | 总长度   |
| -------- | --------- | ------- | ----- |
| 1        | 20B       | 1480B   | 1500B |
| 2        | 20B       | 1480B   | 1500B |
| 3        | 20B       | 40B     | 60B   |
每个 fragment 独立传输
接收端 IP 层根据 identification 和 fragment offset 重组成原始 IP 包

关键点
每个 fragment = 一个独立 IP 包
都可以单独路由 → fragment 可以经过不同链路或乱序到达
TCP segment 或 UDP 数据可能被拆成多个 fragment
IP fragment 重组由接收端 IP 层完成，上层 TCP/UDP 不感知

类比：
写一封大信 → 拆成小信封（每个小信封就是一个 IP fragment / IP 包）
每个信封都能单独寄送，但收信人会根据编号把它们拼回原信

总结为：
IP 分片 = IP packet
原始 IP 包 可能被拆成 多个 IP packet（fragment）
上层 TCP/UDP 只在收到完整 IP 包后才继续处理


==================================================MSS
MSS（Maximum Segment Size）是 TCP 协议端到端协商的值，它的来源既可以是系统默认，也可以通过代码设置

1. 系统默认 MSS
当你创建一个 TCP 连接时，操作系统 TCP 栈会根据本地网络接口的 MTU 自动计算一个默认 MSS：
MSS=MTU−IP header−TCP header
这个值是 系统内核自动设置的，应用程序通常不需要手动干预
举例：以太网 MTU = 1500 → 默认 MSS ≈ 1460

2. 端到端协商
TCP 使用 SYN 包中的 MSS 选项向对端通告自己能接受的最大 segment
对端也会在 SYN-ACK 中回传它的 MSS
最终 TCP 连接使用 双方协商后的 MSS（通常取两者最小值）

MSS 协商就是在三次握手时，通过 SYN/SYN-ACK 交换 MSS 选项来确定双方可接受的最大 TCP segment。

3. 应用/代码层能否设置 MSS
在大部分系统中，你 可以通过 socket 选项设置 MSS：
int sock = socket(AF_INET, SOCK_STREAM, 0);
int mss = 1200;
setsockopt(sock, IPPROTO_TCP, TCP_MAXSEG, &mss, sizeof(mss));
在 iOS/Swift 层，通常不直接设置 MSS，TCP 栈会自动管理

设置 MSS 的场景一般用于：
特殊网络（小 MTU）
避免 IP 分片
性能调优


| 来源    | 描述                                                  |
| ----- | --------------------------------------------------- |
| 系统默认  | 根据本地网络 MTU 自动计算                                     |
| 端到端协商 | SYN 包中协商 TCP MSS，取双方最小值                             |
| 代码设置  | 可以通过 socket 选项（TCP\_MAXSEG）设置，但 iOS/Swift app 通常不需要 |


总结：
MSS 既是 系统设置的默认值，也是 TCP 协议端到端协商的结果
在绝大多数 iOS 应用中，你 不需要手动设置 MSS，TCP 栈会自动处理