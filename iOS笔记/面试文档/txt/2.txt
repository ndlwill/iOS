https://www.jianshu.com/u/8d5b91490ca5

==========struct和class的区别:
swift中，class是引用类型，struct是值类型。值类型在传递和赋值时将进行复制，而引用类型则只会使用引用对象的一个"指向"。所以他们两者之间的区别就是两个类型的区别

class有这几个功能struct没有的：
class可以继承，这样子类可以使用父类的特性和方法
类型转换可以在runtime的时候检查和解释一个实例的类型
可以用deinit来释放资源
一个类可以被多次引用

struct也有这样几个优势：
结构较小，适用于复制操作，相比于一个class的实例被多次引用更加安全。
无须担心内存memory leak或者多线程冲突问题

C语言中，struct与的class的区别：
struct只是作为一种复杂数据类型定义，不能用于面向对象编程。
C++中，struct和class的区别：
对于成员访问权限以及继承方式，class中默认的是private的，而struct中则是public的。class还可以用于表示模板类型，struct则不行

==========观察者模式:
观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新
在IOS中典型的推模型实现方式为NSNotificationCenter和KVO

NSNotificationCenter:
观察者Observer，通过NSNotificationCenter的addObserver:selector:name:object接口来注册对某一类型通知感兴趣。在注册时候一定要注意，NSNotificationCenter不会对观察者进行引用计数+1的操作，我们在程序中释放观察者的时候，一定要去报从center中将其注销了。
通知中心NSNotificationCenter，通知的枢纽。
被观察的对象，通过postNotificationName:object:userInfo:发送某一类型通知，广播改变。
通知对象NSNotification，当有通知来的时候，Center会调用观察者注册的接口来广播通知，同时传递存储着更改内容的NSNotification对象


KVO:
KVO的全称是Key-Value Observer，即键值观察。是一种没有中心枢纽的观察者模式的实现方式。一个主题对象管理所有依赖于它的观察者对象，并且在自身状态发生改变的时候主动通知观察者对象。

注册观察者
[object addObserver:self forKeyPath:property options:NSKeyValueObservingOptionNew context:]。
更改主题对象属性的值，即触发发送更改的通知。
在制定的回调函数中，处理收到的更改通知。
注销观察者 [object removeObserver:self forKeyPath:property]。

==========
在一个HTTPS连接的网站里，输入账号密码点击登录后，到服务器返回这个请求前，中间经历了什么:

HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块
服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据

1. 客户端发起HTTPS请求
2. 服务端的配置
采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面
这套证书其实就是一对公钥和私钥
3. 传送证书
这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等
4. 客户端解析证书
这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密
5. 传送加密信息
这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了
6. 服务段解密信息
服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全
7. 传输加密后的信息
这部分信息是服务段用私钥加密后的信息，可以在客户端被还原
8. 客户端解密信息
客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策

SSL的位置
SSL介于应用层和TCP层之间。应用层数据不再直接传递给传输层，而是传递给SSL层，SSL层对从应用层收到的数据进行加密，并增加自己的SSL头

客户端打包请求。包括url，端口啊，你的账号密码等等。账号密码登陆应该用的是Post方式，所以相关的用户信息会被加载到body里面。这个请求应该包含三个方面：网络地址，协议，资源路径。注意，这里是HTTPS，就是HTTP + SSL / TLS，在HTTP上又加了一层处理加密信息的模块（相当于是个锁）。这个过程相当于是客户端请求钥匙。
服务器接受请求。一般客户端的请求会先发送到DNS服务器。 DNS服务器负责将你的网络地址解析成IP地址，这个IP地址对应网上一台机器。这其中可能发生Hosts Hijack和ISP failure的问题。过了DNS这一关，信息就到了服务器端，此时客户端会和服务器的端口之间建立一个socket连接，socket一般都是以file descriptor的方式解析请求。这个过程相当于是服务器端分析是否要向客户端发送钥匙模板。
服务器端返回数字证书。服务器端会有一套数字证书（相当于是个钥匙模板），这个证书会先发送给客户端。这个过程相当于是服务器端向客户端发送钥匙模板。
客户端生成加密信息。根据收到的数字证书（钥匙模板），客户端会生成钥匙，并把内容锁上，此时信息已经加密。这个过程相当于客户端生成钥匙并锁上请求。
客户端发送加密信息。服务器端会收到由自己发送出去的数字证书加锁的信息。 这个时候生成的钥匙也一并被发送到服务器端。这个过程是相当于客户端发送请求。
服务器端解锁加密信息。服务器端收到加密信息后，会根据得到的钥匙进行解密，并把要返回的数据进行对称加密。这个过程相当于服务器端解锁请求、生成、加锁回应信息。
服务器端向客户端返回信息。客户端会收到相应的加密信息。这个过程相当于服务器端向客户端发送回应。
客户端解锁返回信息。客户端会用刚刚生成的钥匙进行解密，将内容显示在浏览器上

https原理：证书传递、验证和数据加密、解密过程解析
https://blog.csdn.net/clh604/article/details/22179907

==========
在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么:

响应链大概有以下几个步骤:
设备将touch到的UITouch和UIEvent对象打包, 放到当前活动的Application的事件队列中
单例的UIApplication会从事件队列中取出触摸事件并传递给单例UIWindow
UIWindow使用hitTest:withEvent:方法查找touch操作的所在的视图view

RunLoop:
主线程的RunLoop被唤醒
通知Observer，处理Timer和Source 0
Springboard接受touch event之后转给App进程中
RunLoop处理Source 1，Source1 就会触发回调，并调用_UIApplicationHandleEventQueue() 进行应用内部的分发。
RunLoop处理完毕进入睡眠，此前会释放旧的autorelease pool并新建一个autorelease pool
