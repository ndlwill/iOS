http://www.cocoachina.com/ios/20180312/22536.html

// ###
https://github.com/NJHu

模块化

组件原则:
组件被定义为两种类型的组件：基础组件，业务组件。
基础组件可以被业务组件依赖，基础组件不可依赖业务组件。
业务组件不可依赖业务组件

① 基础组件
全局常量、常用宏、常用的分类、常用三方框架的隔离封装、还有一些比较常用的小功能类
② 功能组件
图片轮播器、图文菜单、视频中的弹幕、相机、录像、二维码、下载功能、个性定制的提示框等等，都可以封装在一个组件中
③ 业务模块
例如电商的购物车，订单管理、下单流程、个人中心
再例如视频或者直播的会员管理、视频播放全屏，右下角小屏幕，缓存等等

组件形式： 每个组件都是以pod库的形式存在


分层架构，都会保持上层对下层的单项依赖
例如我们用的平时用的AFNetworking就是如此：AFHTTPSession依赖于AFURLSession，AFURLSession依赖于NSURLSession，NSURLSession依赖于CFNetwork，这些依赖都是单向的
=============================
###
这两种中间件方案都实现了组件对中间件单向依赖
结构基本一致，都将业务分成了调用方、中间件和服务方
###

URLRoute+Procotol：

需要注册组件，通过注册组件使得服务方可以被中间件发现
调用方通过URL调用服务方页面，URL和服务方页面的关系通过路由表映射，路由表需要人工维护(硬编码)，使用持续集成环境简化操作
调用方通过Procotol调用非页面类服务组件，可以传递复杂对象
Target-Action：

不需要注册组件，通过runtime+约定命名规范(硬编码)的方式查找服务方
区分本地调用和远程调用，本地调用通过Target-Action获取服务，同时为远程调用提供服务，远程调用的规则需约定好
参数传递统一用Dictionary实现，获取Dictionary内所需要的内容需要通过文档或者其他说明
通过category的形式拆分中间件的代码，使其分属不同组件
这两种方式谁优谁劣不好直接做判断，综合来看URLRoute+Procotol更适用于页面跳转这种业务较多的场景，同时配合持续集成环境，动态性更好(通过文本信息配置代替代码)，缺点是调用关系复杂，中间层比较庞大，需要配合持续集成环境才能有比较好的使用体验；Target-Action则更适合业务较杂的情况，核心代码很少，调用关系相对简单，缺点是硬编码场景较多，不过硬编码基本都在中间件里
