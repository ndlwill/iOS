gitignore.io:
https://www.toptal.com/developers/gitignore

sudo gem install cocoapods
gem list
sudo gem install cocoapods-acknowledgements
sudo gem uninstall cocoapods X.X.X

==================================================Podfile Syntax Reference
https://guides.cocoapods.org/syntax/podfile.html#post_install

==================================================含第三方库的组件
本地检测代码仓库是否有问题
pod lib lint xxx.podspec --allow-warnings --use-libraries

远程检测代码仓库是否有问题
pod spec lint xxx.podspec --allow-warnings --use-libraries

向远程代码索引库提交spec
pod trunk push xxx.podspec --allow-warnings --use-libraries

==================================================不含第三方库的组件
//本地检测代码仓库是否有问题
pod lib lint --allow-warnings --verbose

//远程检测代码仓库是否有问题
pod spec lint --allow-warnings --verbose

//向远程代码索引库提交spec
pod trunk push xxx.podspec --allow-warnings --verbose

==================================================私有库依赖私有库的
--allow-warnings //用它忽略警告
--verbose //打印执行过程详细信息
--use-libraries //表示使用静态库或者是framework，这里主要是解决当我们依赖一些framework库后校验提示找不到库的时候用到。
--sources=https://github.com/CocoaPods/Specs //如果库依赖了三方的pod库需要设置，可以设置私有库

验证远程spec文件是否有问题:
pod spec lint WYLoginModule.podspec --sources='https://gitee.com/BIMComponent/BIMRepo.git,https://github.com/CocoaPods/Specs.git' --allow-warnings --use-libraries 
pod spec lint xxx.podspec --sources ='repo1 url, repo2 url' --allow-warnings --use-libraries 

验证远程代码库:
pod lib lint WYLoginModule.podspec --sources='https://gitee.com/BIMComponent/BIMRepo.git,https://github.com/CocoaPods/Specs.git' --allow-warnings --use-libraries 
pod lib lint xxx.podspec --sources ='repo1 url, repo2 url' --allow-warnings --use-libraries

上传私有库:
1.   pod trunk me
看上传的私有库是否在列表中
如果不存在，就要在次上传此私有库
pod trunk push xxx.podspec --allow-warnings --use-libraries
上传本地:
pod repo push WYRepo WYLoginModule.podspec --sources='https://gitee.com/BIMComponent/BIMRepo.git,https://github.com/CocoaPods/Specs.git' --allow-warnings --use-libraries 
pod repo push XXXRepo xxx.podspec --sources ='repo1 url, repo2 url' --allow-warnings --use-libraries

上传完成之后:
rm ~/Library/Caches/CocoaPods/search_index.json
pod repo update

eg:
// podspec 设置依赖
s.dependency '私库'
s.dependency 'MBProgressHUD'
s.dependency 'Masonry'

// 本地校验
pod lib lint --verbose --use-libraries --allow-warnings
// 同时依赖私库和公共库，直接本地校验会出错，
 
// 校验podspec文件时会到远程podspec库查找相关依赖，默认只会到官方specs库校验，此时需要指定远程specs库去校验。----sources指定源
pod spec lint JKDJ_UIKit.podspec --verbose --use-libraries --allow-warnings --sources='https://私库.git,https://github.com/CocoaPods/Specs.git'

==================================================流程
pod lib lint -> git commit -> git push -> git tag -> git push --tag -> pod spec lint -> pod push

==================================================多target项目CocoaPods更新
在修改podfile并且pod install之后，复制的target会出现找不到头文件的情况
用abstract_target关键字添加一个不存在的target作为公用版，最下面增加项目中实际存在的target，表示共用上面的库
platform :ios, '8.0'

# Import CocoaPods sources
source 'https://github.com/CocoaPods/Specs.git'

abstract_target 'CommonPods' do

   pod 'AFNetworking'
   pod 'MJExtension'
   pod 'MJRefresh'
   pod 'SDWebImage'
   pod 'MBProgressHUD'
   pod 'IQKeyboardManager'
   pod 'Masonry'
   # 通讯录
   pod 'LJContactManager'
   # 选项卡
   pod 'BRPickerView'
   # 相机
   pod 'PureCamera'
   # 美洽客服
   pod 'Meiqia', '~> 3.4.3'
   # U-Share SDK UI模块（分享面板，建议添加）
   pod 'UMengUShare/UI'
   # 集成微信
   pod 'UMengUShare/Social/WeChat'
   # web 桥接
   pod 'WebViewJavascriptBridge', '~> 5.0'
   # 连连支付
   pod 'LLPay'
   # 极光
   pod 'JPush', '~> 3.0.6'
   
target 'jiebao'
target 'yingjidai'
target 'huawuque'
       
end
CommonPods是项目中不存在的自定义target名，最下面三个（jiebao、yingjidai、huawuque）是实际存在的target，
下面三个target共用了CommonPods中所有的三方库，每添加一个target再执行一遍pod install即可

==================================================cocoapods引入MJRefresh 
use_frameworks!的情况下: 
print(Bundle.main.bundlePath)
let bundle = Bundle(for: MJRefreshGifHeader.self)
print(bundle.bundlePath)

/Users/youdone-ndl/Library/Developer/CoreSimulator/Devices/B2F2E516-D85C-431B-B009-08ED2325EE37/data/Containers/Bundle/Application/4C1B2699-266B-4DB1-880C-48F225D20F67/TestGA.app
/Users/youdone-ndl/Library/Developer/CoreSimulator/Devices/B2F2E516-D85C-431B-B009-08ED2325EE37/data/Containers/Bundle/Application/4C1B2699-266B-4DB1-880C-48F225D20F67/TestGA.app/Frameworks/MJRefresh.framework


分别在app，framework（dynamic library），static lib中定义了三个类，并调用bundleForClass方法输出:
app -> app bundle
framework -> framework bundle
static lib -> app bundle

==================================================cocoapods
sudo gem install cocoapods
CocoaPods是专门为iOS工程提供第三方依赖库的管理工具
CocoaPods 通过一个名为 XXX.xcconfig 的文件来在编译时设置所有的依赖和参数。
CocoaPods是用 Ruby 写的

CocoaPod的核心组件:
CocoaPods/CocoaPod
这是一个面向用户的组件，每当执行一个 pod 命令时，这个组件都将被激活。该组件包括了所有使用 CocoaPods 涉及到的功能，并且还能通过调用所有其它的 gems 来执行任务。

CocoaPods/Core
Core 组件提供支持与 CocoaPods 相关文件的处理，文件主要是 Podfile 和 podspecs。
Podfile
Podfile 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 Podfile 指南。
Podspec
.podspec 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、framework、编译选项和某个库所需要的依赖等。

CocoaPods/Xcodeproj
这个 gem 组件负责所有工程文件的整合。它能够创建并修改 .xcodeproj 和 .xcworkspace 文件。它也可以作为单独的一个 gem 包使用。如果你想要写一个脚本来方便地修改工程文件，那么可以使用这个 gem。

如何直接引用第三方库中的头文件？
在用CocoaPods集成第三方库之后，默认情况下，我们需要使用类似#import <XXX/YYY.h>的方式引入第三方库的头文件。
我们可以在Build Settings -> User Header Search Paths中添加${SRCROOT}并设置成recursive，这样我们就可以直接使用#impot "YYY.h"这种方式了。

CocoaPods: 手动改动动态库为静态库后的问题
我们在执行了pod install之后，CocoaPods会在主工程的Build Phase添加一个 [CP] Embed Pods Frameworks脚本：
这个脚本会在Build之后执行。
我们静态化后，把三方库install_framework相关的代码注释

install_framework到底是干嘛的?
# Copies and strips a vendored framework
install_framework()
{
  # 设置source变量，三方库构建之后的路径
  if [ -r "${BUILT_PRODUCTS_DIR}/$1" ]; then
    local source="${BUILT_PRODUCTS_DIR}/$1"
  elif [ -r "${BUILT_PRODUCTS_DIR}/$(basename "$1")" ]; then
    local source="${BUILT_PRODUCTS_DIR}/$(basename "$1")"
  elif [ -r "$1" ]; then
    local source="$1"
  fi
  
  # 设置destination变量，三方库需要移动到的路径
  local destination="${TARGET_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}"
  
  # 判断source是否为链接文件，需要指向原来的文件
  if [ -L "${source}" ]; then
    echo "Symlinked..."
    source="$(readlink "${source}")"
  fi
  
  # rsync --delete无差异同步，可以简单理解为网盘同步，或者复制
  # 想详细了解rsync，可以在命令行中输入man rsync
  # 这里相当于把source的文件(文件夹)同步到destination
  # 即把*.framework复制到Frameworks文件夹下
  # Use filter instead of exclude so missing patterns don't throw errors.
  echo "rsync --delete -av "${RSYNC_PROTECT_TMP_FILES[@]}" --filter \"- CVS/\" --filter \"- .svn/\" --filter \"- .git/\" --filter \"- .hg/\" --filter \"- Headers\" --filter \"- PrivateHeaders\" --filter \"- Modules\" \"${source}\" \"${destination}\""
  rsync --delete -av "${RSYNC_PROTECT_TMP_FILES[@]}" --filter "- CVS/" --filter "- .svn/" --filter "- .git/" --filter "- .hg/" --filter "- Headers" --filter "- PrivateHeaders" --filter "- Modules" "${source}" "${destination}"
  
  # 下面是找到二进制文件，即framework的Mach-O
  local basename
  basename="$(basename -s .framework "$1")"
  binary="${destination}/${basename}.framework/${basename}"

  if ! [ -r "$binary" ]; then
    binary="${destination}/${basename}"
  elif [ -L "${binary}" ]; then
    echo "Destination binary is symlinked..."
    dirname="$(dirname "${binary}")"
    binary="${dirname}/$(readlink "${binary}")"
  fi
  
  # 去掉无效的架构
  # Strip invalid architectures so "fat" simulator / device frameworks work on device
  if [[ "$(file "$binary")" == *"dynamically linked shared library"* ]]; then
    strip_invalid_archs "$binary"
  fi
  
  # 进行代码签名
  # Resign the code if required by the build settings to avoid unstable apps
  code_sign_if_enabled "${destination}/$(basename "$1")"
  
  # Swift的运行时库，Xcode 7之后就用不到了，可以不管
  # Embed linked Swift runtime libraries. No longer necessary as of Xcode 7.
  if [ "${XCODE_VERSION_MAJOR}" -lt 7 ]; then
    local swift_runtime_libs
    swift_runtime_libs=$(xcrun otool -LX "$binary" | grep --color=never @rpath/libswift | sed -E s/@rpath\\/\(.+dylib\).*/\\1/g | uniq -u)
    for lib in $swift_runtime_libs; do
      echo "rsync -auv \"${SWIFT_STDLIB_PATH}/${lib}\" \"${destination}\""
      rsync -auv "${SWIFT_STDLIB_PATH}/${lib}" "${destination}"
      code_sign_if_enabled "${destination}/${lib}"
    done
  fi
}
如果把这部分注释了，相当于说不会把构建好的 *.framework包复制到App的Frameworks文件夹下，自然 *.framework中的资源文件也就丢失了。
我们构建之后利用脚本把资源拷贝到App文件夹下不就好了。
install_framework_bundle()
{
    # 设置source变量，三方库构建之后的路径
    if [ -r "${BUILT_PRODUCTS_DIR}/$1" ]; then
      local source="${BUILT_PRODUCTS_DIR}/$1"
    elif [ -r "${BUILT_PRODUCTS_DIR}/$(basename "$1")" ]; then
      local source="${BUILT_PRODUCTS_DIR}/$(basename "$1")"
    elif [ -r "$1" ]; then
      local source="$1"
    fi

    # 设置destination变量，三方库需要移动到的路径
    local destination="${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}"

    # 遍历framework下的文件，找到bundle和图片，有其他资源自己改一下
    for filename in `ls ${source} | grep ".*\.bundle\|.*\.jpg\|.*\.jpeg\|.*\.png"`
    do
      full_path=${source}/${filename}
      # 把资源同步到Main Bundle中
      rsync -abrv --suffix .conflict "${full_path}" "${destination}"
    done
}

现在我们的操作就是把被静态化的三方库从install_framework方法改为install_framework_bundle：
if [[ "$CONFIGURATION" == "Debug" ]]; then
  install_framework_bundle "${BUILT_PRODUCTS_DIR}/Pod1/Pod1.framework"
  install_framework_bundle "${BUILT_PRODUCTS_DIR}/Pod2/Pod2.framework"
fi
if [[ "$CONFIGURATION" == "Release" ]]; then
  install_framework_bundle "${BUILT_PRODUCTS_DIR}/Pod1/Pod1.framework"
  install_framework_bundle "${BUILT_PRODUCTS_DIR}/Pod2/Pod2.framework"
fi


-b --suffix .conflict会把重名文件添加后缀 .conflict，这个后缀是可配的。
处理完你可以用find扫一遍App文件夹，看一下有没有重名的资源被 .conflict标记出来
check_conflict()
{
    local destination="${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}"
    conflict_list=`find ${destination} -regex '.*\.conflict'`
    conflict_list=(${conflict_list/ /})
    count=${#conflict_list[*]}
    if [ $count -gt 0 ]; then
        echo "Found conflicts:"
        for var in ${conflict_list[@]}
        do
           echo $var
        done
        exit 1
    fi
}
如果资源重名，可能就没方法静态化了。

==================================================cocoapods使用总结
https://guides.cocoapods.org/using/the-podfile.html

一个工程多个target引入CocoaPods的方式:
（推荐）方式一：通过abstract方式引入
#targetA: [AFNetworking,Masonry]
#targetB:[AFNetworking,SDWebImage]
abstract_target 'abstract_pod' do  #这里的abstract_pod在实际targets中不存在，是虚拟
    pod 'AFNetworking'
    
    target 'targetA' do
        pod 'Masonry'
    end
    
    target 'targetB' do
        pod 'SDWebImage'
    end
end

方式二：循环target 添加pod
#多个target的pod引入，方式一：如每个pod都引入masonry
targetArray = ['target1','target2']
targetArray.each do |t|
    target t do
        pod 'Masonry', '~> 1.1.0'
    end
end

方式三：提取公共pods 各个target引入
#多个target的pod引入，方式二：如每个pod都引入masonry
#添加索引库索引文件地址
source 'https://github.com/LGLee/MySpaces.git'
source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '9.0'

#多个target的pod引入
def commonPods
    pod 'Masonry', '~> 1.1.0'
end

#工程一：
target 'AnyDoorDemo' do
    commonPods
    pod 'AFNetworking', '~> 3.2.1'
    
    #测试相关↓
   target 'AnyDoorDemoTests' do
      inherit! :search_paths
      pod 'Specta', '~> 1.0.7'
      pod 'OCMock', '~> 3.4.2'
      pod 'Expecta', '~> 1.0.6'
   end

  target 'AnyDoorDemoUITests' do
    inherit! :search_paths
    # Pods for testing
  end
end

#工程二：
target 'HostApp' do
    commonPods
end


==================================================使用CocoaPods管理SDK
https://guides.cocoapods.org/making/making-a-cocoapod.html

删除仓库：
pod repo remove CodeBaseSpecs
更新仓库：
pod repo update CodeBaseSpecs

有时候当你使用pod update时会发现特别慢，那是因为pod会默认先更新一次podspec索引。使用--no-repo-update参数可以禁止其做索引更新操作。
pod update --no-repo-update

--verbose:
意思是打印详细信息

--only-errors和--allow-warnings:
--allow-warnings是允许warning的存在，也就是说当你在pod lib lint验证podspec的时候，如果不加这句，而你的代码里又一些警告的话，是验证不通过的。
而加上这句话的话，有警告也能验证通过。
--only-errors这句话是只显示出错误，就是你在验证的时候就算--allow-warnings，但是那些warnings也还是会打印出来和errors混杂在一起，
这会让你很难找error。所以这里使用--only-errors来只打印error，不打印warning

--fail-fast:
出现第一个错误的时候就停止

--use-libraries:
pod在提交或验证的时候如果用到的第三方中需要使用.a静态库文件的话，则会用到这个参数。如果不使用--use-libraries则会验证不通过。
但是比如你用swift创建了一个pod的话，你使用--use-libraries就会报错，因为swift开始，生成的就不是.a静态库了，它是不支持编译为静态库的，
只能生成.Framework动态库。下面就是swift的pod使用--use-libraries时的报错：
ERROR | [iOS] unknown: Encountered an unknown error (Pods written in Swift can only be integrated as frameworks; add use_frameworks! to your Podfile or target to opt into using it. The Swift Pod being used is: Socialite) during validation.

给Pod添加资源文件:
在 podspec 中，我们利用 s.source_files 来指定要编译的源代码文件。但是一些资源文件如图片、nib、plist等要怎么办呢？这里有两种方式：s.resources和s.resource_bundles。
s.resources和s.resource_bundles的区别主要是后者在上面代码[NSBundle bundleForClass:<#ClassFromPodspec#>]中得到的那个bundle对象下面再生成一个.bundle资源文件夹，
相较于s.resources直接平铺的方式更好的组织了文件，避免资源文件命名冲突。
s.resource_bundles = {
'PodTest'(.bundle文件名) => 'PodTest/Assets/*.{png,xib,plist}'
}
Podfile使用use_frameworks!
编译后资源文件会在test.app/Frameworks/PodName.framework下的PodTest.bundle目录下
NSBundle *bundle = [NSBundle bundleForClass:<#ClassFromPodspec#>];
[UIImage imageWithContentsOfFile:[bundle pathForResource:@"PodTest.bundle/imageName@2x" ofType:@"png"]];
Podfile不使用use_frameworks!
编译后资源文件会在test.app下的PodTest.bundle目录下
[UIImage imageNamed:@"PodTest.bundle/imageName"];
//下面这种也可以
NSBundle *bundle = [NSBundle bundleForClass:<#ClassFromPodspec#>];
[UIImage imageWithContentsOfFile:[bundle pathForResource:@"PodTest.bundle/imageName@2x" ofType:@"png"]];
使用s.resources方式
s.resources = ['PodTest/Assets/*.{png,xib,plist}']
注意切换resources和resource_bundles测试的时候要把工程clear一下，不然的话之前的位置那些编译过的资源文件还会存在。

初始化一个Podspec文件:
pod spec create MyTest

/**
 ###私有库###
 pod repo
 github创建私有Specs仓库 https://github.com/ndlwill/CodeBaseSpecs
 pod repo add CodeBaseSpecs https://github.com/ndlwill/CodeBaseSpecs
 github创建私有代码库仓库 https://github.com/ndlwill/ndl-ios-sdk
 pod lib create ndl-ios-sdk
 可以将多个XX.podspec和XX目录的源码全放在ndl-ios-sdk
 
 git init
 git add .
 git commit -m "提交描述"
 git remote add origin 远程私有库地址
 // 第一次push如果报错的话可以加上-f
 git push origin master
 git tag '0.1.0'
 git push --tags
 
 pod lib lint Utilities.podspec --private
 pod spec lint Utilities.podspec --private

 // 这个命令有两个作用：
第一：在本地repo/CodeBaseSpecs仓库添加我们的podspec文件
第二：在我们的远端存放podspec仓库里push最新的podspec文件
 pod repo push 索引库的本地名称 xx.podspec
 pod repo push CodeBaseSpecs Utilities.podspec

 pod spec相对于pod lib会更为精确，pod lib相当于只验证一个本地仓库，pod spec会同时验证本地仓库和远程仓库。

 source 官方索引库url
 source 私有索引库url
 pod '组件名称'
 pod install
 */

搜不到私有库？
pod repo update privateSpecs

==================================================私有库问题总结
1.关于第三方库支持 的cpu的框架
Undefined symbols for architecture i386:
ld: symbol(s) not found for architecture i386
cup的框架 : arm64 x86_64 armv7 armv7s i386
s.xcconfig = { 'VALID_ARCHS' => 'arm64 x86_64 armv7 armv7s' }

2.第三方含有 静态库(.a) 和 动态库(.framework)
///添加
s.static_framework = true

3.自己引进 静态库(.a) 和 动态库(.framework)
s.vendored_libraries  = 'UC_IM/Classes/Lib/*.{a}' /// 该目录下 .a
s.vendored_framework  = 'UC_IM/Classes/Framework/***.framework'  ///Framework目录下的***.framework动态库

4.私有库使用子模块
如果你想引用一个私有库里面的一小部分功能，但是又不想把整个库导入，那么私有库的子模块 ,外部单独依赖这个子模块

子模块的定义，也还是在.podspec文件中
#子模块 —— 头文件
s.subspec 'Header' do |ss|
   ss.source_files = 'UC_IM/Classes/Header/*.{h,m}'
end
使用子模块时只需在podfile中添加  pod 'UC_IM/header' 

5.使用私有库的分支和本地库
主工程podfile
pod 'Ucoupon',:git => 'http://git.hnbangyao.com/ios', :branch => 'dev' #直接使用远程库的branchName最新提交，而不是通过XXXRepo索引库中的tag标签
使用本地的仓库
pod 'Ucoupon',:path => '/Users/MacBook/Project/UC_IM' #直接使用本地库, '/Users/MacBook/Project/UC_IM' 是私有库在本地的目录，这种更方便于开发。

6.直接使用头文件 像PCH文件一样
s.prefix_header_contents = '#import <Masonry/Masonry.h>','#import "header.h"'

7.公共库需要多人操作
//添加管理者
pod trunk add-owner xxx_Mediator xxxxxxxxxxx@qq.com
//删除管理者
pod trunk remove-owner xxx_Mediator xxxxxxxxxxx@qq.com

8.私有库含有swift文件
验证私有库不能使用 --use-libraries  
不能使用静态库的验证

==================================================s.subspec
一般一个大的项目写成pod的时候，它可能会分为多个subspec，这样的话当你用一个庞大的库时，只需要其中的一小部分，那么就可以使用其中的某个subspec了。

我们拿AFNetworking.podspec来看，比如只引入其中的Reachability

pod 'AFNetworking/Reachability'
或者
pod 'AFNetworking',:subspecs=>['Reachability','Security']
所以一般subspec之间最好不要有互相依赖，不然的话，你用了其中一个subspec，而它其中一个文件依赖了另一个你未引入的subspec中的文件的话是会报错的。

如果有多个subspec互相依赖的话，可以像AFNetworking.podspec里这样写，UIKit依赖于NSURLSession
s.subspec 'NSURLSession' do |ss|
    //省略一大段代码
end

s.subspec 'UIKit' do |ss|
    ss.ios.deployment_target = '7.0'
    ss.tvos.deployment_target = '9.0'
    ss.dependency 'AFNetworking/NSURLSession'

    ss.public_header_files = 'UIKit+AFNetworking/*.h'
    ss.source_files = 'UIKit+AFNetworking'
end


PODS:
  - AFNetworking (3.0.0):
    - AFNetworking/NSURLSession (= 3.0.0)
    - AFNetworking/Reachability (= 3.0.0)
    - AFNetworking/Security (= 3.0.0)
    - AFNetworking/Serialization (= 3.0.0)
    - AFNetworking/UIKit (= 3.0.0)
  - AFNetworking/NSURLSession (3.0.0):
    - AFNetworking/Reachability
    - AFNetworking/Security
    - AFNetworking/Serialization
  - AFNetworking/Reachability (3.0.0)
  - AFNetworking/Security (3.0.0)
  - AFNetworking/Serialization (3.0.0)
  - AFNetworking/UIKit (3.0.0):
    - AFNetworking/NSURLSession
DEPENDENCIES:
  - AFNetworking (= 3.0)
SPEC CHECKSUMS:
  AFNetworking: 932ff751f9d6fb1dad0b3af58b7e3ffba0a4e7fd

PODFILE CHECKSUM: f38d14cf91adf9e2024f841ce5336dae96aa6fa6

COCOAPODS: 1.2.0.beta.1


#####s.subspec互相之间的依赖问题#####
当你把源码分为多个s.subspec的时候，其实是需要在对应的subspec下面做依赖的，如下面这样：
s.subspec 'ViewController' do |ss|
     ss.source_files = 'PodName/ViewController/*.{h,m}'
end

s.subspec 'View' do |ss|
     ss.source_files = 'PodName/View/*.{h,m}'
end
如上面这样写的话(ViewController中有文件依赖于View)，你在本地编译安装pod库其实是不会报错的。
但是如果你要pod spec lint的验证这个podspec，它会报错，提示'ViewController'中某个文件找不到引用View中的文件。
其实pod在做检查的时候会把ViewController和View当做两个独立的spec，如果ViewController中有使用View中的文件的话，需要添加依赖关系，如下这样就是正确的。
s.subspec 'ViewController' do |ss|
     ss.source_files = 'PodName/ViewController/*.{h,m}'
     ss.dependency 'PodName/View'
end

s.subspec 'View' do |ss|
     ss.source_files = 'PodName/View/*.{h,m}'
end

==================================================pod install和pod update的区别
源码:
https://github.com/CocoaPods/CocoaPods/blob/1.2.0.beta.1/lib/cocoapods/command/install.rb#L32
https://github.com/CocoaPods/CocoaPods/blob/1.2.0.beta.1/lib/cocoapods/command/update.rb#L47

//是否更新repo索引
install.rb默认不更新
update.rb默认更新
我们就常常会使用pod update --no-repo-update来禁止更新repo

update.rb 独有的，因为有个命令是更新某个特定的pod用的。pod update podName
pod update podName的时候会去Podfile.lock文件检查这个pod是否安装过，如果没有安装过会抛出异常
但是如果直接pod update的话就算Podfile.lock中没有某个pod，这是不会抛出异常，它会默认帮你先安装好，然后写入到Podfile.lock文件中。

//installer.update表示是否更新pod。
install.rb默认不更新
update.rb默认更新
pod update默认是更新pod的，而pod install是不更新的。
但是这是相对于pod 'SDWebImage', '~>3.8.0'这样的写法来用的。比如原来已经安装过3.8.0版本，Podfile.lock中就为3.8.0版本，满足~>3.8.0这个条件，那么pod install的时候是是不会更新到最新版的。
但是pod update会更新到最新版，同时改写Podfile.lock中的版本号为最新版。

而pod 'SDWebImage', '3.8.1'这种写法的话，pod install和pod update是一样的。比如Podfile.lock中原来为3.8.0版本，那么不管怎样都是不等于'3.8.1'的。
pod install的时候就会重新安装'3.8.1'版本，同时改写Podfile.lock中的版本号为'3.8.1'

https://guides.cocoapods.org/using/pod-install-vs-update.html
主要就是说pod install用在adding/removing pods的时候。而当你需要更新pods的时候使用pod update
还有最好把你的Podfile.lock文件提交到版本管理中，要不然，就会破坏整个逻辑，没有了Podfile.lock限制你的Pods中的库的版本。

==================================================第一次pod setup特别慢
利用shadowsocks的socks5代理，配置好后明显加速。用下面两条命令配置好后，保持shadowsocks客户端开启就行了。
//shadowsocks的本地端口默认是1080
git config --global http.proxy 'socks5://127.0.0.1:1080' 
git config --global https.proxy 'socks5://127.0.0.1:1080'
然后用下面这种直接clone的方式能够看到进度
cd ~/.cocoapods/repos
git clone https://github.com/CocoaPods/Specs.git

==================================================Podfile 语法
https://guides.cocoapods.org/syntax/podfile.html#podfile
https://guides.cocoapods.org/syntax/podfile.html#post_install

----------Podfile 的全局配置：
install!
CocoaPods 安装此 Podfile（也就是执行 pod install/update） 时，指定要使用的安装方法和选项。
第一个参数表示要使用的安装方法；下一个参数表示安装选项。
目前唯一可用的安装方法是 'cocoapods'，所以总要将其第一个参数。但未来版本中可能会提供更多的安装方法。

指定自定义的 CocoaPods 安装选项：
install! 'cocoapods',
         :deterministic_uuids => false,
         :integrate_targets => false

支持的命令：
:clean
:deduplicate_targets
:deterministic_uuids
:integrate_targets
:lock_pod_sources
:share_schemes_for_development_pods

----------依赖:
Podfile 会指定每个 target 的依赖关系。

pod:
pod 指定了项目的依赖关系，一般通过 Pod 库名称和可选的版本来定义。
若需要最新版本的 Pod 库，则只需要省略掉版本即可
= 0.1 0.1 版本。
> 0.1 高于 0.1 的任意版本。
>= 0.1 0.1 及更高版本。
< 0.1 低于 0.1 的任意版本。
<= 0.1 0.1 及更低版本。
~> 0.1.2 介于 0.1.2（包含）和 0.2（不包含） 之间的版本，同时会选择满足条件的最高版本。相当于满足 >= 0.1.2 且 < 0.2.0 条件的最高版本。

可以参考:
https://guides.rubygems.org/patterns/#semantic-versioning

构建配置:
默认情况下，target 的所有 build configuration 都会安装依赖。有时出于调试目的或其他原因，只能将依赖安装在部分 build configuration 中。
pod 'PonyDebugger', :configurations => ['Debug', 'Beta']
或者，也可以指定将其包含在单个 build configuration 中。
pod 'PonyDebugger', :configurations => 'Debug'
注意，依赖库是会传递的。有时候需要根据情况手动指定 build configurations。

Subspecs:
通过名字进行 Pod 安装时，会安装其 podspec 中指定的默认 subspecs。
可以通过以下方式安装 subspec：
pod 'QueryKit/Attribute'
也可以指定多个 subspec：
pod 'QueryKit', :subspecs => ['Attribute', 'QuerySet']
依赖也可以从外部指定。

使用本地路径的依赖:
如果项目和 Pod 库同时进行开发，则可以使用 path 选项。
pod 'AFNetworking', :path => '~/Documents/AFNetworking'
使用这个选项，CocoaPods 将把给定的目录作为 Pod 的根目录，并且会将其 Pods 项目中的文件关联起来。这样的话，每次编辑都会对 CocoaPods 产生影响。
请注意，目录中应该包含 Pod 库的 podspec 文件。

使用指定地址的 pod 库:
有时可能需要使用最新版本或特别修改过的 Pod。这种情况下，可以指定 pod 库的地址。
使用依赖库的 master 分支：
pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git'
使用依赖库的另一个分支：
pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :branch => 'dev'
使用 tag：
pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :tag => '0.7.0'
指定某次提交：
pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :commit => '082f8319af'
注意，这也要满足其他 Pod 库的依赖。

podspec 一般位于仓库的根目录中。如果仓库不包含 podspec 文件，就必须使用以下方法。
从外部获取 podspec:
可以考虑从外部获取 podspec，比如说通过 HTTP：
pod 'JSONKit', :podspec => 'https://example.com/JSONKit.podspec'

podspec:
如果没有指定 podspec 参数，则使用 Podfile 根目录中的第一个 podspec。

参数
options Hash {Symbol=>String}
加载 podspec 的路径。如果未提供，则使用 Podfile 目录中的第一个 podspec。

例如：
podspec
podspec :name => 'QuickDialog'
podspec :path => '/Documents/PrettyKit/PrettyKit.podspec'

target：
与 Xcode 的 target 对应，可以指定依赖的作用域。默认情况下，target 会包含外部定义的依赖，除非设置不要 inherit!。

参数
name Symbol, String
target 的名称

例如：
定义 target
target 'ZipApp' do
  pod 'SSZipArchive'
end

定义通过父级访问 SSZipArchive 的测试 target
target 'ZipApp' do
  pod 'SSZipArchive'

  target 'ZipAppTests' do
    inherit! :search_paths
    pod 'Nimble'
  end
end

父 target 的 Pods 应用于多个子 target：
target 'ShowsApp' do
  pod 'ShowsKit'

  # Has its own copy of ShowsKit + ShowTVAuth
  target 'ShowsTV' do
    pod 'ShowTVAuth'
  end

  # Has its own copy of Specta + Expecta
  # and has access to ShowsKit via the app
  # that the test target is bundled into

  target 'ShowsTests' do
    inherit! :search_paths
    pod 'Specta'
    pod 'Expecta'
  end
end

abstract_target:
定义一个新的抽象目标，它可以方便的用于目标依赖继承。

参数
name Symbol, String
target 的名称

定义抽象 target

abstract_target 'Networking' do
  pod 'AlamoFire'

  target 'Networking App 1'
  target 'Networking App 2'
end

定义包含多个 target 的 abstract_target
# 注意：workspace 的 Xcode 项目中并没有名为 "Shows" 的 target
abstract_target 'Shows' do
  pod 'ShowsKit'

  # ShowsiOS 包含 ShowsKit（继承）和添加的 ShowWebAuth
  target 'ShowsiOS' do
    pod 'ShowWebAuth'
  end

  # ShowsTV  包含 ShowsKit（继承）和添加的 ShowTVAuth
  target 'ShowsTV' do
    pod 'ShowTVAuth'
  end

  # ShowsTests 包含 Specta 和 Expecta，同时也作为 Shows 的子 target，引入了 ShowsKit
  target 'ShowsTests' do
    inherit! :search_paths
    pod 'Specta'
    pod 'Expecta'
  end
end

abstract!
表示当前目标是抽象的，因此不会直接链接到 Xcode 的 target。

inherit!
设置当前 target 的继承模式。

参数
inheritance Symbol
要设置的继承模式。
可用的模式：:complete target 继承父级的所有行为。:none target 不会继承父级的行为。:search_paths target 只继承父级的 search paths。

target 'App' do
  target 'AppTests' do
    inherit! :search_paths
  end
end

inherit! :search_paths
明确指定继承于父层的所有pod，默认就是继承的

----------Target configuration
这些设置用于控制 CocoaPods 生成的项目。

需要描述项目适用的 platform。xcodeproj 文件允许明确指定要链接的项目。

platform:
用于指定应建立的静态库的平台。如果不指定，则使用默认的配置

参数
name Symbol
平台名称，可以为，:osx，:ios，:tvos 以及 :watchos。
target String, Version
可选。不设置的话将使用默认配置。

指定平台
platform :ios, '4.0'
platform :ios

project:
默认情况下是没有指定的，当没有指定时，会使用Podfile目录下与target同名的工程
# JYCocoaPodsTest这个Target只有在JYCocoaPodsTest工程中才会链接
target 'JYCocoaPodsTest' do
project 'JYCocoaPodsTest'
...
end

###为 target 指定项目###

还可以指定是否这些设置在 release 或者 debug 模式下生效，参数为 :release 或 :debug。

参数
Path String
项目链接的路径
build_configurations Hash{String => symbol}
键值对。键为 Xcode 项目中的 build configurations 名称，值为基于 :debug 或 :release 配置的 Symbols。如果没有设置的话，默认为 :release。

指定用户项目
# FastGPS 项目中包含此 target
target 'MyGPSApp' do
  project 'FastGPS'
  ...
end

# 相同 Podfile 下，多个 Xcode 项目
target 'MyNotesApp' do
  project 'FastNotes'
  ...
end

使用自定义构建配置
project 'TestProject', 'Mac App Store' => :release, 'Test' => :debug

inhibit_all_warnings!
禁止来自 CocoaPods 库的所有警告。
该属性由子 target 定义继承。

如果每个 pod 库都想禁用警告，则可以使用：
pod 'SSZipArchive', :inhibit_warnings => true

此外，当使用 inhibit_all_warnings！ 属性时，也可以排除某个不禁用警告的库：
pod 'SSZipArchive', :inhibit_warnings => false

use_frameworks!
使用 frameworks 代替静态库。
该属性由子 target 定义继承。

----------Workspace
指定应该包含所有projects的Xcode workspace
如果没有显示指定workspace并且在Podfile所在目录只有一个project，那么project的名称会被用作于workspace的名称
如果没有指定明确的 Xcode workspace，并且 Podfile 同目录下只有一个项目，那么将使用该项目的名称作为 workspace 的名称。

参数
path String
workspace 的路径。

例如：
指定 workspace
workspace 'MyWorkspace'

----------Sources
用来指定 Pod 库的来源。Sources 是全局的，并且不由 target 自己定义。
源是顺序相关的。CocoaPods 将使用包含 Pod 的第一个源的 Pod 的最高版本（无视其他源是否有更高版本）。
官方的 CocoaPods 源是隐士包含的。一旦指定另一个来源，那么它将会包括在。

参数
source String
源地址

例如：
指定首先使用 Artsy 库，然后使用 CocoaPods 的 Master 库
source 'https://github.com/artsy/Specs.git'
source 'https://github.com/CocoaPods/Specs.git'

----------Hooks
Podfile 提供了可以在安装过程中调用的钩子。钩子是全局的，并且不由 target 自己定义。

plugin:
指定了安装期间应使用的插件，以及在调用时应该传递给插件的选项。

参数
name String
插件的名字
options Hash
钩子被调用时应该传递给插件的可选选项。

例如：
指定使用 slather 和 cocoapods-keys 插件。
plugin 'cocoapods-keys', :keyring => 'Eidolon'
plugin 'slather'

pre_install:
这个挂钩允许下载完成之后，但是在安装之前对 Pod 进行修改。
接受 Pod::Installer 作为唯一参数。

例如：
Podfile 中定义 pre-install 钩子
pre_install do |installer|
  # Do something fancy!
end

post_install:
允许生成的 Xcode 项目被写入磁盘之前进行最后的修改，或者执行其他的任务。
接受 Pod::Installer 作为唯一参数。

例如：
自定义所有 target 的构建设置
post_install do |installer|
  installer.pods_project.targets.each do |target|
    target.build_configurations.each do |config|
      config.build_settings['GCC_ENABLE_OBJC_GC'] = 'supported'
    end
  end
end


==========
target 'JYTest' do
pod 'JYPodTest', :path => '~/Desktop/JYPodTest'  # 指定路径
#pod 'JYPodTest', :podspec => '~/Desktop/JYPodTest/JYPodTest.podspec'  #指定podspec文件
end

==================================================创建动态库项目这里以 wx 举例
动态库依赖静态库具有吸附性，那么我们可以自定义一个动态库把微信这种静态库吸附进来。对外整体呈现的是动态库特性。其他的组件依赖我们自定义的动态库。

按照微信的官方文档。添加依赖库
将wx的PublicHeader暴露出来，注意由于我并没有使用到wx相关API所以链接器帮我们链接动态库的时候可能并不会把wx静态库吸附进来。我们手动在build Setting的other link flags加上-all_load标记
在Schema里面跳转编译配置为Release，并且选择所有的CPU架构
于是我们有了我们自己的私有动态库LJWXSDK

其实加在EmbededBinaries里面的东西其实会被复制一份到xx.app里面，所以这个名字起得还是不错的直译就是嵌入的框架

#import<> : 通过build setting里面中的header Search Path里面去找
#import"" : 第一步先搜索user Header search Path再搜索 header search Path 。所以对我们的framework来说，CocoaPod帮我们加到了Header search Path目前2种导入方式都是可以支持的。


配置是non-recursive。如果把non去掉意思就是我可以递归的去查找某些framework下面的头文件了。 但是Xcode的效率肯定就会有影响。还是不建议修改的好。

==================================================动/静态库混用封装组件化
https://guides.cocoapods.org/syntax/podspec.html

// cocoapods 1.4.0
Pod::Spec.new do |s|
s.name                  = 'XXXThirdPartSocial'
s.version               = '1.0'
s.summary               = '第三方社交模块'
s.homepage              = 'xxx.xxx.xxx'
s.license               = { :type => 'MIT'}
s.author                = { 'xxx' => 'xxx@163.com' }
s.source                = { :git => 'xxx.xxx.xxx', :tag => "#{s.version}" }
s.platform              = :ios, '7.0'
s.source_files          = ''
s.requires_arc          = true
s.ios.dependency    'UMengUShare/Social/ReducedQQ'
s.ios.dependency    'UMengUShare/Social/ReducedWeChat'
s.ios.dependency    'UMengUShare/Social/ReducedSina'
s.static_framework  =  true
end

// 或者cocoapods 1.3.1
把dependency一些静态库的pod拍平就是现在的解决方法，自己建pod，保证一层支持framework和.a,另外如果实在自己的pod里dependency的静态库pod，这个时候比较好的选择是建立subspec，直接subspec里面封装对静态库的支持。
这里支持的时候要分为3类，先放一个友盟分享的例子：友盟的framework 和.a都是静态库
Pod::Spec.new do |s|
s.name                  = 'XXXThirdPartSocial'
s.version               = '1.0'
s.summary               = '第三方社交模块'
s.homepage              = 'xxx.xxx.xxx'
s.license               = { :type => 'MIT'}
s.author                = { 'xxx' => 'xxx@163.com' }
s.source                = { :git => 'xxx.xxx.xxx', :tag => "#{s.version}" }
s.platform              = :ios, '7.0'
s.source_files          = ''
s.requires_arc          = true
#s.ios.dependency   'UMengUShare/Social/ReducedQQ'
#s.ios.dependency   'UMengUShare/Social/ReducedWeChat'
#s.ios.dependency   'UMengUShare/Social/ReducedSina'
s.subspec 'XXXThirdPartSocialVendor' do |sss|
sss.source_files            = ''
sss.resource                = 'UMSocialSDK/UMSocialSDKPromptResources.bundle'
sss.ios.vendored_frameworks = 'UMSocialSDK/UMSocialCore.framework','UMSocialSDK/UMSocialNetwork.framework'
sss.ios.vendored_library    = 'SocialLibraries/QQ/libSocialQQ.a','SocialLibraries/Sina/libSocialSina.a','SocialLibraries/WeChat/libSocialWeChat.a'
sss.ios.public_header_files   = 'SocialLibraries/**/*.{h}'
sss.ios.library  = 'sqlite3'
end
end


在cocoapods1.4 之前 对于pods库集成swift库 都是需要我们设置 !use_framework ，这样设置之后所有的pods库都必须使用动态库，但这就带来一个问题，如果我需要集成一个静态库怎么办？
1.升级pods
gem install cocoapods
2.自己组件库的podsepc 添加s.static_framework = true

==================================================https://guides.cocoapods.org/syntax/podspec.html
可参考
https://github.com/firebase/firebase-ios-sdk

----------Root specification
name: required
spec.name = 'AFNetworking'

version: required
spec.version = '0.0.1'

swift_versions:
spec.swift_versions = ['3.0']
spec.swift_versions = ['3.0', '4.0', '4.2']
spec.swift_version = '3.0'
spec.swift_version = '3.0', '4.0'

cocoapods_version:
spec.cocoapods_version = '>= 0.36'

author: required
spec.author = 'Darth Vader'
spec.authors = 'Darth Vader', 'Wookiee'
spec.authors = { 'Darth Vader' => 'darthvader@darkside.com',
                 'Wookiee'     => 'wookiee@aggrrttaaggrrt.com' }

license: required
spec.license = 'MIT'
spec.license = { :type => 'MIT', :file => 'MIT-LICENSE.txt' }
spec.license = { :type => 'MIT', :text => <<-LICENSE
                   Copyright 2012
                   Permission is granted to...
                 LICENSE
               }
Supported Keys:
:type
:file
:text

homepage: required
spec.homepage = 'http://www.example.com'

source: required
spec.source = { :git => 'https://github.com/AFNetworking/AFNetworking.git',
                :tag => spec.version.to_s }
Supported Keys:
:git => :tag, :branch, :commit, :submodules
:svn => :folder, :tag, :revision
:hg => :revision
:http => :flatten, :type, :sha256, :sha1, :headers

summary: required
spec.summary = 'Computes the meaning of life.'

screenshots:
spec.screenshot  = 'http://dl.dropbox.com/u/378729/MBProgressHUD/1.png'
spec.screenshots = [ 'http://dl.dropbox.com/u/378729/MBProgressHUD/1.png',
                     'http://dl.dropbox.com/u/378729/MBProgressHUD/2.png' ]

prepare_command:
If the pod is installed with the :path option this command will not be executed.
spec.prepare_command = 'ruby build_files.rb'
spec.prepare_command = <<-CMD
                        sed -i 's/MyNameSpacedHeader/Header/g' ./**/*.h
                        sed -i 's/MyNameOtherSpacedHeader/OtherHeader/g' ./**/*.h
                   CMD

static_framework:
spec.static_framework = true

deprecated:
spec.deprecated = true

----------Platform
The platform on which this Pod is supported. Leaving this blank means the Pod is supported on all platforms. When supporting multiple platforms you should use deployment_target below instead.

platform:
spec.platform = :osx, '10.8'
spec.platform = :ios
spec.platform = :osx

deployment_target
spec.ios.deployment_target = '6.0'
spec.osx.deployment_target = '10.8'

----------Build settings
In this group are listed the attributes related to the configuration of the build environment that should be used to build the library.
If not defined in a subspec the attributes of this group inherit the value of the parent.

dependency:
Any dependency on other Pods or to a ‘sub-specification’.
Dependencies can specify versions requirements. The use of the optimistic version indicator ~> is recommended because it provides good control over the version without being too restrictive. 
For example, ~> 1.0.1 is equivalent to >= 1.0.1 combined with < 1.1. Similarly, ~> 1.0 will match 1.0, 1.0.1, 1.1, but will not upgrade to 2.0.

Pods with overly restrictive dependencies limit their compatibility with other Pods.

spec.dependency 'AFNetworking', '~> 1.0'
spec.dependency 'AFNetworking', '~> 1.0', :configurations => ['Debug']
spec.dependency 'AFNetworking', '~> 1.0', :configurations => :debug
spec.dependency 'RestKit/CoreData', '~> 0.20.0'
spec.ios.dependency 'MBProgressHUD', '~> 0.5'

info_plist: multi-platform
Key-Value pairs to add to the generated Info.plist.
spec.info_plist = {
  'CFBundleIdentifier' => 'com.myorg.MyLib',
  'MY_VAR' => 'SOME_VALUE'
}

requires_arc: multi-platform
allows you to specify which source_files use ARC. This can either be the files which support ARC, or true to indicate all of the source_files use ARC.
Files which do not use ARC will have the -fno-objc-arc compiler flag.
The default value of this attribute is true.

spec.requires_arc = true

spec.requires_arc = false
spec.requires_arc = 'Classes/Arc'
spec.requires_arc = ['Classes/*ARC.m', 'Classes/ARC.mm']

frameworks: multi-platform
A list of system frameworks that the user’s target needs to link against.
spec.ios.framework = 'CFNetwork'
spec.frameworks = 'QuartzCore', 'CoreData'

weak_frameworks: multi-platform
A list of frameworks that the user’s target needs to weakly link against.
spec.weak_framework = 'Twitter'
spec.weak_frameworks = 'Twitter', 'SafariServices'

libraries: multi-platform
A list of system libraries that the user’s target (application) needs to link against.
spec.ios.library = 'xml2'
spec.libraries = 'xml2', 'z'

compiler_flags: multi-platform
A list of flags which should be passed to the compiler.
spec.compiler_flags = '-DOS_OBJECT_USE_OBJC=0', '-Wno-format'

pod_target_xcconfig: multi-platform
Any flag to add to the final private pod target xcconfig file.
spec.pod_target_xcconfig = { 'OTHER_LDFLAGS' => '-lObjC' }

user_target_xcconfig: multi-platform
Specifies flags to add to the final aggregate target xcconfig file, which propagates to non-overridden and inheriting build settings to the integrated user targets.
spec.user_target_xcconfig = { 'MY_SUBSPEC' => 'YES' }

prefix_header_contents: multi-platform
Any content to inject in the prefix header of the pod project.
This attribute is not recommended as Pods should not pollute the prefix header of other libraries or of the user project.
spec.prefix_header_contents = '#import <UIKit/UIKit.h>'
spec.prefix_header_contents = '#import <UIKit/UIKit.h>', '#import <Foundation/Foundation.h>'

prefix_header_file: multi-platform
spec.prefix_header_file = 'iphone/include/prefix.pch'
spec.prefix_header_file = false

module_name:
The name to use for the framework / clang module which will be generated for this specification instead of the default (header_dir if set, otherwise the specification name).
spec.module_name = 'Three20'

header_dir: multi-platform
spec.header_dir = 'Three20Core'

header_mappings_dir: multi-platform
A directory from where to preserve the folder structure for the headers files. If not provided the headers files are flattened.
spec.header_mappings_dir = 'src/include'

script_phases: multi-platform
This attribute allows to define a script phase to execute as part of compilation of the Pod. 
Unlike a prepare command, script phases execute as part of xcodebuild they can also utilize all environment variables that are set during compilation.
spec.script_phase = { :name => 'Hello World', :script => 'echo "Hello World"' }
spec.script_phase = { :name => 'Hello World', :script => 'echo "Hello World"', :execution_position => :before_compile }
spec.script_phase = { :name => 'Hello World', :script => 'puts "Hello World"', :shell_path => '/usr/bin/ruby' }
spec.script_phase = { :name => 'Hello World', :script => 'echo "Hello World"',
  :input_files => ['/path/to/input_file.txt'], :output_files => ['/path/to/output_file.txt']
}
spec.script_phase = { :name => 'Hello World', :script => 'echo "Hello World"',
  :input_file_lists => ['/path/to/input_files.xcfilelist'], :output_file_lists => ['/path/to/output_files.xcfilelist']
}
spec.script_phases = [
    { :name => 'Hello World', :script => 'echo "Hello World"' },
    { :name => 'Hello Ruby World', :script => 'puts "Hello World"', :shell_path => '/usr/bin/ruby' },
  ]

----------File patterns
Podspecs should be located at the root of the repository, and paths to files should be specified relative to the root of the repository as well. 
File patterns do not support traversing the parent directory ( .. ). File patterns may contain the following wildcard patterns:

Pattern: *
Matches any file. Can be restricted by other values in the glob.
* will match all files
c* will match all files beginning with c
*c will match all files ending with c
*c* will match all files that have c in them (including at the beginning or end)
Equivalent to /.*/x in regexp.
Note this will not match Unix-like hidden files (dotfiles). In order to include those in the match results, you must use something like {*,.*}.

Pattern: **
Matches directories recursively.

Pattern: ?
Matches any one character. Equivalent to /.{1}/ in regexp.

Pattern: [set]
Matches any one character in set.
Behaves exactly like character sets in Regexp, including set negation ([^a-z]).

Pattern: {p,q}
Matches either literal p or literal q.
Matching literals may be more than one character in length. More than two literals may be specified.
Equivalent to pattern alternation in regexp.

Pattern: \
Escapes the next meta-character.

Examples:
"JSONKit.?"    #=> ["JSONKit.h", "JSONKit.m"]
"*.[a-z][a-z]" #=> ["CHANGELOG.md", "README.md"]
"*.[^m]*"      #=> ["JSONKit.h"]
"*.{h,m}"      #=> ["JSONKit.h", "JSONKit.m"]
"*"            #=> ["CHANGELOG.md", "JSONKit.h", "JSONKit.m", "README.md"]

source_files: multi-platform
spec.source_files = 'Classes/**/*.{h,m}'
spec.source_files = 'Classes/**/*.{h,m}', 'More_Classes/**/*.{h,m}'

public_header_files: multi-platform
spec.public_header_files = 'Headers/Public/*.h'

private_header_files: multi-platform
spec.private_header_files = 'Headers/Private/*.h'

vendored_frameworks: multi-platform
The paths of the framework bundles that come shipped with the Pod.
spec.ios.vendored_frameworks = 'Frameworks/MyFramework.framework'
spec.vendored_frameworks = 'MyFramework.framework', 'TheirFramework.framework'

vendored_libraries: multi-platform
The paths of the libraries that come shipped with the Pod.
spec.ios.vendored_library = 'Libraries/libProj4.a'
spec.vendored_libraries = 'libProj4.a', 'libJavaScriptCore.a'

resource_bundles: multi-platform
This attribute allows to define the name and the file of the resource bundles which should be built for the Pod. 
They are specified as a hash where the keys represent the name of the bundles and the values the file patterns that they should include.
For building the Pod as a static library, we strongly recommend library developers to adopt resource bundles as there can be name collisions using the resources attribute.
The names of the bundles should at least include the name of the Pod to minimise the chance of name collisions.
spec.ios.resource_bundle = { 'MapBox' => 'MapView/Map/Resources/*.png' }
spec.resource_bundles = {
    'MapBox' => ['MapView/Map/Resources/*.png'],
    'MapBoxOtherResources' => ['MapView/Map/OtherResources/*.png']
  }

resources: multi-platform
A list of resources that should be copied into the target bundle.
For building the Pod as a static library, we strongly recommend library developers to adopt resource bundles as there can be name collisions using the resources attribute. 
Moreover, resources specified with this attribute are copied directly to the client target and therefore they are not optimised by Xcode.
spec.resource = 'Resources/HockeySDK.bundle'
spec.resources = ['Images/*.png', 'Sounds/*']

exclude_files: multi-platform
A list of file patterns that should be excluded from the other file patterns.
spec.ios.exclude_files = 'Classes/osx'
spec.exclude_files = 'Classes/**/unused.{h,m}'

preserve_paths: multi-platform
Any file that should not be removed after being downloaded.
By default, CocoaPods removes all files that are not matched by any of the other file pattern.
spec.preserve_path = 'IMPORTANT.txt'
spec.preserve_paths = 'Frameworks/*.framework'

module_map: multi-platform
The module map file that should be used when this pod is integrated as a framework.
By default, CocoaPods creates a module map file based upon the public headers in a specification.
spec.module_map = 'source/module.modulemap'

----------Subspecs
A library can specify a dependency on either another library, a subspec of another library, or a subspec of itself.

subspec:
Represents specification for a module of the library.
Subspecs participate on a dual hierarchy.
On one side, a specification automatically inherits as a dependency all it children ‘sub-specifications’ (unless a default subspec is specified).
On the other side, a ‘sub-specification’ inherits the value of the attributes of the parents so common values for attributes can be specified in the ancestors.

pod 'ShareKit', '2.0'
Installs ShareKit with all the sharers like ShareKit/Evernote, ShareKit/Facebook, etc, as they are defined as subspecs.
pod 'ShareKit/Twitter',  '2.0'
pod 'ShareKit/Pinboard', '2.0'
Installs ShareKit with only the source files for ShareKit/Twitter, ShareKit/Pinboard. Note that, in this case, the ‘sub-specifications’ to compile need the source files, 
the dependencies, and the other attributes defined by the root specification. CocoaPods is smart enough to handle any issues arising from duplicate attributes.

Examples:
Subspecs with different source files.
subspec 'Twitter' do |sp|
  sp.source_files = 'Classes/Twitter'
end

subspec 'Pinboard' do |sp|
  sp.source_files = 'Classes/Pinboard'
end

Subspecs referencing dependencies to other subspecs.
Pod::Spec.new do |s|
  s.name = 'RestKit'

  s.subspec 'Core' do |cs|
    cs.dependency 'RestKit/ObjectMapping'
    cs.dependency 'RestKit/Network'
    cs.dependency 'RestKit/CoreData'
  end

  s.subspec 'ObjectMapping' do |os|
  end
end

Nested subspecs.
Pod::Spec.new do |s|
  s.name = 'Root'

  s.subspec 'Level_1' do |sp|
    sp.subspec 'Level_2' do |ssp|
    end
  end
end

requires_app_host: multi-platform
Whether a test specification requires an app host to run tests. This only applies to test specifications.
test_spec.requires_app_host = true

app_host_name: multi-platform
The app specification to use as an app host, if necessary.

scheme: multi-platform
Specifies the scheme configuration to be used for this specification.
spec.scheme = { :launch_arguments => ['Arg1'] }
spec.scheme = { :launch_arguments => ['Arg1', 'Arg2'], :environment_variables => { 'Key1' => 'Val1'} }
Supported Keys:
:launch_arguments
:environment_variables
:code_coverage

test_spec:
Represents a test specification for the library. Here you can place all your tests for your podspec along with the test dependencies.
Examples:
Pod::Spec.new do |spec|
  spec.name = 'NSAttributedString+CCLFormat'

  spec.test_spec do |test_spec|
    test_spec.source_files = 'NSAttributedString+CCLFormatTests.m'
    test_spec.dependency 'Expecta'
  end
end

app_spec:
Represents an app specification for the library. Here you can place all your app source files for your podspec along with the app dependencies.
Examples:
Pod::Spec.new do |spec|
  spec.name = 'NSAttributedString+CCLFormat'

  spec.app_spec do |app_spec|
    app_spec.source_files = 'NSAttributedString+CCLFormat.m'
    app_spec.dependency 'AFNetworking'
  end
end

default_subspecs:
An array of subspecs names that should be used as preferred dependency. If not specified, a specification requires all of its subspecs as dependencies.
You may use the value :none to specify that none of the subspecs are required to compile this pod and that all subspecs are optional.
A Pod should make available the full library by default. Users can fine tune their dependencies, and exclude unneeded subspecs, once their requirements are known. 
Therefore, this attribute is rarely needed. It is intended to be used to select a default if there are ‘sub-specifications’ which provide alternative incompatible implementations, 
or to exclude modules rarely needed (especially if they trigger dependencies on other libraries).
Examples:
spec.default_subspec = 'Core'
spec.default_subspecs = 'Core', 'UI'
spec.default_subspecs = :none

----------Multi-Platform support
A specification can store values which are specific to only one platform.
For example one might want to store resources which are specific to only iOS projects.
spec.resources = 'Resources/**/*.png'
spec.ios.resources = 'Resources_ios/**/*.png'

ios
Provides support for specifying iOS attributes.
spec.ios.source_files = 'Classes/ios/**/*.{h,m}'

osx
Provides support for specifying OS X attributes.
spec.osx.source_files = 'Classes/osx/**/*.{h,m}'

macos
Provides support for specifying OS X attributes.
spec.osx.source_files = 'Classes/osx/**/*.{h,m}'

tvos
Provides support for specifying tvOS attributes.
spec.tvos.source_files = 'Classes/tvos/**/*.{h,m}'

watchos
Provides support for specifying watchOS attributes.
spec.watchos.source_files = 'Classes/watchos/**/*.{h,m}'




==================================================podspec
Pod::Spec.new do |s|

  s.name         = "YBImageBrowser"

  s.version      = "3.0.9"

  s.summary      = "iOS image browser / iOS 图片浏览器"

  s.description  = <<-DESC
  					iOS 图片浏览器，功能强大，易于拓展，极致的性能优化和严格的内存控制让其运行更加的流畅和稳健。
                   DESC

  s.homepage     = "https://github.com/indulgeIn"

  s.license      = "MIT"

  s.author       = { "杨波" => "1106355439@qq.com" }

  s.platform     = :ios, "8.0"

  s.source       = { :git => "https://github.com/indulgeIn/YBImageBrowser.git", :tag => "#{s.version}" }

  s.requires_arc = true

  s.default_subspec = "Core"

  s.subspec "Core" do |core|
    core.source_files   = "YBImageBrowser/**/*.{h,m}"
    core.resources      = "YBImageBrowser/YBImageBrowser.bundle"
    core.dependency 'YYImage'
    core.dependency 'SDWebImage', '>= 5.0.0'
  end
  s.subspec "NOSD" do |core|
    core.source_files   = "YBImageBrowser/**/*.{h,m}"
    core.exclude_files  = "YBImageBrowser/WebImageMediator/YBIBDefaultWebImageMediator.{h,m}"
    core.resources      = "YBImageBrowser/YBImageBrowser.bundle"
    core.dependency 'YYImage'
  end

  s.subspec "Video" do |video|
    video.source_files = "Video/*.{h,m}"
    video.resources    = "Video/YBImageBrowserVideo.bundle"
    video.dependency 'YBImageBrowser/Core'
  end
  s.subspec "VideoNOSD" do |video|
    video.source_files = "Video/*.{h,m}"
    video.resources    = "Video/YBImageBrowserVideo.bundle"
    video.dependency 'YBImageBrowser/NOSD'
  end

end

==================================================[Cocoapods]支持Swift静态库
// Cocoapods国内镜像
https://mirrors.tuna.tsinghua.edu.cn/help/CocoaPods/

混编，加use_frameworks!，OC引用全部报红
https://blog.cocoapods.org/
https://blog.cocoapods.org/CocoaPods-1.5.0/
https://stackoverflow.com/
Cocoapods在1.5.0版本就支持Swift以静态库的形式集成到项目中。

==================================================Cocoapods 1.7.0
从1.7.2开始，已经完全切到CDN上了。1.8以上甚至把CDN作为默认源
使用，在Podfile最上面添加即可
source 'https://cdn.cocoapods.org/'


一个功能是 Multiple Pod Projects:
install! 'cocoapods', :generate_multiple_pod_projects => true

install! 函数只能调用一次
需要注意 install! 是个用来配置的函数
install! 'cocoapods', generate_multiple_pod_projects: true
install! 'cocoapods', disable_input_output_paths: true
这么做之后发现不生效，后来才想起来 install! 是一个用来配置的函数，重复调用的话，只会以最后一次的调用为准。所以应该在一次调用里把它们都传入进去：
install! 'cocoapods', 
         disable_input_output_paths: true,
         generate_multiple_pod_projects: true

但是如果开启了 generate_multiple_pod_projects 的话，由于项目结构的变化，installer.pod_targets 就没办法获得所有 pods 引入的 target 了:
post_install do |installer|
  swift_4_0_compatible = [ ... ]
  swift_4_2_compatible = [ ... ]

  installer.pod_targets.each do |t|
    t.build_configurations.each do |c|
      c.build_settings['SWIFT_VERSION'] = '4.0' if swift_4_0_compatible.include? t.name
      c.build_settings['SWIFT_VERSION'] = '4.2' if swift_4_2_compatible.include? t.name
    end
  end
end


==================================================Cocoapods 1.8.0
project_name Podfile DSL

DSL 其实是 Domain Specific Language 的缩写,中文翻译为领域特定语言

install! 'cocoapods', :generate_multiple_pod_projects => true // 改变了库的依赖方式，之前是以Targets方式依赖

target 'MyApp' do
  use_frameworks!

  pod 'Moya', :project_name => 'Networking'// 改变依赖方式的同时，分组
  pod 'Alamofire', :project_name => 'Networking'
  pod 'Result', :project_name => 'Networking'

  target 'MyAppTests' do
    inherit! :search_paths
    pod 'OCMock', :project_name => 'Testing'
  end
end

分组project_name:
如果某一个库内部依赖了其他库，是不能分组到目的项目中的。不过问题也不是很大，如果真的较真，非要把它分出来。可以把内部依赖库再pod指向一下。

以YYWebImage为例子，内部依赖了YYCache、YYImage
pod 'YYWebImage', :project_name => 'Image'
复制代码如果只设置了YYWebImage到Image项目中去，那么YYCache、YYImage就会跑到外面去，可以把内部依赖也指向一下
pod 'YYWebImage', :project_name => 'Image'
pod 'YYCache', :project_name => 'Image'
pod 'YYImage', :project_name => 'Image'

==================================================Pod install (有点小缺陷，理解思想为主)
每次我们需要安装pod第三方库的时候，都需要:
先跳到终端
然后找到podfile所有路径
再执行pod install 或 pod update

解决办法:
创建一个PodInstall的脚本target，每次需要的时候，执行build这个脚本。

export PATH=/Users/xxxx/.rvm/rubies/ruby-2.6.3/bin:$PATH
pod install