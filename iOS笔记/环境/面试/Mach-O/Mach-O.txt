https://sourceforge.net/projects/machoview/
https://gitcode.com/gdbinit/MachOView/overview?utm_source=csdn_github_accelerator&isLogin=1

==================================================虚拟内存 & 物理内存
早期的数据访问是直接通过物理地址访问的，这种方式有以下两个问题:
1、内存不够用
2、内存数据的安全问题

内存不够用的方案：虚拟内存
针对问题1，我们在进程和物理内存之间增加一个中间层，这个中间层就是所谓的虚拟内存，主要用于解决当多个进程同时存在时，对物理内存的管理。
提高了CPU的利用率，使多个进程可以同时、按需加载。所以虚拟内存其本质就是一张虚拟地址和物理地址对应关系的映射表
每个进程都有一个独立的虚拟内存，其地址都是从0开始，大小是4G固定的，每个虚拟内存又会划分为一个一个的页（页的大小在iOS中是16K，其他的是4K），每次加载都是以页为单位加载的，进程间是无法互相访问的，保证了进程间数据的安全性。
一个进程中，只有部分功能是活跃的，所以只需要将进程中活跃的部分放入物理内存，避免物理内存的浪费
当CPU需要访问数据时，首先是访问虚拟内存，然后通过虚拟内存去寻址，即可以理解为在表中找对应的物理地址，然后对相应的物理地址进行访问
如果在访问时，虚拟地址的内容未加载到物理内存，会发生缺页异常（pagefault），将当前进程阻塞掉，此时需要先将数据载入到物理内存，然后再寻址，进行读取。这样就避免了内存浪费


内存数据的安全问题：ASLR技术
虚拟内存的起始地址与大小都是固定的，这意味着，当我们访问时，其数据的地址也是固定的，这会导致我们的数据非常容易被破解
所以苹果为了解决这个问题，在iOS4.3开始引入了ASLR技术。

ASLR的概念：(Address Space Layout Randomization ) 地址空间配置随机加载，是一种针对缓冲区溢出的安全保护技术，
通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。

其目的的通过利用随机方式配置数据地址空间，使某些敏感数据（例如APP登录注册、支付相关代码）配置到一个恶意程序无法事先获知的地址，令攻击者难以进行攻击。

由于ASLR的存在，导致可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，
所以需要在编译时来修复镜像中的资源指针，来指向正确的地址。即正确的内存地址 = ASLR地址 + 偏移值


==================================================可执行文件
不同的操作系统，其可执行文件的格式也不同。系统内核将可执行文件读取到内存，然后根据可执行文件的头签名（magic魔数）判断二进制文件的格式

其中PE、ELF、Mach-O这三种可执行文件格式都是COFF（Command file format）格式的变种，COFF的主要贡献是目标文件里面引入了“段”的机制，不同的目标文件可以拥有不同数量和不同类型的“段”。


==================================================通用二进制文件
因为不同CPU平台支持的指令不同，比如arm64和x86，苹果中的通用二进制格式就是将多种架构的Mach-O文件打包在一起，然后系统根据自己的CPU平台，选择合适的Mach-O，所以通用二进制格式也被称为胖二进制格式

// xnu
https://github.com/apple-oss-distributions/xnu/tags

通用二进制格式的定义在<mach-o/fat.h>中，可以在下载xnu，然后根据 xnu -> EXTERNAL_HEADERS ->mach-o中找到该文件
通用二进制文件开始的Fat Header是fat_header结构体，而Fat Archs是表示通用二进制文件中有多少个Mach-O，单个Mach-O的描述是通过fat_arch结构体

/*
 - magic：可以让系统内核读取该文件时知道是通用二进制文件
 - nfat_arch：表明下面有多个fat_arch结构体，即通用二进制文件包含多少个Mach-O
 */
struct fat_header {
    uint32_t    magic;      /* FAT_MAGIC */
    uint32_t    nfat_arch;  /* number of structs that follow */
};

/*
 fat_arch是描述Mach-O
 - cputype 和 cpusubtype：说明Mach-O适用的平台
 - offset（偏移）、size（大小）、align（页对齐）描述了Mach-O二进制位于通用二进制文件的位置
 */
struct fat_arch {
    cpu_type_t  cputype;    /* cpu specifier (int) */
    cpu_subtype_t   cpusubtype; /* machine specifier (int) */
    uint32_t    offset;     /* file offset to this object file */
    uint32_t    size;       /* size of this object file */
    uint32_t    align;      /* alignment as a power of 2 */
};
通用二进制文件是苹果公司提出的一种新的二进制文件的存储结构，可以同时存储多种架构的二进制指令，使CPU在读取该二进制文件时可以自动检测并选用合适的架构，以最理想的方式进行读取
由于通用二进制文件会同时存储多种架构，所以比单一架构的二进制文件大很多，会占用大量的磁盘空间，但由于系统会自动选择最合适的，不相关的架构代码不会占用内存空间，且执行效率高了
还可以通过指令来进行Mach-O的合并与拆分
查看当前Mach-O的架构：lipo -info MachO文件
合并：lipo -create MachO1 MachO2 -output 输出文件路径
拆分：lipo MachO文件 –thin 架构 –output 输出文件路径


==================================================Mach-O文件
Mach-O文件是Mach Object文件格式的缩写，它是用于可执行文件、动态库、目标代码的文件格式。
作为a.out格式的替代，Mach-O格式提供了更强的扩展性，以及更快的符号表信息访问速度

熟悉Mach-O文件格式，有助于更好的理解苹果底层的运行机制，更好的掌握dyld加载Mach-O的步骤。

查看Mach-O文件，可以通过以下两种方式:
(1)otool 是苹果提供的一个命令行工具，用于查看和分析 macOS 和 iOS 应用程序的二进制文件（如可执行文件和库）。它可以显示文件的各种详细信息，包括但不限于文件头、段、节、符号表、动态库依赖关系等。
otool -l Mach-O文件名
(2)MachOView工具
将Mach-O可执行文件拖动到MachOView工具打开

Mach-O文件格式:
对于 OS X 和 iOS 来说，Mach-O是其可执行文件的格式，主要包括以下几种文件类型
