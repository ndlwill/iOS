@property：帮我们自动生成属性的setter和getter方法的声明
@synthesize：帮我们自动生成setter和getter方法的实现以及下划线成员变量（私有）

在 iOS 6 之后 LLVM 编译器引入了 “property autosynthesis”，即属性自动合成。
换句话说，就是编译器会自动为每个@property添加@synthesize，我们不用写了。
具体流程
1、自动合成 getter, setter： 编译器会自动检查，如果没有手动实现，会自动添加 getter，setter，如果实现了，则不做处理
2、自动指定变量名字：@synthesize age = _age;
3、变量_age 自动添加 @private 关键字 私有
4、getter方法名 age setter方法名 setAge

那些情况下自动合成会失效
1、同时重写了 setter 和 getter
2、使用了 @dynamic
3、在 @protocol 中定义的所有属性
4、在 category 中定义的所有属性

@dynamic
告诉编译器不用自动进行@synthesize，等到运行时再添加方法实现，但是它不会影响@property生成的setter和getter方法的声明。

==================================================1. 离屏渲染
屏幕上最终显示的数据有两种加载流程:
正常渲染加载流程
离屏渲染加载流程
他们之间的区别就是离屏渲染比正常渲染多了一个离屏缓冲区

正常渲染流程:
APP中的数据经过CPU计算和GPU渲染后，将结果存放在帧缓冲区，利用视频控制器从帧缓冲区中取出，并显示到屏幕上。
在GPU的渲染流程中，显示到屏幕上的图像是遵循大画家算法按照由远及近的顺序，依次将结果存储到帧缓冲区
视屏控制器从帧缓冲区中读取一帧数据，将其显示到屏幕上后，会立即丢弃这帧数据，不会做任何保留，这样做的目的是可以节省空间，且在屏幕上是各自显示各自的，互相不影响。

离屏渲染流程:
当App需要进行额外的渲染和合并时，例如按钮设置圆角，我们是需要对UIButton这个控件中的所有图层都进行圆角+裁剪，
然后再将合并后的结果存入帧缓存区，再从帧缓存中取出交由屏幕显示，这时，在正常的渲染流程中，我们是无法做到对所有图层进行圆角裁剪的，因为它是用一个丢一个。
所以我们需要提前将处理好的结果放入离屏缓冲区，最后将几个图层进行叠加合并，存放到站缓冲区，最后屏幕上就是我们想实现的效果。

离屏缓存区就是一个临时的缓冲区，用来存放在后续操作使用，但目前并不使用的数据。

离屏渲染再给我们带来方便的同时，也带来了严重的性能问题。
由于离屏渲染中的离屏缓冲区，是额外开辟的一个存储空间，当它将数据转存到Frame Buffer时，也是需要耗费时间的，所以在转存的过程中，仍有掉帧的可能。

离屏缓冲区的空间并不是无限大的， 它是又上限的，最大只能是屏幕的2.5倍

那为什么我们明知有性能问题时，还是要使用离屏渲染呢？
可以处理一些特殊的效果，这种效果并不能一次就完成，需要使用离屏缓冲区来保存中间状态，不得不使用离屏渲染，这种情况下的离屏渲染是系统自动触发的，
例如经常使用的圆角、阴影、高斯模糊、光栅化等
可以提升渲染的效率，如果一个效果是多次实现的，可以提前渲染，保存到离屏缓冲区，以达到复用的目的。这种情况是需要开发者手动触发的。

光栅化:
When the value of this property is YES, the layer is rendered as a bitmap in its local coordinate space and then composited to the destination with any other content.
当我们开启光栅化时，会将layer渲染成位图保存在缓存中，这样在下次使用时，就可以直接复用，提高效率。
针对光栅化的使用，有以下几个建议:
如果layer不能被复用，则没有必要开启光栅化
如果layer不是静态，需要被频繁修改（例如动画过程中），此时开启光栅化反而影响效率
离屏渲染缓存内容有时间限制，如果100ms内没有被使用，那么就会丢弃，无法进行复用
离屏渲染的缓存空间有限，是屏幕的2.5倍，超过2.5倍屏幕像素大小的话也会失效，无法实现复用


CALayer的构成
它是由backgroundColor、contents、borderWidth&borderColor构成的
圆角中离屏渲染的触发时机:
官方文档告诉我们，设置cornerRadius只会对CALayer中的backgroundColor 和 boder设置圆角，不会设置contents的圆角，
如果contents需要设置圆角，需要同时将maskToBounds / clipsToBounds设置为true。

圆角设置不生效: 必须要设置masksToBounds为 true
// 根本原因是没有对contents设置圆角，而按钮设置的image是放在contents里面的，所以看到的界面上的就是image没有进行圆角裁剪。
let btn0 = UIButton(type: .custom)
btn0.frame = CGRect(x: 100, y: 60, width: 100, height: 100)
//设置圆角
btn0.layer.cornerRadius = 50
//设置border宽度和颜色
btn0.layer.borderWidth = 2
btn0.layer.borderColor = UIColor.red.cgColor
self.view.addSubview(btn0)
//设置背景图片
btn0.setImage(UIImage(named: "mouse"), for: .normal)

圆角设置中什么时候会离屏渲染触发?
(1)仅设置背景颜色+border
let btn01 = UIButton(type: .custom)
btn01.frame = CGRect(x: 100, y: 200, width: 100, height: 100)
//设置圆角
btn01.layer.cornerRadius = 50
//设置border宽度和颜色
btn01.layer.borderWidth = 4
btn01.layer.borderColor = UIColor.red.cgColor
self.view.addSubview(btn01)
//设置背景颜色
btn01.backgroundColor = UIColor.green
在这种情况下，无论是使用默认的maskToBounds / clipsToBounds（false），还是将其修改为true，都不会触发离屏渲染，
究其根本原因是 contents中没有需要圆角处理的layer。

(2)按钮设置背景图片+boder
let btn0 = UIButton(type: .custom)
btn0.frame = CGRect(x: 100, y: 60, width: 100, height: 100)
//设置圆角
btn0.layer.cornerRadius = 50
//设置border宽度和颜色
btn0.layer.borderWidth = 2
btn0.layer.borderColor = UIColor.red.cgColor
self.view.addSubview(btn0)
//设置背景图片
btn0.setImage(UIImage(named: "mouse"), for: .normal)
使用默认的maskToBounds / clipsToBounds（false）
这种情况就是最开始我们讲到的圆角设置不生效的情况
maskToBounds / clipsToBounds 修改为true
此时触发了离屏渲染
是因为圆角的设置是需要对所有layer都进行裁剪的，而maskToBounds裁剪是应用到所有layer上的。
如果从正常渲染的角度来说，一个个layer是用完即扔的。而现在我们的圆角设置需要3个layer叠加合并的，
所以将先处理好的layer保存在离屏缓冲区，等到最后一个layer处理完，合并进行圆角+裁剪，所以才会触发离屏渲染


当只设置backgroundColor、border，而contents中没有子视图时，无论maskToBounds / clipsToBounds是true还是false，都不会触发离屏渲染,但是这种情况在UIImageView中并不适用
当UIImageView中只设置图片+maskToBounds / clipsToBounds是不会触发离屏渲染
苹果对UIImageView优化我想也只是将image直接画在了contents上面这样不设置背景色其实只需要渲染一个layer,所以不需要用到离屏缓冲区
如果此时再加上背景色，就会触发离屏渲染。
综合来说，离屏渲染是否触发，在于我们是否需要使用离屏缓冲区


==================================================2. 屏幕卡顿的原因
主要有以下三种原因:
(1)CPU和GPU在渲染的流水线中耗时过长，导致从缓存区获取位图显示时，下一帧的数据还没有准备好，获取的仍是上一帧的数据，产生掉帧现象，掉帧就会导致屏幕卡顿
(2)苹果官方针对屏幕撕裂问题，目前一直使用的方案是垂直同步+双缓存区，可以从根本上防止和解决屏幕撕裂，但是同时也导致了新的问题掉帧。
虽然我们采用了双缓存区，但是我们并不能解决CPU和GPU处理图形图像的速度问题，导致屏幕在接收到垂直信号时，数据尚未准备好，缓存区仍是上一帧的数据，因此导致掉帧
(3)在垂直同步+双缓存区的方案上，再次进行优化，将双缓存区，改为三缓存区，这样其实也并不能从根本上解决掉帧的问题，只是比双缓存区掉帧的概率小了很多，仍有掉帧的可能性，对于用户而言，可能是无感知的。

==================================================3. UIView和CALayer的关系
UIView基于UIKit框架，可以处理用户触摸事件，并管理子视图
CALayer基于CoreAnimation，而CoreAnimation是基于QuartzCode的。所以CALayer只负责显示，不能处理用户的触摸事件
从父类来说，CALayer继承的是NSObject，而UIView是直接继承自UIResponder的，所以UIVIew相比CALayer而言，只是多了事件处理功能，
从底层来说，UIView属于UIKit的组件，而UIKit的组件到最后都会被分解成layer，存储到图层树中
在应用层面来说，需要与用户交互时，使用UIView，不需要交互时，使用两者都可以

==================================================4. 自定义类的 alloc & init & new
(1)
//alloc源码分析-第一步
+ (id)alloc {
    return _objc_rootAlloc(self);
}

(2)
//alloc源码分析-第二步
id
_objc_rootAlloc(Class cls)
{
    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);
}

(3)
static ALWAYS_INLINE id
callAlloc(Class cls, bool checkNil, bool allocWithZone=false)// alloc 源码 第三步
{
#if __OBJC2__ //有可用的编译器优化
    /*
     参考链接：https://www.jianshu.com/p/536824702ab6
     */
    
    // checkNil 为false，!cls 也为false ，所以slowpath 为 false，假值判断不会走到if里面，即不会返回nil
    if (slowpath(checkNil && !cls)) return nil;
    
    //判断一个类是否有自定义的 +allocWithZone 实现，没有则走到if里面的实现
    if (fastpath(!cls->ISA()->hasCustomAWZ())) {
        return _objc_rootAllocWithZone(cls, nil);
    }
#endif

    // No shortcuts available. // 没有可用的编译器优化
    if (allocWithZone) {
        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);
    }
    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));
}

slowpath & fastpath
其中关于slowpath和fastpath这里需要简要说明下，这两个都是objc源码中定义的宏
//x很可能为真， fastpath 可以简称为 真值判断
#define fastpath(x) (__builtin_expect(bool(x), 1)) 
//x很可能为假，slowpath 可以简称为 假值判断
#define slowpath(x) (__builtin_expect(bool(x), 0)) 

其中的__builtin_expect指令是由gcc引入的，
1、目的：编译器可以对代码进行优化，以减少指令跳转带来的性能下降。即性能优化
2、作用：允许程序员将最有可能执行的分支告诉编译器。
3、指令的写法为：__builtin_expect(EXP, N)。表示 EXP==N的概率很大。
4、fastpath定义中__builtin_expect((x),1)表示 x 的值为真的可能性更大；即 执行if 里面语句的机会更大
5、slowpath定义中的__builtin_expect((x),0)表示 x 的值为假的可能性更大。即执行 else 里面语句的机会更大
6、在日常的开发中，也可以通过设置来优化编译器，达到性能优化的目的，设置的路径为：Build Setting --> Optimization Level --> Debug --> 将None 改为 fastest 或者 smallest

cls->ISA()->hasCustomAWZ()
其中fastpath中的 cls->ISA()->hasCustomAWZ() 表示判断一个类是否有自定义的 +allocWithZone 实现，这里通过断点调试，是没有自定义的实现，所以会执行到 if 里面的代码，即走到_objc_rootAllocWithZone

(4)
id
_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)// alloc 源码 第四步
{
    // allocWithZone under __OBJC2__ ignores the zone parameter
    //zone 参数不再使用 类创建实例内存空间
    return _class_createInstanceFromZone(cls, 0, nil,
                                         OBJECT_CONSTRUCT_CALL_BADALLOC);
}

(5)
static ALWAYS_INLINE id
_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,
                              int construct_flags = OBJECT_CONSTRUCT_NONE,
                              bool cxxConstruct = true,
                              size_t *outAllocatedSize = nil)// alloc 源码 第五步
{
    ASSERT(cls->isRealized()); //检查是否已经实现

    // Read class's info bits all at once for performance
    //一次性读取类的位信息以提高性能
    bool hasCxxCtor = cxxConstruct && cls->hasCxxCtor();
    bool hasCxxDtor = cls->hasCxxDtor();
    bool fast = cls->canAllocNonpointer();
    size_t size;

    //计算需要开辟的内存大小，传入的extraBytes 为 0
    size = cls->instanceSize(extraBytes);
    if (outAllocatedSize) *outAllocatedSize = size;

    id obj;
    if (zone) {
        obj = (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);
    } else {
        //申请内存
        obj = (id)calloc(1, size);
    }
    if (slowpath(!obj)) {
        if (construct_flags & OBJECT_CONSTRUCT_CALL_BADALLOC) {
            return _objc_callBadAllocHandler(cls);
        }
        return nil;
    }

    if (!zone && fast) {
        //将 cls类 与 obj指针（即isa） 关联
        obj->initInstanceIsa(cls, hasCxxDtor);
    } else {
        // Use raw pointer isa on the assumption that they might be
        // doing something weird with the zone or RR.
        obj->initIsa(cls);
    }

    if (fastpath(!hasCxxCtor)) {
        return obj;
    }

    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;
    return object_cxxConstructFromClass(obj, cls, construct_flags);
}

这部分是alloc源码的核心操作
该方法的实现主要分为三部分:
cls->instanceSize：计算需要开辟的内存空间大小
calloc：申请内存，返回地址指针
obj->initInstanceIsa：将 类 与 isa 关联


size_t instanceSize(size_t extraBytes) const {
    //编译器快速计算内存大小
    if (fastpath(cache.hasFastInstanceSize(extraBytes))) {
        return cache.fastInstanceSize(extraBytes);
    }
    
    // 计算类中所有属性的大小 + 额外的字节数0
    size_t size = alignedInstanceSize() + extraBytes;
    // CF requires all objects be at least 16 bytes.
    //如果size 小于 16，最小取16
    if (size < 16) size = 16;
    return size;
}

size_t fastInstanceSize(size_t extra) const
{
    ASSERT(hasFastInstanceSize(extra));

    //Gcc的内建函数 __builtin_constant_p 用于判断一个值是否为编译时常数，如果参数EXP 的值是常数，函数返回 1，否则返回 0
    if (__builtin_constant_p(extra) && extra == 0) {
        return _flags & FAST_CACHE_ALLOC_MASK16;
    } else {
        size_t size = _flags & FAST_CACHE_ALLOC_MASK;
        // remove the FAST_CACHE_ALLOC_DELTA16 that was added
        // by setFastInstanceSize
        //删除由setFastInstanceSize添加的FAST_CACHE_ALLOC_DELTA16 8个字节
        return align16(size + extra - FAST_CACHE_ALLOC_DELTA16);
    }
}

//16字节对齐算法
static inline size_t align16(size_t x) {
    return (x + size_t(15)) & ~size_t(15);
}


内存字节对齐的原则，主要有以下三点:
数据成员对齐规则：struct 或者 union 的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如数据、结构体等）的整数倍开始（例如int在32位机中是4字节，则要从4的整数倍地址开始存储）
数据成员为结构体：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储（例如：struct a里面存有struct b，b里面有char、int、double等元素，则b应该从8的整数倍开始存储）
结构体的整体对齐规则：结构体的总大小，即sizeof的结果，必须是其内部做大成员的整数倍，不足的要补齐


为什么需要16字节对齐:
通常内存是由一个个字节组成的，cpu在存取数据时，并不是以字节为单位存储，而是以块为单位存取，块的大小为内存存取力度。频繁存取字节未对齐的数据，会极大降低cpu的性能，所以可以通过减少存取次数来降低cpu的开销
16字节对齐，是由于在一个对象中，第一个属性isa占8字节，当然一个对象肯定还有其他属性，当无属性时，会预留8字节，即16字节对齐，如果不预留，相当于这个对象的isa和其他对象的isa紧挨着，容易造成访问混乱
16字节对齐后，可以加快CPU读取速度，同时使访问更安全，不会产生访问混乱的情况


字节对齐-总结:
在字节对齐算法中，对齐的主要是对象，而对象的本质则是一个 struct objc_object的结构体，
结构体在内存中是连续存放的，所以可以利用这点对结构体进行强转。
苹果早期是8字节对齐，现在是16字节对齐


calloc：申请内存，返回地址指针:
通过instanceSize计算的内存大小，向内存中申请 大小 为 size的内存，并赋值给obj，因此 obj是指向内存地址的指针
obj = (id)calloc(1, size);
一般一个对象的打印的格式都是类似于这样的<LGPerson: 0x01111111f>（是一个指针）.为什么这里只有地址？
主要是因为objc 地址 还没有与传入 的 cls进行关联，
同时印证了 alloc的根本作用就是 开辟内存


obj->initInstanceIsa：类与isa关联:
经过calloc可知，内存已经申请好了，类也已经传入进来了，接下来就需要将 类与 地址指针 即isa指针进行关联
主要过程就是初始化一个isa指针，并将isa指针指向申请的内存地址，在将指针与cls类进行 关联
在执行完initInstanceIsa后，在通过po obj可以得出一个对象指针

总结:
通过对alloc源码的分析，可以得知alloc的主要目的就是开辟内存，而且开辟的内存需要使用16字节对齐算法，现在开辟的内存的大小基本上都是16的整数倍
开辟内存的核心步骤有3步：计算 -- 申请 -- 关联


init 源码:
init的源码实现有以下两种
(1)类方法 init
+ (id)init {
    return (id)self;
}
这里能使用id强转的原因，主要还是因为 内存字节对齐后，可以使用类型强转为你所需的类型

(2)实例方法 init
- (id)init {
    return _objc_rootInit(self);
}

id
_objc_rootInit(id obj)
{
    // In practice, it will be hard to rely on this function.
    // Many classes do not properly chain -init calls.
    return obj;
}


new 源码:
new函数中直接调用了callAlloc函数（即alloc中分析的函数），且调用了init函数，所以可以得出new 其实就等价于 [alloc init]的结论
+ (id)new {
    return [callAlloc(self, false/*checkNil*/) init];
}
但是一般开发中并不建议使用new，主要是因为有时会重写init方法做一些自定义的操作，例如 initWithXXX，会在这个方法中调用[super init]，用new初始化可能会无法走到自定义的initWithXXX部分。

例如，在CJLPerson中有两个初始化方法，一个是重写的父类的init，一个是自定义的initWithXXX方法:
总结:
如果子类没有重写父类的init，new会调用父类的init方法
如果子类重写了父类的init，new会调用子类重写的init方法
如果使用 alloc + 自定义的init，可以帮助我们自定义初始化操作，例如传入一些子类所需参数等，最终也会走到父类的init，相比new而言，扩展性更好，更灵活。


==================================================5. 内存对齐原理
获取内存大小的三种方式分别是:
sizeof
class_getInstanceSize
malloc_size

sizeof:
1、sizeof是一个操作符，不是函数
2、我们一般用sizeof计算内存大小时，传入的主要对象是数据类型，这个在编译器的编译阶段(即编译时)就会确定大小而不是在运行时确定。
3、sizeof最终得到的结果是该数据类型占用空间的大小

class_getInstanceSize:
是runtime提供的api，用于获取类的实例对象所占用的内存大小，并返回具体的字节数，其本质就是获取实例对象中成员变量的内存大小

malloc_size:
这个函数是获取系统实际分配的内存大小

#import <Foundation/Foundation.h>
#import "LGPerson.h"
#import <objc/runtime.h>
#import <malloc/malloc.h>

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSObject *objc = [[NSObject alloc] init];
        NSLog(@"objc对象类型占用的内存大小：%lu",sizeof(objc));// 8
        NSLog(@"objc对象实际占用的内存大小：%lu",class_getInstanceSize([objc class]));// 8
        NSLog(@"objc对象实际分配的内存大小：%lu",malloc_size((__bridge const void*)(objc)));// 16
    }
    return 0;
}

总结:
sizeof：计算类型占用的内存大小，其中可以放 基本数据类型、对象、指针
对于类似于int这样的基本数据而言，sizeof获取的就是数据类型占用的内存大小，不同的数据类型所占用的内存大小是不一样的
而对于类似于NSObject定义的实例对象而言，其对象类型的本质就是一个结构体（即 struct objc_object）的指针，所以sizeof(objc)打印的是对象objc的指针大小，我们知道一个指针的内存大小是8，所以sizeof(objc) 打印是 8。注意：这里的8字节与isa指针一点关系都没有！！！）
对于指针而言，sizeof打印的就是8，因为一个指针的内存大小是8，
###
在64位处理器架构中，指针是64位长，即8字节。
###

class_getInstanceSize：计算对象实际占用的内存大小，这个需要依据类的属性而变化，如果自定义类没有自定义属性，仅仅只是继承自NSObject，则类的实例对象实际占用的内存大小是8，可以简单理解为8字节对齐

malloc_size：计算对象实际分配的内存大小，这个是由系统完成的，可以从上面的打印结果看出，实际分配的和实际占用的内存大小并不相等。16字节对齐算法来解释这个问题

//1、定义两个结构体
struct Mystruct1{
    char a;     //1字节
    double b;   //8字节
    int c;      //4字节
    short d;    //2字节
}Mystruct1;

struct Mystruct2{
    double b;   //8字节
    int c;      //4字节
    short d;    //2字节
    char a;     //1字节
}Mystruct2;

//计算 结构体占用的内存大小
NSLog(@"%lu-%lu",sizeof(Mystruct1),sizeof(Mystruct2));// 24-16

内存对齐规则:
每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。程序员可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。
在ios中，Xcode默认为#pragma pack(8)，即8字节对齐
【原则一】 数据成员的对齐规则可以理解为min(m, n) 的公式, 其中 m表示当前成员的开始位置, n表示当前成员所需要的位数。如果满足条件 m 整除 n （即 m % n == 0）, n 从 m 位置开始存储, 反之继续检查 m+1 能否整除 n, 直到可以整除, 从而就确定了当前成员的开始位置。
【原则二】数据成员为结构体：当结构体嵌套了结构体时，作为数据成员的结构体的自身长度作为外部结构体的最大成员的内存大小，比如结构体a嵌套结构体b，b中有char、int、double等，则b的自身长度为8
【原则三】最后结构体的内存大小必须是结构体中最大成员内存大小的整数倍，不足的需要补齐。


结构体嵌套结构体:
//1、结构体嵌套结构体
struct Mystruct3{
    double b;   //8字节
    int c;      //4字节
    short d;    //2字节
    char a;     //1字节
    struct Mystruct2 str; 
}Mystruct3;

//2、打印 Mystruct3 的内存大小
NSLog(@"Mystruct3内存大小：%lu", sizeof(Mystruct3));// 32
NSLog(@"Mystruct3中结构体成员内存大小：%lu", sizeof(Mystruct3.str));// 16


struct Mystruct4{
    int a;              //4字节 min（0，4）--- （0，1，2，3）
    struct Mystruct5{   //从4开始，存储开始位置必须是最大的整数倍（最大成员为8），min（4，8）不符合 4，5，6，7，8 -- min（8，8）满足，从8开始存储
        double b;       //8字节 min(8,8)  --- (8,9,10,11,12,13,14,15)
        short c;         //1字节,从16开始，min（16，1） -- （16，17）
    }Mystruct5;
}Mystruct4;// 24


内存优化（属性重排）:
MyStruct1 通过内存字节对齐原则，增加了9个字节，而MyStruct2通过内存字节对齐原则，通过4+2+1的组合，只需要补齐一个字节即可满足字节对齐规则，这里得出一个结论结构体内存大小与结构体成员内存大小的顺序有关
如果是结构体中数据成员是根据内存从小到大的顺序定义的，根据内存对齐规则来计算结构体内存大小，需要增加有较大的内存padding即内存占位符，才能满足内存对齐规则，比较浪费内存
如果是结构体中数据成员是根据内存从大到小的顺序定义的，根据内存对齐规则来计算结构体内存大小，我们只需要补齐少量内存padding即可满足堆存对齐规则，这种方式就是苹果中采用的，利用空间换时间，将类中的属性进行重排，来达到优化内存的目的


x：代表检查内存（"examine memory"）。
8：表示要显示的内存单元的数量。在这个例子中，表示显示8个内存单元。
g：表示内存单元的大小。在LLDB中，g代表8字节（64位）整数（也称为"giant" word）。
x：表示以十六进制格式显示内存内容。
x/8gx ptr
假设 ptr 指向的内存地址为 0x1000，该命令的输出可能如下:
0x0000000100001000: 0x0000000100002000 0x0000000100003000
0x0000000100001010: 0x0000000100004000 0x0000000100005000
0x0000000100001020: 0x0000000100006000 0x0000000100007000
0x0000000100001030: 0x0000000100008000 0x0000000100009000

@interface CJLPerson : NSObject

@property (nonatomic, copy) NSString *name;
@property (nonatomic, copy) NSString *nickName;
@property (nonatomic, assign) int age;
@property (nonatomic, assign) long height;

@property (nonatomic) char c1;
@property (nonatomic) char c2;
@end

@implementation CJLPerson

@end

int main(int argc, char * argv[]) {
    @autoreleasepool {
        CJLPerson *person = [CJLPerson alloc];
        person.name      = @"CJL";
        person.nickName  = @"C";
        person.age       = 18;
        person.c1        = 'a';
        person.c2        = 'b';

        NSLog(@"%@",person);
    }
    return 0;
}
1、char类型的数据读取出来是以ASCII码的形式显示
2、地址为0x0000000000000000,表示person中还有属性未赋值

总结下苹果中的内存对齐思想:
大部分的内存都是通过固定的内存块进行读取，
尽管我们在内存中采用了内存对齐的方式，但并不是所有的内存都可以进行浪费的，苹果会自动对属性进行重排，以此来优化内存

字节对齐到底采用多少字节对齐？
既提到了8字节对齐，也提及了16字节对齐，那我们到底采用哪种字节对齐呢？
我们可以通过objc4中class_getInstanceSize的源码来进行分析
/** 
 * Returns the size of instances of a class.
 * 
 * @param cls A class object.
 * 
 * @return The size in bytes of instances of the class \e cls, or \c 0 if \e cls is \c Nil.
 */
OBJC_EXPORT size_t
class_getInstanceSize(Class _Nullable cls) 
    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);

size_t class_getInstanceSize(Class cls)
{
    if (!cls) return 0;
    return cls->alignedInstanceSize();
}

// Class's ivar size rounded up to a pointer-size boundary.
uint32_t alignedInstanceSize() const {
    return word_align(unalignedInstanceSize());
}

static inline uint32_t word_align(uint32_t x) {
    //x+7 & (~7) --> 8字节对齐
    return (x + WORD_MASK) & ~WORD_MASK;
}

//其中 WORD_MASK 为
#   define WORD_MASK 7UL

7UL 是一个常量表达式，其中每个字符都有特定的意义:
7: 这是一个整数常量，表示十进制数7。
U: 表示这个整数常量是无符号整数（unsigned）。
L: 表示这个整数常量是长整数（long）。

对于一个对象来说，其真正的对齐方式 是 8字节对齐，8字节对齐已经足够满足对象的需求了
apple系统为了防止一切的容错，采用的是16字节对齐的内存，主要是因为采用8字节对齐时，两个对象的内存会紧挨着，显得比较紧凑，而16字节比较宽松，利于苹果以后的扩展。
总结:
class_getInstanceSize：是采用8字节对齐，参照的对象的属性内存大小
malloc_size：采用16字节对齐，参照的整个对象的内存大小，对象实际分配的内存大小必须是16的整数倍


内存对齐算法:
目前已知的16字节内存对齐算法有两种
alloc源码分析中的align16
malloc源码分析中的segregated_size_to_fit

align16： 16字节对齐算法
static inline size_t align16(size_t x) {
    return (x + size_t(15)) & ~size_t(15);
}

segregated_size_to_fit： 16字节对齐算法
#define SHIFT_NANO_QUANTUM      4
#define NANO_REGIME_QUANTA_SIZE (1 << SHIFT_NANO_QUANTUM)   // 16

static MALLOC_INLINE size_t
segregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)
{
    size_t k, slot_bytes;

    if (0 == size) {
        size = NANO_REGIME_QUANTA_SIZE; // Historical behavior
    }
    k = (size + NANO_REGIME_QUANTA_SIZE - 1) >> SHIFT_NANO_QUANTUM; // round up and shift for number of quanta
    slot_bytes = k << SHIFT_NANO_QUANTUM;                           // multiply by power of two quanta size
    *pKey = k - 1;                                                  // Zero-based!

    return slot_bytes;
}
算法原理：k + 15 >> 4 << 4 ，其中 右移4 + 左移4相当于将后4位抹零，跟 k/16 * 16一样 ，是16字节对齐算法，小于16就成0了


==================================================6. NSObject 的 alloc 源码
NSObject中的alloc是与自定义类的alloc的源码流程的区别，以及为什么NSObject中的alloc不走源码工程。

通过汇编可以发现NSObject并没有走 alloc 源码，而是走的objc_alloc
然后打开objc_alloc的断点，发现会进入objc_alloc的源码实现，此时查看 cls 是 NSObject

探索 NSObject 为什么走 objc_alloc？
NSObject 与 LGPerson的区别:
NSObject 是iOS中的基类，所有自定义的类都需要继承自NSObject
LGPerson 是继承自NSObject类的，重写了NSObject中的alloc方法

根据汇编的显示，可以看出，NSObject 和 LGPerson 都调用了objc_alloc，所以这里就有两个疑问：
为什么NSObject 调用alloc方法 会走到 objc_alloc 源码？
为什么LGPerson中的alloc 会走两次？即调用了alloc，进入源码，然后还要走到 objc_alloc？

LGPerson中alloc 走两次 的 Why？
发现LGPerson 第一次的alloc会走到 objc_alloc --> callAlloc方法中最下方的objc_msgSend
继续执行代码，发现会走到 alloc --> callAlloc --> _objc_rootAllocWithZOne

bt 第二次走到callAlloc方法中的调用堆栈情况

LGPerson走两次的原因是首先需要去查找sel，以及对应的imp的关系，当前需要查找的是 alloc 的方法编号，但是为什么会找到objc_alloc？
这个就需要问系统了，肯定是系统在底层做了一些操作。


NSObject中alloc 走到 objc_alloc 的 why？
这部分需要通过 LLVM源码（即llvm-project） 来分析
(1)在llvm源码中搜索objc_alloc
(2)搜索shouldUseRuntimeFunctionForCombinedAllocInit，表示版本控制
(3)搜索tryEmitSpecializedAllocInit，非常著名的特殊消息发送,在这里也没有找到 objc_alloc
(4)还可以通过omf_alloc:找到tryGenerateSpecializedMessageSend，表示尝试生成特殊消息发送
然后在这个case中可以找到调用alloc，其中的关键代码是EmitObjCAlloc
(5)跳转至EmitObjCAlloc的定义可以看到alloc 的处理是调用了 objc_alloc
由此可以得出 NSObject中的alloc 会走到 objc_alloc，其实这部分是由系统级别的消息处理逻辑，所以NSObject的初始化是由系统完成的


==================================================7. malloc 源码分析
alloc有3个核心操作，其中一个就是calloc，即申请内存

objc4中分析calloc 源码:
首先从alloc进入objc的源码，找到obj = (id)calloc(1, size);操作，涉及的方法顺序是alloc --> _objc_rootAlloc --> callAlloc --> _objc_rootAllocWithZone --> _class_createInstanceFromZone
这里calloc的探索需要切换到 libmalloc源码中

(1)
进入calloc的源码实现，其中的关键代码在于 malloc_zone_calloc
其中default_zone是一个默认的zone，目的就是引导程序进入一个创建真正zone的流程
进入malloc_zone_calloc的源码实现，关键代码是 zone->calloc, 这个关键代码的目的就是申请一个指针，并将指针地址返回
(2)
在进入zone->calloc的源码，发现是一个calloc的声明，到此，源码就无法继续跟进了

想要继续跟进源码，可以通过以下方式:
在 malloc_zone_calloc中的关键代码，即ptr = zone->calloc(zone, num_items, size);处，加一个断点，然后运行
断点断在 ptr位置，想要进入zone->calloc源码实现，有两种方式:
(1)按住control + step into，进入calloc的源码实现
(2)通过lldb命令p zone->callocde查找源码实现，通过打印得知zone->calloc的源码实现在default_zone_calloc方法，然后全局搜索default_zone_calloc方法，找到具体实现


==================================================8. isa与类关联的原理
clang是一个由Apple主导编写，基于LLVM的C/C++/OC的编译器
主要是用于底层编译，将一些文件``输出成c++文件，例如main.m 输出成main.cpp，其目的是为了更好的观察底层的一些结构 及 实现的逻辑，方便理解底层原理。

OC对象的本质是什么？
@interface LGPerson : NSObject
@property (nonatomic, copy) NSString *name;
@end

@implementation LGPerson
@end

利用clang将main.m编译成 main.cpp,有以下几种编译命令，这里使用的是第一种:
//1、将 main.m 编译成 main.cpp
clang -rewrite-objc main.m -o main.cpp

//2、将 ViewController.m 编译成  ViewController.cpp
clang -rewrite-objc -fobjc-arc -fobjc-runtime=ios-13.0.0 -isysroot / /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator13.7.sdk ViewController.m

//以下两种方式是通过指定架构模式的命令行，使用xcode工具 xcrun
//3、模拟器文件编译
- xcrun -sdk iphonesimulator clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp 

//4、真机文件编译
- xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main- arm64.cpp 

发现LGPerson在底层会被编译成 struct 结构体

//NSObject的定义
@interface NSObject <NSObject> {
    Class isa  OBJC_ISA_AVAILABILITY;
}

//NSObject 的底层编译
struct NSObject_IMPL {
    Class isa;
};

//LGPerson的底层编译
struct LGPerson_IMPL {
    struct NSObject_IMPL NSObject_IVARS; // 等效于 Class isa;
    NSString *_name;
};
LGPerson_IMPL中的第一个属性 其实就是 isa，是继承自NSObject，属于伪继承，伪继承的方式是直接将NSObject结构体定义为LGPerson中的第一个属性，意味着LGPerson 拥有 NSObject中的所有成员变量。
LGPerson中的第一个属性 NSObject_IVARS 等效于 NSObject中的 isa

提及过alloc方法的核心之一的initInstanceIsa方法，通过查看这个方法的源码实现，我们发现，在初始化isa指针时，是通过isa_t类型初始化的
而在NSObject定义中isa的类型是Class，其根本原因是由于isa 对外反馈的是类信息，为了让开发人员更加清晰明确，需要在isa返回时做了一个类型强制转换，类似于swift中的 as 的强转。

总结:
OC对象的本质 其实就是 结构体
LGPerson中的isa是继承自NSObject中的isa


objc_setProperty 源码:
除了LGPersong的底层定义，我们发现还有属性 name 对应的 set 和 get方法
其中set方法的实现依赖于runtime中的objc_setProperty。
在objc4-781中全局搜索objc_setProperty，找到objc_setProperty的源码实现
进入reallySetProperty的源码实现，其方法的原理就是新值retain，旧值release

总结:
通过对objc_setProperty的底层源码探索，有以下几点说明：
objc_setProperty方法的目的适用于关联 上层的set方法 以及 底层的set方法，其本质就是一个接口
这么设计的原因是，上层的set方法有很多，如果直接调用底层set方法中，会产生很多的临时变量，当你想查找一个sel时，会非常麻烦
基于上述原因，苹果采用了适配器设计模式（即将底层接口适配为客户端需要的接口），对外提供一个接口，供上层的set方法使用，对内调用底层的set方法，使其相互不受影响，即无论上层怎么变，下层都是不变的，或者下层的变化也无法影响上层，主要是达到上下层接口隔离的目的


cls 与 类 的关联原理:
探索initInstanceIsa是如何将cls与isa关联的
需要先了解什么是联合体，为什么isa的类型isa_t是使用联合体定义

构造数据类型的方式有以下两种:
结构体（struct）
联合体（union，也称为共用体）

结构体:
结构体是指把不同的数据组合成一个整体，其变量是共存的，变量不管是否使用，都会分配内存。
缺点：所有属性都分配内存，比较浪费内存，假设有4个int成员，一共分配了16字节的内存，但是在使用时，你只使用了4字节，剩余的12字节就是属于内存的浪费
优点：存储容量较大，包容性强，且成员之间不会相互影响

联合体:
联合体也是由不同的数据类型组成，但其变量是互斥的，所有的成员共占一段内存。而且共用体采用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会将原来成员的值覆盖掉
缺点：包容性弱
优点：所有成员共用一段内存，使内存的使用更为精细灵活，同时也节省了内存空间

两者的区别:
内存占用情况
结构体的各个成员会占用不同的内存，互相之间没有影响
共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员
内存分配大小
结构体内存 >= 所有成员占用的内存总和（成员之间可能会有缝隙）
共用体占用的内存等于最大的成员占用的内存




isa的类型 isa_t：
以下是isa指针的类型isa_t的定义，从定义中可以看出是通过联合体（union）定义的。
union isa_t { //联合体
    isa_t() { }
    isa_t(uintptr_t value) : bits(value) { }
    //提供了cls 和 bits ，两者是互斥关系
    Class cls;
    uintptr_t bits;
#if defined(ISA_BITFIELD)
    struct {
        ISA_BITFIELD;  // defined in isa.h
    };
#endif
};

isa_t类型使用联合体的原因也是基于内存优化的考虑，这里的内存优化是指在isa指针中通过char + 位域（即二进制中每一位均可表示不同的信息）的原理实现。
通常来说，isa指针占用的内存大小是8字节，即64位，已经足够存储很多的信息了，这样可以极大的节省内存，以提高性能


nonpointer isa（非指针 isa）
从 iOS 7（64 位）开始，Apple 对 isa 做了优化 —— nonpointer isa，顾名思义就是 它不再仅仅是一个指针，而是一个“位域结构”
虽然 isa 变量依然是一个 64 位的值（类似指针），但 它并不只是一个纯粹的指针，而是 将多个 flag 信息编码在指针的高位中
Apple 使用了一种叫 ISA_MASK 的方式从中提取真实的类地址
#define ISA_MASK 0x0000000ffffffff8ULL
通过位运算提取 class 指针：
Class realClass = (Class)(isa & ISA_MASK);

如果是“单纯的类指针”（nonpointer isa 未启用）
此时对象的 isa 成员就只是一个标准的 C 指针，指向这个对象所属的 Class 结构体（也就是类对象）
NSObject *obj = [[NSObject alloc] init];
Class cls = object_getClass(obj);
如果 isa 是“纯指针”，那么：
obj->isa == cls
也就是 isa 就是一个指向类对象的指针（这个类对象中包含方法列表、父类信息、元类信息等）——这才是早期 Objective-C 的运行机制（比如 32 位系统中就是这样的）。


从isa_t的定义中可以看出:
提供了两个成员，cls 和 bits，由联合体的定义所知，这两个成员是互斥的，
也就意味着，当初始化isa指针时，有两种初始化方式：
通过cls初始化，bits无默认值
通过bits初始化，cls有默认值
还提供了一个结构体定义的位域，用于存储类信息及其他信息，结构体的成员ISA_BITFIELD，这是一个宏定义，有两个版本 __arm64__（对应ios 移动端） 和 __x86_64__（对应macOS）
它们的一些宏定义:
nonpointer有两个值，表示自定义的类等，占1位
0：纯isa指针
1：不只是类对象地址，isa中包含了类信息、对象的引用计数等
has_assoc表示关联对象标志位，占1位
0：没有关联对象
1：存在关联对象
has_cxx_dtor 表示该对象是否有C++/OC的析构器（类似于dealloc），占1位
如果有析构函数，则需要做析构逻辑
如果没有，则可以更快的释放对象
shiftcls表示存储类的指针的值（类的地址）， 即类信息
arm64中占 33位，开启指针优化的情况下，在arm64架构中有33位用来存储类指针
x86_64中占 44位
magic 用于调试器判断当前对象是真的对象 还是 没有初始化的空间，占6位
weakly_refrenced是 指对象是否被指向 或者 曾经指向一个ARC的弱变量
没有弱引用的对象可以更快释放
deallocating 标志对象是是否正在释放内存
has_sidetable_rc表示 当对象引用计数大于10时，则需要借用该变量存储进位
extra_rc（额外的引用计数） ,表示该对象的引用计数值，实际上是引用计数值减1:
如果对象的引用计数为10，那么extra_rc为9（这个仅为举例说明），实际上iPhone 真机上的 extra_rc 是使用 19位来存储引用计数的


原理:
通过alloc --> _objc_rootAlloc --> callAlloc --> _objc_rootAllocWithZone --> _class_createInstanceFromZone方法路径，查找到initInstanceIsa

inline void 
objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)
{
    ASSERT(!cls->instancesRequireRawIsa());
    ASSERT(hasCxxDtor == cls->hasCxxDtor());
    //初始化isa
    initIsa(cls, true, hasCxxDtor); 
}

#####
进入initIsa方法的源码实现，主要是初始化isa指针
该方法的逻辑主要分为两部分
通过 cls 初始化 isa
通过 bits 初始化 isa
#####


苹果引入了优化过的 isa 指针，即 non-pointer isa（非指针 isa），该指针不仅仅用于存储类的地址，还包含其他信息。
纯 isa 指针:
一个纯 isa 指针指的是这个指针只存储了对象的类的内存地址，没有包含其他信息。在这种情况下，isa 指针完全是一个指向类对象的指针。
Non-pointer isa:
为了优化内存和性能，苹果在 64 位架构上引入了 non-pointer isa，即在 isa 指针中嵌入了额外的标志位和数据。
这种设计利用了 64 位指针中的一些位来存储其他信息，而不仅仅是类的地址。

Non-pointer isa 的结构
在 64 位架构下，isa 指针包含如下字段：
class pointer: 存储对象的类的地址。
extra_rc: 引用计数的额外部分，用于优化 retain/release 操作。
has_cxx_dtor: 标志对象是否有 C++ 析构函数。
shiftcls: 存储实际的类指针（经过偏移）。
magic: 用于调试和识别对象是否已被释放。
weakly_referenced: 标志对象是否曾经被弱引用。
deallocating: 标志对象是否正在被析构。
has_assoc: 标志对象是否有关联引用（associated references）。
has_sidetable_rc: 标志对象是否有旁路引用计数（sidetable refcounts）。



验证 isa指针 位域（0-64）:
通过main中的LGPerson 断点 --> initInstanceIsa --> initIsa --> 走到else中的 isa初始化
执行lldb命令：p newisa，得到newisa的详细信息
继续往下执行，走到newisa.bits = ISA_MAGIC_VALUE;下一行，表示为isa的bits成员赋值，重新执行lldb命令p newisa
（这边initIsa中涉及到是否是#if SUPPORT_INDEXED_ISA, 走newisa.bits = ISA_MAGIC_VALUE就不是）

isa指针中有这些位域（目前是处于macOS，所以使用的是x86_64）:
其中magic是59是由于将isa指针地址转换为二进制，从47（因为前面有4个位域，共占用47位，地址是从0开始）位开始读取6位，再转换为十进制



isa 与 类 的关联:
cls 与 isa 关联原理就是isa指针中的shiftcls位域中存储了类信息
其中initInstanceIsa的过程是将 calloc 指针 和当前的 类cls 关联起来，有以下几种验证方式:
【方式一】通过initIsa方法中的newisa.shiftcls = (uintptr_t)cls >> 3;验证
【方式二】通过isa指针地址与ISA_MSAK 的值 & 来验证
【方式三】通过runtime的方法object_getClass验证
【方式四】通过位运算验证


方式一：通过 initIsa 方法
运行至newisa.shiftcls = (uintptr_t)cls >> 3;前一步，其中 shiftcls存储当前类的值信息
shiftcls赋值的逻辑是将 LGPerson进行编码后，右移3位
执行lldb命令p (uintptr_t)cls，结果为(uintptr_t) $2 = 4294975720
再右移三位，将得到536871965存储到newisa的shiftcls中
p (uintptr_t)cls >> 3，或者（通过上一步的结果$2，执行lldb命令p $2 >> 3）
继续执行程序到isa = newisa;部分，此时执行p newisa

与bits赋值结果的对比，bits的位域中有两处变化
cls 由默认值，变成了LGPerson，将isa与cls完美关联
shiftcls由0变成了536871965

为什么在shiftcls赋值时需要类型强转？
因为内存的存储不能存储字符串，机器码只能识别 0 、1这两种数字，所以需要将其转换为uintptr_t数据类型，这样shiftcls中存储的类信息才能被机器码理解， 其中uintptr_t是long

为什么需要右移3位？
主要是由于shiftcls处于isa指针地址的中间部分，前面还有3个位域，为了不影响前面的3个位域的数据，需要右移将其抹零。


方式二：通过 isa & ISA_MSAK
在方式一后，继续执行，回到_class_createInstanceFromZone方法，此时cls 与 isa已经关联完成，执行po objc
执行x/4gx obj,得到isa指针的地址0x001d8001000020e9
将isa指针地址 & ISA_MASK （处于macOS，使用x86_64中的宏定义），即 po 0x001d8001000020e9 & 0x00007ffffffffff8 ，得出LGPerson
arm64中，ISA_MASK 宏定义的值为0x0000000ffffffff8ULL
x86_64中，ISA_MASK 宏定义的值为0x00007ffffffffff8ULL


方式三：通过 object_getClass
通过查看object_getClass的源码实现，同样可以验证isa与类关联的原理
有以下几步：
main中导入#import <objc/runtime.h>
通过runtime的api，即object_getClass函数获取类信息
点击进入object_getClass 底层实现
进入getIsa的源码实现
点击ISA()，进入源码，可以看到如果是indexed类型，执行if流程，反之 执行的是else流程
在else流程中，拿到isa的bits这个位，再 & ISA_MASK，这与方式二中的原理是一致的，获得当前的类信息
从这里也可以得出 cls 与 isa 已经完美关联


方式四：通过位运算
回到_class_createInstanceFromZone方法。通过x/4gx obj 得到obj的存储信息，当前类的信息存储在isa指针中，且isa中的shiftcls此时占44位（因为处于macOS环境）
想要读取中间的44位 类信息，就需要经过位运算 ，将右边3位，和左边除去44位以外的部分都抹零，其相对位置是不变的。
其中shiftcls即为需要读取的类信息

将isa地址右移3位：p/x 0x001d8001000020e9 >> 3 ，得到0x0003b0002000041d
在将得到的0x0003b0002000041d``左移20位：p/x 0x0003b0002000041d << 20 ,得到0x0002000041d00000
为什么是左移20位？因为先右移了3位，相当于向右偏移了3位，而左边需要抹零的位数有17位，所以一共需要移动20位
将得到的0x0002000041d00000 再右移17位：p/x 0x0002000041d00000 >> 17 得到新的0x00000001000020e8
获取cls的地址 与 上面的进行验证 ：p/x cls 也得出0x00000001000020e8，所以由此可以证明 cls 与 isa 是关联的


==================================================9.类 & 类结构
类的分析 主要是分析 isa的走向 以及 继承关系

@interface CJLPerson : NSObject
{
    NSString *hobby;
}
@property (nonatomic, copy) NSString *cjl_name;
- (void)sayHello;
+ (void)sayBye;
@end

@implementation CJLPerson
- (void)sayHello
{}
+ (void)sayBye
{}
@end

@interface CJLTeacher : CJLPerson
@end

@implementation CJLTeacher
@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        //ISA_MASK  0x00007ffffffffff8ULL
        CJLPerson *person = [CJLPerson alloc];
        CJLTeacher *teacher = [CJLTeacher alloc];
        NSLog(@"Hello, World! %@ - %@",person,teacher);  
    }
    return 0;
}


元类的说明:
在Apple中，我们简称CJLPerson类的类为 元类

对象的isa 是指向类，类的其实也是一个对象，可以称为类对象，其isa的位域指向苹果定义的元类
元类是系统给的，其定义和创建都是由编译器完成，在这个过程中，类的归属来自于元类
元类 是类对象 的类，每个类都有一个独一无二的元类用来存储 类方法的相关信息。
元类本身是没有名称的，由于与类相关联，所以使用了同类名一样的名称

元类的走向，也就是isa的走位：对象 --> 类 --> 元类 --> NSobject, NSObject 指向自身

总结:
对象 的 isa 指向 类（也可称为类对象）
类 的 isa 指向 元类
元类 的 isa 指向 根元类，即NSObject
根元类 的 isa 指向 它自己


NSObject到底有几个？
有以下两种验证方式
【方式一】lldb命令验证
【方式二】代码验证

【方式一】lldb命令验证
来验证这两个NSObject是否是同一个
最后NSObject类的元类 也是NSObject，与上面的CJLPerson中的根元类（NSObject）的元类，是同一个，所以可以得出一个结论：内存中只存在存在一份根元类NSObject，根元类的元类是指向它自己

【方式二】代码验证
//MARK:--- 分析类对象内存 存在个数
void testClassNum(){
    Class class1 = [CJLPerson class];
    Class class2 = [CJLPerson alloc].class;
    Class class3 = object_getClass([CJLPerson alloc]);
    NSLog(@"\n%p-\n%p-\n%p-\n%p", class1, class2, class3);
}
打印的地址都是同一个，所以NSObject只有一份，即NSObject（根元类）在内存中永远只存在一份


isa的走向有以下几点说明:
实例对象（Instance of Subclass）的 isa 指向 类（class）
类对象（class） isa 指向 元类（Meta class）
元类（Meta class）的isa 指向 根元类（Root metal class）
根元类（Root metal class） 的isa 指向它自己本身，形成闭环，这里的根元类就是NSObject

superclass（即继承关系）的走向也有以下几点说明:
类 之间 的继承关系：
类（subClass） 继承自 父类（superClass）
父类（superClass） 继承自 根类（RootClass），此时的根类是指NSObject
根类 继承自 nil，所以根类即NSObject
元类也存在继承，元类之间的继承关系如下:
子类的元类（metal SubClass） 继承自 父类的元类（metal SuperClass）
父类的元类（metal SuperClass） 继承自 根元类（Root metal Class
根元类（Root metal Class） 继承于 根类（Root class），此时的根类是指NSObject

【注意】实例对象之间没有继承关系，类之间有继承关系

isa 走位链（两条）
teacher的isa走位链：teacher(子类对象) --> CJLTeacher （子类）--> CJLTeacher（子元类） --> NSObject（根元类） --> NSObject（跟根元类，即自己）
person的isa走位图：person(父类对象) --> CJLPerson （父类）--> CJLPerson（父元类） --> NSObject（根元类） --> NSObject（跟根元类，即自己）

superclass走位链（两条）
类的继承关系链：CJLTeacher（子类） --> CJLPerson(父类) --> NSObject（根类）--> nil
元类的继承关系链：CJLTeacher（子元类） --> CJLPerson(父元类) --> NSObject（根元类）--> NSObject（根类）--> nil


objc_class & objc_object:
为什么 对象 和 类都有isa属性呢？这里就不得不提到两个结构体类型：objc_class & objc_object
使用clang编译过main.m文件，从编译后的c++文件中可以看到如下c++源码
NSObject的底层编译是NSObject_IMPL结构体，
其中 Class是isa指针的类型，是由objc_class定义的类型，
而objc_class是一个结构体。在iOS中，所有的Class都是以 objc_class 为模板创建的

struct NSObject_IMPL {
    Class isa;
};
typedef struct objc_class *Class;

在objc4源码中搜索objc_class的定义，源码中对其的定义有两个版本
旧版 位于 runtime.h中，已经被废除
（旧版objc_class包含 isa、super_class、name、version、。。。、ivars、methodLists等等）
###
新版 位于objc-runtime-new.h
从新版的定义中，可以看到 objc_class 结构体类型是继承自 objc_object的
（新版objc_class包含 superclass、cache、bits、data()等等）
###

在objc4源码中搜索objc_object (或者 objc_object {,这个类型也有两个版本
一个位于 objc.h，没有被废除，从编译的main.cpp中可以看到，使用的这个版本的objc_object
struct objc_object {
    Class isa;// typedef struct objc_class *Class;
}
一个位于 objc-privat.h
struct objc_object {
    private:
    isa_t isa;
    public:
    Class ISA();
}

以下是编译后的main.cpp中的objc_object的定义
struct objc_object {
    Class _Nonnull isa __attribute__((deprecated));
};


【问题】objc_class 与 objc_object 有什么关系？
结构体类型objc_class 继承自objc_object类型，其中objc_object也是一个结构体，且有一个isa属性，所以objc_class也拥有了isa属性
mian.cpp底层编译文件中，NSObject中的isa在底层是由Class 定义的，其中class的底层编码来自 objc_class类型，所以NSObject也拥有了isa属性
NSObject 是一个类，用它初始化一个实例对象objc，objc 满足 objc_object 的特性（即有isa属性），主要是因为isa 是由 NSObject 从objc_class继承过来的，而objc_class继承自objc_object，objc_object 有isa属性。所以对象都有一个 isa，isa表示指向，来自于当前的objc_object
objc_object（结构体） 是 当前的 根对象，所有的对象都有这样一个特性 objc_object，即拥有isa属性


总结:
所有的对象 + 类 + 元类 都有isa属性
所有的对象都是由objc_object继承来的
万物皆对象，万物皆来源于objc_object，有以下两点结论:
所有以 objc_object为模板 创建的对象，都有isa属性
所有以objc_class为模板，创建的类，都有isa属性
在结构层面可以通俗的理解为上层OC 与 底层的对接:
下层是通过 结构体 定义的 模板，例如objc_class、objc_object
上层 是通过底层的模板创建的 一些类型，例如CJLPerson


类结构分析:
主要是分析类信息中存储了哪些内容

分析类结构之前,先了解内存偏移:
对象指针:
//对象
CJLPerson *p1 = [CJLPerson alloc]; // p1 是指针
CJLPerson *p2 = [CJLPerson alloc];
NSLog(@"%d -- %p", p1, &p1);
NSLog(@"%d -- %p", p2, &p2);
p1、p2 是指针，p1 是 指向 [CJLPerson alloc]创建的空间地址，即内存地址
&p1、&p2是 指向 p1、p2对象指针的地址，这个指针 就是 二级指针

数组指针:
//数组指针
int c[4] = {1, 2, 3, 4};
int *d = c;
NSLog(@"%p -- %p - %p", &c, &c[0], &c[1]);
NSLog(@"%p -- %p - %p", d, d+1, d+2);
&c 和 &c[0] 都是取 首地址，即数组名等于首地址
&c 与 &c[1] 相差4个字节，地址之间相差的字节数，主要取决于存储的数据类型
可以通过 首地址+偏移量取出数组中的其他元素，其中偏移量是数组的下标，内存中首地址实际移动的字节数 等于 偏移量 * 数据类型字节数


探索类信息中都有哪些内容:
事先我们并不清楚类的结构是什么样的，但是我们可以通过类得到一个首地址，然后通过地址平移去获取里面所有的值
objc_class 的新版定义（objc4-781版本）如下，有以下几个属性
struct objc_class : objc_object {
    // Class ISA; //8字节
    Class superclass; //Class 类型 8字节
    cache_t cache;             // formerly cache pointer and vtable
    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags
    
    //....方法部分省略
}

isa属性：继承自objc_object的isa，占 8字节
superclass 属性：Class类型，Class是由objc_object定义的，是一个指针，占8字节
cache属性：简单从类型class_data_bits_t目前无法得知，而class_data_bits_t是一个结构体类型，结构体的内存大小需要根据内部的属性来确定，而结构体指针才是8字节
bits属性：只有首地址经过上面3个属性的内存大小总和的平移，才能获取到bits


计算 cache 类的内存大小:
进入cache类cache_t的定义（只贴出了结构体中非static修饰的属性，主要是因为static类型的属性 不存在结构体的内存中），有如下几个属性
struct cache_t {
#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED
    explicit_atomic<struct bucket_t *> _buckets; // 是一个结构体指针类型，占8字节
    explicit_atomic<mask_t> _mask; //是mask_t 类型，而 mask_t 是 unsigned int 的别名，占4字节
#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16
    explicit_atomic<uintptr_t> _maskAndBuckets; //是指针，占8字节
    mask_t _mask_unused; //是mask_t 类型，而 mask_t 是 uint32_t 类型定义的别名，占4字节
    
#if __LP64__
    uint16_t _flags;  //是uint16_t类型，uint16_t是 unsigned short 的别名，占 2个字节
#endif
    uint16_t _occupied; //是uint16_t类型，uint16_t是 unsigned short 的别名，占 2个字节

总结：所以最后计算出cache类的内存大小 = 12 + 2 + 2 = 16字节


获取bits:
所以有上述计算可知，想要获取bits的中的内容，只需通过类的首地址平移32字节即可


获取类的首地址有两种方式:
通过p/x CJLPerson.class直接获取首地址
通过x/4gx CJLPerson.class，打印内存信息获取

其中的data()获取数据，是由objc_class提供的方法

bits中存储的信息，其类型是class_rw_t，也是一个结构体类型
通过查看class_rw_t定义的源码发现，结构体中有提供相应的方法去获取 属性列表、方法列表等

属性列表，即 property_list:
propertoes方法是由class_rw_t提供的,方法中返回的实际类型为property_array_t
由于list的类型是property_list_t，是一个指针，所以通过 p *$10获取内存中的信息，同时也证明bits中存储了 property_list，即属性列表

###
由此可得出property_list 中只有属性，没有成员变量，属性与成员变量的区别就是有没有set、get方法，如果有，则是属性，如果没有，则是成员变量。
###


方法列表，即methods_list:
//CJLPerson.h
@property (nonatomic, copy) NSString *cjl_name;
- (void)sayHello;
+ (void)sayBye;
@end

//CJLPerson.m
@implementation CJLPerson
- (void)sayHello
{}
+ (void)sayBye
{}
@end

通过 p $4.methods() 获得具体的方法列表的list结构，其中methods也是class_rw_t提供的方法
通过打印的count = 4可知，存储了4个方法,可以通过p $7.get(i)内存偏移的方式获取单个方法,i 的范围是0-3


【问题】探索成员变量的存储:
通过查看objc_class中bits属性中存储数据的类class_rw_t的定义发现，除了methods、properties、protocols方法，还有一个ro方法，其返回类型是class_ro_t
通过查看其定义，发现其中有一个ivars属性，我们可以做如下猜测：是否成员变量就存储在这个ivar_list_t类型的ivars属性中呢？

class_ro_t结构体中的属性如下所示，想要获取ivars，需要ro的首地址平移48字节

struct class_ro_t {
    uint32_t flags;     //4
    uint32_t instanceStart;//4
    uint32_t instanceSize;//4
#ifdef __LP64__
    uint32_t reserved;  //4
#endif

    const uint8_t * ivarLayout; //8
    
    const char * name; // 8
    method_list_t * baseMethodList; // 8
    protocol_list_t * baseProtocols; // 8
    const ivar_list_t * ivars;

    const uint8_t * weakIvarLayout;
    property_list_t *baseProperties;
    
    //方法省略
}

获取的ivars属性，其中的count 为2，通过打印发现 成员列表中除了有hobby，还有name，所以可以得出以下一些结论:
通过{}定义的成员变量，会存储在类的bits属性中，通过bits --> data() -->ro() --> ivars获取成员变量列表，除了包括成员变量，还包括属性定义的成员变量
通过@property定义的属性，也会存储在bits属性中，通过bits --> data() --> properties() --> list获取属性列表，其中只包含属性


【问题】探索类方法的存储:
methods list 中只有 实例方法，没有类方法
类对象的isa指向就是元类，元类是用来存储类的相关信息的，所以我们猜测：是否类方法存储在元类的bits中呢？可以通过lldb命令来验证我们的猜测。

可以得出以下结论:
类的实例方法存储在类的bits属性中，通过bits --> methods() --> list获取实例方法列表，例如CJLPersong类的实例方法sayHello 就存储在 CJLPerson类的bits属性中，类中的方法列表除了包括实例方法，还包括属性的set方法 和 get方法
类的类方法存储在元类的bits属性中，通过元类bits --> methods() --> list获取类方法列表，例如CJLPerson中的类方法sayBye 就存储在CJLPerson类的元类（名称也是CJLPerson）的bits属性中


==================================================OC底层面试
（1）Runtime Asssociate方法关联的对象，需要在dealloc中释放?
当我们对象释放时，会调用dealloc
1、C++函数释放 ：objc_cxxDestruct
2、移除关联属性：_object_remove_assocations
3、将弱引用自动设置nil：weak_clear_no_lock(&table.weak_table, (id)this);
4、引用计数处理：table.refcnts.erase(this）
5、销毁对象：free(obj)
所以，关联对象不需要我们手动移除，会在对象析构即dealloc时释放


dealloc 源码:
dealloc的源码查找路径为：dealloc -> _objc_rootDealloc -> rootDealloc -> object_dispose（释放对象）-> objc_destructInstance -> _object_remove_assocations

在objc源码中搜索dealloc的源码实现
进入_objc_rootDealloc源码实现，主要是对对象进行析构
进入rootDealloc源码实现，发现其中有关联属性时设置bool值，当有这些条件时，需要进入else流程
进入object_dispose源码实现，主要是销毁实例对象
进入objc_destructInstance源码实现，在这里有移除关联属性的方法
进入_object_remove_assocations源码，关联属性的移除，主要是从全局哈希map中找到相关对象的迭代器，然后将迭代器中关联属性，从头到尾的移除


（2）方法的调用顺序
类的方法 和 分类方法 重名，如果调用，是什么情况？

如果同名方法是普通方法，包括initialize -- 先调用分类方法
    因为分类的方法是在类realize之后 attach进去的，插在类的方法的前面，所以优先调用分类的方法（注意：不是分类覆盖主类！！）
    initialize方法什么时候调用？ initialize方法也是主动调用，即第一次消息时调用，为了不影响整个load，可以将需要提前加载的数据写到initialize中
如果同名方法是load方法 -- 先 主类load，后分类load（分类之间，看编译的顺序）


(3)Runtime是什么？
runtime是由C和C++汇编实现的一套API，为OC语言加入了 面向对象、以及运行时的功能
平时编写的OC代码，在程序运行的过程中，其实最终会转换成runtime的C语言代码， runtime是OC的幕后工作者
运行时是指将数据类型的确定由编译时 推迟到了 运行时

extension 和 category 的区别:
category 类别、分类
专门用来给类添加新的方法
不能给类添加成员属性，添加了成员属性，也无法取到
注意：其实可以通过runtime 给分类添加属性，即属性关联，重写setter、getter方法
分类中用@property 定义变量，只会生成变量的setter、getter方法的声明，不能生成方法实现 和 带下划线的成员变量

extension 类扩展
可以说成是特殊的分类 ，也可称作 匿名分类
可以给类添加成员属性，但是是私有变量
可以给类添加方法，也是私有方法


(4)方法的本质，sel是什么？IMP是什么？两者之间的关系又是什么？
方法的本质：发送消息，消息会有以下几个流程
快速查找（objc_msgSend） - cache_t缓存消息中查找
慢速查找 - 递归自己|父类 - lookUpImpOrForward
查找不到消息：动态方法解析 - resolveInstanceMethod
消息快速转发 - forwardingTargetForSelector
消息慢速转发 - methodSignatureForSelector & forwardInvocation


sel是方法编号 - 在read_images期间就编译进了内存
imp是函数实现指针 ，找imp就是找函数的过程


(5)能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量
1、不能向编译后的得到的类中增加实例变量
2、只要类没有注册到内存还是可以添加的
3、可以添加属性+方法
【原因】：编译好的实例变量存储的位置是ro，一旦编译完成，内存结构就完全确定了


(6)[self class]和[super class]的区别以及原理分析
[self class]就是发送消息 objc_msgSend，消息接收者是self，方法编号 class
###
[super class] 本质就是objc_msgSendSuper，消息的接收者还是 self，方法编号 class，
在运行时，底层调用的是_objc_msgSendSuper2
###
只是 objc_msgSendSuper2 会更快，直接跳过self的查找

进入[self class]中的class源码
- (Class)class {
    return object_getClass(self);
}

Class object_getClass(id obj)
{
    if (obj) return obj->getIsa();
    else return Nil;
}

其底层是获取对象的isa，当前的对象是LGTeacher，其isa是同名的LGTeacher，所以[self class]打印的是LGTeacher

[super class]中，其中super 是语法的 关键字，可以通过clang 看super的本质
其中第一个参数是消息接收者，是一个__rw_objc_super结构
底层源码中搜索__rw_objc_super，是一个中间结构体

objc中搜索objc_msgSendSuper，查看其隐藏参数
搜索struct objc_super
通过clang的底层编译代码可知，当前消息的接收者 等于 self，而self 等于 LGTeacher，所以 [super class]进入class方法源码后，其中的self是init后的实例对象，实例对象的isa指向的是本类，即消息接收者是LGTeacher本类

再来看[super class]在运行时是否如上一步的底层编码所示
打开汇编调试，调试结果如下
搜索objc_msgSendSuper2，从注释得知，是从 类开始查找，而不是父类
查看objc_msgSendSuper2的汇编源码，是从superclass中的cache中查找方法

ENTRY _objc_msgSendSuper2
UNWIND _objc_msgSendSuper2, NoFrame

ldp p0, p16, [x0]       // p0 = real receiver, p16 = class 取出receiver 和 class
ldr p16, [x16, #SUPERCLASS] // p16 = class->superclass
CacheLookup NORMAL, _objc_msgSendSuper2//cache中查找--快速查找

END_ENTRY _objc_msgSendSuper2

所以，最完整的回答如下:
[self class]方法调用的本质是 发送消息，调用class的消息流程，拿到元类的类型，在这里是因为类已经加载到内存，所以在读取时是一个字符串类型，这个字符串类型是在map_images的readClass时已经加入表中，所以打印为LGTeacher
[super class]打印的是LGTeacher，原因是当前的super是一个关键字，在这里只调用objc_msgSendSuper2，其实他的消息接收者和[self class]是一模一样的，所以返回的是LGTeacher


(7)内存平移
Class cls = [LGPerson class];
void  *kc = &cls;  //
[(__bridge id)kc saySomething];
LGPerson中有一个属性 kc_name 和一个实例方法saySomething，通过上面代码这种方式，能否调用实例方法？为什么？

我们在日常开发中的调用方式是下面这种
LGPerson *person = [LGPerson alloc];
[person saySomething];

通过运行发现，是可以执行的
person的 isa指向类LGPerson 即person的首地址 指向 LGPerson的首地址，我们可以通过LGPerson的内存平移找到cache，在cache中查找方法
[(__bridge id)kc saySomething]中的kc是来自于LGPerson 这个类，然后有一个指针kc，将其指向LGPerson的首地址
所以，person是指向LGPerson类的结构，kc也是指向LGPerson类的结构，然后都是在LGPerson中的methodList中查找方法


栈是一个先进后出的结构，参数传入就是一个不断压栈的过程，
其中隐藏参数会压入栈，且每个函数都会有两个隐藏参数(id self，sel _cmd)
隐藏参数压栈的过程，其地址是递减的，而栈是从高地址->低地址 分配的，即在栈中，参数会从前往后一直压

viewDidLoad {
struct kc_struct {
    NSNumber *num1;
    NSNumber *num2;
} kc_struct;
struct kc_struct kcs = {@(10), @(20)};
LGPerson *person3 = [LGPerson alloc];

Class cls = [LGPerson class];
void  *kc = &cls;  //

}

p &person3 0x00007ffee83a8088
p *(NSNumber **)0x00007ffee83a8090
p *(NSNumber **)0x00007ffee83a8098
可以得出 20先加入，再加入10，因此结构体内部的压栈情况是 低地址->高地址，递增的，栈中结构体内部的成员是反向压入栈，即低地址->高地址，是递增的，

super通过clang查看底层的编译，是objc_msgSendSuper，其第一个参数是一个结构体__rw_objc_super（self，class_getSuperclass），那么结构体中的属性是如何压栈的？
所以到目前为止，栈中从高地址到低地址的顺序的：self - _cmd - (id)class_getSuperclass(objc_getClass("ViewController")) - self - cls - kc - person

self和_cmd是viewDidLoad方法的两个隐藏参数，是高地址->低地址正向压栈的
class_getSuperClass 和 self为objc_msgSendSuper2中的结构体成员，是从最后一个成员变量，即低地址->高地址反向压栈的


哪些东西在栈里 哪些在堆里:
alloc的对象 都在堆中
指针、对象 在栈中，例如person指向的空间在堆中，person所在的空间在栈中
临时变量在栈中
属性值 在堆，属性随对象是在栈中


堆是从小到大，即低地址->高地址
栈是从大到小，即从高地址->低地址分配
函数隐藏参数会从前往后一直压，即 从高地址->低地址 开始入栈，
结构体内部的成员是从低地址->高地址
一般情况下，内存地址有如下规则
0x60 开头表示在 堆中
0x70 开头的地址表示在 栈中
0x10 开头的地址表示在全局区域中


Person *p = [[Person alloc] init];
NSLog(@"%@ %p %p", p, p, &p);
<Person: 0x600000010320> 0x600000010320 0x16b4af918
%@: 打印 Person 对象的描述，假设 Person 类没有覆盖 description 方法，默认实现会打印对象的类名和内存地址，例如 <Person: 0x600003bcc800>。
%p (第一个): 打印指向 Person 对象的指针的地址
%p (第二个): 打印指向指针 p 自身的指针的地址


(8)Runtime是如何实现weak的，为什么可以自动置nil
1、通过SideTable 找到我们的 weak_table
2、weak_table 根据 referent找到或者创建 weak_entry_t
3、然后append_referrer（entry，referrer）将我的新弱引用的对象加进去entry
4、最后 weak_entry_insert，把entry加入到我们的weak_table


==================================================
1.
LP64 表示 “Long and Pointer 64”
long 类型：在 LP64 中，long 类型是 64 位的，即它占用 8 个字节。
指针类型：指针类型（如 void*、int* 等）也是 64 位的，占用 8 个字节。
int 类型：int 类型保持为 32 位，占用 4 个字节。

2. 一个实例对象的内存结构存在哪些元素
A:成员变量
B: supClass
C: cache_t
D: bit
解析： 实例对象的大小由成员变量决定。其中BCD是类的结构

3. 下面 sizeof(struct3)大小等于
struct LGStruct1 {
    char b;
    int c;
    double a; -- 逢8归零
    short d;
}struct1;  -- 24

struct LGStruct2 {
    double a; 
    int b;
    char c;
    short d;
}struct2; -- 16


struct LGStruct3 {
    double a;
    int b;
    char c;
    struct LGStruct1 str1;// 结构体的最大对齐单位并不是由某个成员结构体的总大小决定的，而是由它所有成员中对齐要求最大的那个成员的对齐值决定的。
    short d;
    int e;
    struct LGStruct2 str2;
}struct3;// 64



union kc_t {
    uintptr_t bits;
    struct {
        int a;
        char b;
    };
}// 8

4. (x + 7) & ~7 这个算法是几字节对齐： 8
带入实际数据计算，例如（8+7）& ~7
8+7 => 1111
~7 => 1000
& => 1000


5. 消息的流程是
cache快速查找 - 慢速继承链递归查找 - 动态方法决议 - 消息转发（快速转发 + 慢速转发）


6. 对象地址怎么确认对象是否存在关联对象
可以通过isa判断关联对象的标识

7. 内存偏移
int c[4] = {1,2,3,4}; int *d = c; c[2] = *(d+2)

8. 类也是对象

9. ISA_MASK = 0x00007ffffffffff8ULL 那么这个 ISA_MASK 的算法意义是什么
目的是为了得到isa中存储的class信息。
大部分isa都是不纯的isa，即nonpointIsa，是一个64位的联合体位域数据，而存储class信息的部分只有其中的部分位，剩余的位置存储了其他信息
读取class信息时，需要将其他位的信息清零，此时就需要用到掩码
任何数据与isa_mask进行按位与操作，都只保留isa_mask对应位的信息。其目的就是遮盖不需要的位


10. 类的结构里面为什么会有 rw 和 ro 以及 rwe
ro属于clean memory，即在编译时期确定的内存空间，只读，加载后不会再改变的内存
rw属于dirty memory，是运行时产生的内存，可读可写，可以向类中添加属性、方法等，即在运行时可以改变的内存
rwe相当于类的额外信息，因为在使用过程中，只有很少的类会真正改变其内容，所以为了避免资源浪费就有了rwe
运行时如果需要动态向类中添加方法、协议等，会创建rwe，并将ro的数据优先attach到rwe中。在读取时会优先返回rwe的数据，如果rwe中没有被初始化，则返回ro
有扩展，从rwe获取
没有扩展，从ro获取

rw中包含ro、rwe，其目的是为了让dirty memory占用更少的空间，将rw中可变的部分抽取出来作为rwe

clean memory越多越好，dirty memory越少越好。因为iOS 系统底层是虚拟内存机制，在内存不足时，会将一部分内容回收掉，后面使用时需要再次从磁盘中加载的。
而clean memory是可以从磁盘中重新加载的内存，例如mach-o文件、动态库。
dirty memory是运行时产生的数据，是不能从磁盘中重新加载的，所以必须一直占用内存
当系统物理内存紧张时会回收clean memory，如果dirty memory过大则会直接回收掉

设计ro、rwe、rw的目的是为了更好更细致的区分clean memory和dirty memory


11. cache 在什么时候开始扩容
一般情况下：如果当前方法cache后，缓存的使用容量超过总容量的3/4，需要先进行扩容，扩容为原来的2倍，然后再插入本次的方法
某些特殊预处理宏定义编译命令下，首次会存储满之后在进行扩容
扩展选择3/4作为负载因子，是和hash表中使用的链表和红黑树数据结构有关，0.75是最符合泊松分布概率计算得出的数值，此时的hash表的空间和时间效率是最高的

12. objc_msgSend 为什么用汇编写 , objc_msgSend 是如何递归找到imp?
使用汇编响应速度快

使用了两个循环
循环1：通过获取的mask与要查找的_cmd进行hash运行，获取下表，从而获取_cmd对应的bucket；然后通过向前平移查找，每次平移16位，如果找到对应的sel，则cacheHit；当平移到bucket的首地址时，如果还没有找到，则进入循环2
循环2：首先获取末尾bucket地址，同样采用向前查找方式，向_cmd对应的地址进行平移查找

13. 一个类的类方法没有实现为什么可以调用 NSObject 同名对象方法
类的isa指向元类，在方法快速查找过程中，会根据类的isa找到元类，

如果元类中没有该方法，怎会走到lookUpImpOrForward慢速查找流程中，会根据元类的继承链进行递归查找。
其中元类的父类是根元类，根元类的父类指向NSObject，所以会找到NSObject的同名对象方法

@interface TestObject : NSObject
+ (void)test;
- (void)test;
@end

@implementation TestObject
- (void)test {
    NSLog(@"===test===");
}
@end

@interface NSObject (NSObjectExt)
- (void)test;
@end

@implementation NSObject (NSObjectExt)

- (void)test {
    NSLog(@"===NSObject test===");
}

@end



[TestObject test];// ===NSObject test===