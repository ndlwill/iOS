åœ¨libdispatch.dylibå»æ¢ç´¢é˜Ÿåˆ—æ˜¯å¦‚ä½•åˆ›å»ºçš„

åº•å±‚æºç åˆ†æ
åœ¨æºç ä¸­æœç´¢dispatch_queue_create

dispatch_queue_t
dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
    return _dispatch_lane_create_with_target(label, attr, DISPATCH_TARGET_QUEUE_DEFAULT, true);
}

DISPATCH_NOINLINE
static dispatch_queue_t
_dispatch_lane_create_with_target(const char *label, dispatch_queue_attr_t dqa,
        dispatch_queue_t tq, bool legacy)
{
    // dqai åˆ›å»º -
    dispatch_queue_attr_info_t dqai = _dispatch_queue_attr_to_info(dqa);
    
    //ç¬¬ä¸€æ­¥ï¼šè§„èŒƒåŒ–å‚æ•°ï¼Œä¾‹å¦‚qos, overcommit, tq
    ...
    
    //æ‹¼æ¥é˜Ÿåˆ—åç§°
    const void *vtable;
    dispatch_queue_flags_t dqf = legacy ? DQF_MUTABLE : 0;
    if (dqai.dqai_concurrent) { //vtableè¡¨ç¤ºç±»çš„ç±»å‹
        // OS_dispatch_queue_concurrent
        vtable = DISPATCH_VTABLE(queue_concurrent);
    } else {
        vtable = DISPATCH_VTABLE(queue_serial);
    }
    
    ....
    
    //åˆ›å»ºé˜Ÿåˆ—ï¼Œå¹¶åˆå§‹åŒ–
    dispatch_lane_t dq = _dispatch_object_alloc(vtable,
            sizeof(struct dispatch_lane_s)); // alloc
    //æ ¹æ®dqai.dqai_concurrentçš„å€¼ï¼Œå°±èƒ½åˆ¤æ–­é˜Ÿåˆ— æ˜¯ ä¸²è¡Œ è¿˜æ˜¯å¹¶å‘
    _dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?
            DISPATCH_QUEUE_WIDTH_MAX : 1, DISPATCH_QUEUE_ROLE_INNER |
            (dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : 0)); // init
    //è®¾ç½®é˜Ÿåˆ—labelæ ‡è¯†ç¬¦
    dq->dq_label = label;//labelèµ‹å€¼
    dq->dq_priority = _dispatch_priority_make((dispatch_qos_t)dqai.dqai_qos, dqai.dqai_relpri);//ä¼˜å…ˆçº§å¤„ç†
    
    ...
    
    //ç±»ä¼¼äºç±»ä¸å…ƒç±»çš„ç»‘å®šï¼Œä¸æ˜¯ç›´æ¥çš„ç»§æ‰¿å…³ç³»ï¼Œè€Œæ˜¯ç±»ä¼¼äºæ¨¡å‹ä¸æ¨¡æ¿çš„å…³ç³»
    dq->do_targetq = tq;
    _dispatch_object_debug(dq, "%s", __func__);
    return _dispatch_trace_queue_create(dq)._dq;//ç ”ç©¶dq
}

ã€ç¬¬ä¸€æ­¥ã€‘é€šè¿‡_dispatch_queue_attr_to_infoæ–¹æ³•ä¼ å…¥dqaï¼ˆå³é˜Ÿåˆ—ç±»å‹ï¼Œä¸²è¡Œã€å¹¶å‘ç­‰ï¼‰åˆ›å»ºdispatch_queue_attr_info_tç±»å‹çš„å¯¹è±¡dqaiï¼Œç”¨äºå­˜å‚¨é˜Ÿåˆ—çš„ç›¸å…³å±æ€§ä¿¡æ¯
ã€ç¬¬äºŒæ­¥ã€‘è®¾ç½®é˜Ÿåˆ—ç›¸å…³è”çš„å±æ€§ï¼Œä¾‹å¦‚æœåŠ¡è´¨é‡qosç­‰
ã€ç¬¬ä¸‰æ­¥ã€‘é€šè¿‡DISPATCH_VTABLEæ‹¼æ¥é˜Ÿåˆ—åç§°ï¼Œå³vtableï¼Œå…¶ä¸­DISPATCH_VTABLEæ˜¯å®å®šä¹‰
æ‰€ä»¥é˜Ÿåˆ—çš„ç±»å‹æ˜¯é€šè¿‡OS_dispatch_+é˜Ÿåˆ—ç±»å‹queue_concurrentæ‹¼æ¥è€Œæˆçš„
ä¸²è¡Œé˜Ÿåˆ—ç±»å‹ï¼šOS_dispatch_queue_serial
å¹¶å‘é˜Ÿåˆ—ç±»å‹ï¼šOS_dispatch_queue_concurrent
object_getClass(serial)// serialä¸ºåˆ›å»ºçš„ä¸²è¡Œé˜Ÿåˆ—å¯¹è±¡ï¼Œè·å–å®ƒçš„ç±»å‹

#define DISPATCH_VTABLE(name) DISPATCH_OBJC_CLASS(name)
ğŸ‘‡
#define DISPATCH_OBJC_CLASS(name)   (&DISPATCH_CLASS_SYMBOL(name))
ğŸ‘‡
#define DISPATCH_CLASS(name) OS_dispatch_##name

ã€ç¬¬å››æ­¥ã€‘é€šè¿‡alloc+initåˆå§‹åŒ–é˜Ÿåˆ—ï¼Œå³dqï¼Œå…¶ä¸­åœ¨_dispatch_queue_initä¼ å‚ä¸­æ ¹æ®dqai.dqai_concurrentçš„å¸ƒå°”å€¼ï¼Œ
å°±èƒ½åˆ¤æ–­é˜Ÿåˆ— æ˜¯ ä¸²è¡Œ è¿˜æ˜¯å¹¶å‘ï¼Œè€Œ vtableè¡¨ç¤ºé˜Ÿåˆ—çš„ç±»å‹ï¼Œè¯´æ˜é˜Ÿåˆ—ä¹Ÿæ˜¯å¯¹è±¡
è¿›å…¥_dispatch_object_alloc -> _os_object_alloc_realizedæ–¹æ³•ä¸­è®¾ç½®äº†isaçš„æŒ‡å‘ï¼Œä»è¿™é‡Œå¯ä»¥éªŒè¯é˜Ÿåˆ—ä¹Ÿæ˜¯å¯¹è±¡çš„è¯´æ³•
è¿›å…¥_dispatch_queue_initæ–¹æ³•,é˜Ÿåˆ—ç±»å‹æ˜¯dispatch_queue_t,å¹¶è®¾ç½®é˜Ÿåˆ—çš„ç›¸å…³å±æ€§
ã€ç¬¬äº”æ­¥ã€‘é€šè¿‡_dispatch_trace_queue_createå¯¹åˆ›å»ºçš„é˜Ÿåˆ—è¿›è¡Œå¤„ç†ï¼Œå…¶ä¸­_dispatch_trace_queue_createæ˜¯_dispatch_introspection_queue_createå°è£…çš„å®å®šä¹‰ï¼Œæœ€åä¼šè¿”å›å¤„ç†è¿‡çš„_dq
è¿›å…¥_dispatch_introspection_queue_create_hook -> dispatch_introspection_queue_get_info -> _dispatch_introspection_lane_get_infoä¸­å¯ä»¥çœ‹å‡ºï¼Œä¸æˆ‘ä»¬è‡ªå®šä¹‰çš„ç±»è¿˜æ˜¯æœ‰æ‰€åŒºåˆ«çš„ï¼Œåˆ›å»ºé˜Ÿåˆ—åœ¨åº•å±‚çš„å®ç°æ˜¯é€šè¿‡æ¨¡æ¿åˆ›å»ºçš„

æ€»ç»“:
é˜Ÿåˆ—åˆ›å»ºæ–¹æ³•dispatch_queue_createä¸­çš„å‚æ•°äºŒï¼ˆå³é˜Ÿåˆ—ç±»å‹ï¼‰ï¼Œå†³å®šäº†ä¸‹å±‚ä¸­ max & 1ï¼ˆç”¨äºåŒºåˆ†æ˜¯ ä¸²è¡Œ è¿˜æ˜¯ å¹¶å‘ï¼‰ï¼Œå…¶ä¸­1è¡¨ç¤ºä¸²è¡Œ
queue ä¹Ÿæ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œä¹Ÿéœ€è¦åº•å±‚é€šè¿‡alloc + init åˆ›å»ºï¼Œå¹¶ä¸”åœ¨allocä¸­ä¹Ÿæœ‰ä¸€ä¸ªclassï¼Œè¿™ä¸ªclassæ˜¯é€šè¿‡å®å®šä¹‰æ‹¼æ¥è€Œæˆï¼Œå¹¶ä¸”åŒæ—¶ä¼šæŒ‡å®šisaçš„æŒ‡å‘
åˆ›å»ºé˜Ÿåˆ—åœ¨åº•å±‚çš„å¤„ç†æ˜¯é€šè¿‡æ¨¡æ¿åˆ›å»ºçš„ï¼Œå…¶ç±»å‹æ˜¯dispatch_introspection_queue_sç»“æ„ä½“



å¼‚æ­¥å‡½æ•°dispatch_async å’Œ åŒæ­¥å‡½æ•°dispatch_sync:
å¼‚æ­¥å‡½æ•° dispatch_async:
void
dispatch_async(dispatch_queue_t dq, dispatch_block_t work)//work ä»»åŠ¡
{
    dispatch_continuation_t dc = _dispatch_continuation_alloc();
    uintptr_t dc_flags = DC_FLAG_CONSUME;
    dispatch_qos_t qos;

    // ä»»åŠ¡åŒ…è£…å™¨ï¼ˆworkåœ¨è¿™é‡Œæ‰æœ‰ä½¿ç”¨ï¼‰ - æ¥å—work - ä¿å­˜work - å¹¶å‡½æ•°å¼ç¼–ç¨‹
    // ä¿å­˜ block 
    qos = _dispatch_continuation_init(dc, dq, work, 0, dc_flags);
    //å¹¶å‘å¤„ç†
    _dispatch_continuation_async(dq, dc, qos, dc->dc_flags);
}

DISPATCH_ALWAYS_INLINE
static inline dispatch_qos_t
_dispatch_continuation_init(dispatch_continuation_t dc,
        dispatch_queue_class_t dqu, dispatch_block_t work,
        dispatch_block_flags_t flags, uintptr_t dc_flags)
{
    void *ctxt = _dispatch_Block_copy(work);//æ‹·è´ä»»åŠ¡

    dc_flags |= DC_FLAG_BLOCK | DC_FLAG_ALLOCATED;
    if (unlikely(_dispatch_block_has_private_data(work))) {
        dc->dc_flags = dc_flags;
        dc->dc_ctxt = ctxt;//èµ‹å€¼
        // will initialize all fields but requires dc_flags & dc_ctxt to be set
        return _dispatch_continuation_init_slow(dc, dqu, flags);
    }

    dispatch_function_t func = _dispatch_Block_invoke(work);//å°è£…work - å¼‚æ­¥å›è°ƒ
    if (dc_flags & DC_FLAG_CONSUME) {
        func = _dispatch_call_block_and_release;//å›è°ƒå‡½æ•°èµ‹å€¼ - åŒæ­¥å›è°ƒ
    }
    return _dispatch_continuation_init_f(dc, dqu, ctxt, func, flags, dc_flags);
}

DISPATCH_ALWAYS_INLINE
static inline void
_dispatch_continuation_async(dispatch_queue_class_t dqu,
        dispatch_continuation_t dc, dispatch_qos_t qos, uintptr_t dc_flags)
{
#if DISPATCH_INTROSPECTION
    if (!(dc_flags & DC_FLAG_NO_INTROSPECTION)) {
        _dispatch_trace_item_push(dqu, dc);//è·Ÿè¸ªæ—¥å¿—
    }
#else
    (void)dc_flags;
#endif
    return dx_push(dqu._dq, dc, qos);//ä¸dx_invokeä¸€æ ·ï¼Œéƒ½æ˜¯å®
}
#define dx_push(x, y, z) dx_vtable(x)->dq_push(x, y, z)


#define _dispatch_Block_invoke(bb) \
        ((dispatch_function_t)((struct Block_layout *)bb)->invoke)
å…¶blockå›è°ƒæ‰§è¡Œçš„è°ƒç”¨è·¯å¾„ä¸º:
_dispatch_root_queues_init_once ->_dispatch_worker_thread2 -> _dispatch_root_queue_drain -> _dispatch_root_queue_drain -> _dispatch_continuation_pop_inline -> _dispatch_continuation_invoke_inline -> _dispatch_client_callout -> dispatch_call_block_and_release


é˜Ÿåˆ—ä¹Ÿæ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œæœ‰çˆ¶ç±»ã€æ ¹ç±»ï¼Œæ‰€ä»¥ä¼šé€’å½’æ‰§è¡Œåˆ°æ ¹ç±»çš„æ–¹æ³•


åŒæ­¥å‡½æ•°:
è¿›å…¥dispatch_syncæºç å®ç°ï¼Œå…¶åº•å±‚çš„å®ç°æ˜¯é€šè¿‡æ …æ å‡½æ•°å®ç°çš„
åŒæ­¥å‡½æ•° + å¹¶å‘é˜Ÿåˆ— é¡ºåºæ‰§è¡Œçš„åŸå› :
å°†ä»»åŠ¡å‹å…¥é˜Ÿåˆ—ï¼š _dispatch_thread_frame_push
æ‰§è¡Œä»»åŠ¡çš„blockå›è°ƒï¼š _dispatch_client_callout
å°†ä»»åŠ¡å‡ºé˜Ÿï¼š_dispatch_thread_frame_pop



æ …æ å‡½æ•°:
GCDä¸­å¸¸ç”¨çš„æ …æ å‡½æ•°ï¼Œä¸»è¦æœ‰ä¸¤ç§
åŒæ­¥æ …æ å‡½æ•°dispatch_barrier_syncï¼ˆåœ¨ä¸»çº¿ç¨‹ä¸­æ‰§è¡Œï¼‰ï¼šå‰é¢çš„ä»»åŠ¡æ‰§è¡Œå®Œæ¯•æ‰ä¼šæ¥åˆ°è¿™é‡Œï¼Œä½†æ˜¯åŒæ­¥æ …æ å‡½æ•°ä¼šå µå¡çº¿ç¨‹ï¼Œå½±å“åé¢çš„ä»»åŠ¡æ‰§è¡Œ
å¼‚æ­¥æ …æ å‡½æ•°dispatch_barrier_asyncï¼šå‰é¢çš„ä»»åŠ¡æ‰§è¡Œå®Œæ¯•æ‰ä¼šæ¥åˆ°è¿™é‡Œ
æ …æ å‡½æ•°æœ€ç›´æ¥çš„ä½œç”¨å°±æ˜¯ æ§åˆ¶ä»»åŠ¡æ‰§è¡Œé¡ºåºï¼Œä½¿åŒæ­¥æ‰§è¡Œã€‚

æ å‡½æ•°éœ€è¦æ³¨æ„ä¸€ä¸‹å‡ ç‚¹:
æ …æ å‡½æ•°åªèƒ½æ§åˆ¶åŒä¸€å¹¶å‘é˜Ÿåˆ—
åŒæ­¥æ …æ æ·»åŠ è¿›å…¥é˜Ÿåˆ—çš„æ—¶å€™ï¼Œå½“å‰çº¿ç¨‹ä¼šè¢«é”æ­»ï¼Œç›´åˆ°åŒæ­¥æ …æ ä¹‹å‰çš„ä»»åŠ¡å’ŒåŒæ­¥æ …æ ä»»åŠ¡æœ¬èº«æ‰§è¡Œå®Œæ¯•æ—¶ï¼Œå½“å‰çº¿ç¨‹æ‰ä¼šæ‰“å¼€ç„¶åç»§ç»­æ‰§è¡Œä¸‹ä¸€å¥ä»£ç ã€‚
åœ¨ä½¿ç”¨æ …æ å‡½æ•°æ—¶.ä½¿ç”¨è‡ªå®šä¹‰é˜Ÿåˆ—æ‰æœ‰æ„ä¹‰,å¦‚æœç”¨çš„æ˜¯ä¸²è¡Œé˜Ÿåˆ—æˆ–è€…ç³»ç»Ÿæä¾›çš„å…¨å±€å¹¶å‘é˜Ÿåˆ—,è¿™ä¸ªæ …æ å‡½æ•°çš„ä½œç”¨ç­‰åŒäºä¸€ä¸ªåŒæ­¥å‡½æ•°çš„ä½œç”¨ï¼Œæ²¡æœ‰ä»»ä½•æ„ä¹‰

å¼‚æ­¥æ …æ å‡½æ•° ä¸ä¼šé˜»å¡ä¸»çº¿ç¨‹ ï¼Œå¼‚æ­¥ å µå¡ çš„æ˜¯é˜Ÿåˆ—
åŒæ­¥æ …æ å‡½æ•° ä¼šå µå¡ä¸»çº¿ç¨‹ï¼ŒåŒæ­¥ å µå¡ æ˜¯å½“å‰çš„çº¿ç¨‹
æ€»ç»“:
å¼‚æ­¥æ …æ å‡½æ•°é˜»å¡çš„æ˜¯é˜Ÿåˆ—ï¼Œè€Œä¸”å¿…é¡»æ˜¯è‡ªå®šä¹‰çš„å¹¶å‘é˜Ÿåˆ—ï¼Œä¸å½±å“ä¸»çº¿ç¨‹ä»»åŠ¡çš„æ‰§è¡Œ
åŒæ­¥æ …æ å‡½æ•°é˜»å¡çš„æ˜¯çº¿ç¨‹ï¼Œä¸”æ˜¯ä¸»çº¿ç¨‹ï¼Œä¼šå½±å“ä¸»çº¿ç¨‹å…¶ä»–ä»»åŠ¡çš„æ‰§è¡Œ

æ³¨æ„:
å¦‚æœæ …æ å‡½æ•°ä¸­ä½¿ç”¨ å…¨å±€é˜Ÿåˆ—ï¼Œ è¿è¡Œä¼šå´©æºƒï¼ŒåŸå› æ˜¯ç³»ç»Ÿä¹Ÿåœ¨ç”¨å…¨å±€å¹¶å‘é˜Ÿåˆ—ï¼Œä½¿ç”¨æ …æ åŒæ—¶ä¼šæ‹¦æˆªç³»ç»Ÿçš„ï¼Œæ‰€ä»¥ä¼šå´©æºƒ
å¦‚æœå°†è‡ªå®šä¹‰å¹¶å‘é˜Ÿåˆ—æ”¹ä¸ºä¸²è¡Œé˜Ÿåˆ—ï¼Œå³serial ï¼Œä¸²è¡Œé˜Ÿåˆ—æœ¬èº«å°±æ˜¯æœ‰åºåŒæ­¥ æ­¤æ—¶åŠ æ …æ ï¼Œä¼šæµªè´¹æ€§èƒ½
æ …æ å‡½æ•°åªä¼šé˜»å¡ä¸€æ¬¡

dispatch_barrier_asyncæºç å®ç°ï¼Œå…¶åº•å±‚çš„å®ç°ä¸dispatch_asyncç±»ä¼¼


ä¿¡å·é‡:
ä¿¡å·é‡çš„ä½œç”¨ä¸€èˆ¬æ˜¯ç”¨æ¥ä½¿ä»»åŠ¡åŒæ­¥æ‰§è¡Œï¼Œç±»ä¼¼äºäº’æ–¥é”ï¼Œç”¨æˆ·å¯ä»¥æ ¹æ®éœ€è¦æ§åˆ¶GCDæœ€å¤§å¹¶å‘æ•°

dispatch_semaphore_t sem = dispatch_semaphore_create(1);

dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
dispatch_semaphore_signal(sem);

dispatch_semaphore_create ä¸»è¦å°±æ˜¯åˆå§‹åŒ–é™å·é‡
dispatch_semaphore_waitæ˜¯å¯¹ä¿¡å·é‡çš„valueè¿›è¡Œ--ï¼Œå³åŠ é”æ“ä½œ
dispatch_semaphore_signal æ˜¯å¯¹ä¿¡å·é‡çš„valueè¿›è¡Œ++ï¼Œå³è§£é”æ“ä½œ


è°ƒåº¦ç»„:
dispatch_group_t
dispatch_group_create(void)
{
    return _dispatch_group_create_with_count(0);
}

DISPATCH_ALWAYS_INLINE
static inline dispatch_group_t
_dispatch_group_create_with_count(uint32_t n)
{
    //åˆ›å»ºgroupå¯¹è±¡,ç±»å‹ä¸ºOS_dispatch_group
    dispatch_group_t dg = _dispatch_object_alloc(DISPATCH_VTABLE(group),
            sizeof(struct dispatch_group_s));
    //groupå¯¹è±¡èµ‹å€¼
    dg->do_next = DISPATCH_OBJECT_LISTLESS;
    dg->do_targetq = _dispatch_get_default_queue(false);
    if (n) {
        os_atomic_store2o(dg, dg_bits,
                (uint32_t)-n * DISPATCH_GROUP_VALUE_INTERVAL, relaxed);
        os_atomic_store2o(dg, do_ref_cnt, 1, relaxed); // <rdar://22318411>
    }
    return dg;
}

void
dispatch_group_enter(dispatch_group_t dg)
{
    // The value is decremented on a 32bits wide atomic so that the carry
    // for the 0 -> -1 transition is not propagated to the upper 32bits.
    uint32_t old_bits = os_atomic_sub_orig2o(dg, dg_bits,//åŸå­é€’å‡ 0 -> -1
            DISPATCH_GROUP_VALUE_INTERVAL, acquire);
    uint32_t old_value = old_bits & DISPATCH_GROUP_VALUE_MASK;
    if (unlikely(old_value == 0)) {//å¦‚æœold_value
        _dispatch_retain(dg); // <rdar://problem/22318411>
    }
    if (unlikely(old_value == DISPATCH_GROUP_VALUE_MAX)) {//åˆ°è¾¾ä¸´ç•Œå€¼ï¼Œä¼šæŠ¥crash
        DISPATCH_CLIENT_CRASH(old_bits,
                "Too many nested calls to dispatch_group_enter()");
    }
}

void
dispatch_group_leave(dispatch_group_t dg)
{
    // The value is incremented on a 64bits wide atomic so that the carry for
    // the -1 -> 0 transition increments the generation atomically.
    uint64_t new_state, old_state = os_atomic_add_orig2o(dg, dg_state,//åŸå­é€’å¢ ++
            DISPATCH_GROUP_VALUE_INTERVAL, release);
    uint32_t old_value = (uint32_t)(old_state & DISPATCH_GROUP_VALUE_MASK);
    //æ ¹æ®çŠ¶æ€ï¼Œå”¤é†’
    if (unlikely(old_value == DISPATCH_GROUP_VALUE_1)) {
        old_state += DISPATCH_GROUP_VALUE_INTERVAL;
        do {
            new_state = old_state;
            if ((old_state & DISPATCH_GROUP_VALUE_MASK) == 0) {
                new_state &= ~DISPATCH_GROUP_HAS_WAITERS;
                new_state &= ~DISPATCH_GROUP_HAS_NOTIFS;
            } else {
                // If the group was entered again since the atomic_add above,
                // we can't clear the waiters bit anymore as we don't know for
                // which generation the waiters are for
                new_state &= ~DISPATCH_GROUP_HAS_NOTIFS;
            }
            if (old_state == new_state) break;
        } while (unlikely(!os_atomic_cmpxchgv2o(dg, dg_state,
                old_state, new_state, &old_state, relaxed)));
        return _dispatch_group_wake(dg, old_state, true);//å”¤é†’
    }
    //-1 -> 0, 0+1 -> 1ï¼Œå³å¤šæ¬¡leaveï¼Œä¼šæŠ¥crashï¼Œç®€å•æ¥è¯´å°±æ˜¯enter-leaveä¸å¹³è¡¡
    if (unlikely(old_value == 0)) {
        DISPATCH_CLIENT_CRASH((uintptr_t)old_value,
                "Unbalanced call to dispatch_group_leave()");
    }
}


æ€»ç»“:
enter-leaveåªè¦æˆå¯¹å°±å¯ä»¥ï¼Œä¸ç®¡è¿œè¿‘
dispatch_group_enteråœ¨åº•å±‚æ˜¯é€šè¿‡C++å‡½æ•°ï¼Œå¯¹groupçš„valueè¿›è¡Œ--æ“ä½œï¼ˆå³0 -> -1ï¼‰
dispatch_group_leaveåœ¨åº•å±‚æ˜¯é€šè¿‡C++å‡½æ•°ï¼Œå¯¹groupçš„valueè¿›è¡Œ++æ“ä½œï¼ˆå³-1 -> 0ï¼‰
dispatch_group_notifyåœ¨åº•å±‚ä¸»è¦æ˜¯åˆ¤æ–­groupçš„stateæ˜¯å¦ç­‰äº0ï¼Œå½“ç­‰äº0æ—¶ï¼Œå°±é€šçŸ¥
blockä»»åŠ¡çš„å”¤é†’ï¼Œå¯ä»¥é€šè¿‡dispatch_group_leaveï¼Œä¹Ÿå¯ä»¥é€šè¿‡dispatch_group_notify
dispatch_group_async ç­‰åŒäºenter - leaveï¼Œå…¶åº•å±‚çš„å®ç°å°±æ˜¯enter-leave
