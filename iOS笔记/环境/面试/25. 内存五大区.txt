在iOS中，内存主要分为栈区、堆区、全局区、常量区、代码区五大区域


栈区（Stack）:
栈是系统数据结构，其对应的进程或者线程是唯一的
栈是向低地址扩展的数据结构
栈是一块连续的内存区域，遵循先进后出（FILO）原则
栈的地址空间在iOS中是以0X7开头
栈区一般在运行时分配

存储
栈区是由编译器自动分配并释放的，主要用来存储:
局部变量
函数的参数，例如函数的隐藏参数（id self，SEL _cmd）

优缺点
优点：因为栈是由编译器自动分配并释放的，不会产生内存碎片，所以快速高效
缺点：栈的内存大小有限制，数据不灵活
iOS主线程栈大小是1MB
其他线程是512KB
MAC只有8M
https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW7


堆区（Heap）:
堆是向高地址扩展的数据结构
堆是不连续的内存区域，类似于链表结构（便于增删，不便于查询），遵循先进先出（FIFO）原则
堆的地址空间在iOS中是以0x6开头，其空间的分配总是动态的
堆区的分配一般是在运行时分配

存储
堆区是由程序员动态分配和释放的，如果程序员不释放，程序结束后，可能由操作系统回收，主要用于存放
OC中使用alloc或者 使用new开辟空间创建对象
C语言中使用malloc、calloc、realloc分配的空间，需要free释放

优缺点
优点：灵活方便，数据适应面广泛
缺点：需手动管理，速度慢、容易产生内存碎片
当需要访问堆中内存时，一般需要先通过对象读取到栈区的指针地址，然后通过指针地址访问堆区


全局区（静态区，即.bss & .data）:
全局区是编译时分配的内存空间，在iOS中一般以0x1开头，在程序运行过程中，此内存中的数据一直存在，程序结束后由系统释放，主要存放
未初始化的全局变量和静态变量，即BSS区（.bss）
已初始化的全局变量和静态变量，即数据区（.data）
其中，全局变量是指变量值可以在运行时被动态修改，而静态变量是static修饰的变量，包含静态局部变量和静态全局变量


常量区（即.rodata）:
常量区是编译时分配的内存空间，在程序结束后由系统释放，主要存放
已经使用了的，且没有指向的字符串常量
字符串常量因为可能在程序中被多次使用，所以`在程序运行之前就会提前分配内存


代码区（即.text）
代码区是编译时分配主要用于存放程序运行时的代码,代码会被编译成二进制存进内存的


- (void)test{
    
    NSInteger i = 123;
    NSLog(@"i的内存地址：%p", &i);
    
    NSString *string = @"CJL";
    NSLog(@"string的内存地址：%p", string);
    NSLog(@"&string的内存地址：%p", &string);
    
    NSObject *obj = [[NSObject alloc] init];
    NSLog(@"obj的内存地址：%p", obj);
    NSLog(@"&obj的内存地址：%p", &obj);  
}
对于局部变量i，从地址可以看出是0x7开头，所以i存放在栈区

对于字符串对象string，分别打印了string的对象地址 和 string对象的指针地址
string的对象地址是以0x1开头，说明是存放在常量区
string对象的指针地址是以0x7开头，说明是存放在栈区

对于alloc创建的对象obj，分别打印了obj的对象地址 和 obj对象的指针地址
obj的对象地址是以0x6开头，说明是存放在堆区
obj对象的指针地址是以0x7开头，说明是存放在栈区



函数栈:
函数栈又称为栈区，在内存中从高地址往低地址分配，与堆区相对
栈帧是指函数（运行中且未完成）占用的一块独立的连续内存区域
应用中新创建的每个线程都有专用的栈空间，栈可以在线程期间自由使用。而线程中有千千万万的函数调用，这些函数共享进程的这个栈空间。每个函数所使用的栈空间是一个栈帧，所有的栈帧就组成了这个线程完整的栈
函数调用是发生在栈上的，每个函数的相关信息（例如局部变量、调用记录等）都存储在一个栈帧中，每执行一次函数调用，就会生成一个与其相关的栈帧，然后将其栈帧压入函数栈，而当函数执行结束，则将此函数对应的栈帧出栈并释放掉

其中main stack frame为调用函数的栈帧
func1 stack frame为当前函数(被调用者)的栈帧
栈底在高地址，栈向下增长。
FP就是栈基址，它指向函数的栈帧起始地址
SP则是函数的栈指针，它指向栈顶的位置。
ARM压栈的顺序很是规矩(也比较容易被黑客攻破么)，依次为当前函数指针PC、返回指针LR、栈指针SP、栈基址FP、传入参数个数及指针、本地变量和临时变量。
如果函数准备调用另一个函数，跳转之前临时变量区先要保存另一个函数的参数。
ARM也可以用栈基址和栈指针明确标示栈帧的位置，栈指针SP一直移动，ARM的特点是，两个栈空间内的地址（SP+FP）前面，必然有两个代码地址（PC+LR）明确标示着调用函数位置内的某个地址。


堆栈溢出:
一般情况下应用程序是不需要考虑堆和栈的大小的，但是事实上堆和栈都不是无上限的，过多的递归会导致栈溢出，过多的alloc变量会导致堆溢出。
所以预防堆栈溢出的方法:
（1）避免层次过深的递归调用；
（2）不要使用过多的局部变量，控制局部变量的大小；
（3）避免分配占用空间太大的对象，并及时释放;
（4）实在不行，适当的情景下调用系统API修改线程的堆栈大小；
