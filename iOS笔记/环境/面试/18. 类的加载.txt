ç†è§£ç±»çš„ç›¸å…³ä¿¡æ¯æ˜¯å¦‚ä½•åŠ è½½åˆ°å†…å­˜çš„ï¼Œå…¶ä¸­é‡ç‚¹å…³æ³¨map_imageså’Œload_images

map_imagesï¼šä¸»è¦æ˜¯ç®¡ç†æ–‡ä»¶ä¸­å’ŒåŠ¨æ€åº“ä¸­çš„æ‰€æœ‰ç¬¦å·ï¼Œå³classã€protocolã€selectorã€categoryç­‰
load_imagesï¼šåŠ è½½æ‰§è¡Œloadæ–¹æ³•
å…¶ä¸­ä»£ç é€šè¿‡ç¼–è¯‘ï¼Œè¯»å–åˆ°Mach-Oå¯æ‰§è¡Œæ–‡ä»¶ä¸­ï¼Œå†ä»Mach-Oä¸­è¯»å–åˆ°å†…å­˜


map_imagesï¼šåŠ è½½é•œåƒæ–‡ä»¶åˆ°å†…å­˜
é¦–å…ˆéœ€è¦è¯´æ˜ä¸ºä»€ä¹ˆmap_imagesæœ‰&ï¼Œè€Œload_imagesæ²¡æœ‰
map_imagesæ˜¯ å¼•ç”¨ç±»å‹ï¼Œå¤–ç•Œå˜äº†ï¼Œè·Ÿç€å˜ã€‚
load_imagesæ˜¯ å€¼ç±»å‹ï¼Œä¸ä¼ é€’å€¼

map_imagesæ–¹æ³•çš„ä¸»è¦ä½œç”¨æ˜¯å°†Mach-Oä¸­çš„ç±»ä¿¡æ¯åŠ è½½åˆ°å†…å­˜
void
map_images(unsigned count, const char * const paths[],
           const struct mach_header * const mhdrs[])
{
    mutex_locker_t lock(runtimeLock);
    return map_images_nolock(count, paths, mhdrs);
}

è¿›å…¥ map_images_nolock æºç ï¼Œå…¶å…³é”®ä»£ç æ˜¯_read_images
void
map_images_nolock(unsigned mhCount, const char * const mhPaths[],
                  const struct mach_header * const mhdrs[])
{
    //...çœç•¥

    // Find all images with Objective-C metadata.æŸ¥æ‰¾æ‰€æœ‰å¸¦æœ‰Objective-Cå…ƒæ•°æ®çš„æ˜ åƒ
    hCount = 0;

    // Count classes. Size various table based on the total.è®¡ç®—ç±»çš„ä¸ªæ•°
    int totalClasses = 0;
    int unoptimizedTotalClasses = 0;
    //ä»£ç å—ï¼šä½œç”¨åŸŸï¼Œè¿›è¡Œå±€éƒ¨å¤„ç†ï¼Œå³å±€éƒ¨å¤„ç†ä¸€äº›äº‹ä»¶
    {
        //...çœç•¥
    }
    
    //...çœç•¥

    if (hCount > 0) {
        //åŠ è½½é•œåƒæ–‡ä»¶
        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);
    }

    firstTime = NO;
    
    // Call image load funcs after everything is set up.ä¸€åˆ‡è®¾ç½®å®Œæˆåï¼Œè°ƒç”¨é•œåƒåŠ è½½åŠŸèƒ½ã€‚
    for (auto func : loadImageFuncs) {
        for (uint32_t i = 0; i < mhCount; i++) {
            func(mhdrs[i]);
        }
    }
}

_read_imagesä¸»è¦æ˜¯ä¸»è¦æ˜¯åŠ è½½ç±»ä¿¡æ¯ï¼Œå³ç±»ã€åˆ†ç±»ã€åè®®ç­‰ï¼Œè¿›å…¥_read_imagesæºç å®ç°ï¼Œä¸»è¦åˆ†ä¸ºä»¥ä¸‹å‡ éƒ¨åˆ†ï¼š
1ã€æ¡ä»¶æ§åˆ¶è¿›è¡Œçš„ä¸€æ¬¡åŠ è½½
2ã€ä¿®å¤é¢„ç¼–è¯‘é˜¶æ®µçš„@selectorçš„æ··ä¹±é—®é¢˜
3ã€é”™è¯¯æ··ä¹±çš„ç±»å¤„ç†
4ã€ä¿®å¤é‡æ˜ å°„ä¸€äº›æ²¡æœ‰è¢«é•œåƒæ–‡ä»¶åŠ è½½è¿›æ¥çš„ç±»
5ã€ä¿®å¤ä¸€äº›æ¶ˆæ¯
6ã€å½“ç±»é‡Œé¢æœ‰åè®®æ—¶ï¼šreadProtocol è¯»å–åè®®
7ã€ä¿®å¤æ²¡æœ‰è¢«åŠ è½½çš„åè®®
8ã€åˆ†ç±»å¤„ç†
9ã€ç±»çš„åŠ è½½å¤„ç†
10ã€æ²¡æœ‰è¢«å¤„ç†çš„ç±»ï¼Œä¼˜åŒ–é‚£äº›è¢«ä¾µçŠ¯çš„ç±»


1ã€æ¡ä»¶æ§åˆ¶è¿›è¡Œçš„ä¸€æ¬¡åŠ è½½
åœ¨doneOnceæµç¨‹ä¸­é€šè¿‡NXCreateMapTable åˆ›å»ºè¡¨ï¼Œå­˜æ”¾ç±»ä¿¡æ¯ï¼Œ
å³åˆ›å»ºä¸€å¼ ç±»çš„å“ˆå¸Œè¡¨``gdb_objc_realized_classesï¼Œå…¶ç›®çš„æ˜¯ä¸ºäº†ç±»æŸ¥æ‰¾æ–¹ä¾¿ã€å¿«æ·
if (!doneOnce) {
     
    //...çœç•¥
    
    // namedClasses
    // Preoptimized classes don't go in this table.
    // 4/3 is NXMapTable's load factor
    int namedClassesSize = 
        (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * 4 / 3;
//åˆ›å»ºè¡¨ï¼ˆå“ˆå¸Œè¡¨key-valueï¼‰ï¼Œç›®çš„æ˜¯æŸ¥æ‰¾å¿«
    gdb_objc_realized_classes =
        NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);

    ts.log("IMAGE TIMES: first time tasks");
}

æŸ¥çœ‹gdb_objc_realized_classesçš„æ³¨é‡Šè¯´æ˜ï¼Œè¿™ä¸ªå“ˆå¸Œè¡¨ç”¨äºå­˜å‚¨ä¸åœ¨å…±äº«ç¼“å­˜ä¸”å·²å‘½åç±»ï¼Œæ— è®ºç±»æ˜¯å¦å®ç°ï¼Œå…¶å®¹é‡æ˜¯ç±»æ•°é‡çš„4/3
// This is a misnomer: gdb_objc_realized_classes is actually a list of 
// named classes not in the dyld shared cache, whether realized or not.
//gdb_objc_realized_classeså®é™…ä¸Šæ˜¯ä¸åœ¨dyldå…±äº«ç¼“å­˜ä¸­çš„å·²å‘½åç±»çš„åˆ—è¡¨ï¼Œæ— è®ºæ˜¯å¦å®ç°
NXMapTable *gdb_objc_realized_classes;  // exported for debuggers in objc-gdb.h


2ã€ä¿®å¤é¢„ç¼–è¯‘é˜¶æ®µçš„@selectorçš„æ··ä¹±é—®é¢˜
ä¸»è¦æ˜¯é€šè¿‡é€šè¿‡_getObjc2SelectorRefsæ‹¿åˆ°Mach_Oä¸­çš„é™æ€æ®µ__objc_selrefsï¼Œéå†åˆ—è¡¨è°ƒç”¨sel_registerNameNoLockå°†SELæ·»åŠ åˆ°namedSelectorså“ˆå¸Œè¡¨ä¸­

// Fix up @selector references ä¿®å¤@selectorå¼•ç”¨
//sel ä¸æ˜¯ç®€å•çš„å­—ç¬¦ä¸²ï¼Œè€Œæ˜¯å¸¦åœ°å€çš„å­—ç¬¦ä¸²
static size_t UnfixedSelectors;
{
    mutex_locker_t lock(selLock);
    for (EACH_HEADER) {
        if (hi->hasPreoptimizedSelectors()) continue;

        bool isBundle = hi->isBundle();
        //é€šè¿‡_getObjc2SelectorRefsæ‹¿åˆ°Mach-Oä¸­çš„é™æ€æ®µ__objc_selrefs
        SEL *sels = _getObjc2SelectorRefs(hi, &count);
        UnfixedSelectors += count;
        for (i = 0; i < count; i++) { //åˆ—è¡¨éå†
            const char *name = sel_cname(sels[i]);
            //æ³¨å†Œselæ“ä½œï¼Œå³å°†selæ·»åŠ åˆ°
            SEL sel = sel_registerNameNoLock(name, isBundle);
            if (sels[i] != sel) {//å½“selä¸sels[i]åœ°å€ä¸ä¸€è‡´æ—¶ï¼Œéœ€è¦è°ƒæ•´ä¸ºä¸€è‡´çš„
                sels[i] = sel;
            }
        }
    }
}

å…¶ä¸­_getObjc2SelectorRefsçš„æºç å¦‚ä¸‹ï¼Œè¡¨ç¤ºè·å–Mach-Oä¸­çš„é™æ€æ®µ__objc_selrefsï¼Œåç»­é€šè¿‡_getObjc2å¼€å¤´çš„Mach-Oé™æ€æ®µè·å–ï¼Œéƒ½å¯¹åº”ä¸åŒçš„section name
åç»­é€šè¿‡_getObjc2å¼€å¤´çš„Mach-Oé™æ€æ®µè·å–ï¼Œéƒ½å¯¹åº”ä¸åŒçš„section name

//      function name                 content type     section name
GETSECT(_getObjc2SelectorRefs,        SEL,             "__objc_selrefs"); 
GETSECT(_getObjc2MessageRefs,         message_ref_t,   "__objc_msgrefs"); 
GETSECT(_getObjc2ClassRefs,           Class,           "__objc_classrefs");
GETSECT(_getObjc2SuperRefs,           Class,           "__objc_superrefs");
GETSECT(_getObjc2ClassList,           classref_t const,      "__objc_classlist");
GETSECT(_getObjc2NonlazyClassList,    classref_t const,      "__objc_nlclslist");
GETSECT(_getObjc2CategoryList,        category_t * const,    "__objc_catlist");
GETSECT(_getObjc2CategoryList2,       category_t * const,    "__objc_catlist2");
GETSECT(_getObjc2NonlazyCategoryList, category_t * const,    "__objc_nlcatlist");
GETSECT(_getObjc2ProtocolList,        protocol_t * const,    "__objc_protolist");
GETSECT(_getObjc2ProtocolRefs,        protocol_t *,    "__objc_protorefs");
GETSECT(getLibobjcInitializers,       UnsignedInitializer, "__objc_init_func");

sel_registerNameNoLockæºç è·¯å¾„å¦‚ä¸‹ï¼šsel_registerNameNoLock -> __sel_registerName,å¦‚ä¸‹æ‰€ç¤ºï¼Œå…¶å…³é”®ä»£ç æ˜¯auto it = namedSelectors.get().insert(name);ï¼Œå³å°†selæ’å…¥namedSelectorså“ˆå¸Œè¡¨

SEL sel_registerNameNoLock(const char *name, bool copy) {
    return __sel_registerName(name, 0, copy);  // NO lock, maybe copy
}

static SEL __sel_registerName(const char *name, bool shouldLock, bool copy) 
{
    SEL result = 0;

    if (shouldLock) selLock.assertUnlocked();
    else selLock.assertLocked();

    if (!name) return (SEL)0;

    result = search_builtins(name);
    if (result) return result;
    
    conditional_mutex_locker_t lock(selLock, shouldLock);
    auto it = namedSelectors.get().insert(name);//selæ’å…¥è¡¨
    if (it.second) {
        // No match. Insert.
        *it.first = (const char *)sel_alloc(name, copy);
    }
    return (SEL)*it.first;
}

å…¶ä¸­selector --> selå¹¶ä¸æ˜¯ç®€å•çš„å­—ç¬¦ä¸²ï¼Œæ˜¯å¸¦åœ°å€çš„å­—ç¬¦ä¸²
sels[i]ä¸selå­—ç¬¦ä¸²ä¸€è‡´ï¼Œä½†æ˜¯åœ°å€ä¸ä¸€è‡´ï¼Œæ‰€ä»¥éœ€è¦è°ƒæ•´ä¸ºä¸€è‡´çš„ã€‚å³fix up


3ã€é”™è¯¯æ··ä¹±çš„ç±»å¤„ç†
ä¸»è¦æ˜¯ä»Mach-Oä¸­å–å‡ºæ‰€æœ‰ç±»ï¼Œåœ¨éå†è¿›è¡Œå¤„ç†
//3ã€é”™è¯¯æ··ä¹±çš„ç±»å¤„ç†
// Discover classes. Fix up unresolved future classes. Mark bundle classes.
bool hasDyldRoots = dyld_shared_cache_some_image_overridden();
//è¯»å–ç±»ï¼šreadClass
for (EACH_HEADER) {
    if (! mustReadClasses(hi, hasDyldRoots)) {
        // Image is sufficiently optimized that we need not call readClass()
        continue;
    }
    //ä»ç¼–è¯‘åçš„ç±»åˆ—è¡¨ä¸­å–å‡ºæ‰€æœ‰ç±»ï¼Œå³ä»Mach-Oä¸­è·å–é™æ€æ®µ__objc_classlistï¼Œæ˜¯ä¸€ä¸ªclassref_tç±»å‹çš„æŒ‡é’ˆ
    classref_t const *classlist = _getObjc2ClassList(hi, &count);

    bool headerIsBundle = hi->isBundle();
    bool headerIsPreoptimized = hi->hasPreoptimizedClasses();

    for (i = 0; i < count; i++) {
        Class cls = (Class)classlist[i];//æ­¤æ—¶è·å–çš„clsåªæ˜¯ä¸€ä¸ªåœ°å€
        Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized); //è¯»å–ç±»ï¼Œç»è¿‡è¿™æ­¥åï¼Œclsè·å–çš„å€¼æ‰æ˜¯ä¸€ä¸ªåå­—
        //ç»è¿‡è°ƒè¯•ï¼Œå¹¶æœªæ‰§è¡Œifé‡Œé¢çš„æµç¨‹
        //åˆå§‹åŒ–æ‰€æœ‰æ‡’åŠ è½½çš„ç±»éœ€è¦çš„å†…å­˜ç©ºé—´ï¼Œä½†æ˜¯æ‡’åŠ è½½ç±»çš„æ•°æ®ç°åœ¨æ˜¯æ²¡æœ‰åŠ è½½åˆ°çš„ï¼Œè¿ç±»éƒ½æ²¡æœ‰åˆå§‹åŒ–
        if (newCls != cls  &&  newCls) {
            // Class was moved but not deleted. Currently this occurs 
            // only when the new class resolved a future class.
            // Non-lazily realize the class below.
            //å°†æ‡’åŠ è½½çš„ç±»æ·»åŠ åˆ°æ•°ç»„ä¸­
            resolvedFutureClasses = (Class *)
                realloc(resolvedFutureClasses, 
                        (resolvedFutureClassCount+1) * sizeof(Class));
            resolvedFutureClasses[resolvedFutureClassCount++] = newCls;
        }
    }
}
ts.log("IMAGE TIMES: discover classes");

é€šè¿‡ä»£ç è°ƒè¯•ï¼ŒçŸ¥é“äº†åœ¨æœªæ‰§è¡ŒreadClassæ–¹æ³•å‰ï¼Œclsåªæ˜¯ä¸€ä¸ªåœ°å€
åœ¨æ‰§è¡Œåï¼Œclsæ˜¯ä¸€ä¸ªç±»çš„åç§°
æ‰€ä»¥åˆ°è¿™æ­¥ä¸ºæ­¢ï¼Œç±»çš„ä¿¡æ¯ç›®å‰ä»…å­˜å‚¨äº†åœ°å€+åç§°


4ã€ä¿®å¤é‡æ˜ å°„ä¸€äº›æ²¡æœ‰è¢«é•œåƒæ–‡ä»¶åŠ è½½è¿›æ¥çš„ç±»
ä¸»è¦æ˜¯å°†æœªæ˜ å°„çš„Class å’ŒSuper Classè¿›è¡Œé‡æ˜ å°„ï¼Œå…¶ä¸­
_getObjc2ClassRefsæ˜¯è·å–Mach-Oä¸­çš„é™æ€æ®µ__objc_classrefså³ç±»çš„å¼•ç”¨
_getObjc2SuperRefsæ˜¯è·å–Mach-Oä¸­çš„é™æ€æ®µ__objc_superrefså³çˆ¶ç±»çš„å¼•ç”¨
é€šè¿‡æ³¨é‡Šå¯ä»¥å¾—çŸ¥ï¼Œè¢«remapClassRefçš„ç±»éƒ½æ˜¯æ‡’åŠ è½½çš„ç±»ï¼Œæ‰€ä»¥æœ€åˆç»è¿‡è°ƒè¯•æ—¶ï¼Œè¿™éƒ¨åˆ†ä»£ç æ˜¯æ²¡æœ‰æ‰§è¡Œçš„
//4ã€ä¿®å¤é‡æ˜ å°„ä¸€äº›æ²¡æœ‰è¢«é•œåƒæ–‡ä»¶åŠ è½½è¿›æ¥çš„ç±»
// Fix up remapped classes ä¿®æ­£é‡æ–°æ˜ å°„çš„ç±»
// Class list and nonlazy class list remain unremapped.ç±»åˆ—è¡¨å’Œéæƒ°æ€§ç±»åˆ—è¡¨ä¿æŒæœªæ˜ å°„
// Class refs and super refs are remapped for message dispatching.ç±»å¼•ç”¨å’Œè¶…çº§å¼•ç”¨å°†é‡æ–°æ˜ å°„ä»¥è¿›è¡Œæ¶ˆæ¯åˆ†å‘
//ç»è¿‡è°ƒè¯•ï¼Œå¹¶æœªæ‰§è¡Œifé‡Œé¢çš„æµç¨‹
//å°†æœªæ˜ å°„çš„Class å’Œ Super Classé‡æ˜ å°„ï¼Œè¢«remapçš„ç±»éƒ½æ˜¯æ‡’åŠ è½½çš„ç±»
if (!noClassesRemapped()) {
    for (EACH_HEADER) {
        Class *classrefs = _getObjc2ClassRefs(hi, &count);//Mach-Oçš„é™æ€æ®µ __objc_classrefs
        for (i = 0; i < count; i++) {
            remapClassRef(&classrefs[i]);
        }
        // fixme why doesn't test future1 catch the absence of this?
        classrefs = _getObjc2SuperRefs(hi, &count);//Mach_Oä¸­çš„é™æ€æ®µ __objc_superrefs
        for (i = 0; i < count; i++) {
            remapClassRef(&classrefs[i]);
        }
    }
}

ts.log("IMAGE TIMES: remap classes");


5ã€ä¿®å¤ä¸€äº›æ¶ˆæ¯
ä¸»è¦æ˜¯é€šè¿‡_getObjc2MessageRefs è·å–Mach-Oçš„é™æ€æ®µ __objc_msgrefsï¼Œå¹¶éå†é€šè¿‡fixupMessageRefå°†å‡½æ•°æŒ‡é’ˆè¿›è¡Œæ³¨å†Œï¼Œå¹¶fixä¸ºæ–°çš„å‡½æ•°æŒ‡é’ˆ
#if SUPPORT_FIXUP
//5ã€ä¿®å¤ä¸€äº›æ¶ˆæ¯
    // Fix up old objc_msgSend_fixup call sites
    for (EACH_HEADER) {
        // _getObjc2MessageRefs è·å–Mach-Oçš„é™æ€æ®µ __objc_msgrefs
        message_ref_t *refs = _getObjc2MessageRefs(hi, &count);
        if (count == 0) continue;

        if (PrintVtables) {
            _objc_inform("VTABLES: repairing %zu unsupported vtable dispatch "
                         "call sites in %s", count, hi->fname());
        }
        //ç»è¿‡è°ƒè¯•ï¼Œå¹¶æœªæ‰§è¡Œforé‡Œé¢çš„æµç¨‹
        //éå†å°†å‡½æ•°æŒ‡é’ˆè¿›è¡Œæ³¨å†Œï¼Œå¹¶fixä¸ºæ–°çš„å‡½æ•°æŒ‡é’ˆ
        for (i = 0; i < count; i++) {
            fixupMessageRef(refs+i);
        }
    }

    ts.log("IMAGE TIMES: fix up objc_msgSend_fixup");
#endif


6ã€å½“ç±»é‡Œé¢æœ‰åè®®æ—¶ï¼šreadProtocol è¯»å–åè®®
//6ã€å½“ç±»é‡Œé¢æœ‰åè®®æ—¶ï¼šreadProtocol è¯»å–åè®®
// Discover protocols. Fix up protocol refs. å‘ç°åè®®ã€‚ä¿®æ­£åè®®å‚è€ƒ
//éå†æ‰€æœ‰åè®®åˆ—è¡¨ï¼Œå¹¶ä¸”å°†åè®®åˆ—è¡¨åŠ è½½åˆ°Protocolçš„å“ˆå¸Œè¡¨ä¸­
for (EACH_HEADER) {
    extern objc_class OBJC_CLASS_$_Protocol;
    //cls = Protocolç±»ï¼Œæ‰€æœ‰åè®®å’Œå¯¹è±¡çš„ç»“æ„ä½“éƒ½ç±»ä¼¼ï¼Œisaéƒ½å¯¹åº”Protocolç±»
    Class cls = (Class)&OBJC_CLASS_$_Protocol;
    ASSERT(cls);
    //è·å–protocolå“ˆå¸Œè¡¨ -- protocol_map
    NXMapTable *protocol_map = protocols();
    bool isPreoptimized = hi->hasPreoptimizedProtocols();

    // Skip reading protocols if this is an image from the shared cache
    // and we support roots
    // Note, after launch we do need to walk the protocol as the protocol
    // in the shared cache is marked with isCanonical() and that may not
    // be true if some non-shared cache binary was chosen as the canonical
    // definition
    if (launchTime && isPreoptimized && cacheSupportsProtocolRoots) {
        if (PrintProtocols) {
            _objc_inform("PROTOCOLS: Skipping reading protocols in image: %s",
                         hi->fname());
        }
        continue;
    }

    bool isBundle = hi->isBundle();
    //é€šè¿‡_getObjc2ProtocolList è·å–åˆ°Mach-Oä¸­çš„é™æ€æ®µ__objc_protoliståè®®åˆ—è¡¨ï¼Œ
    //å³ä»ç¼–è¯‘å™¨ä¸­è¯»å–å¹¶åˆå§‹åŒ–protocol
    protocol_t * const *protolist = _getObjc2ProtocolList(hi, &count);
    for (i = 0; i < count; i++) {
        //é€šè¿‡æ·»åŠ protocolåˆ°protocol_mapå“ˆå¸Œè¡¨ä¸­
        readProtocol(protolist[i], cls, protocol_map, 
                     isPreoptimized, isBundle);
    }
}

ts.log("IMAGE TIMES: discover protocols");

é€šè¿‡NXMapTable *protocol_map = protocols();åˆ›å»ºprotocolå“ˆå¸Œè¡¨ï¼Œè¡¨çš„åç§°ä¸ºprotocol_map
/***********************************************************************
* protocols
* Returns the protocol name => protocol map for protocols.
* Locking: runtimeLock must read- or write-locked by the caller
**********************************************************************/
static NXMapTable *protocols(void)
{
    static NXMapTable *protocol_map = nil;
    
    runtimeLock.assertLocked();

    INIT_ONCE_PTR(protocol_map, 
                  NXCreateMapTable(NXStrValueMapPrototype, 16), 
                  NXFreeMapTable(v) );

    return protocol_map;
}

é€šè¿‡_getObjc2ProtocolList è·å–åˆ°Mach-Oä¸­çš„é™æ€æ®µ__objc_protoliståè®®åˆ—è¡¨ï¼Œå³ä»ç¼–è¯‘å™¨ä¸­è¯»å–å¹¶åˆå§‹åŒ–protocol
protocol_t * const *protolist = _getObjc2ProtocolList(hi, &count);

å¾ªç¯éå†åè®®åˆ—è¡¨ï¼Œé€šè¿‡readProtocolæ–¹æ³•å°†åè®®æ·»åŠ åˆ°protocol_mapå“ˆå¸Œè¡¨ä¸­
readProtocol(protolist[i], cls, protocol_map, 
                         isPreoptimized, isBundle);


7ã€ä¿®å¤æ²¡æœ‰è¢«åŠ è½½çš„åè®®
ä¸»è¦æ˜¯é€šè¿‡ _getObjc2ProtocolRefs è·å–åˆ°Mach-Oçš„é™æ€æ®µ __objc_protorefsï¼ˆä¸6ä¸­çš„__objc_protolistå¹¶ä¸æ˜¯åŒä¸€ä¸ªä¸œè¥¿ï¼‰ï¼Œç„¶åéå†éœ€è¦ä¿®å¤çš„åè®®ï¼Œé€šè¿‡remapProtocolRefæ¯”è¾ƒå½“å‰åè®®å’Œåè®®åˆ—è¡¨ä¸­çš„åŒä¸€ä¸ªå†…å­˜åœ°å€çš„åè®®æ˜¯å¦ç›¸åŒï¼Œå¦‚æœä¸åŒåˆ™æ›¿æ¢

//7ã€ä¿®å¤æ²¡æœ‰è¢«åŠ è½½çš„åè®®
// Fix up @protocol references
// Preoptimized images may have the right 
// answer already but we don't know for sure.
for (EACH_HEADER) {
    // At launch time, we know preoptimized image refs are pointing at the
    // shared cache definition of a protocol.  We can skip the check on
    // launch, but have to visit @protocol refs for shared cache images
    // loaded later.
    if (launchTime && cacheSupportsProtocolRoots && hi->isPreoptimized())
        continue;
    //_getObjc2ProtocolRefs è·å–åˆ°Mach-Oçš„é™æ€æ®µ __objc_protorefs
    protocol_t **protolist = _getObjc2ProtocolRefs(hi, &count);
    for (i = 0; i < count; i++) {//éå†
        //æ¯”è¾ƒå½“å‰åè®®å’Œåè®®åˆ—è¡¨ä¸­çš„åŒä¸€ä¸ªå†…å­˜åœ°å€çš„åè®®æ˜¯å¦ç›¸åŒï¼Œå¦‚æœä¸åŒåˆ™æ›¿æ¢
        remapProtocolRef(&protolist[i]);//ç»è¿‡ä»£ç è°ƒè¯•ï¼Œå¹¶æœªæ‰§è¡Œ
    }
}

ts.log("IMAGE TIMES: fix up @protocol references");

/***********************************************************************
* remapProtocolRef
* Fix up a protocol ref, in case the protocol referenced has been reallocated.
* Locking: runtimeLock must be read- or write-locked by the caller
**********************************************************************/
static size_t UnfixedProtocolReferences;
static void remapProtocolRef(protocol_t **protoref)
{
    runtimeLock.assertLocked();
    //è·å–åè®®åˆ—è¡¨ä¸­ç»Ÿä¸€å†…å­˜åœ°å€çš„åè®®
    protocol_t *newproto = remapProtocol((protocol_ref_t)*protoref);
    if (*protoref != newproto) {//å¦‚æœå½“å‰åè®® ä¸ åŒä¸€å†…å­˜åœ°å€åè®®ä¸åŒï¼Œåˆ™æ›¿æ¢
        *protoref = newproto;
        UnfixedProtocolReferences++;
    }
}


8ã€åˆ†ç±»å¤„ç†
ä¸»è¦æ˜¯å¤„ç†åˆ†ç±»ï¼Œéœ€è¦åœ¨åˆ†ç±»åˆå§‹åŒ–å¹¶å°†æ•°æ®åŠ è½½åˆ°ç±»åæ‰æ‰§è¡Œï¼Œå¯¹äºè¿è¡Œæ—¶å‡ºç°çš„åˆ†ç±»ï¼Œå°†åˆ†ç±»çš„å‘ç°æ¨è¿Ÿæ¨è¿Ÿåˆ°å¯¹_dyld_objc_notify_registerçš„è°ƒç”¨å®Œæˆåçš„ç¬¬ä¸€ä¸ªload_imagesè°ƒç”¨ä¸ºæ­¢
//8ã€åˆ†ç±»å¤„ç†
// Discover categories. Only do this after the initial category å‘ç°åˆ†ç±»
// attachment has been done. For categories present at startup,
// discovery is deferred until the first load_images call after
// the call to _dyld_objc_notify_register completes. rdar://problem/53119145
if (didInitialAttachCategories) {
    for (EACH_HEADER) {
        load_categories_nolock(hi);
    }
}

ts.log("IMAGE TIMES: discover categories");


9ã€ç±»çš„åŠ è½½å¤„ç†
ä¸»è¦æ˜¯å®ç°ç±»çš„åŠ è½½å¤„ç†ï¼Œå®ç°éæ‡’åŠ è½½ç±»
é€šè¿‡_getObjc2NonlazyClassListè·å–Mach-Oçš„é™æ€æ®µ__objc_nlclslistéæ‡’åŠ è½½ç±»è¡¨

é€šè¿‡addClassTableEntryå°†éæ‡’åŠ è½½ç±»æ’å…¥ç±»è¡¨ï¼Œå­˜å‚¨åˆ°å†…å­˜ï¼Œå¦‚æœå·²ç»æ·»åŠ å°±ä¸ä¼šè½½æ·»åŠ ï¼Œéœ€è¦ç¡®ä¿æ•´ä¸ªç»“æ„éƒ½è¢«æ·»åŠ 

é€šè¿‡realizeClassWithoutSwiftå®ç°å½“å‰çš„ç±»ï¼Œå› ä¸ºå‰é¢3ä¸­çš„readClassè¯»å–åˆ°å†…å­˜çš„ä»…ä»…åªæœ‰åœ°å€+åç§°ï¼Œç±»çš„dataæ•°æ®å¹¶æ²¡æœ‰åŠ è½½å‡ºæ¥

// Realize non-lazy classes (for +load methods and static instances) åˆå§‹åŒ–éæ‡’åŠ è½½ç±»ï¼Œè¿›è¡Œrwã€roç­‰æ“ä½œï¼šrealizeClassWithoutSwift
//æ‡’åŠ è½½ç±» -- åˆ«äººä¸åŠ¨æˆ‘ï¼Œæˆ‘å°±ä¸åŠ¨
//å®ç°éæ‡’åŠ è½½çš„ç±»ï¼Œå¯¹äºloadæ–¹æ³•å’Œé™æ€å®ä¾‹å˜é‡
for (EACH_HEADER) {
    //é€šè¿‡_getObjc2NonlazyClassListè·å–Mach-Oçš„é™æ€æ®µ__objc_nlclslistéæ‡’åŠ è½½ç±»è¡¨
    classref_t const *classlist = 
        _getObjc2NonlazyClassList(hi, &count);
    for (i = 0; i < count; i++) {
        Class cls = remapClass(classlist[i]);
        
        const char *mangledName  = cls->mangledName();
            const char *LGPersonName = "LGPerson";
        
            if (strcmp(mangledName, LGPersonName) == 0) {
                auto kc_ro = (const class_ro_t *)cls->data();
                printf("_getObjc2NonlazyClassList: è¿™ä¸ªæ˜¯æˆ‘è¦ç ”ç©¶çš„ %s \n",LGPersonName);
            }
        
        if (!cls) continue;

        addClassTableEntry(cls);//æ’å…¥è¡¨ï¼Œä½†æ˜¯å‰é¢å·²ç»æ’å…¥è¿‡äº†ï¼Œæ‰€ä»¥ä¸ä¼šé‡æ–°æ’å…¥

        if (cls->isSwiftStable()) {
            if (cls->swiftMetadataInitializer()) {
                _objc_fatal("Swift class %s with a metadata initializer "
                            "is not allowed to be non-lazy",
                            cls->nameForLogging());
            }
            // fixme also disallow relocatable classes
            // We can't disallow all Swift classes because of
            // classes like Swift.__EmptyArrayStorage
        }
        //å®ç°å½“å‰çš„ç±»ï¼Œå› ä¸ºå‰é¢readClassè¯»å–åˆ°å†…å­˜çš„ä»…ä»…åªæœ‰åœ°å€+åç§°ï¼Œç±»çš„dataæ•°æ®å¹¶æ²¡æœ‰åŠ è½½å‡ºæ¥
        //å®ç°æ‰€æœ‰éæ‡’åŠ è½½çš„ç±»(å®ä¾‹åŒ–ç±»å¯¹è±¡çš„ä¸€äº›ä¿¡æ¯ï¼Œä¾‹å¦‚rw)
        realizeClassWithoutSwift(cls, nil);
    }
}

ts.log("IMAGE TIMES: realize non-lazy classes");


10ã€æ²¡æœ‰è¢«å¤„ç†çš„ç±»ï¼Œä¼˜åŒ–é‚£äº›è¢«ä¾µçŠ¯çš„ç±»
// Realize newly-resolved future classes, in case CF manipulates them
if (resolvedFutureClasses) {
    for (i = 0; i < resolvedFutureClassCount; i++) {
        Class cls = resolvedFutureClasses[i];
        if (cls->isSwiftStable()) {
            _objc_fatal("Swift class is not allowed to be future");
        }
        //å®ç°ç±»
        realizeClassWithoutSwift(cls, nil);
        cls->setInstancesRequireRawIsaRecursively(false/*inherited*/);
    }
    free(resolvedFutureClasses);
}

ts.log("IMAGE TIMES: realize future classes");

if (DebugNonFragileIvars) {
    //å®ç°æ‰€æœ‰ç±»
    realizeAllClasses();
}
é‡ç‚¹å…³æ³¨çš„æ˜¯3ä¸­çš„readClassä»¥åŠ9ä¸­realizeClassWithoutSwiftä¸¤ä¸ªæ–¹æ³•



readClassï¼šè¯»å–ç±»
readClassä¸»è¦æ˜¯è¯»å–ç±»ï¼Œåœ¨æœªè°ƒç”¨è¯¥æ–¹æ³•å‰ï¼Œclsåªæ˜¯ä¸€ä¸ªåœ°å€ï¼Œæ‰§è¡Œè¯¥æ–¹æ³•åï¼Œclsæ˜¯ç±»çš„åç§°ï¼Œå…¶æºç å®ç°å¦‚ä¸‹ï¼Œå…³é”®ä»£ç æ˜¯addNamedClasså’ŒaddClassTableEntry
/***********************************************************************
* readClass
* Read a class and metaclass as written by a compiler. è¯»å–ç¼–è¯‘å™¨ç¼–å†™çš„ç±»å’Œå…ƒç±»
* Returns the new class pointer. This could be:  è¿”å›æ–°çš„ç±»æŒ‡é’ˆï¼Œå¯èƒ½æ˜¯ï¼š
* - cls
* - nil  (cls has a missing weak-linked superclass)
* - something else (space for this class was reserved by a future class)
*
* Note that all work performed by this function is preflighted by 
* mustReadClasses(). Do not change this function without updating that one.
*
* Locking: runtimeLock acquired by map_images or objc_readClassPair
**********************************************************************/
Class readClass(Class cls, bool headerIsBundle, bool headerIsPreoptimized)
{
    const char *mangledName = cls->mangledName();//åå­—
    
    // **CJLå†™çš„** ----å¦‚æœæƒ³è¿›å…¥è‡ªå®šä¹‰ï¼Œè‡ªå·±åŠ ä¸€ä¸ªåˆ¤æ–­
    const char *LGPersonName = "LGPerson";
    if (strcmp(mangledName, LGPersonName) == 0) {
        auto kc_ro = (const class_ro_t *)cls->data();
        printf("%s -- ç ”ç©¶é‡ç‚¹--%s\n", __func__,mangledName);
    }
    //å½“å‰ç±»çš„çˆ¶ç±»ä¸­è‹¥æœ‰ä¸¢å¤±çš„weak-linkedç±»ï¼Œåˆ™è¿”å›nil
    if (missingWeakSuperclass(cls)) {
        // No superclass (probably weak-linked). 
        // Disavow any knowledge of this subclass.
        if (PrintConnecting) {
            _objc_inform("CLASS: IGNORING class '%s' with "
                         "missing weak-linked superclass", 
                         cls->nameForLogging());
        }
        addRemappedClass(cls, nil);
        cls->superclass = nil;
        return nil;
    }
    
    cls->fixupBackwardDeployingStableSwift();
//åˆ¤æ–­æ˜¯ä¸æ˜¯åæœŸè¦å¤„ç†çš„ç±»
    //æ­£å¸¸æƒ…å†µä¸‹ï¼Œä¸ä¼šèµ°åˆ°popFutureNamedClassï¼Œå› ä¸ºè¿™æ˜¯ä¸“é—¨é’ˆå¯¹æœªæ¥å¾…å¤„ç†çš„ç±»çš„æ“ä½œ
    //é€šè¿‡æ–­ç‚¹è°ƒè¯•ï¼Œä¸ä¼šèµ°åˆ°ifæµç¨‹é‡Œé¢ï¼Œå› æ­¤ä¹Ÿä¸ä¼šå¯¹roã€rwè¿›è¡Œæ“ä½œ
    Class replacing = nil;
    if (Class newCls = popFutureNamedClass(mangledName)) {
        // This name was previously allocated as a future class.
        // Copy objc_class to future class's struct.
        // Preserve future's rw data block.
        
        if (newCls->isAnySwift()) {
            _objc_fatal("Can't complete future class request for '%s' "
                        "because the real class is too big.", 
                        cls->nameForLogging());
        }
        //è¯»å–classçš„dataï¼Œè®¾ç½®roã€rw
        //ç»è¿‡è°ƒè¯•ï¼Œå¹¶ä¸ä¼šèµ°åˆ°è¿™é‡Œ
        class_rw_t *rw = newCls->data();
        const class_ro_t *old_ro = rw->ro();
        memcpy(newCls, cls, sizeof(objc_class));
        rw->set_ro((class_ro_t *)newCls->data());
        newCls->setData(rw);
        freeIfMutable((char *)old_ro->name);
        free((void *)old_ro);
        
        addRemappedClass(cls, newCls);
        
        replacing = cls;
        cls = newCls;
    }
    //åˆ¤æ–­æ˜¯å¦ç±»æ˜¯å¦å·²ç»åŠ è½½åˆ°å†…å­˜
    if (headerIsPreoptimized  &&  !replacing) {
        // class list built in shared cache
        // fixme strict assert doesn't work because of duplicates
        // ASSERT(cls == getClass(name));
        ASSERT(getClassExceptSomeSwift(mangledName));
    } else {
        addNamedClass(cls, mangledName, replacing);//åŠ è½½å…±äº«ç¼“å­˜ä¸­çš„ç±»
        addClassTableEntry(cls);//æ’å…¥è¡¨ï¼Œå³ç›¸å½“äºä»mach-Oæ–‡ä»¶ è¯»å–åˆ° å†…å­˜ ä¸­
    }

    // for future reference: shared cache never contains MH_BUNDLEs
    if (headerIsBundle) {
        cls->data()->flags |= RO_FROM_BUNDLE;
        cls->ISA()->data()->flags |= RO_FROM_BUNDLE;
    }
    
    return cls;
}


é€šè¿‡æºç å®ç°ï¼Œä¸»è¦åˆ†ä¸ºä»¥ä¸‹å‡ æ­¥ï¼š
é€šè¿‡mangledNameè·å–ç±»çš„åå­—ï¼Œå…¶ä¸­mangledNameæ–¹æ³•çš„æºç å®ç°å¦‚ä¸‹
const char *mangledName() { 
    // fixme can't assert locks here
    ASSERT(this);

    if (isRealized()  ||  isFuture()) { //è¿™ä¸ªåˆå§‹åŒ–åˆ¤æ–­åœ¨lookupImpä¹Ÿæœ‰ç±»ä¼¼çš„
        return data()->ro()->name;//å¦‚æœå·²ç»å®ä¾‹åŒ–ï¼Œåˆ™ä»roä¸­è·å–name
    } else {
        return ((const class_ro_t *)data())->name;//åä¹‹ï¼Œä»mach-Oçš„æ•°æ®dataä¸­è·å–name
    }
}
å½“å‰ç±»çš„çˆ¶ç±»ä¸­è‹¥æœ‰ä¸¢å¤±çš„weak-linkedç±»ï¼Œåˆ™è¿”å›nil
åˆ¤æ–­æ˜¯ä¸æ˜¯åæœŸéœ€è¦å¤„ç†çš„ç±»ï¼Œåœ¨æ­£å¸¸æƒ…å†µä¸‹ï¼Œä¸ä¼šèµ°åˆ°popFutureNamedClassï¼Œå› ä¸ºè¿™æ˜¯ä¸“é—¨é’ˆå¯¹æœªæ¥å¾…å¤„ç†çš„ç±»çš„æ“ä½œï¼Œä¹Ÿå¯ä»¥é€šè¿‡æ–­ç‚¹è°ƒè¯•ï¼Œå¯çŸ¥ä¸ä¼šèµ°åˆ°ifæµç¨‹é‡Œé¢ï¼Œå› æ­¤ä¹Ÿä¸ä¼šå¯¹roã€rwè¿›è¡Œæ“ä½œ
dataæ˜¯mach-Oçš„æ•°æ®ï¼Œå¹¶ä¸åœ¨classçš„å†…å­˜ä¸­
roçš„èµ‹å€¼æ˜¯ä»mach-Oä¸­çš„dataå¼ºè½¬èµ‹å€¼çš„
rwé‡Œçš„roæ˜¯ä»roå¤åˆ¶è¿‡å»çš„

é€šè¿‡addNamedClasså°†å½“å‰ç±»æ·»åŠ åˆ°å·²ç»åˆ›å»ºå¥½çš„gdb_objc_realized_classeså“ˆå¸Œè¡¨ï¼Œè¯¥è¡¨ç”¨äºå­˜æ”¾æ‰€æœ‰ç±»

é€šè¿‡addClassTableEntryï¼Œå°†åˆå§‹åŒ–çš„ç±»æ·»åŠ åˆ°allocatedClassesè¡¨ï¼Œæ˜¯åœ¨_objc_initä¸­çš„runtime_initå°±åˆ›å»ºäº†allocatedClassesè¡¨
/***********************************************************************
* addClassTableEntry å°†ä¸€ä¸ªç±»æ·»åŠ åˆ°æ‰€æœ‰ç±»çš„è¡¨ä¸­
* Add a class to the table of all classes. If addMeta is true,
* automatically adds the metaclass of the class as well.
* Locking: runtimeLock must be held by the caller.
**********************************************************************/
static void
addClassTableEntry(Class cls, bool addMeta = true)
{
    runtimeLock.assertLocked();

    // This class is allowed to be a known class via the shared cache or via
    // data segments, but it is not allowed to be in the dynamic table already.
    auto &set = objc::allocatedClasses.get();//å¼€è¾Ÿçš„ç±»çš„è¡¨ï¼Œåœ¨objc_initä¸­çš„runtime_initå°±åˆ›å»ºäº†è¡¨

    ASSERT(set.find(cls) == set.end());

    if (!isKnownClass(cls))
        set.insert(cls);
    if (addMeta)
        //æ·»åŠ åˆ°allocatedClasseså“ˆå¸Œè¡¨
        addClassTableEntry(cls->ISA(), false);
}


æ€»ç»“:
readClassçš„ä¸»è¦ä½œç”¨å°±æ˜¯å°†Mach-Oä¸­çš„ç±»è¯»å–åˆ°å†…å­˜ï¼Œå³æ’å…¥è¡¨ä¸­ï¼Œä½†æ˜¯ç›®å‰çš„ç±»ä»…æœ‰ä¸¤ä¸ªä¿¡æ¯ï¼šåœ°å€ä»¥åŠåç§°ï¼Œè€Œmach-Oçš„å…¶ä¸­çš„dataæ•°æ®è¿˜æœªè¯»å–å‡ºæ¥



realizeClassWithoutSwiftï¼šå®ç°ç±»
realizeClassWithoutSwiftæ–¹æ³•ä¸­æœ‰roã€rwçš„ç›¸å…³æ“ä½œï¼Œè¿™ä¸ªæ–¹æ³•åœ¨æ¶ˆæ¯æµç¨‹çš„æ…¢é€ŸæŸ¥æ‰¾ä¸­æœ‰æ‰€æåŠ,æ–¹æ³•è·¯å¾„ä¸ºï¼šæ…¢é€ŸæŸ¥æ‰¾(lookUpImpOrForward) -- realizeClassMaybeSwiftAndLeaveLocked -- realizeClassMaybeSwiftMaybeRelock -- realizeClassWithoutSwiftï¼ˆå®ç°ç±»ï¼‰
realizeClassWithoutSwiftæ–¹æ³•ä¸»è¦ä½œç”¨æ˜¯å®ç°ç±»ï¼Œå°†ç±»çš„dataæ•°æ®åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œä¸»è¦æœ‰ä»¥ä¸‹å‡ éƒ¨åˆ†æ“ä½œï¼š
ã€ç¬¬ä¸€æ­¥ã€‘è¯»å–dataæ•°æ®ï¼Œå¹¶è®¾ç½®roã€rw
ã€ç¬¬äºŒæ­¥ã€‘é€’å½’è°ƒç”¨realizeClassWithoutSwiftå®Œå–„ç»§æ‰¿é“¾
ã€ç¬¬ä¸‰æ­¥ã€‘é€šè¿‡methodizeClassæ–¹æ³•åŒ–ç±»

ç¬¬ä¸€æ­¥ï¼šè¯»å–dataæ•°æ®
è¯»å–classçš„dataæ•°æ®ï¼Œå¹¶å°†å…¶å¼ºè½¬ä¸ºroï¼Œä»¥åŠrwåˆå§‹åŒ–å’Œroæ‹·è´ä¸€ä»½åˆ°rwä¸­çš„ro
ro è¡¨ç¤º readOnlyï¼Œå³åªè¯»ï¼Œå…¶åœ¨ç¼–è¯‘æ—¶å°±å·²ç»ç¡®å®šäº†å†…å­˜ï¼ŒåŒ…å«ç±»åç§°ã€æ–¹æ³•ã€åè®®å’Œå®ä¾‹å˜é‡çš„ä¿¡æ¯ï¼Œç”±äºæ˜¯åªè¯»çš„ï¼Œæ‰€ä»¥å±äºClean Memoryï¼Œè€ŒClean Memoryæ˜¯æŒ‡åŠ è½½åä¸ä¼šå‘ç”Ÿæ›´æ”¹çš„å†…å­˜
rw è¡¨ç¤º readWriteï¼Œå³å¯è¯»å¯å†™ï¼Œç”±äºå…¶åŠ¨æ€æ€§ï¼Œå¯èƒ½ä¼šå¾€ç±»ä¸­æ·»åŠ å±æ€§ã€æ–¹æ³•ã€æ·»åŠ åè®®.å…¶å®åœ¨rwä¸­åªæœ‰10%çš„ç±»çœŸæ­£çš„æ›´æ”¹äº†å®ƒä»¬çš„æ–¹æ³•ï¼Œæ‰€ä»¥æœ‰äº†rweï¼Œå³ç±»çš„é¢å¤–ä¿¡æ¯ã€‚
å¯¹äºé‚£äº›ç¡®å®éœ€è¦é¢å¤–ä¿¡æ¯çš„ç±»ï¼Œå¯ä»¥åˆ†é…rweæ‰©å±•è®°å½•ä¸­çš„ä¸€ä¸ªï¼Œå¹¶å°†å…¶æ»‘å…¥ç±»ä¸­ä¾›å…¶ä½¿ç”¨ã€‚å…¶ä¸­rwå°±å±äºdirty memoryï¼Œè€Œ dirty memoryæ˜¯æŒ‡åœ¨è¿›ç¨‹è¿è¡Œæ—¶ä¼šå‘ç”Ÿæ›´æ”¹çš„å†…å­˜ï¼Œç±»ç»“æ„ä¸€ç»ä½¿ç”¨å°±ä¼šå˜æˆ ditry memoryï¼Œå› ä¸ºè¿è¡Œæ—¶ä¼šå‘å®ƒå†™å…¥æ–°æ•°æ®ï¼Œä¾‹å¦‚ åˆ›å»ºä¸€ä¸ªæ–°çš„æ–¹æ³•ç¼“å­˜ï¼Œå¹¶ä»ç±»ä¸­æŒ‡å‘å®ƒ

// fixme verify class is not in an un-dlopened part of the shared cache?
//è¯»å–classçš„data()ï¼Œä»¥åŠro/rwåˆ›å»º
auto ro = (const class_ro_t *)cls->data(); //è¯»å–ç±»ç»“æ„çš„bitså±æ€§ã€//ro -- clean memoryï¼Œåœ¨ç¼–è¯‘æ—¶å°±å·²ç»ç¡®å®šäº†å†…å­˜
auto isMeta = ro->flags & RO_META; //åˆ¤æ–­å…ƒç±»
if (ro->flags & RO_FUTURE) {
    // This was a future class. rw data is already allocated.
    rw = cls->data(); //dirty memory è¿›è¡Œèµ‹å€¼
    ro = cls->data()->ro();
    ASSERT(!isMeta);
    cls->changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);
} else { //æ­¤æ—¶å°†æ•°æ®è¯»å–è¿›æ¥äº†ï¼Œä¹Ÿèµ‹å€¼å®Œæ¯•äº†
    // Normal class. Allocate writeable class data.
    rw = objc::zalloc<class_rw_t>(); //ç”³è¯·å¼€è¾Ÿzalloc -- rw
    rw->set_ro(ro);//rwä¸­çš„roè®¾ç½®ä¸ºä¸´æ—¶å˜é‡ro
    rw->flags = RW_REALIZED|RW_REALIZING|isMeta;
    cls->setData(rw);//å°†clsçš„dataèµ‹å€¼ä¸ºrwå½¢å¼
}

ã€ç¬¬äºŒæ­¥ã€‘é€’å½’è°ƒç”¨ realizeClassWithoutSwift å®Œå–„ ç»§æ‰¿é“¾
é€’å½’è°ƒç”¨realizeClassWithoutSwiftå®Œå–„ç»§æ‰¿é“¾,å¹¶è®¾ç½®å½“å‰ç±»ã€çˆ¶ç±»ã€å…ƒç±»çš„rw
é€’å½’è°ƒç”¨ realizeClassWithoutSwiftè®¾ç½®çˆ¶ç±»ã€å…ƒç±»
è®¾ç½®çˆ¶ç±»å’Œå…ƒç±»çš„isaæŒ‡å‘
é€šè¿‡addSubclass å’Œ addRootClassè®¾ç½®çˆ¶å­çš„åŒå‘é“¾è¡¨æŒ‡å‘å…³ç³»ï¼Œå³çˆ¶ç±»ä¸­å¯ä»¥æ‰¾åˆ°å­ç±»ï¼Œå­ç±»ä¸­å¯ä»¥æ‰¾åˆ°çˆ¶ç±»

 // Realize superclass and metaclass, if they aren't already.
    // This needs to be done after RW_REALIZED is set above, for root classes.
    // This needs to be done after class index is chosen, for root metaclasses.
    // This assumes that none of those classes have Swift contents,
    //   or that Swift's initializers have already been called.
    //   fixme that assumption will be wrong if we add support
    //   for ObjC subclasses of Swift classes. --
    //é€’å½’è°ƒç”¨realizeClassWithoutSwiftå®Œå–„ç»§æ‰¿é“¾,å¹¶å¤„ç†å½“å‰ç±»çš„çˆ¶ç±»ã€å…ƒç±»
    //é€’å½’å®ç° è®¾ç½®å½“å‰ç±»ã€çˆ¶ç±»ã€å…ƒç±»çš„ rwï¼Œä¸»è¦ç›®çš„æ˜¯ç¡®å®šç»§æ‰¿é“¾ ï¼ˆç±»ç»§æ‰¿é“¾ã€å…ƒç±»ç»§æ‰¿é“¾ï¼‰
    //å®ç°å…ƒç±»ã€çˆ¶ç±»
    //å½“isaæ‰¾åˆ°æ ¹å…ƒç±»ä¹‹åï¼Œæ ¹å…ƒç±»çš„isaæ˜¯æŒ‡å‘è‡ªå·±çš„ï¼Œä¸ä¼šè¿”å›nilä»è€Œå¯¼è‡´æ­»å¾ªç¯â€”â€”remapClassä¸­å¯¹ç±»åœ¨è¡¨ä¸­è¿›è¡ŒæŸ¥æ‰¾çš„æ“ä½œï¼Œå¦‚æœè¡¨ä¸­å·²æœ‰è¯¥ç±»ï¼Œåˆ™è¿”å›ä¸€ä¸ªç©ºå€¼ï¼›å¦‚æœæ²¡æœ‰åˆ™è¿”å›å½“å‰ç±»ï¼Œè¿™æ ·ä¿è¯äº†ç±»åªåŠ è½½ä¸€æ¬¡å¹¶ç»“æŸé€’å½’
    supercls = realizeClassWithoutSwift(remapClass(cls->superclass), nil);
    metacls = realizeClassWithoutSwift(remapClass(cls->ISA()), nil);
    
...

// Update superclass and metaclass in case of remapping -- class æ˜¯ åŒå‘é“¾è¡¨ç»“æ„ å³çˆ¶å­å…³ç³»éƒ½ç¡®è®¤äº†
// å°†çˆ¶ç±»å’Œå…ƒç±»ç»™æˆ‘ä»¬çš„ç±» åˆ†åˆ«æ˜¯isaå’Œçˆ¶ç±»çš„å¯¹åº”å€¼
cls->superclass = supercls;
cls->initClassIsa(metacls);

...

// Connect this class to its superclass's subclass lists
//åŒå‘é“¾è¡¨æŒ‡å‘å…³ç³» çˆ¶ç±»ä¸­å¯ä»¥æ‰¾åˆ°å­ç±» å­ç±»ä¸­ä¹Ÿå¯ä»¥æ‰¾åˆ°çˆ¶ç±»
//é€šè¿‡addSubclassæŠŠå½“å‰ç±»æ”¾åˆ°çˆ¶ç±»çš„å­ç±»åˆ—è¡¨ä¸­å»
if (supercls) {
    addSubclass(supercls, cls);
} else {
    addRootClass(cls);
}

realizeClassWithoutSwifté€’å½’è°ƒç”¨æ—¶ï¼Œisaæ‰¾åˆ°æ ¹å…ƒç±»ä¹‹åï¼Œæ ¹å…ƒç±»çš„isaæ˜¯æŒ‡å‘è‡ªå·±ï¼Œå¹¶ä¸ä¼šè¿”å›nilï¼Œæ‰€ä»¥æœ‰ä»¥ä¸‹é€’å½’ç»ˆæ­¢æ¡ä»¶ï¼Œå…¶ç›®çš„æ˜¯ä¿è¯ç±»åªåŠ è½½ä¸€æ¬¡

åœ¨realizeClassWithoutSwiftä¸­
å¦‚æœç±»ä¸å­˜åœ¨ï¼Œåˆ™è¿”å›nil
å¦‚æœç±»å·²ç»å®ç°ï¼Œåˆ™ç›´æ¥è¿”å›cls

static Class realizeClassWithoutSwift(Class cls, Class previously)
{
    runtimeLock.assertLocked();
    
    //å¦‚æœç±»ä¸å­˜åœ¨ï¼Œåˆ™è¿”å›nil
    if (!cls) return nil;
    å¦‚æœç±»å·²ç»å®ç°ï¼Œåˆ™ç›´æ¥è¿”å›cls
    if (cls->isRealized()) return cls;
    ASSERT(cls == remapClass(cls));
    
    ...
}

åœ¨remapClassæ–¹æ³•ä¸­ï¼Œå¦‚æœclsä¸å­˜åœ¨ï¼Œåˆ™ç›´æ¥è¿”å›nil
/***********************************************************************
* remapClass
* Returns the live class pointer for cls, which may be pointing to 
* a class struct that has been reallocated.
* Returns nil if cls is ignored because of weak linking.
* Locking: runtimeLock must be read- or write-locked by the caller
**********************************************************************/
static Class remapClass(Class cls)
{
    runtimeLock.assertLocked();

    if (!cls) return nil;//å¦‚æœclsä¸å­˜åœ¨ï¼Œåˆ™è¿”å›nil

    auto *map = remappedClasses(NO);
    if (!map)
        return cls;
    
    auto iterator = map->find(cls);
    if (iterator == map->end())
        return cls;
    return std::get<1>(*iterator);
}


ã€ç¬¬ä¸‰æ­¥ã€‘é€šè¿‡ methodizeClass æ–¹æ³•åŒ–ç±»
é€šè¿‡methodizeClassæ–¹æ³•ï¼Œä»roä¸­è¯»å–æ–¹æ³•åˆ—è¡¨ï¼ˆåŒ…æ‹¬åˆ†ç±»ä¸­çš„æ–¹æ³•ï¼‰ã€å±æ€§åˆ—è¡¨ã€åè®®åˆ—è¡¨èµ‹å€¼ç»™rwï¼Œå¹¶è¿”å›cls
// Attach categories é™„åŠ ç±»åˆ« -- ç–‘é—®ï¼šroä¸­ä¹Ÿæœ‰æ–¹æ³•åˆ—è¡¨ rwä¸­ä¹Ÿæœ‰æ–¹æ³•åˆ—è¡¨ï¼Œä¸‹é¢è¿™ä¸ªæ–¹æ³•å¯ä»¥è¯´æ˜
//å°†roæ•°æ®å†™å…¥åˆ°rw
methodizeClass(cls, previously);

return cls;


methodizeClassï¼šæ–¹æ³•åŒ–ç±»
ä¸»è¦åˆ†ä¸ºå‡ éƒ¨åˆ†ï¼š
å°†å±æ€§åˆ—è¡¨ã€æ–¹æ³•åˆ—è¡¨ã€åè®®åˆ—è¡¨ç­‰è´´åˆ°rweä¸­
é™„åŠ åˆ†ç±»ä¸­çš„æ–¹æ³•

static void methodizeClass(Class cls, Class previously)
{
    runtimeLock.assertLocked();

    bool isMeta = cls->isMetaClass();
    auto rw = cls->data(); // åˆå§‹åŒ–ä¸€ä¸ªrw
    auto ro = rw->ro();
    auto rwe = rw->ext();
    
    ...

    // Install methods and properties that the class implements itself.
    //å°†å±æ€§åˆ—è¡¨ã€æ–¹æ³•åˆ—è¡¨ã€åè®®åˆ—è¡¨ç­‰è´´åˆ°rwä¸­
    // å°†roä¸­çš„æ–¹æ³•åˆ—è¡¨åŠ å…¥åˆ°rwä¸­
    method_list_t *list = ro->baseMethods();//è·å–roçš„baseMethods
    if (list) {
        prepareMethodLists(cls, &list, 1, YES, isBundleClass(cls));//methodsè¿›è¡Œæ’åº
        if (rwe) rwe->methods.attachLists(&list, 1);//å¯¹rweè¿›è¡Œå¤„ç†
    }
    // åŠ å…¥å±æ€§
    property_list_t *proplist = ro->baseProperties;
    if (rwe && proplist) {
        rwe->properties.attachLists(&proplist, 1);
    }
    // åŠ å…¥åè®®
    protocol_list_t *protolist = ro->baseProtocols;
    if (rwe && protolist) {
        rwe->protocols.attachLists(&protolist, 1);
    }

    // Root classes get bonus method implementations if they don't have 
    // them already. These apply before category replacements.
    if (cls->isRootMetaclass()) {
        // root metaclass
        addMethod(cls, @selector(initialize), (IMP)&objc_noop_imp, "", NO);
    }

    // Attach categories.
    // åŠ å…¥åˆ†ç±»ä¸­çš„æ–¹æ³•
    if (previously) {
        if (isMeta) {
            objc::unattachedCategories.attachToClass(cls, previously,
                                                     ATTACH_METACLASS);
        } else {
            // When a class relocates, categories with class methods
            // may be registered on the class itself rather than on
            // the metaclass. Tell attachToClass to look for those.
            objc::unattachedCategories.attachToClass(cls, previously,
                                                     ATTACH_CLASS_AND_METACLASS);
        }
    }
    objc::unattachedCategories.attachToClass(cls, cls,
                                             isMeta ? ATTACH_METACLASS : ATTACH_CLASS);

    ....
}

æ–¹æ³•åˆ—è¡¨åŠ å…¥rweçš„é€»è¾‘å¦‚ä¸‹ï¼š
è·å–roçš„baseMethods
é€šè¿‡prepareMethodListsæ–¹æ³•æ’åº
å¯¹rweè¿›è¡Œå¤„ç†å³é€šè¿‡attachListsæ’å…¥


æ…¢é€ŸæŸ¥æ‰¾æµç¨‹ä¸­ï¼Œæ–¹æ³•çš„æŸ¥æ‰¾ç®—æ³•æ˜¯é€šè¿‡äºŒåˆ†æŸ¥æ‰¾ç®—æ³•ï¼Œè¯´æ˜sel-impæ˜¯æœ‰æ’åºçš„,é‚£ä¹ˆæ˜¯å¦‚ä½•æ’åºçš„å‘¢ï¼Ÿ
è¿›å…¥prepareMethodListsçš„æºç å®ç°,å…¶å†…éƒ¨æ˜¯é€šè¿‡fixupMethodListæ–¹æ³•æ’åº
static void 
prepareMethodLists(Class cls, method_list_t **addedLists, int addedCount,
                   bool baseMethods, bool methodsFromBundle)
{
    ...

    // Add method lists to array.
    // Reallocate un-fixed method lists.
    // The new methods are PREPENDED to the method list array.

    for (int i = 0; i < addedCount; i++) {
        method_list_t *mlist = addedLists[i];
        ASSERT(mlist);

        // Fixup selectors if necessary
        if (!mlist->isFixedUp()) {
            fixupMethodList(mlist, methodsFromBundle, true/*sort*/);//æ’åº
        }
    }
    
    ...
}

è¿›å…¥fixupMethodListæºç å®ç°ï¼Œæ˜¯æ ¹æ®selector addressæ’åº
static void 
fixupMethodList(method_list_t *mlist, bool bundleCopy, bool sort)
{
    runtimeLock.assertLocked();
    ASSERT(!mlist->isFixedUp());

    // fixme lock less in attachMethodLists ?
    // dyld3 may have already uniqued, but not sorted, the list
    if (!mlist->isUniqued()) {
        mutex_locker_t lock(selLock);
    
        // Unique selectors in list.
        for (auto& meth : *mlist) {
            const char *name = sel_cname(meth.name);
            meth.name = sel_registerNameNoLock(name, bundleCopy);
        }
    }

    // Sort by selector address.æ ¹æ®selåœ°å€æ’åº
    if (sort) {
        method_t::SortBySELAddress sorter;
        std::stable_sort(mlist->begin(), mlist->end(), sorter);
    }
    
    // Mark method list as uniqued and sorted
    mlist->setFixedUp();
}


éªŒè¯æ–¹æ³•æ’åº:
è¯»å– roä¸­çš„ methodlist
è¿›å…¥prepareMethodListsæ–¹æ³•ï¼Œå°†roä¸­çš„baseMethodsè¿›è¡Œæ’åº
è¿›å…¥fixupMethodListæºç å®ç°ï¼Œï¼ˆsel æ ¹æ®selAdress æ’åºï¼‰
æ‰€ä»¥æ€»ç»“å¦‚ä¸‹ï¼šmethodizeClassæ–¹æ³•ä¸­å®ç°ç±»ä¸­æ–¹æ³•ï¼ˆåè®®ç­‰ï¼‰çš„åºåˆ—åŒ–


attachToClassæ–¹æ³•:
åœ¨methodlistæ–¹æ³•ä¸»è¦æ˜¯å°†åˆ†ç±»æ·»åŠ åˆ°ä¸»ç±»ä¸­ï¼Œå…¶æºç å®ç°å¦‚ä¸‹
void attachToClass(Class cls, Class previously, int flags)
{
    runtimeLock.assertLocked();
    ASSERT((flags & ATTACH_CLASS) ||
           (flags & ATTACH_METACLASS) ||
           (flags & ATTACH_CLASS_AND_METACLASS));

    
    const char *mangledName  = cls->mangledName();
    const char *LGPersonName = "LGPerson";

    if (strcmp(mangledName, LGPersonName) == 0) {
        bool kc_isMeta = cls->isMetaClass();
        auto kc_rw = cls->data();
        auto kc_ro = kc_rw->ro();
        if (!kc_isMeta) {
            printf("%s: è¿™ä¸ªæ˜¯æˆ‘è¦ç ”ç©¶çš„ %s \n",__func__,LGPersonName);
        }
    }
    
    
    auto &map = get();
    auto it = map.find(previously);//æ‰¾åˆ°ä¸€ä¸ªåˆ†ç±»è¿›æ¥ä¸€æ¬¡ï¼Œå³ä¸€ä¸ªä¸ªåŠ è½½åˆ†ç±»ï¼Œä¸è¦æ··ä¹±

    if (it != map.end()) {//è¿™é‡Œä¼šèµ°è¿›æ¥ï¼šå½“ä¸»ç±»æ²¡æœ‰å®ç°loadï¼Œåˆ†ç±»å¼€å§‹åŠ è½½ï¼Œè¿«ä½¿ä¸»ç±»åŠ è½½ï¼Œä¼šèµ°åˆ°ifæµç¨‹é‡Œé¢
        category_list &list = it->second;
        if (flags & ATTACH_CLASS_AND_METACLASS) {//åˆ¤æ–­æ˜¯å¦æ˜¯å…ƒç±»
            int otherFlags = flags & ~ATTACH_CLASS_AND_METACLASS;
            attachCategories(cls, list.array(), list.count(), otherFlags | ATTACH_CLASS);//å®ä¾‹æ–¹æ³•
            attachCategories(cls->ISA(), list.array(), list.count(), otherFlags | ATTACH_METACLASS);//ç±»æ–¹æ³•
        } else {
            //å¦‚æœä¸æ˜¯å…ƒç±»ï¼Œåˆ™åªèµ°ä¸€æ¬¡ attachCategories
            attachCategories(cls, list.array(), list.count(), flags);
        }
        map.erase(it);
    }
}


å› ä¸ºattachToClassä¸­çš„å¤–éƒ¨å¾ªç¯æ˜¯æ‰¾åˆ°ä¸€ä¸ªåˆ†ç±»å°±ä¼šè¿›åˆ°attachCategoriesä¸€æ¬¡ï¼Œå³æ‰¾ä¸€ä¸ªå°±å¾ªç¯ä¸€æ¬¡


attachCategoriesæ–¹æ³•:
åœ¨attachCategories æ–¹æ³•ä¸­å‡†å¤‡åˆ†ç±»çš„æ•°æ®ï¼Œå…¶æºç å®ç°å¦‚ä¸‹
static void
attachCategories(Class cls, const locstamped_category_t *cats_list, uint32_t cats_count,
                 int flags)
{
    if (slowpath(PrintReplacedMethods)) {
        printReplacements(cls, cats_list, cats_count);
    }
    if (slowpath(PrintConnecting)) {
        _objc_inform("CLASS: attaching %d categories to%s class '%s'%s",
                     cats_count, (flags & ATTACH_EXISTING) ? " existing" : "",
                     cls->nameForLogging(), (flags & ATTACH_METACLASS) ? " (meta)" : "");
    }

    /*
     * Only a few classes have more than 64 categories during launch.
     * This uses a little stack, and avoids malloc.
     *
     * Categories must be added in the proper order, which is back
     * to front. To do that with the chunking, we iterate cats_list
     * from front to back, build up the local buffers backwards,
     * and call attachLists on the chunks. attachLists prepends the
     * lists, so the final result is in the expected order.
     */
    constexpr uint32_t ATTACH_BUFSIZ = 64;
    method_list_t   *mlists[ATTACH_BUFSIZ];
    property_list_t *proplists[ATTACH_BUFSIZ];
    protocol_list_t *protolists[ATTACH_BUFSIZ];

    uint32_t mcount = 0;
    uint32_t propcount = 0;
    uint32_t protocount = 0;
    bool fromBundle = NO;
    bool isMeta = (flags & ATTACH_METACLASS);
    /*
     rweçš„åˆ›å»ºï¼Œ
     é‚£ä¹ˆä¸ºä»€ä¹ˆè¦åœ¨è¿™é‡Œè¿›è¡Œ`rweçš„åˆå§‹åŒ–`ï¼Ÿå› ä¸ºæˆ‘ä»¬ç°åœ¨è¦åšä¸€ä»¶äº‹ï¼šå¾€`æœ¬ç±»`ä¸­`æ·»åŠ å±æ€§ã€æ–¹æ³•ã€åè®®`ç­‰
     */
    auto rwe = cls->data()->extAllocIfNeeded();
        
    //mlists æ˜¯ä¸€ä¸ªäºŒç»´æ•°ç»„
    for (uint32_t i = 0; i < cats_count; i++) {
        auto& entry = cats_list[i];

        method_list_t *mlist = entry.cat->methodsForMeta(isMeta);
        if (mlist) {
            if (mcount == ATTACH_BUFSIZ) {//mcount = 0ï¼ŒATTACH_BUFSIZ= 64ï¼Œä¸ä¼šèµ°åˆ°ifé‡Œé¢çš„æµç¨‹
                prepareMethodLists(cls, mlists, mcount, NO, fromBundle);//å‡†å¤‡æ’åº
                rwe->methods.attachLists(mlists, mcount);
                mcount = 0;
            }
            mlists[ATTACH_BUFSIZ - ++mcount] = mlist;
            fromBundle |= entry.hi->isBundle();
        }

        property_list_t *proplist =
            entry.cat->propertiesForMeta(isMeta, entry.hi);
        if (proplist) {
            if (propcount == ATTACH_BUFSIZ) {
                rwe->properties.attachLists(proplists, propcount);
                propcount = 0;
            }
            proplists[ATTACH_BUFSIZ - ++propcount] = proplist;
        }

        protocol_list_t *protolist = entry.cat->protocolsForMeta(isMeta);
        if (protolist) {
            if (protocount == ATTACH_BUFSIZ) {
                rwe->protocols.attachLists(protolists, protocount);
                protocount = 0;
            }
            protolists[ATTACH_BUFSIZ - ++protocount] = protolist;
        }
    }

    if (mcount > 0) {
        prepareMethodLists(cls, mlists + ATTACH_BUFSIZ - mcount, mcount, NO, fromBundle);//æ’åº
        rwe->methods.attachLists(mlists + ATTACH_BUFSIZ - mcount, mcount);//mlists + ATTACH_BUFSIZ - mcount ä¸ºå†…å­˜å¹³ç§»
        if (flags & ATTACH_EXISTING) flushCaches(cls);
    }

    rwe->properties.attachLists(proplists + ATTACH_BUFSIZ - propcount, propcount);

    rwe->protocols.attachLists(protolists + ATTACH_BUFSIZ - protocount, protocount);
}

åœ¨auto rwe = cls->data()->extAllocIfNeeded();æ˜¯è¿›è¡Œrweçš„åˆ›å»º,é‚£ä¹ˆä¸ºä»€ä¹ˆè¦åœ¨è¿™é‡Œè¿›è¡Œrweçš„åˆå§‹åŒ–ï¼Ÿï¼Ÿå› ä¸ºæˆ‘ä»¬ç°åœ¨è¦åšä¸€ä»¶äº‹ï¼šå¾€æœ¬ç±»ä¸­æ·»åŠ å±æ€§ã€æ–¹æ³•ã€åè®®ç­‰,å³å¯¹åŸæ¥çš„ clean memoryè¦è¿›è¡Œå¤„ç†äº†

è¿›å…¥extAllocIfNeededæ–¹æ³•çš„æºç å®ç°ï¼Œåˆ¤æ–­rweæ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨åˆ™ç›´æ¥è·å–ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™å¼€è¾Ÿ
è¿›å…¥extAllocæºç å®ç°ï¼Œå³å¯¹rwe 0-1çš„è¿‡ç¨‹ï¼Œåœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œå°±å°†æœ¬ç±»çš„dataæ•°æ®åŠ è½½è¿›å»äº†

class_rw_ext_t *extAllocIfNeeded() {
    auto v = get_ro_or_rwe();
    if (fastpath(v.is<class_rw_ext_t *>())) { //åˆ¤æ–­rweæ˜¯å¦å­˜åœ¨
        return v.get<class_rw_ext_t *>();//å¦‚æœå­˜åœ¨ï¼Œåˆ™ç›´æ¥è·å–
    } else {
        return extAlloc(v.get<const class_ro_t *>());//å¦‚æœä¸å­˜åœ¨åˆ™è¿›è¡Œå¼€è¾Ÿ
    }
}

ğŸ‘‡//extAllocæºç å®ç°
class_rw_ext_t *
class_rw_t::extAlloc(const class_ro_t *ro, bool deepCopy)
{
    runtimeLock.assertLocked();
    //æ­¤æ—¶åªæœ‰rwï¼Œéœ€è¦å¯¹rweè¿›è¡Œæ•°æ®æ·»åŠ ï¼Œå³0-1çš„è¿‡ç¨‹
    auto rwe = objc::zalloc<class_rw_ext_t>();//åˆ›å»º
    
    rwe->version = (ro->flags & RO_META) ? 7 : 0;

    method_list_t *list = ro->baseMethods();
    if (list) {
        if (deepCopy) list = list->duplicate();
        rwe->methods.attachLists(&list, 1);
    }

    // See comments in objc_duplicateClass
    // property lists and protocol lists historically
    // have not been deep-copied
    //
    // This is probably wrong and ought to be fixed some day
    property_list_t *proplist = ro->baseProperties;
    if (proplist) {
        rwe->properties.attachLists(&proplist, 1);
    }

    protocol_list_t *protolist = ro->baseProtocols;
    if (protolist) {
        rwe->protocols.attachLists(&protolist, 1);
    }

    set_ro_or_rwe(rwe, ro);
    return rwe;
}

å…¶ä¸­å…³é”®ä»£ç æ˜¯rwe->methods.attachLists(mlists + ATTACH_BUFSIZ - mcount, mcount);å³å­˜å…¥mlistsçš„æœ«å°¾ï¼Œmlistsçš„æ•°æ®æ¥æºå‰é¢çš„forå¾ªç¯

åœ¨è°ƒè¯•è¿è¡Œæ—¶ï¼Œå‘ç°category_tä¸­çš„nameç¼–è¯‘æ—¶æ˜¯LGPersonï¼Œè¿è¡Œæ—¶æ˜¯LGAå³åˆ†ç±»çš„åå­—

ä»£ç mlists[ATTACH_BUFSIZ - ++mcount] = mlist;ï¼Œç»è¿‡è°ƒè¯•å‘ç°æ­¤æ—¶çš„mcountç­‰äº1ï¼Œå³å¯ä»¥ç†è§£ä¸º å€’åºæ’å…¥,64çš„åŸå› æ˜¯å…è®¸å®¹çº³64ä¸ªï¼ˆæœ€å¤š64ä¸ªåˆ†ç±»ï¼‰

æ€»ç»“:æœ¬ç±» ä¸­ éœ€è¦æ·»åŠ å±æ€§ã€æ–¹æ³•ç­‰ï¼Œæ‰€ä»¥éœ€è¦åˆå§‹åŒ–rwe,
rweçš„åˆå§‹åŒ–ä¸»è¦æ¶‰åŠï¼šåˆ†ç±»ã€addMethodã€addPropertyã€addprotocol ï¼Œ å³å¯¹åŸå§‹ç±»è¿›è¡Œä¿®æ”¹æˆ–è€…å¤„ç†æ—¶ï¼Œæ‰ä¼šè¿›è¡Œrweçš„åˆå§‹åŒ–



attachListsæ–¹æ³•ï¼šæ’å…¥
å…¶ä¸­æ–¹æ³•ã€å±æ€§ç»§æ‰¿äºentsize_list_ttï¼Œåè®®åˆ™æ˜¯ç±»ä¼¼entsize_list_ttå®ç°ï¼Œéƒ½æ˜¯äºŒç»´æ•°ç»„

struct method_list_t : entsize_list_tt<method_t, method_list_t, 0x3> 

struct property_list_t : entsize_list_tt<property_t, property_list_t, 0> 

struct protocol_list_t {
    // count is pointer-sized by accident.
    uintptr_t count;
    protocol_ref_t list[0]; // variable-size

    size_t byteSize() const {
        return sizeof(*this) + count*sizeof(list[0]);
    }

    protocol_list_t *duplicate() const {
        return (protocol_list_t *)memdup(this, this->byteSize());
    }
    ...
}


è¿›å…¥attachListsæ–¹æ³•çš„æºç å®ç°:
void attachLists(List* const * addedLists, uint32_t addedCount) {
    if (addedCount == 0) return;

    if (hasArray()) {
        // many lists -> many lists
        //è®¡ç®—æ•°ç»„ä¸­æ—§listsçš„å¤§å°
        uint32_t oldCount = array()->count;
        //è®¡ç®—æ–°çš„å®¹é‡å¤§å° = æ—§æ•°æ®å¤§å°+æ–°æ•°æ®å¤§å°
        uint32_t newCount = oldCount + addedCount;
        //æ ¹æ®æ–°çš„å®¹é‡å¤§å°ï¼Œå¼€è¾Ÿä¸€ä¸ªæ•°ç»„ï¼Œç±»å‹æ˜¯ array_tï¼Œé€šè¿‡array()è·å–
        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));
        //è®¾ç½®æ•°ç»„å¤§å°
        array()->count = newCount;
        //æ—§çš„æ•°æ®ä» addedCount æ•°ç»„ä¸‹æ ‡å¼€å§‹ å­˜æ”¾æ—§çš„listsï¼Œå¤§å°ä¸º æ—§æ•°æ®å¤§å° * å•ä¸ªæ—§listå¤§å°
        memmove(array()->lists + addedCount, array()->lists, 
                oldCount * sizeof(array()->lists[0]));
        //æ–°æ•°æ®ä»æ•°ç»„ é¦–ä½ç½®å¼€å§‹å­˜å‚¨ï¼Œå­˜æ”¾æ–°çš„listsï¼Œå¤§å°ä¸º æ–°æ•°æ®å¤§å° * å•ä¸ªlistå¤§å°
        memcpy(
               array()->lists, addedLists, 
               addedCount * sizeof(array()->lists[0]));
    }
    else if (!list  &&  addedCount == 1) {
        // 0 lists -> 1 list
        list = addedLists[0];//å°†liståŠ å…¥mlistsçš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œæ­¤æ—¶çš„listæ˜¯ä¸€ä¸ªä¸€ç»´æ•°ç»„
    } 
    else {
        // 1 list -> many lists æœ‰äº†ä¸€ä¸ªlistï¼Œæœ‰å¾€é‡ŒåŠ å¾ˆå¤šlist
        //æ–°çš„listå°±æ˜¯åˆ†ç±»ï¼Œæ¥è‡ªLRUçš„ç®—æ³•æ€ç»´ï¼Œå³æœ€è¿‘æœ€å°‘ä½¿ç”¨
        //è·å–æ—§çš„list
        List* oldList = list;
        uint32_t oldCount = oldList ? 1 : 0;
        //è®¡ç®—å®¹é‡å’Œ = æ—§listä¸ªæ•°+æ–°listsçš„ä¸ªæ•°
        uint32_t newCount = oldCount + addedCount;
        //å¼€è¾Ÿä¸€ä¸ªå®¹é‡å’Œå¤§å°çš„é›†åˆï¼Œç±»å‹æ˜¯ array_tï¼Œå³åˆ›å»ºä¸€ä¸ªæ•°ç»„ï¼Œæ”¾åˆ°arrayä¸­ï¼Œé€šè¿‡array()è·å–
        setArray((array_t *)malloc(array_t::byteSize(newCount)));
        //è®¾ç½®æ•°ç»„çš„å¤§å°
        array()->count = newCount;
        //åˆ¤æ–­oldæ˜¯å¦å­˜åœ¨ï¼Œoldè‚¯å®šæ˜¯å­˜åœ¨çš„ï¼Œå°†æ—§çš„listæ”¾å…¥åˆ°æ•°ç»„çš„æœ«å°¾
        if (oldList) array()->lists[addedCount] = oldList;
        // memcpyï¼ˆå¼€å§‹ä½ç½®ï¼Œæ”¾ä»€ä¹ˆï¼Œæ”¾å¤šå¤§ï¼‰ æ˜¯å†…å­˜å¹³ç§»ï¼Œä»æ•°ç»„èµ·å§‹ä½ç½®å­˜å…¥æ–°çš„list
        //å…¶ä¸­array()->lists è¡¨ç¤ºé¦–ä½å…ƒç´ ä½ç½®
        memcpy(array()->lists, addedLists, 
               addedCount * sizeof(array()->lists[0]));
    }
}

æ’å…¥è¡¨ä¸»è¦åˆ†ä¸ºä¸‰ç§æƒ…å†µï¼š
ã€æƒ…å†µ1ï¼šå¤šå¯¹å¤šã€‘å¦‚æœå½“å‰è°ƒç”¨attachListsçš„list_array_ttäºŒç»´æ•°ç»„ä¸­æœ‰å¤šä¸ªä¸€ç»´æ•°ç»„
è®¡ç®—æ•°ç»„ä¸­æ—§listsçš„å¤§å°

è®¡ç®—æ–°çš„å®¹é‡å¤§å° = æ—§æ•°æ®å¤§å°+æ–°æ•°æ®å¤§å°

æ ¹æ®æ–°çš„å®¹é‡å¤§å°ï¼Œå¼€è¾Ÿä¸€ä¸ªæ•°ç»„ï¼Œç±»å‹æ˜¯ array_tï¼Œé€šè¿‡array()è·å–

è®¾ç½®æ•°ç»„å¤§å°

æ—§çš„æ•°æ®ä» addedCount æ•°ç»„ä¸‹æ ‡å¼€å§‹ å­˜æ”¾æ—§çš„listsï¼Œå¤§å°ä¸º æ—§æ•°æ®å¤§å° * å•ä¸ªæ—§listå¤§å°ï¼Œå³æ•´æ®µå¹³ç§»ï¼Œå¯ä»¥ç®€å•ç†è§£ä¸ºåŸæ¥çš„æ•°æ®ç§»åŠ¨åˆ°åé¢ï¼Œå³æŒ‡é’ˆåç§»

æ–°æ•°æ®ä»æ•°ç»„ é¦–ä½ç½®å¼€å§‹å­˜å‚¨ï¼Œå­˜æ”¾æ–°çš„listsï¼Œå¤§å°ä¸º æ–°æ•°æ®å¤§å° * å•ä¸ªlistå¤§å°ï¼Œå¯ä»¥ç®€å•ç†è§£ä¸ºè¶Šæ™šåŠ è¿›æ¥ï¼Œè¶Šåœ¨å‰é¢ï¼Œè¶Šåœ¨å‰é¢ï¼Œè°ƒç”¨æ—¶åˆ™ä¼˜å…ˆè°ƒç”¨

ã€æƒ…å†µ2ï¼š0å¯¹ä¸€ã€‘å¦‚æœè°ƒç”¨attachListsçš„list_array_ttäºŒç»´æ•°ç»„ä¸ºç©ºä¸”æ–°å¢å¤§å°æ•°ç›®ä¸º 1
ç›´æ¥èµ‹å€¼addedListçš„ç¬¬ä¸€ä¸ªlist

ã€æƒ…å†µ3ï¼šä¸€å¯¹å¤šã€‘å¦‚æœå½“å‰è°ƒç”¨attachListsçš„list_array_ttäºŒç»´æ•°ç»„åªæœ‰ä¸€ä¸ªä¸€ç»´æ•°ç»„
è·å–æ—§çš„list

è®¡ç®—å®¹é‡å’Œ = æ—§listä¸ªæ•°+æ–°listsçš„ä¸ªæ•°

å¼€è¾Ÿä¸€ä¸ªå®¹é‡å’Œå¤§å°çš„é›†åˆï¼Œç±»å‹æ˜¯ array_tï¼Œå³åˆ›å»ºä¸€ä¸ªæ•°ç»„ï¼Œæ”¾åˆ°arrayä¸­ï¼Œé€šè¿‡array()è·å–

è®¾ç½®æ•°ç»„çš„å¤§å°

åˆ¤æ–­oldæ˜¯å¦å­˜åœ¨ï¼Œoldè‚¯å®šæ˜¯å­˜åœ¨çš„ï¼Œå°†æ—§çš„listæ”¾å…¥åˆ°æ•°ç»„çš„æœ«å°¾

memcpyï¼ˆå¼€å§‹ä½ç½®ï¼Œæ”¾ä»€ä¹ˆï¼Œæ”¾å¤šå¤§ï¼‰ æ˜¯å†…å­˜å¹³ç§»ï¼Œä»æ•°ç»„èµ·å§‹ä½ç½®å¼€å§‹å­˜å…¥æ–°çš„listï¼Œå…¶ä¸­array()->lists è¡¨ç¤ºé¦–ä½å…ƒç´ ä½ç½®


é’ˆå¯¹æƒ…å†µ3ï¼Œè¿™é‡Œçš„listsæ˜¯æŒ‡åˆ†ç±»
è¿™æ˜¯æ—¥å¸¸å¼€å‘ä¸­ï¼Œä¸ºä»€ä¹ˆå­ç±»å®ç°çˆ¶ç±»æ–¹æ³•ä¼šæŠŠçˆ¶ç±»æ–¹æ³•è¦†ç›–çš„åŸå› 
åŒç†ï¼Œå¯¹äºåŒåæ–¹æ³•ï¼Œåˆ†ç±»æ–¹æ³•è¦†ç›–ç±»æ–¹æ³•çš„åŸå› 
è¿™ä¸ªæ“ä½œæ¥è‡ªä¸€ä¸ªç®—æ³•æ€ç»´ LRUå³æœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼ŒåŠ è¿™ä¸ªnewlistçš„ç›®çš„æ˜¯ç”±äºè¦ä½¿ç”¨è¿™ä¸ªnewlistä¸­çš„æ–¹æ³•ï¼Œè¿™ä¸ªnewlistå¯¹äºç”¨æˆ·çš„ä»·å€¼è¦é«˜ï¼Œå³ä¼˜å…ˆè°ƒç”¨
ä¼šæ¥åˆ°1å¯¹å¤šçš„åŸå›  ï¼Œä¸»è¦æ˜¯æœ‰åˆ†ç±»çš„æ·»åŠ ï¼Œå³æ—§çš„å…ƒç´ åœ¨åé¢ï¼Œæ–°çš„å…ƒç´ åœ¨å‰é¢ ï¼Œç©¶å…¶æ ¹æœ¬åŸå› ä¸»è¦æ˜¯ä¼˜å…ˆè°ƒç”¨categoryï¼Œè¿™ä¹Ÿæ˜¯åˆ†ç±»çš„æ„ä¹‰æ‰€åœ¨


memmoveå’Œmemcpyçš„åŒºåˆ«
åœ¨ä¸çŸ¥é“éœ€è¦å¹³ç§»çš„å†…å­˜å¤§å°æ—¶ï¼Œéœ€è¦memmoveè¿›è¡Œå†…å­˜å¹³ç§»ï¼Œä¿è¯å®‰å…¨
memcpyä»åŸå†…å­˜åœ°å€çš„èµ·å§‹ä½ç½®å¼€å§‹æ‹·è´è‹¥å¹²ä¸ªå­—èŠ‚åˆ°ç›®æ ‡å†…å­˜åœ°å€ä¸­ï¼Œé€Ÿåº¦å¿«


==================================================rwe æ•°æ®åŠ è½½:
rwe -- æœ¬ç±»çš„æ•°æ®åŠ è½½
rweæ•°æ®0-1çš„è¿‡ç¨‹ï¼Œå³æ·»åŠ ç±»çš„æ–¹æ³•åˆ—è¡¨

attachCategories -> extAllocIfNeeded -> extAlloc
attachCategoriesæ–¹æ³•ä¸­auto rwe = cls->data()->extAllocIfNeeded()ã€‚è¿™é‡Œçš„ä½œç”¨æ˜¯ å¼€è¾Ÿrwe
åœ¨attachListsæ–¹æ³•ä¸­çš„if (hasArray()) {å¤„è®¾ç½®æ–­ç‚¹ï¼Œå¹¶è¿è¡Œæ–­ä½ï¼Œç»§ç»­å¾€ä¸‹æ‰§è¡Œï¼Œä¼šèµ°åˆ° else-ifæµç¨‹ï¼Œå³0å¯¹1 -- LGPersonæœ¬ç±»çš„æ–¹æ³•åˆ—è¡¨çš„æ·»åŠ  ä¼šèµ° 0å¯¹1æµç¨‹
p addedLists ï¼Œæ­¤æ—¶æ˜¯ä¸€ä¸ªlistæŒ‡é’ˆçš„åœ°å€ï¼Œç»™äº†mlistsçš„ç¬¬ä¸€ä¸ªå…ƒç´ , ç±»å‹æ˜¯method_list_t *const *
æ€»ç»“:
æ‰€ä»¥ 0å¯¹1æ˜¯ä¸€ç§ä¸€ç»´èµ‹å€¼ï¼Œå‡½æ•°è·¯å¾„ä¸ºï¼š
map_images -> _read_images -> readClass -> realizeClassWithoutSwift -> methodizeClass -> prepareMethodLists -> fixupMethodList -> attachToClass -> load_categories_nolock -> attachCategories -> extAllocIfNeeded -> extAlloc -> attachLists


method_list_t *list = ro->baseMethods();
list[0]:
list æ˜¯ä¸€ä¸ªæŒ‡å‘ method_list_t çš„æŒ‡é’ˆã€‚
list[0] è¡¨ç¤ºæŒ‡é’ˆ list æ‰€æŒ‡å‘çš„ method_list_t ç»“æ„ä½“ã€‚
æ¢å¥è¯è¯´ï¼Œlist[0] æ˜¯ method_list_t æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå®é™…ä¸Šå°±æ˜¯ *listã€‚
(&list)[0]:
&list æ˜¯ä¸€ä¸ªæŒ‡å‘ method_list_t* çš„æŒ‡é’ˆï¼ˆæŒ‡é’ˆçš„æŒ‡é’ˆï¼‰ã€‚
(&list)[0] è¡¨ç¤º &list æ‰€æŒ‡å‘çš„å†…å®¹ï¼Œå³ list æœ¬èº«ã€‚

method_list_t methodList1;
method_list_t *list = &methodList1;

// list[0] æ˜¯æŒ‡å‘ methodList1 çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå³ methodList1 æœ¬èº«
method_list_t firstList = list[0]; // ç­‰åŒäº methodList1

// &list æ˜¯ä¸€ä¸ªæŒ‡å‘ list çš„æŒ‡é’ˆï¼Œ(&list)[0] å°±æ˜¯ list æœ¬èº«
method_list_t *sameList = (&list)[0]; // ç­‰åŒäº list

// è¿›ä¸€æ­¥éªŒè¯ sameList å’Œ list æ˜¯åŒä¸€ä¸ªæŒ‡é’ˆ
if (sameList == list) {
    printf("sameList and list are the same.\n");
}

--------------------------------------------------

method_list_t methodList1;
method_list_t *list = &methodList1;

// &list æ˜¯ä¸€ä¸ªæŒ‡å‘ list çš„æŒ‡é’ˆ
method_list_t **listPtr = &list;

// (&list)[0] ç­‰åŒäº *(&list)
method_list_t *sameList1 = (&list)[0];
method_list_t *sameList2 = *(&list);

// è¿›ä¸€æ­¥éªŒè¯ sameList1 å’Œ sameList2 æ˜¯å¦ç­‰åŒäº list
if (sameList1 == list && sameList2 == list) {
    printf("sameList1, sameList2, and list are the same.\n");
}



rwe -- LGAåˆ†ç±»æ•°æ®åŠ è½½
èµ°åˆ°method_list_t *mlist = entry.cat->methodsForMeta(isMeta);
p mlist
p *$10 ï¼Œæ­¤æ—¶çš„mlistæ˜¯ åˆ†ç±»LGA çš„
åœ¨if (mcount > 0) {éƒ¨åˆ†åŠ æ–­ç‚¹ï¼Œç»§ç»­å¾€ä¸‹æ‰§è¡Œ
å¾€ä¸‹æ‰§è¡Œä¸€æ­¥ï¼Œæ­¤æ—¶çš„mlists ä¸ºé›†åˆçš„é›†åˆ

å…¶ä¸­mlists + ATTACH_BUFSIZ - mcountä¸ºå†…å­˜å¹³ç§»
p mlists + ATTACH_BUFSIZ - mcount , å› ä¸ºmcount = 1ï¼Œ ATTACH_BUFSIZ = 64ï¼Œä»é¦–ä½å¹³ç§»åˆ°63ä½ï¼Œå³æœ€åä¸€ä¸ªå…ƒç´ 
mlistsæœ€åä¸€ä¸ªå…ƒç´ çš„å†…å®¹ä¸º æœ¬ç±»çš„æ–¹æ³•åˆ—è¡¨
è¿›å…¥attachListsæ–¹æ³•ï¼Œ åœ¨if (hasArray()) {å¤„åŠ æ–­ç‚¹ï¼Œç»§ç»­æ‰§è¡Œï¼Œç”±äºå·²ç»æœ‰äº†ä¸€ä¸ªlistï¼Œæ‰€ä»¥ ä¼šèµ°åˆ° 1å¯¹å¤šçš„æµç¨‹
æ‰§è¡Œåˆ°æœ€åï¼Œè¾“å‡ºå½“å‰çš„array å³ p array()
è¿™ä¸ªlist_array_tt<method_t, method_list_t>è¡¨ç¤º arrayä¸­ä¼šæ”¾å¾ˆå¤šçš„ method_list_tï¼Œmethod_list_tä¸­ä¼šæ”¾å¾ˆå¤šmethod_t
æ€»ç»“:å¦‚æœæœ¬ç±»åªæœ‰ä¸€ä¸ªåˆ†ç±»ï¼Œåˆ™ä¼šèµ°åˆ°æƒ…å†µ3ï¼Œå³1å¯¹å¤šçš„æƒ…å†µ



rwe -- LGBåˆ†ç±»æ•°æ®åŠ è½½
å¦‚æœå†åŠ ä¸€ä¸ªåˆ†ç±»LGBï¼Œèµ°åˆ°ç¬¬ä¸‰ç§æƒ…å†µï¼Œå³å¤šå¯¹å¤š
å†æ¬¡èµ°åˆ°attachCategories -- if (mcount > 0) {ï¼Œè¿›å…¥attachListsï¼Œèµ°åˆ° å¤šå¯¹å¤šçš„æƒ…å†µ
æŸ¥çœ‹å½“å‰ array çš„å½¢å¼ å³ p array()
ç¬¬ä¸€ä¸ªé‡Œé¢å­˜å‚¨çš„LGBçš„æ–¹æ³•åˆ—è¡¨


æ€»ç»“:
ç»¼ä¸Šæ‰€è¿°ï¼ŒattachListsæ–¹æ³•ä¸»è¦æ˜¯å°†ç±» å’Œ åˆ†ç±» çš„æ•°æ®åŠ è½½åˆ°rweä¸­
é¦–å…ˆåŠ è½½æœ¬ç±»çš„dataæ•°æ®ï¼Œæ­¤æ—¶çš„rweæ²¡æœ‰æ•°æ®ä¸ºç©ºï¼Œèµ°0å¯¹1æµç¨‹
å½“åŠ å…¥ä¸€ä¸ªåˆ†ç±»æ—¶ï¼Œæ­¤æ—¶çš„rweä»…æœ‰ä¸€ä¸ªlistï¼Œå³æœ¬ç±»çš„listï¼Œèµ°1å¯¹å¤šæµç¨‹
å†åŠ å…¥ä¸€ä¸ªåˆ†ç±»æ—¶ï¼Œæ­¤æ—¶çš„rweä¸­æœ‰ä¸¤ä¸ªlistï¼Œå³æœ¬ç±»+åˆ†ç±»çš„listï¼Œèµ°å¤šå¯¹å¤šæµç¨‹



æ‡’åŠ è½½ç±» å’Œ éæ‡’åŠ è½½ç±»:
åœ¨éªŒè¯æ–¹æ³•æ’åºçš„åŸºç¡€ä¸Šï¼Œç»§ç»­åœ¨rweåŠ æ–­ç‚¹ï¼Œæ­¤æ—¶ä¸ºNULL
ç»§ç»­å¾€ä¸‹ä¸€æ­¥æ­¥æ‰§è¡Œï¼Œrweä»ä¸ºNULLï¼Œä¸ä¼šèµ°ifé‡Œé¢çš„æµç¨‹
åœ¨è¿™é‡Œï¼Œå°½ç®¡æ–¹æ³•å¤„ç†å®Œæ¯•ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰ä»rwä¸­å­˜å‚¨åˆ°rweä¸­ï¼Œé‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œä»data -> ro -> rw -> çœ‹åˆ°äº†rwe,å³realizeClassWithoutSwiftï¼ˆroã€rwæ“ä½œï¼‰-> methodizeClassï¼Œä½†æ˜¯å¹¶æ²¡æœ‰èµ°ifé‡Œé¢çš„æµç¨‹ï¼Œä¸ºä»€ä¹ˆï¼Ÿ
ç©¶å…¶æ ¹æœ¬åŸå› æ˜¯_read_imagesæ–¹æ³•ä¸­çš„ç¬¬ä¹æ­¥ å®ç°éæ‡’åŠ è½½ç±»ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ˜¯å¦‚ä½•å°† æ‡’åŠ è½½ç±» å˜æˆ éæ‡’åŠ è½½ç±»çš„å‘¢?
ä¸»è¦æ˜¯åœ¨è¿è¡Œobjcæºç å‰ï¼Œæˆ‘ä»¬åœ¨LGPersonä¸­å®ç°äº†ä¸€ä¸ª+loadæ–¹æ³•ï¼Œåä¹‹ï¼Œå¦‚æœå»æ‰+loadæ–¹æ³•ï¼Œæ˜¯æ‡’åŠ è½½ç±»ï¼Œä¸ä¼šèµ°åˆ°ç¬¬ä¹æ­¥çš„forå¾ªç¯ä¸­
æ‰€ä»¥ï¼Œç»¼ä¸Šæ‰€è¿°ï¼Œæ‡’åŠ è½½ç±»å’Œ éæ‡’åŠ è½½ç±»çš„åŒºåˆ« å°±æ˜¯ æ˜¯å¦å®ç°äº†+loadæ–¹æ³•
å®ç°+loadï¼Œåˆ™æ˜¯éæ‡’åŠ è½½ç±»ï¼Œ
åä¹‹ï¼Œæ˜¯æ‡’åŠ è½½ç±»

ä¸ºä»€ä¹ˆå®ç°loadæ–¹æ³•å°±ä¼šå˜æˆéæ‡’åŠ è½½ç±»ï¼Ÿ
ä¸»è¦æ˜¯å› ä¸ºloadä¼šæå‰åŠ è½½ï¼ˆloadæ–¹æ³•ä¼šåœ¨load_images è°ƒç”¨ï¼Œå‰ææ˜¯ç±»å­˜åœ¨ï¼‰

æ‡’åŠ è½½ç±»åœ¨ä»€ä¹ˆæ—¶å€™åŠ è½½ï¼Ÿ
åœ¨è°ƒç”¨æ–¹æ³•çš„æ—¶å€™åŠ è½½



è°ƒè¯•éªŒè¯ æ‡’åŠ è½½ç±»åŠ è½½çš„æ—¶æœº:
é€šè¿‡ä»£ç è°ƒè¯•æ¥éªŒè¯:
æ³¨é‡Šæ‰LGPersonä¸­çš„+loadæ–¹æ³•,å¹¶åœ¨mainä¸­å®ä¾‹åŒ–personå¤„åŠ ä¸€ä¸ªæ–­ç‚¹
åœ¨_read_imagesçš„ç¬¬ä¹æ­¥ forå¾ªç¯åŠ ä¸€ä¸ªæ–­ç‚¹ -- readClass -- mainçš„æ–­ç‚¹å¤„
ç»§ç»­å¾€ä¸‹æ‰§è¡Œï¼Œèµ°åˆ° realizeClassWithoutSwift -- methodizeClass -- prepareMethodLists -- [person kc_instanceMethod1]

å †æ ˆä¿¡æ¯éªŒè¯:
ä¹Ÿå¯ä»¥é€šè¿‡bt å †æ ˆä¿¡æ¯æŸ¥çœ‹.å…¶æœ¬è´¨æ˜¯å› ä¸º èµ°åˆ°realizeClassWithoutSwiftï¼Œå…¶æœ¬è´¨æ˜¯è°ƒç”¨allocï¼Œå³æ¶ˆæ¯çš„å‘é€


æ€»ç»“:
readClassä¸»è¦æ˜¯è¯»å–ç±»ï¼Œå³æ­¤æ—¶çš„ç±»ä»…æœ‰åœ°å€+åç§°ï¼Œè¿˜æ²¡æœ‰dataæ•°æ®
realizeClassWithoutSwiftä¸»è¦æ˜¯å®ç°ç±»ï¼Œå³å°†ç±»çš„dataæ•°æ®è¯»å–åˆ°å†…å­˜ä¸­
    methodizeClassæ–¹æ³•ä¸­å®ç°ç±»ä¸­æ–¹æ³•ï¼ˆåè®®ç­‰ï¼‰çš„`åºåˆ—åŒ–
    attachCategoriesæ–¹æ³•ä¸­å®ç°ç±»ä»¥åŠåˆ†ç±»çš„æ•°æ®åŠ è½½


==================================================
ä¸Šé¢ç†è§£äº†ç±»æ˜¯å¦‚ä½•ä»Mach-OåŠ è½½åˆ°å†…å­˜ä¸­
æ¥è§£é‡Šä¸‹åˆ†ç±»æ˜¯å¦‚ä½•åŠ è½½åˆ°ç±»ä¸­çš„ï¼Œä»¥åŠåˆ†ç±»å’Œç±»æ­é…ä½¿ç”¨çš„æƒ…å†µ

åœ¨mainä¸­å®šä¹‰LGpersonçš„åˆ†ç±»LG

æ¢ç´¢åˆ†ç±»çš„æœ¬è´¨ï¼Œæœ‰ä»¥ä¸‹ä¸‰ç§æ–¹å¼
ã€æ–¹å¼ä¸€ã€‘é€šè¿‡clang
ã€æ–¹å¼äºŒã€‘é€šè¿‡Xcodeæ–‡æ¡£æœç´¢Category
ã€æ–¹å¼ä¸‰ã€‘é€šè¿‡objcæºç æœç´¢ category_t


æ–¹å¼ä¸€ï¼šé€šè¿‡clang
ã€æ–¹å¼ä¸€ã€‘clang -rewrite-objc main.m -o main.cpp æŸ¥çœ‹åº•å±‚ç¼–è¯‘ï¼Œå³ main.cpp
å…¶ä¸­åˆ†ç±»çš„ ç±»å‹æ˜¯_category_t
åˆ†ç±»çš„å€’æ•°ç¬¬äºŒä¸ª0ï¼Œè¡¨ç¤ºçš„æ˜¯æ²¡æœ‰åè®®ï¼Œæ‰€ä»¥èµ‹å€¼ä¸º0

æœç´¢struct _category_t
å…¶ä¸­æœ‰ä¸¤ä¸ªmethod_list_tï¼Œåˆ†åˆ«è¡¨ç¤ºå®ä¾‹æ–¹æ³• å’Œ ç±»æ–¹æ³•
æœç´¢_CATEGORY_INSTANCE_METHODS_LGPerson_ï¼Œæ‰¾åˆ°å…¶åº•å±‚å®ç°
å…¶ä¸­æœ‰3ä¸ªæ–¹æ³•ï¼Œæ ¼å¼ä¸ºï¼šsel+ç­¾å+åœ°å€ï¼Œæ˜¯method_tç»“æ„ä½“çš„å±æ€§å³key
æœç´¢method_tï¼Œå…¶ä¸­å¯¹åº”å…³ç³»å¦‚ä¸‹:
name å¯¹åº” sel
type å¯¹åº” æ–¹æ³•ç­¾å
imp å¯¹åº” å‡½æ•°åœ°å€

åŒæ—¶ï¼Œæˆ‘ä»¬å‘ç°äº†ä¸€ä¸ªé—®é¢˜ï¼šæŸ¥çœ‹çœ‹_prop_list_tï¼Œæ˜æ˜åˆ†ç±»ä¸­å®šä¹‰äº†å±æ€§ï¼Œä½†æ˜¯åœ¨åº•å±‚ç¼–è¯‘ä¸­å¹¶æ²¡æœ‰çœ‹åˆ°å±æ€§
è¿™æ˜¯å› ä¸ºåˆ†ç±»ä¸­å®šä¹‰çš„å±æ€§æ²¡æœ‰ç›¸åº”çš„setã€getæ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å…³è”å¯¹è±¡æ¥è®¾ç½®


æ–¹å¼äºŒï¼šé€šè¿‡Xcodeæ–‡æ¡£æœç´¢ Category


æ–¹å¼ä¸‰ï¼šé€šè¿‡objcæºç æœç´¢ category_t
å¯ä»¥é€šè¿‡objcæºç æœç´¢category_tç±»å‹


æ€»ç»“:
ç»¼ä¸Šæ‰€è¿°ï¼Œåˆ†ç±»çš„æœ¬è´¨ æ˜¯ä¸€ä¸ª_category_tç±»å‹
æœ‰ä¸¤ä¸ªå±æ€§ï¼šnameï¼ˆç±»çš„åç§°ï¼‰ å’Œ clsï¼ˆç±»å¯¹è±¡ï¼‰
æœ‰ä¸¤ä¸ª method_list_tç±»å‹çš„æ–¹æ³•åˆ—è¡¨ï¼Œè¡¨ç¤ºåˆ†ç±»ä¸­å®ç°çš„å®ä¾‹æ–¹æ³•+ç±»æ–¹æ³•
ä¸€ä¸ªprotocol_list_tç±»å‹çš„åè®®åˆ—è¡¨ï¼Œè¡¨ç¤ºåˆ†ç±»ä¸­å®ç°çš„åè®®
ä¸€ä¸ªprop_list_tç±»å‹çš„å±æ€§åˆ—è¡¨ï¼Œè¡¨ç¤ºåˆ†ç±»ä¸­å®šä¹‰çš„å±æ€§ï¼Œä¸€èˆ¬åœ¨åˆ†ç±»ä¸­æ·»åŠ çš„å±æ€§éƒ½æ˜¯é€šè¿‡å…³è”å¯¹è±¡æ¥å®ç°
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåˆ†ç±»ä¸­çš„å±æ€§æ˜¯æ²¡æœ‰setã€getæ–¹æ³•



åˆ†ç±»çš„åŠ è½½:
åˆ›å»ºLGPersonçš„ä¸¤ä¸ªåˆ†ç±»ï¼šLGAã€LGB
åˆ†ç±»çš„åŠ è½½é¡ºåºæ˜¯ï¼šLGA -> LGBçš„é¡ºåºåŠ è½½åˆ°ç±»ä¸­ï¼Œå³è¶Šæ™šåŠ è¿›æ¥ï¼Œè¶Šåœ¨å‰é¢

###
å…¶ä¸­æŸ¥çœ‹methodizeClassçš„æºç å®ç°ï¼Œå¯ä»¥å‘ç°ç±»çš„æ•°æ®å’Œ åˆ†ç±»çš„æ•°æ®æ˜¯åˆ†å¼€å¤„ç†çš„ï¼Œä¸»è¦æ˜¯å› ä¸ºåœ¨ç¼–è¯‘é˜¶æ®µï¼Œå°±å·²ç»ç¡®å®šå¥½äº†æ–¹æ³•çš„å½’å±ä½ç½®ï¼ˆå³å®ä¾‹æ–¹æ³•å­˜å‚¨åœ¨ç±»ä¸­ï¼Œç±»æ–¹æ³•å­˜å‚¨åœ¨å…ƒç±»ä¸­ï¼‰ï¼Œ
è€Œåˆ†ç±»æ˜¯åé¢æ‰åŠ è¿›æ¥çš„
###

å…¶ä¸­åˆ†ç±»éœ€è¦é€šè¿‡attatchToClassæ·»åŠ åˆ°ç±»ï¼Œç„¶åæ‰èƒ½åœ¨å¤–ç•Œè¿›è¡Œä½¿ç”¨
åˆ†ç±»çš„åŠ è½½ä¸»è¦åˆ†ä¸º3æ­¥ï¼š
åˆ†ç±»æ•°æ®åŠ è½½æ—¶æœºï¼šæ ¹æ®ç±»å’Œåˆ†ç±»æ˜¯å¦å®ç°loadæ–¹æ³•æ¥åŒºåˆ†ä¸åŒçš„æ—¶æœº
attachCategorieså‡†å¤‡åˆ†ç±»æ•°æ®
attachListså°†åˆ†ç±»æ•°æ®æ·»åŠ åˆ°ä¸»ç±»ä¸­




åˆ†ç±»çš„åŠ è½½æ—¶æœº:
==================================================ä»¥ä¸»ç±»LGPerson + åˆ†ç±»LGAã€LGB å‡å®ç°+loadæ–¹æ³•ä¸ºä¾‹

ä»€ä¹ˆæ—¶å€™è°ƒç”¨attachCategoriesçš„,æœ‰ä¸¤ä¸ªæ–¹æ³•ä¸­è°ƒç”¨
load_categories_nolockæ–¹æ³•ä¸­
addToClassæ–¹æ³•ä¸­ï¼Œè¿™é‡Œç»è¿‡è°ƒè¯•å‘ç°ï¼Œä»æ¥ä¸ä¼šè¿›åˆ°ifæµç¨‹ä¸­ï¼Œé™¤éåŠ è½½ä¸¤æ¬¡ï¼Œä¸€èˆ¬çš„ç±»ä¸€èˆ¬åªä¼šåŠ è½½ä¸€æ¬¡
ä¸åŠ ä»»ä½•æ–­ç‚¹ï¼Œè¿è¡Œobjcä»£ç ï¼Œå¯ä»¥å¾—å‡ºä»¥ä¸‹æ‰“å°æ—¥å¿—ï¼Œé€šè¿‡æ—¥å¿—å¯ä»¥å‘ç°addToClassæ–¹æ³•çš„ä¸‹ä¸€æ­¥å°±æ˜¯load_categories_nolockæ–¹æ³•å°±æ˜¯åŠ è½½åˆ†ç±»æ•°æ®

å…¨å±€æœç´¢load_categories_nolockçš„è°ƒç”¨ï¼Œæœ‰ä¸¤æ¬¡è°ƒç”¨
ä¸€æ¬¡åœ¨loadAllCategoriesæ–¹æ³•ä¸­
ä¸€æ¬¡åœ¨_read_imagesæ–¹æ³•ä¸­
ä½†æ˜¯ç»è¿‡è°ƒè¯•å‘ç°ï¼Œæ˜¯ä¸ä¼šèµ°_read_imagesæ–¹æ³•ä¸­çš„ifæµç¨‹çš„ï¼Œè€Œæ˜¯èµ°çš„loadAllCategoriesæ–¹æ³•ä¸­çš„

å…¨å±€æœç´¢æŸ¥çœ‹loadAllCategoriesçš„è°ƒç”¨ï¼Œå‘ç°æ˜¯åœ¨load_imagesæ—¶è°ƒç”¨çš„


é€šè¿‡å †æ ˆä¿¡æ¯åˆ†æ:
åœ¨attachCategoriesä¸­åŠ è‡ªå®šä¹‰é€»è¾‘çš„æ–­ç‚¹ï¼ŒbtæŸ¥çœ‹å †æ ˆä¿¡æ¯

æ‰€ä»¥ç»¼ä¸Šæ‰€è¿°ï¼Œè¯¥æƒ…å†µä¸‹çš„åˆ†ç±»çš„æ•°æ®åŠ è½½æ—¶æœºçš„åæ¨è·¯å¾„ä¸ºï¼šattachCategories -> load_categories_nolock -> loadAllCategories -> load_images

è€Œæˆ‘ä»¬çš„åˆ†ç±»åŠ è½½æ­£å¸¸çš„æµç¨‹çš„è·¯å¾„ä¸ºï¼šrealizeClassWithoutSwift -> methodizeClass -> attachToClass ->attachCategories



==================================================å†æ¥çœ‹ä¸€ç§æƒ…å†µï¼šä¸»ç±»+åˆ†ç±»LGAå®ç°+loadï¼Œåˆ†ç±»LGBä¸å®ç°+loadæ–¹æ³•
æ–­ç‚¹å®šåœ¨attachCategoriesä¸­åŠ è‡ªå®šä¹‰é€»è¾‘éƒ¨åˆ†ï¼Œä¸€æ­¥æ­¥å¾€ä¸‹æ‰§è¡Œ
p entry.cat// LGA
ç»§ç»­å¾€ä¸‹æ‰§è¡Œï¼Œä¼šå†æ¬¡æ¥åˆ° attachCategoriesæ–¹æ³•ä¸­
p entry.cat// LGB

æ€»ç»“ï¼šåªè¦æœ‰ä¸€ä¸ªåˆ†ç±»æ˜¯éæ‡’åŠ è½½åˆ†ç±»ï¼Œé‚£ä¹ˆæ‰€æœ‰çš„åˆ†ç±»éƒ½ä¼šè¢«æ ‡è®°ä½éæ‡’åŠ è½½åˆ†ç±»ï¼Œæ„æ€å°±æ˜¯åŠ è½½ä¸€æ¬¡ å·²ç»å¼€è¾Ÿäº†rweï¼Œå°±ä¸ä¼šå†æ¬¡æ‡’åŠ è½½ï¼Œé‡æ–°å»å¤„ç† LGPerson


åˆ†ç±»å’Œç±»çš„æ­é…ä½¿ç”¨:
é€šè¿‡ä¸Šé¢çš„ä¸¤ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥å¤§è‡´å°†ç±» å’Œ åˆ†ç±» æ˜¯å¦å®ç°+loadçš„æƒ…å†µåˆ†ä¸º4ç§

ç±»+åˆ†ç±»			
                  åˆ†ç±»å®ç°+load	            åˆ†ç±»æœªå®ç°+load	
ç±»å®ç°+load	       éæ‡’åŠ è½½ç±»+éæ‡’åŠ è½½åˆ†ç±»	    éæ‡’åŠ è½½ç±»+æ‡’åŠ è½½åˆ†ç±»	
ç±»æœªå®ç°+load	    æ‡’åŠ è½½ç±»+éæ‡’åŠ è½½åˆ†ç±»	    æ‡’åŠ è½½ç±»+æ‡’åŠ è½½åˆ†ç±»

ã€æƒ…å†µ1ã€‘éæ‡’åŠ è½½ç±» + éæ‡’åŠ è½½åˆ†ç±»
ã€æƒ…å†µ2ã€‘éæ‡’åŠ è½½ç±» + æ‡’åŠ è½½åˆ†ç±»
ã€æƒ…å†µ3ã€‘æ‡’åŠ è½½ç±» + æ‡’åŠ è½½åˆ†ç±»
ã€æƒ…å†µ4ã€‘æ‡’åŠ è½½ç±» + éæ‡’åŠ è½½åˆ†ç±»


éæ‡’åŠ è½½ç±» ä¸ éæ‡’åŠ è½½åˆ†ç±»:
å³ä¸»ç±»å®ç°äº†+loadæ–¹æ³•ï¼Œåˆ†ç±»åŒæ ·å®ç°äº†+loadæ–¹æ³•ï¼Œåœ¨å‰æ–‡åˆ†ç±»çš„åŠ è½½æ—¶æœºæ—¶ï¼Œæˆ‘ä»¬å·²ç»åˆ†æè¿‡è¿™ç§æƒ…å†µï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥å¾—å‡ºç»“è®ºï¼Œè¿™ç§æƒ…å†µä¸‹
ç±»çš„æ•°æ®åŠ è½½æ˜¯é€šè¿‡_getObjc2NonlazyClassListåŠ è½½ï¼Œå³roã€rwçš„æ“ä½œï¼Œå¯¹rweèµ‹å€¼åˆå§‹åŒ–ï¼Œæ˜¯åœ¨extAllocæ–¹æ³•ä¸­
åˆ†ç±»çš„æ•°æ®åŠ è½½æ˜¯é€šè¿‡load_imagesåŠ è½½åˆ°ç±»ä¸­çš„

å…¶è°ƒç”¨è·¯å¾„ä¸º:
map_images -> map_images_nolock -> _read_images -> readClass -> _getObjc2NonlazyClassList -> realizeClassWithoutSwift -> methodizeClass -> attachToClass ,æ­¤æ—¶çš„mlistsæ˜¯ä¸€ç»´æ•°ç»„ï¼Œç„¶åèµ°åˆ°load_imageséƒ¨åˆ†

load_images --> loadAllCategories -> load_categories_nolock -> load_categories_nolock -> attachCategories -> attachListsï¼Œæ­¤æ—¶çš„mlistsæ˜¯äºŒç»´æ•°ç»„


éæ‡’åŠ è½½ç±» ä¸ æ‡’åŠ è½½åˆ†ç±»:
å³ä¸»ç±»å®ç°äº†+loadæ–¹æ³•ï¼Œåˆ†ç±»æœªå®ç°+loadæ–¹æ³•
æ‰“å¼€realizeClassWithoutSwiftä¸­çš„è‡ªå®šä¹‰æ–­ç‚¹ï¼Œçœ‹ä¸€ä¸‹ro
æ–¹æ³•çš„é¡ºåºæ˜¯ LGBâ€”LGA-LGPersonç±»ï¼Œæ­¤æ—¶åˆ†ç±»å·²ç» åŠ è½½è¿›æ¥äº†ï¼Œä½†æ˜¯è¿˜æ²¡æœ‰æ’åºï¼Œè¯´æ˜åœ¨æ²¡æœ‰è¿›è¡Œéæ‡’åŠ è½½æ—¶ï¼Œé€šè¿‡cls->dataè¯»å–Mach-Oæ•°æ®æ—¶ï¼Œæ•°æ®å°±å·²ç»ç¼–è¯‘è¿›æ¥äº†ï¼Œä¸éœ€è¦è¿è¡Œæ—¶æ·»åŠ è¿›å»
æ¥åˆ°methodizeClassæ–¹æ³•ä¸­æ–­ç‚¹éƒ¨åˆ†
p list
æ¥åˆ°prepareMethodListsçš„forå¾ªç¯éƒ¨åˆ†
æ¥åˆ°fixupMethodListæ–¹æ³•ä¸­çš„if (sort) {éƒ¨åˆ†
å…¶ä¸­SortBySELAddressçš„æºç å®ç°å¦‚ä¸‹ï¼šæ ¹æ®åå­—çš„åœ°å€è¿›è¡Œæ’åº
èµ°åˆ°mlist->setFixedUp();ï¼Œåœ¨è¯»å–list
p mlist
é€šè¿‡æ‰“å°å‘ç°ï¼Œä»…å¯¹åŒåæ–¹æ³•è¿›è¡Œäº†æ’åºï¼Œè€Œåˆ†ç±»ä¸­çš„å…¶ä»–æ–¹æ³•æ˜¯ä¸éœ€è¦æ’åºçš„ï¼Œå…¶ä½ impåœ°å€æ˜¯æœ‰åºçš„ï¼ˆä»å°åˆ°å¤§ï¼‰ -- fixupMethodListä¸­çš„æ’åºåªé’ˆå¯¹ name åœ°å€è¿›è¡Œæ’åº

æ€»ç»“ï¼šéæ‡’åŠ è½½ç±» ä¸ æ‡’åŠ è½½åˆ†ç±»çš„æ•°æ®åŠ è½½ï¼Œæœ‰å¦‚ä¸‹ç»“è®ºï¼š
ç±» å’Œ åˆ†ç±»çš„åŠ è½½æ˜¯åœ¨read_imageså°±åŠ è½½æ•°æ®äº†
å…¶ä¸­dataæ•°æ®åœ¨ç¼–è¯‘æ—¶æœŸå°±å·²ç»å®Œæˆäº†


æ‡’åŠ è½½ç±» ä¸ æ‡’åŠ è½½åˆ†ç±»:
å³ä¸»ç±»å’Œåˆ†ç±»å‡æœªå®ç°+loadæ–¹æ³•
å…¶ä¸­realizeClassMaybeSwiftMaybeRelockæ˜¯æ¶ˆæ¯æµç¨‹ä¸­æ…¢é€ŸæŸ¥æ‰¾ä¸­æœ‰çš„å‡½æ•°ï¼Œå³åœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨æ¶ˆæ¯æ—¶æ‰æœ‰çš„å‡½æ•°
åœ¨readClassæ–­ä½,ç„¶åè¯»å–kc_roï¼Œå³è¯»å–æ•´ä¸ªdata
æ­¤æ—¶çš„baseMethodListçš„countè¿˜æ˜¯16ï¼Œè¯´æ˜ä¹Ÿæ˜¯ä»dataä¸­è¯»å–å‡ºæ¥çš„ï¼Œæ‰€ä»¥ä¸éœ€è¦ç»è¿‡ä¸€å±‚ç¼“æ…¢çš„load_imagesåŠ è½½è¿›æ¥
æ€»ç»“ï¼šæ‡’åŠ è½½ç±» ä¸ æ‡’åŠ è½½åˆ†ç±»çš„æ•°æ®åŠ è½½æ˜¯åœ¨æ¶ˆæ¯ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶åŠ è½½


æ‡’åŠ è½½ç±» ä¸ éæ‡’åŠ è½½åˆ†ç±»:
å³ä¸»ç±»æœªå®ç°+loadæ–¹æ³•ï¼Œ åˆ†ç±»å®ç°äº†+loadæ–¹æ³•
åœ¨æ‰“å°çš„æ—¥å¿—ä¸­æ²¡æœ‰çœ‹åˆ°load_categories_nolockæ–¹æ³•ï¼ŒæŸ¥çœ‹attachCategories -- extAlloc -- attachToClass -- attachCategoriesï¼Œåœ¨attachToClassä¸­åŠ æ–­ç‚¹
åœ¨readClassæ–¹æ³•ä¸­æ–­ä½ï¼ŒæŸ¥çœ‹kc_ro
å…¶ä¸­baseMethodListçš„countæ˜¯8ä¸ªï¼Œæ‰“å°çœ‹çœ‹ï¼šå¯¹è±¡æ–¹æ³•3ä¸ª+å±æ€§çš„setgetæ–¹æ³•å…±4ä¸ª+1ä¸ªcxxæ–¹æ³• ï¼Œå³ ç°åœ¨åªæœ‰ä¸»ç±»çš„æ•°æ®

ä¸ºäº†è°ƒè¯•åˆ†ç±»çš„æ•°æ®åŠ è½½ï¼Œ ç»§ç»­å¾€ä¸‹æ‰§è¡Œï¼ŒbtæŸ¥çœ‹å †æ ˆï¼šload_images -> loadAllCategories -> load_categories_nolock
æ€»ç»“ï¼šæ‡’åŠ è½½ç±» + éæ‡’åŠ è½½åˆ†ç±»çš„æ•°æ®åŠ è½½ï¼Œåªè¦åˆ†ç±»å®ç°äº†loadï¼Œä¼šè¿«ä½¿ä¸»ç±»æå‰åŠ è½½,å³ ä¸»ç±» å¼ºè¡Œè½¬æ¢ä¸º éæ‡’åŠ è½½ç±»æ ·å¼



æ€»ç»“:
ç±»å’Œåˆ†ç±»æ­é…ä½¿ç”¨ï¼Œå…¶æ•°æ®çš„åŠ è½½æ—¶æœºæ€»ç»“å¦‚ä¸‹ï¼š
ã€æƒ…å†µ1ã€‘éæ‡’åŠ è½½ç±» + éæ‡’åŠ è½½åˆ†ç±»ï¼Œå…¶æ•°æ®çš„åŠ è½½åœ¨load_imagesæ–¹æ³•ä¸­ï¼Œé¦–å…ˆå¯¹ç±»è¿›è¡ŒåŠ è½½ï¼Œç„¶åæŠŠåˆ†ç±»çš„ä¿¡æ¯è´´åˆ°ç±»ä¸­
ã€æƒ…å†µ2ã€‘éæ‡’åŠ è½½ç±» + æ‡’åŠ è½½åˆ†ç±»ï¼Œå…¶æ•°æ®åŠ è½½åœ¨read_imageå°±åŠ è½½æ•°æ®ï¼Œæ•°æ®æ¥è‡ªdataï¼Œdataåœ¨ç¼–è¯‘æ—¶æœŸå°±å·²ç»å®Œæˆï¼Œå³dataä¸­é™¤äº†ç±»çš„æ•°æ®ï¼Œè¿˜æœ‰åˆ†ç±»çš„æ•°æ®ï¼Œä¸ç±»ç»‘å®šåœ¨ä¸€èµ·
ã€æƒ…å†µ3ã€‘æ‡’åŠ è½½ç±» + æ‡’åŠ è½½åˆ†ç±» ï¼Œå…¶æ•°æ®åŠ è½½æ¨è¿Ÿåˆ° ç¬¬ä¸€æ¬¡æ¶ˆæ¯æ—¶ï¼Œæ•°æ®åŒæ ·æ¥è‡ªdataï¼Œdataåœ¨ç¼–è¯‘æ—¶æœŸå°±å·²ç»å®Œæˆ
ã€æƒ…å†µ4ã€‘æ‡’åŠ è½½ç±» + éæ‡’åŠ è½½åˆ†ç±» ï¼Œåªè¦åˆ†ç±»å®ç°äº†loadï¼Œä¼šè¿«ä½¿ä¸»ç±»æå‰åŠ è½½ï¼Œå³åœ¨_read_imagesä¸­ä¸ä¼šå¯¹ç±»åšå®ç°æ“ä½œï¼Œéœ€è¦åœ¨load_imagesæ–¹æ³•ä¸­è§¦å‘ç±»çš„æ•°æ®åŠ è½½ï¼Œå³rweåˆå§‹åŒ–ï¼ŒåŒæ—¶åŠ è½½åˆ†ç±»æ•°æ®



==================================================load_imagesåŸç†åˆ†æ
load_imagesæ–¹æ³•çš„ä¸»è¦ä½œç”¨æ˜¯åŠ è½½é•œåƒæ–‡ä»¶ï¼Œå…¶ä¸­æœ€é‡è¦çš„æœ‰ä¸¤ä¸ªæ–¹æ³•ï¼šprepare_load_methodsï¼ˆåŠ è½½ï¼‰ å’Œ call_load_methodsï¼ˆè°ƒç”¨ï¼‰

è¿›å…¥prepare_load_methodsæºç :
è¿›å…¥_getObjc2NonlazyClassList -> schedule_class_loadæºç ,è¿™é‡Œä¸»è¦æ˜¯æ ¹æ®ç±»çš„ç»§æ‰¿é“¾é€’å½’è°ƒç”¨è·å–loadï¼Œç›´åˆ°clsä¸å­˜åœ¨æ‰ç»“æŸé€’å½’ï¼Œç›®çš„æ˜¯ä¸ºäº†ç¡®ä¿çˆ¶ç±»çš„loadä¼˜å…ˆåŠ è½½

è¿›å…¥add_class_to_loadable_listï¼Œä¸»è¦æ˜¯å°†loadæ–¹æ³•å’Œclsç±»åä¸€èµ·åŠ åˆ°loadable_classesè¡¨ä¸­

è¿›å…¥getLoadMethodï¼Œä¸»è¦æ˜¯è·å–æ–¹æ³•çš„selä¸ºloadçš„æ–¹æ³•

_getObjc2NonlazyCategoryList -> realizeClassWithoutSwift -> add_category_to_loadable_list ,ä¸»è¦æ˜¯å°†éæ‡’åŠ è½½åˆ†ç±»çš„loadæ–¹æ³•åŠ å…¥è¡¨ä¸­

è¿›å…¥add_category_to_loadable_listå®ç°,è·å–æ‰€æœ‰çš„éæ‡’åŠ è½½åˆ†ç±»ä¸­çš„loadæ–¹æ³•ï¼Œå°†åˆ†ç±»å+loadåŠ å…¥è¡¨loadable_categories


è¿›å…¥call_load_methodsæºç ï¼Œä¸»è¦æœ‰3éƒ¨åˆ†æ“ä½œ:
åå¤è°ƒç”¨ç±»çš„+loadï¼Œç›´åˆ°ä¸å†æœ‰
è°ƒç”¨ä¸€æ¬¡åˆ†ç±»çš„+load
å¦‚æœæœ‰ç±»æˆ–æ›´å¤šæœªå°è¯•çš„åˆ†ç±»ï¼Œåˆ™è¿è¡Œæ›´å¤šçš„+load

è¿›å…¥call_class_loadsï¼Œä¸»è¦æ˜¯åŠ è½½ç±»çš„loadæ–¹æ³•
å…¶ä¸­loadæ–¹æ³•ä¸­æœ‰ä¸¤ä¸ªéšè—å‚æ•°ï¼Œç¬¬ä¸€ä¸ªä¸ºid å³selfï¼Œç¬¬äºŒä¸ªä¸ºselï¼Œå³cmd

call_category_loadsï¼Œä¸»è¦æ˜¯åŠ è½½ä¸€æ¬¡åˆ†ç±»çš„loadæ–¹æ³•

åŸç†ä¸»è¦åˆ†ä¸ºä¸¤æ­¥:
ä»æ‰€æœ‰çš„éæ‡’åŠ è½½ç±»å’Œåˆ†ç±»ä¸­çš„+loadåˆ†åˆ«æ·»åŠ åˆ°è¡¨ä¸­
è°ƒç”¨ç±»å’Œåˆ†ç±»çš„+loadæ–¹æ³•