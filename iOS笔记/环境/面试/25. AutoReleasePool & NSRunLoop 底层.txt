self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(fireHome) userInfo:nil repeats:YES];
[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];
Runloopå¯¹timerçš„å¼ºæŒæœ‰


NSLog(@"%ld",CFGetRetainCount((__bridge CFTypeRef)self));// 8
__weak typeof(self) weakSelf = self;
NSLog(@"%ld",CFGetRetainCount((__bridge CFTypeRef)self));// 8

weakSelfä¼šå¯¹å¼•ç”¨è®¡æ•°è¿›è¡Œ+1æ“ä½œå—ï¼Ÿ
weakSelfæ²¡æœ‰å¯¹å†…å­˜è¿›è¡Œ+1æ“ä½œ

#####
weakSelf å’Œ self çš„æŒ‡é’ˆåœ°å€ç›¸åŒå—ï¼Œæ˜¯æŒ‡å‘åŒä¸€ç‰‡å†…å­˜å—ï¼Ÿ
po weakSelf
po self
po &weakSelf
po &self
ä»æ‰“å°ç»“æœå¯ä»¥çœ‹å‡ºï¼Œå½“å‰selfå–åœ°å€ å’Œ weakSelfå–åœ°å€çš„å€¼æ˜¯ä¸ä¸€æ ·çš„ã€‚
æ„å‘³ç€æœ‰ä¸¤ä¸ªæŒ‡é’ˆåœ°å€ï¼ŒæŒ‡å‘çš„æ˜¯åŒä¸€ç‰‡å†…å­˜ç©ºé—´ï¼Œå³weakSelf å’Œ self çš„å†…å­˜åœ°å€æ˜¯ä¸ä¸€æ ·ï¼Œéƒ½æŒ‡å‘åŒä¸€ç‰‡å†…å­˜ç©ºé—´çš„
#####


æ­¤æ—¶timeræ•è·çš„æ˜¯<LGTimerViewController: 0x7f890741f5b0>ï¼Œæ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œæ‰€ä»¥æ— æ³•é€šè¿‡weakSelfæ¥è§£å†³å¼ºæŒæœ‰ã€‚
å³å¼•ç”¨é“¾å…³ç³»ä¸ºï¼šNSRunLoop -> timer -> weakSelfï¼ˆ<LGTimerViewController: 0x7f890741f5b0>ï¼‰ã€‚æ‰€ä»¥RunLoopå¯¹æ•´ä¸ª å¯¹è±¡çš„ç©ºé—´æœ‰å¼ºæŒæœ‰ï¼Œrunloopæ²¡åœï¼Œtimer å’Œ weakSelfæ˜¯æ— æ³•é‡Šæ”¾çš„
åœ¨BlockåŸç†ä¸­æåŠçš„blockçš„å¾ªç¯å¼•ç”¨ï¼Œä¸timerçš„æ˜¯æœ‰åŒºåˆ«çš„ã€‚
é€šè¿‡blockåº•å±‚åŸç†çš„æ–¹æ³•__Block_object_assignå¯çŸ¥ï¼Œblockæ•è·çš„æ˜¯ å¯¹è±¡çš„æŒ‡é’ˆåœ°å€ï¼Œå³weakself æ˜¯ ä¸´æ—¶å˜é‡çš„æŒ‡é’ˆåœ°å€ï¼Œè·Ÿselfæ²¡æœ‰å…³ç³»ï¼Œå› ä¸ºweakSelfæ˜¯æ–°çš„åœ°å€ç©ºé—´ã€‚
æ‰€ä»¥æ­¤æ—¶çš„weakSelfç›¸å½“äºä¸­é—´å€¼ã€‚å…¶å¼•ç”¨å…³ç³»é“¾ä¸ºself -> block -> weakSelfï¼ˆä¸´æ—¶å˜é‡çš„æŒ‡é’ˆåœ°å€ï¼‰ï¼Œå¯ä»¥é€šè¿‡åœ°å€æ‹¿åˆ°æŒ‡é’ˆ


åŒºåˆ«ä¸‹blockå’Œtimerå¾ªç¯å¼•ç”¨çš„æ¨¡å‹
timeræ¨¡å‹ï¼šself -> timer -> weakSelf -> self,å½“å‰çš„timeræ•è·çš„æ˜¯Bç•Œé¢çš„å†…å­˜ï¼Œå³vcå¯¹è±¡çš„å†…å­˜ï¼Œå³weakSelfè¡¨ç¤ºçš„æ˜¯vcå¯¹è±¡
Blockæ¨¡å‹ï¼šself -> block -> weakSelf -> selfï¼Œå½“å‰çš„blockæ•è·çš„æ˜¯æŒ‡é’ˆåœ°å€ï¼Œå³weakSelfè¡¨ç¤ºçš„æ˜¯æŒ‡å‘selfçš„ä¸´æ—¶å˜é‡çš„æŒ‡é’ˆåœ°å€

è§£å†³ å¼ºå¼•ç”¨:
æ€è·¯ä¸€ï¼špopæ—¶åœ¨å…¶ä»–æ–¹æ³•ä¸­é”€æ¯timer
didMoveToParentViewController

æ€è·¯äºŒï¼šä¸­ä»‹è€…æ¨¡å¼ï¼Œå³ä¸ä½¿ç”¨selfï¼Œä¾èµ–äºå…¶ä»–å¯¹è±¡
//**********1ã€å®šä¹‰å…¶ä»–å¯¹è±¡**********
@property (nonatomic, strong) id            target;

//**********1ã€ä¿®æ”¹target**********
self.target = [[NSObject alloc] init];
class_addMethod([NSObject class], @selector(fireHome), (IMP)fireHomeObjc, "v@:");
self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self.target selector:@selector(fireHome) userInfo:nil repeats:YES];

//**********3ã€imp**********
void fireHomeObjc(id obj){
    NSLog(@"%s -- %@",__func__,obj);
}

æ€è·¯ä¸‰ï¼šè‡ªå®šä¹‰å°è£…timer
è¿™ç§æ–¹å¼æ˜¯æ ¹æ®æ€è·¯äºŒçš„åŸç†

æ€è·¯å››ï¼šåˆ©ç”¨NSProxyè™šåŸºç±»çš„å­ç±»
å³ä½¿ç”¨NSProxyä½œä¸ºä¸­é—´ä»£ç†ã€ä¸­é—´è€…


==================================================AutoReleasePool è‡ªåŠ¨é‡Šæ”¾æ± 
https://www.jianshu.com/u/5c9dfddcd1dd

è‡ªåŠ¨é‡Šæ”¾æ± å®é™…ä¸Šæ˜¯ä¸€ä¸ªç”± AutoreleasePoolPage ç»„æˆçš„åŒå‘é“¾è¡¨ç»“æ„, ä¸€ä¸ªè‡ªåŠ¨é‡Šæ”¾æ± ä¸­æœ‰ä¸€ä¸ªæˆ–å¤šä¸ª AutoreleasePoolPage èŠ‚ç‚¹


è‡ªåŠ¨é‡Šæ”¾æ± æ˜¯OCä¸­çš„ä¸€ç§å†…å­˜è‡ªåŠ¨å›æ”¶æœºåˆ¶ï¼Œå®ƒå¯ä»¥å°†åŠ å…¥AutoreleasePoolä¸­çš„å˜é‡releaseçš„æ—¶æœºå»¶è¿Ÿï¼Œç®€å•æ¥è¯´ï¼Œå°±æ˜¯å½“åˆ›å»ºä¸€ä¸ªå¯¹è±¡ï¼Œåœ¨æ­£å¸¸æƒ…å†µä¸‹ï¼Œå˜é‡ä¼šåœ¨è¶…å‡ºå…¶ä½œç”¨åŸŸçš„æ—¶ç«‹å³releaseã€‚
å¦‚æœå°†å¯¹è±¡åŠ å…¥åˆ°äº†è‡ªåŠ¨é‡Šæ”¾æ± ä¸­ï¼Œè¿™ä¸ªå¯¹è±¡å¹¶ä¸ä¼šç«‹å³é‡Šæ”¾ï¼Œä¼šç­‰åˆ°runloopä¼‘çœ /è¶…å‡ºautoreleasepoolä½œç”¨åŸŸ{}ä¹‹åæ‰ä¼šè¢«é‡Šæ”¾ã€‚

1ã€ä»ç¨‹åºå¯åŠ¨åˆ°åŠ è½½å®Œæˆï¼Œä¸»çº¿ç¨‹å¯¹åº”çš„runloopä¼šå¤„äºä¼‘çœ çŠ¶æ€ï¼Œç­‰å¾…ç”¨æˆ·äº¤äº’æ¥å”¤é†’runloop
2ã€ç”¨æˆ·çš„æ¯ä¸€æ¬¡äº¤äº’éƒ½ä¼šå¯åŠ¨ä¸€æ¬¡runloopï¼Œç”¨äºå¤„ç†ç”¨æˆ·çš„æ‰€æœ‰ç‚¹å‡»ã€è§¦æ‘¸äº‹ä»¶ç­‰
3ã€runloopåœ¨ç›‘å¬åˆ°äº¤äº’äº‹ä»¶åï¼Œå°±ä¼šåˆ›å»ºè‡ªåŠ¨é‡Šæ”¾æ± ï¼Œå¹¶å°†æ‰€æœ‰å»¶è¿Ÿé‡Šæ”¾çš„å¯¹è±¡æ·»åŠ åˆ°è‡ªåŠ¨é‡Šæ”¾æ± ä¸­
4ã€åœ¨ä¸€æ¬¡å®Œæ•´çš„runloopç»“æŸä¹‹å‰ï¼Œä¼šå‘è‡ªåŠ¨é‡Šæ”¾æ± ä¸­æ‰€æœ‰å¯¹è±¡å‘é€releaseæ¶ˆæ¯ï¼Œç„¶åé”€æ¯è‡ªåŠ¨é‡Šæ”¾æ± 



Clangåˆ†æ:
å…ˆé€šè¿‡clangæ¥åˆ†æ:
int main(int argc, const char * argv[]) {
    @autoreleasepool {
    }
}

struct __AtAutoreleasePool {
    //æ„é€ å‡½æ•°
    __AtAutoreleasePool() {
            atautoreleasepoolobj = objc_autoreleasePoolPush();
    }
    //ææ„å‡½æ•°
    ~__AtAutoreleasePool() {
            objc_autoreleasePoolPop(atautoreleasepoolobj);
     }
      void * atautoreleasepoolobj;
};

int main(int argc, const char * argv[]) {
   { 
        //æ˜¯ä¸€ä¸ªç»“æ„ä½“
         __AtAutoreleasePool __autoreleasepool; 
    }
    return 0;
}
è‡ªåŠ¨é‡Šæ”¾æ± å…¶æœ¬è´¨ä¹Ÿæ˜¯ä¸€ä¸ªå¯¹è±¡
@autoreleasepool {}
//ç­‰ä»·äº
{__AtAutoreleasePool __autoreleasepool; }

__AtAutoreleasePoolæ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œæœ‰æ„é€ å‡½æ•° + ææ„å‡½æ•°ï¼Œç»“æ„ä½“å®šä¹‰çš„å¯¹è±¡åœ¨ä½œç”¨åŸŸç»“æŸåï¼Œä¼šè‡ªåŠ¨è°ƒç”¨ææ„å‡½æ•°
å…¶ä¸­{} æ˜¯ ä½œç”¨åŸŸ ï¼Œä¼˜ç‚¹æ˜¯ç»“æ„æ¸…æ™°ï¼Œå¯è¯»æ€§å¼ºï¼Œå¯ä»¥åŠæ—¶åˆ›å»ºé”€æ¯

è¯¥è‡ªåŠ¨é‡Šæ”¾æ± ä» objc_autoreleasePoolPush() å¼€å§‹, æœŸé—´çš„ autorelease ç±»å‹çš„å¯¹è±¡éƒ½ä¼šåŠ å…¥åˆ°è¿™ä¸ªè‡ªåŠ¨é‡Šæ”¾æ± ä¸­, æœ€ååœ¨ objc_autoreleasePoolPop() è°ƒç”¨æ—¶, é‡Šæ”¾æ‰æ± ä¸­æ‰€æœ‰çš„ autorelease å¯¹è±¡.


struct CJLTest{
    CJLTest
(){
        printf("1123 - %s\n", __func__);
    }
    ~CJLTest(){
        printf("5667 - %s\n", __func__);
    }
};

int main(int argc, const char * argv[]) {
    {
        CJLTest test;
    }
}

//**********è¿è¡Œç»“æœ**********
1123 - CJLTest
5667 - ~CJLTest
åœ¨CJLTeståˆ›å»ºå¯¹è±¡æ—¶ï¼Œä¼šè‡ªåŠ¨è°ƒç”¨æ„é€ å‡½æ•°ï¼Œåœ¨å‡ºäº†{}ä½œç”¨åŸŸåï¼Œä¼šè‡ªåŠ¨è°ƒç”¨ææ„å‡½æ•°


æ±‡ç¼–åˆ†æ:
é€šè¿‡è°ƒè¯•ç»“æœå‘ç°ï¼Œè¯æ˜äº†æˆ‘ä»¬clangåˆ†æçš„ç»“æœ

æ€»ç»“:
autoreleasepoolå…¶æœ¬è´¨æ˜¯ä¸€ä¸ªç»“æ„ä½“å¯¹è±¡ï¼Œä¸€ä¸ªè‡ªåŠ¨é‡Šæ”¾æ± å¯¹è±¡å°±æ˜¯é¡µï¼Œæ˜¯æ ˆç»“æ„å­˜å‚¨ï¼Œç¬¦åˆå…ˆè¿›åå‡ºçš„åŸåˆ™å³å¯
é¡µçš„æ ˆåº•æ˜¯ä¸€ä¸ª56å­—èŠ‚å¤§å°çš„ç©ºå ä½ç¬¦ï¼Œä¸€é¡µæ€»å¤§å°ä¸º4096å­—èŠ‚
åªæœ‰ç¬¬ä¸€é¡µæœ‰å“¨å…µå¯¹è±¡ï¼Œæœ€å¤šå­˜å‚¨504ä¸ªå¯¹è±¡ï¼Œä»ç¬¬äºŒé¡µå¼€å§‹æœ€å¤šå­˜å‚¨505ä¸ªå¯¹è±¡
autoreleasepoolåœ¨åŠ å…¥è¦é‡Šæ”¾çš„å¯¹è±¡æ—¶ï¼Œåº•å±‚è°ƒç”¨çš„æ˜¯objc_autoreleasePoolPushæ–¹æ³•
autoreleasepoolåœ¨è°ƒç”¨ææ„å‡½æ•°é‡Šæ”¾æ—¶ï¼Œå†…éƒ¨çš„å®ç°æ˜¯è°ƒç”¨objc_autoreleasePoolPopæ–¹æ³•



å®å®šä¹‰å’Œé™æ€å¸¸é‡:
#   define EMPTY_POOL_PLACEHOLDER ((id*)1) //pool ä¸­æ²¡æœ‰å¯¹è±¡å­˜å…¥
#   define POOL_BOUNDARY nil //å“¨å…µå¯¹è±¡, ç”¨æ¥æ ‡è¯†é‡Šæ”¾è¾¹ç•Œ
static pthread_key_t const key = AUTORELEASE_POOL_KEY; //é”®å€¼å¯¹ä¸­çš„key, å€¼ä¸º AutoreleasePoolPage * ç±»å‹æŒ‡é’ˆ
static uint8_t const SCRIBBLE = 0xA3; //é‡Šæ”¾åçš„ä½ç½®ä¼šç½®ä¸º 0xA3A3A3A3
static size_t const SIZE = PAGE_MAX_SIZE; //æ¯ä¸ª page çš„å¤§å°, 4096 ä¸ªå­—èŠ‚(Page å¯¹è±¡æœ¬èº«å  56 ä¸ªå­—èŠ‚)
static size_t const COUNT = SIZE / sizeof(id); //page ä¸­èƒ½å­˜æ”¾çš„å¯¹è±¡ä¸ªæ•°

æˆå‘˜å˜é‡:
magic_t const magic; //ç”¨äºæ ¡éªŒ AutoreleasePoolPage çš„ç»“æ„
id *next; //ä¸‹ä¸€ä¸ªå¯¹è±¡è¦æ’å…¥çš„ä½ç½®
pthread_t const thread; //æ‰€å±çº¿ç¨‹å¥æŸ„
AutoreleasePoolPage * const parent; //åŒå‘é“¾è¡¨çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹
AutoreleasePoolPage *child; //åŒå‘é“¾è¡¨çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
uint32_t const depth; //é“¾è¡¨æ·±åº¦
uint32_t hiwat; //AutoreleasePool ä¸­å­˜å‚¨å¯¹è±¡ä¸ªæ•°çš„æœ€å¤§å€¼


å®å®šä¹‰å’Œé™æ€å¸¸é‡:
EMPTY_POOL_PLACEHOLDER
æ ¹æ®æ³¨é‡Šä»¥åŠä»£ç åˆ†æ, å¯ä»¥å¤§è‡´å¾—å‡ºè¿™ä¸ªå®å®šä¹‰ç”¨ä½œ pool ä¸­æ²¡æœ‰ add å…¥å¯¹è±¡æ—¶çš„æ ‡è®°. 
å½“ä¸€ä¸ªè‡ªåŠ¨é‡Šæ”¾æ± è¢«åˆ›å»ºä½†æ˜¯æ²¡æœ‰åŠ å…¥ä»»ä½• Autorelease å¯¹è±¡æ—¶, ä¼šè®©è¿™ä¸ªè‡ªåŠ¨é‡Šæ”¾æ± çš„å¥æŸ„ç­‰äº EMPTY_POOL_PLACEHOLDER, å¹¶ä¸ä¸ºå…¶åˆ†é…å†…å­˜.

POOL_BOUNDARY ä¼šåœ¨å»ºç«‹æ–°çš„è‡ªåŠ¨é‡Šæ”¾æ± æ—¶ä½œä¸ºç¬¬ä¸€ä¸ªå¯¹è±¡åŠ å…¥åˆ°æ± ä¸­, è¢«ç§°ä¸ºå“¨å…µå¯¹è±¡
@autoreleasepool {} æ˜¯åœ¨ä½œç”¨åŸŸçš„å¼€å§‹ä½¿ç”¨ push() æ–¹æ³•æ¥åˆ›å»ºè‡ªåŠ¨é‡Šæ”¾æ± , åœ¨ä½œç”¨åŸŸç»“æŸæ—¶, ä½¿ç”¨ pop() æ–¹æ³•æ¥é”€æ¯è‡ªåŠ¨é‡Šæ”¾æ± 
åœ¨åµŒå¥—ç»“æ„ä¸­ push() æ–¹æ³•ä¸ä¸€å®šä¼šåˆ›å»ºæ–°çš„ page èŠ‚ç‚¹, å¦‚æœå½“å‰èŠ‚ç‚¹æœªæ»¡åˆ™ä¼šç›´æ¥æ’å…¥ä¸€ä¸ªå“¨å…µå¯¹è±¡, å¦‚æœå½“å‰èŠ‚ç‚¹å·²æ»¡åˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„ page èŠ‚ç‚¹å¹¶ä¸”æ’å…¥ä¸€ä¸ªå“¨å…µå¯¹è±¡
push() å‡½æ•°çš„è¿”å›å€¼å°±æ˜¯è¿™ä¸ªå“¨å…µå¯¹è±¡çš„åœ°å€(å“¨å…µå¯¹è±¡çš„å€¼æ˜¯ nil, ä½†å“¨å…µå¯¹è±¡çš„åœ°å€ä¸ä¸º nil)
ç„¶ååœ¨ pop() æ–¹æ³•è°ƒç”¨æ—¶, ä¼ å…¥è¿™ä¸ªå“¨å…µå¯¹è±¡çš„åœ°å€, å¯¹è¿™ä¸ªåœ°å€ä¹‹åçš„ Autorelease å¯¹è±¡å‘é€ release æ–¹æ³•.

SCRIBBLE çš„å€¼ä¸º 0xA3. åœ¨ pop() æ–¹æ³•è¢«æ‰§è¡Œæ—¶, ä¼šç»™å¯¹åº”çš„å“¨å…µå¯¹è±¡ä¹‹åçš„æ‰€æœ‰å¯¹è±¡éƒ½å‘é€ release æ¶ˆæ¯, 
åŒæ—¶ä» page èŠ‚ç‚¹ä¸­ç§»é™¤è¿™äº›å¯¹è±¡, ç§»é™¤çš„æ–¹æ³•å°±æ˜¯ä½¿ç”¨ memset() å‡½æ•°ç»™åŸæ¥å­˜å‚¨å¯¹è±¡åœ°å€çš„åœ°æ–¹, 
å­˜å…¥SCRIBBLE(memset() ä¼šä¸º 8 ä¸ªå­—èŠ‚çš„åœ°å€éƒ½å­˜å…¥ 0xA3, å³ä¸º 0xA3A3A3A3A3A3A3A3).

SIZE = PAGE_MAX_SIZE, å®å®šä¹‰ PAGE_MAX_SIZE çš„æœ€ç»ˆå€¼ä¸º 4096(å•ä½æ˜¯å­—èŠ‚), è¿™ä¸ªé™æ€å¸¸é‡è¡¨ç¤ºä¸€ä¸ª AutoreleasePoolPage ä¸­ç”¨äºå­˜å‚¨å¯¹è±¡æŒ‡é’ˆçš„å†…å­˜å¤§å°.

COUNT å³æ¯ä¸ª page èŠ‚ç‚¹èƒ½å­˜å‚¨çš„ Autorelease å¯¹è±¡ä¸ªæ•°, åœ¨ 64 ä½æ“ä½œç³»ç»Ÿä¸‹, 4096 ä¸ªå­—èŠ‚å¯ä»¥å­˜å‚¨ 8 å­—èŠ‚çš„æŒ‡é’ˆå…± 512 ä¸ª, å³ä¸€ä¸ª page èŠ‚ç‚¹èƒ½å­˜å‚¨ 512 ä¸ªå¯¹è±¡. page å¯¹è±¡æœ¬èº«å  56 ä¸ªå­—èŠ‚, æ‰€ä»¥å®é™…èƒ½å­˜å‚¨ Autorelease å¯¹è±¡ä¸ªæ•°ä¸º 505 ä¸ª.
COUNT åœ¨ä»£ç ä¸­å¹¶æ²¡æœ‰å®é™…ç”¨é€”, åªæ˜¯é…åˆ depth å’Œ hiwat åœ¨è°ƒè¯•è¾“å‡ºæ—¶ä½¿ç”¨.

æˆå‘˜å˜é‡:
magic

next
æŒ‡å‘ page ä¸­ä¸‹ä¸€ä¸ªå°†è¦å­˜æ”¾ Autorelease å¯¹è±¡çš„åœ°å€, 
é€šå¸¸é€šè¿‡ *next++ = obj æ¥å®ç°å¯¹è±¡çš„å­˜å…¥å’Œ next æŒ‡é’ˆçš„ç´¯åŠ , ç”¨ *--next æ¥å–å‡ºè¦ release çš„å¯¹è±¡å’Œå®ç° next çš„é€’å‡.

thread
å½“å‰ page èŠ‚ç‚¹æ‰€å±çš„çº¿ç¨‹å¥æŸ„

parent å’Œ child
parent æ˜¯åŒå‘é“¾è¡¨ç»“æ„ä¸­æŒ‡å‘ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ, child æ˜¯åŒå‘é“¾è¡¨ä¸­æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ.

depth å’Œ hiwat
depth æ˜¯é“¾è¡¨çš„æ·±åº¦(å³æ€»å…±çš„èŠ‚ç‚¹æ•°), hiwat æ˜¯å¯¹åº”çš„è‡ªåŠ¨é‡Šæ”¾æ± ä¸­å­˜å‚¨å¯¹è±¡ä¸ªæ•°çš„æœ€å¤§å€¼(æ¯”å¦‚æ›¾ç»å­˜å‚¨è¿‡100ä¸ª, ç°åœ¨åªå‰©50ä¸ª, hiwat å°±æ˜¯ 100)
ä¸ºäº†è°ƒè¯•æ—¶è¾“å‡º AutoreleasePool ä¿¡æ¯


åº•å±‚åˆ†æ:
åœ¨objcæºç ä¸­ï¼Œå¯¹AutoreleasePoolçš„è§£é‡Šå¦‚ä¸‹
Autorelease pool implementation
- A thread's autorelease pool is a stack of pointers. 
çº¿ç¨‹çš„è‡ªåŠ¨é‡Šæ”¾æ± æ˜¯æŒ‡é’ˆçš„å †æ ˆ

- Each pointer is either an object to release, or POOL_BOUNDARY which is an autorelease pool boundary.
æ¯ä¸ªæŒ‡é’ˆéƒ½æ˜¯è¦é‡Šæ”¾çš„å¯¹è±¡ï¼Œæˆ–è€…æ˜¯POOL_BOUNDARYï¼Œå®ƒæ˜¯è‡ªåŠ¨é‡Šæ”¾æ± çš„è¾¹ç•Œã€‚

- A pool token is a pointer to the POOL_BOUNDARY for that pool. When the pool is popped, every object hotter than the sentinel is released.
æ± ä»¤ç‰Œæ˜¯æŒ‡å‘è¯¥æ± çš„POOL_BOUNDARYçš„æŒ‡é’ˆã€‚å¼¹å‡ºæ± åï¼Œå°†é‡Šæ”¾æ¯”å“¨ç‚¹æ›´çƒ­çš„æ¯ä¸ªå¯¹è±¡ã€‚

- The stack is divided into a doubly-linked list of pages. Pages are added and deleted as necessary. 
å †æ ˆåˆ†ä¸ºä¸¤ä¸ªåŒå‘é“¾æ¥çš„é¡µé¢åˆ—è¡¨ã€‚æ ¹æ®éœ€è¦æ·»åŠ å’Œåˆ é™¤é¡µé¢ã€‚

- Thread-local storage points to the hot page, where newly autoreleased objects are stored. 
çº¿ç¨‹æœ¬åœ°å­˜å‚¨æŒ‡å‘çƒ­é¡µé¢ï¼Œè¯¥é¡µé¢å­˜å‚¨æ–°è‡ªåŠ¨é‡Šæ”¾çš„å¯¹è±¡ã€‚

1ã€è‡ªåŠ¨é‡Šæ”¾æ±  æ˜¯ä¸€ä¸ª å…³äºæŒ‡é’ˆçš„æ ˆç»“æ„
2ã€å…¶ä¸­çš„æŒ‡é’ˆæ˜¯æŒ‡è¦é‡Šæ”¾çš„å¯¹è±¡æˆ–è€… pool_boundary å“¨å…µï¼ˆç°åœ¨ç»å¸¸è¢«ç§°ä¸º è¾¹ç•Œï¼‰
3ã€è‡ªåŠ¨é‡Šæ”¾æ± æ˜¯ä¸€ä¸ªé¡µçš„ç»“æ„ï¼ˆè™šæ‹Ÿå†…å­˜ä¸­æåŠè¿‡ï¼‰ ï¼Œè€Œä¸”è¿™ä¸ªé¡µæ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨ï¼ˆè¡¨ç¤ºæœ‰çˆ¶èŠ‚ç‚¹ å’Œ å­èŠ‚ç‚¹ï¼Œåœ¨ç±»ä¸­æåŠè¿‡ï¼Œå³ç±»çš„ç»§æ‰¿é“¾ï¼‰
4ã€è‡ªåŠ¨é‡Šæ”¾æ± å’Œçº¿ç¨‹æœ‰å…³ç³»


AutoreleasePoolPage:
//***********pushæ–¹æ³•***********
void *
objc_autoreleasePoolPush(void)
{
    return AutoreleasePoolPage::push();
}

//***********popæ–¹æ³•***********
void
objc_autoreleasePoolPop(void *ctxt)
{
    AutoreleasePoolPage::pop(ctxt);
}



//************å®å®šä¹‰************
#define PAGE_MIN_SIZE           PAGE_SIZE
#define PAGE_SIZE               I386_PGBYTES
#define I386_PGBYTES            4096            /* bytes per 80386 page */

//************ç±»å®šä¹‰************
class AutoreleasePoolPage : private AutoreleasePoolPageData
{
    friend struct thread_data_t;

public:
    //é¡µçš„å¤§å°
    static size_t const SIZE =
#if PROTECT_AUTORELEASEPOOL
        PAGE_MAX_SIZE;  // must be multiple of vm page size
#else
        PAGE_MIN_SIZE;  // size and alignment, power of 2
#endif

private:
    
    ...
    
    //æ„é€ å‡½æ•°
    AutoreleasePoolPage(AutoreleasePoolPage *newParent) :
        AutoreleasePoolPageData(begin(),//å¼€å§‹å­˜å‚¨çš„ä½ç½®
                                objc_thread_self(),//ä¼ çš„æ˜¯å½“å‰çº¿ç¨‹ï¼Œå½“å‰çº¿ç¨‹æ—¶é€šè¿‡tlsè·å–çš„
                                newParent,
                                newParent ? 1+newParent->depth : 0,//å¦‚æœæ˜¯ç¬¬ä¸€é¡µæ·±åº¦ä¸º0ï¼Œå¾€åæ˜¯å‰ä¸€ä¸ªçš„æ·±åº¦+1
                                newParent ? newParent->hiwat : 0)
    {...}
    
    //ææ„å‡½æ•°
    ~AutoreleasePoolPage() {...}
    
    ...
    
    //é¡µçš„å¼€å§‹ä½ç½®
    id * begin() {...}
    
    //é¡µçš„ç»“æŸä½ç½®
    id * end() {...}
   
    //é¡µæ˜¯å¦ä¸ºç©º
    bool empty() {...}
    
    //é¡µæ˜¯å¦æ»¡äº†
    bool full() {...}
   
    //é¡µçš„å­˜å‚¨æ˜¯å¦å°‘äºä¸€åŠ
    bool lessThanHalfFull() {...}
     
     //æ·»åŠ é‡Šæ”¾å¯¹è±¡
    id *add(id obj){...}
    
    //é‡Šæ”¾æ‰€æœ‰å¯¹è±¡
    void releaseAll() {...}
    
    //é‡Šæ”¾åˆ°stopä½ç½®ä¹‹å‰çš„æ‰€æœ‰å¯¹è±¡
    void releaseUntil(id *stop) {...}
    
    //æ€æ‰
    void kill() {...}
    
    //é‡Šæ”¾æœ¬åœ°çº¿ç¨‹å­˜å‚¨ç©ºé—´
    static void tls_dealloc(void *p) {...}
    
    //è·å–AutoreleasePoolPage
    static AutoreleasePoolPage *pageForPointer(const void *p) {...}
    static AutoreleasePoolPage *pageForPointer(uintptr_t p)  {...}
    
    //æ˜¯å¦æœ‰ç©ºæ± å ä½ç¬¦
    static inline bool haveEmptyPoolPlaceholder() {...}
    
    //è®¾ç½®ç©ºæ± å ä½ç¬¦
    static inline id* setEmptyPoolPlaceholder(){...}
    
    //è·å–å½“å‰æ“ä½œé¡µ
    static inline AutoreleasePoolPage *hotPage(){...}
    
    //è®¾ç½®å½“å‰æ“ä½œé¡µ
    static inline void setHotPage(AutoreleasePoolPage *page) {...}
    
    //è·å–coldPage
    static inline AutoreleasePoolPage *coldPage() {...}
    
    //å¿«é€Ÿé‡Šæ”¾
    static inline id *autoreleaseFast(id obj){...}
   
   //æ·»åŠ è‡ªåŠ¨é‡Šæ”¾å¯¹è±¡ï¼Œå½“é¡µæ»¡çš„æ—¶å€™è°ƒç”¨è¿™ä¸ªæ–¹æ³•
    static __attribute__((noinline))
    id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) {...}
    
    //æ·»åŠ è‡ªåŠ¨é‡Šæ”¾å¯¹è±¡ï¼Œå½“æ²¡é¡µçš„æ—¶å€™ä½¿ç”¨è¿™ä¸ªæ–¹æ³•
    static __attribute__((noinline))
    id *autoreleaseNoPage(id obj){...}
   
   //åˆ›å»ºæ–°é¡µ
    static __attribute__((noinline))
    id *autoreleaseNewPage(id obj) {...}
    
public:
    //è‡ªåŠ¨é‡Šæ”¾
    static inline id autorelease(id obj){...}
   
    //å…¥æ ˆ
    static inline void *push() {...}
    
    //å…¼å®¹è€çš„ SDK å‡ºæ ˆæ–¹æ³•
    __attribute__((noinline, cold))
    static void badPop(void *token){...}
    
    //å‡ºæ ˆé¡µé¢
    template<bool allowDebug>
    static void
    popPage(void *token, AutoreleasePoolPage *page, id *stop){...}
    __attribute__((noinline, cold))
    static void
    popPageDebug(void *token, AutoreleasePoolPage *page, id *stop){...}
    
    //å‡ºæ ˆ
    static inline void
    pop(void *token){...}
    
    static void init(){...}
    
    //æ‰“å°
    __attribute__((noinline, cold))
    void print(){...}
    
    //æ‰“å°æ‰€æœ‰
    __attribute__((noinline, cold))
    static void printAll(){...}
    
    //æ‰“å°Hiwat
    __attribute__((noinline, cold))
    static void printHiwat(){...}


AutoreleasePoolPageæ˜¯ç»§æ‰¿è‡ªAutoreleasePoolPageData,ä¸”è¯¥ç±»çš„å±æ€§ä¹Ÿæ˜¯æ¥è‡ªçˆ¶ç±»ï¼Œä»¥ä¸‹æ˜¯AutoreleasePoolPageDataçš„å®šä¹‰ï¼Œ

è‡ªåŠ¨é‡Šæ”¾æ± é™¤äº†æ˜¯ä¸€ä¸ªé¡µï¼Œè¿˜æ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨ç»“æ„
class AutoreleasePoolPage;
struct AutoreleasePoolPageData
{
    //ç”¨æ¥æ ¡éªŒAutoreleasePoolPageçš„ç»“æ„æ˜¯å¦å®Œæ•´
    magic_t const magic;//16ä¸ªå­—èŠ‚
    //æŒ‡å‘æœ€æ–°æ·»åŠ çš„autoreleasedå¯¹è±¡çš„ä¸‹ä¸€ä¸ªä½ç½®ï¼Œåˆå§‹åŒ–æ—¶æŒ‡å‘begin()
    __unsafe_unretained id *next;//8å­—èŠ‚
    //æŒ‡å‘å½“å‰çº¿ç¨‹
    pthread_t const thread;//8å­—èŠ‚
    //æŒ‡å‘çˆ¶èŠ‚ç‚¹ï¼Œç¬¬ä¸€ä¸ªç»“ç‚¹çš„parentå€¼ä¸ºnil
    AutoreleasePoolPage * const parent;//8å­—èŠ‚
    //æŒ‡å‘å­èŠ‚ç‚¹ï¼Œæœ€åä¸€ä¸ªç»“ç‚¹çš„childå€¼ä¸ºnil
    AutoreleasePoolPage *child;//8å­—èŠ‚
    //è¡¨ç¤ºæ·±åº¦ï¼Œä»0å¼€å§‹ï¼Œå¾€åé€’å¢1
    uint32_t const depth;//4å­—èŠ‚
    //è¡¨ç¤ºhigh water mark æœ€å¤§å…¥æ ˆæ•°é‡æ ‡è®°
    uint32_t hiwat;//4å­—èŠ‚

    //åˆå§‹åŒ–
    AutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat)
        : magic(), next(_next), thread(_thread),
          parent(_parent), child(nil),
          depth(_depth), hiwat(_hiwat)
    {
    }
};

å…¶ä¸­AutoreleasePoolPageDataç»“æ„ä½“çš„å†…å­˜å¤§å°ä¸º56å­—èŠ‚:
å±æ€§magic çš„ç±»å‹æ˜¯magic_tç»“æ„ä½“ï¼Œæ‰€å å†…å­˜å¤§å°ä¸ºm[4];æ‰€å å†…å­˜ï¼ˆå³4*4=16å­—èŠ‚ï¼‰
å±æ€§nextï¼ˆæŒ‡é’ˆï¼‰ã€threadï¼ˆå¯¹è±¡ï¼‰ã€parentï¼ˆå¯¹è±¡ï¼‰ã€childï¼ˆå¯¹è±¡ï¼‰å‡å 8å­—èŠ‚ï¼ˆå³4*8=32å­—èŠ‚ï¼‰
å±æ€§depthã€hiwatç±»å‹ä¸ºuint32_tï¼Œå®é™…ç±»å‹æ˜¯unsigned intç±»å‹ï¼Œå‡å 4å­—èŠ‚ï¼ˆå³2*4=8å­—èŠ‚ï¼‰



--------------------------------------------------objc_autoreleasePoolPush æºç åˆ†æ:
//å…¥æ ˆ
static inline void *push() 
{
    id *dest;
    //åˆ¤æ–­æ˜¯å¦æœ‰pool
    // DebugPoolAllocation æ˜¯ç”¨åœ¨è°ƒè¯•æ¨¡å¼ä¸‹çš„, è°ƒè¯•æ¨¡å¼ä¸‹ä¼šç›´æ¥ç”Ÿæˆæ–°çš„ page èŠ‚ç‚¹
    if (slowpath(DebugPoolAllocation)) {
        // Each autorelease pool starts on a new pool page.è‡ªåŠ¨é‡Šæ”¾æ± ä»æ–°æ± é¡µé¢å¼€å§‹
        //å¦‚æœæ²¡æœ‰ï¼Œåˆ™åˆ›å»º
        dest = autoreleaseNewPage(POOL_BOUNDARY);
    } else {
        //å‹æ ˆä¸€ä¸ªPOOL_BOUNDARYï¼Œå³å‹æ ˆå“¨å…µ
        dest = autoreleaseFast(POOL_BOUNDARY);
    }
    ASSERT(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);
    return dest;
}

è¿›å…¥pushæºç å®ç°:
åˆ¤æ–­æ˜¯å¦ä¸ºæœ‰ pool
å¦‚æœæ²¡æœ‰ï¼Œåˆ™é€šè¿‡autoreleaseNewPageæ–¹æ³•åˆ›å»º
å¦‚æœæœ‰ï¼Œåˆ™é€šè¿‡autoreleaseFastå‹æ ˆå“¨å…µå¯¹è±¡


1ã€åˆ›å»ºé¡µ autoreleaseNewPage
è¿›å…¥objc_autoreleasePoolPush -> push -> autoreleaseNewPageæºç å®ç°ï¼Œä¸»è¦æ˜¯é€šè¿‡hotPage`è·å–å½“å‰é¡µï¼Œåˆ¤æ–­å½“å‰é¡µæ˜¯å¦å­˜åœ¨
å¦‚æœå­˜åœ¨ï¼Œåˆ™é€šè¿‡autoreleaseFullPageæ–¹æ³•å‹æ ˆå¯¹è±¡
å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™é€šè¿‡autoreleaseNoPageæ–¹æ³•åˆ›å»ºé¡µ

//åˆ›å»ºæ–°é¡µ
static __attribute__((noinline))
id *autoreleaseNewPage(id obj)
{
    //è·å–å½“å‰æ“ä½œé¡µ
    AutoreleasePoolPage *page = hotPage();
    //å¦‚æœå­˜åœ¨ï¼Œåˆ™å‹æ ˆå¯¹è±¡
    if (page) return autoreleaseFullPage(obj, page);
    //å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºé¡µ
    else return autoreleaseNoPage(obj);
}

//******** hotPageæ–¹æ³• ********
//è·å–å½“å‰æ“ä½œé¡µ
static inline AutoreleasePoolPage *hotPage() 
{
    //è·å–å½“å‰é¡µ
    AutoreleasePoolPage *result = (AutoreleasePoolPage *)
        tls_get_direct(key);
    //å¦‚æœæ˜¯ä¸€ä¸ªç©ºæ± ï¼Œåˆ™è¿”å›nilï¼Œå¦åˆ™ï¼Œè¿”å›å½“å‰çº¿ç¨‹çš„è‡ªåŠ¨é‡Šæ”¾æ± 
    if ((id *)result == EMPTY_POOL_PLACEHOLDER) return nil;
    if (result) result->fastcheck();
    return result;
}


tls_get_direct
åªè€ƒè™‘çœŸæœºè¿è¡Œçš„æƒ…å†µ, æœ€ç»ˆè°ƒç”¨æƒ…å†µæ˜¯
__attribute__((always_inline)) static __inline__ void* _os_tsd_get_direct(unsigned long slot)
{
    return _os_tsd_get_base()[slot]; //slotå³ä¸ºä¼ è¿›æ¥çš„key
}

//_os_tsd_get_base å‡½æ•°çš„å®ç°
__attribute__((always_inline, pure)) static __inline__ void** _os_tsd_get_base(void)
{
#if ......
  //ä¸€äº›é arm64 ç¯å¢ƒä¸‹çš„æ“ä½œ
#elif defined(__arm64__) // arm64 ç‰ˆæœ¬å¯¹åº”çš„å‘½ä»¤
    uint64_t tsd;
    __asm__("mrs %0, TPIDRRO_EL0" : "=r" (tsd)); //å°†çº¿ç¨‹æŒ‡é’ˆå¯„å­˜å™¨(TPIDRRO_EL0)é‡Œçš„å€¼èµ‹å€¼ç»™å˜é‡ tsd
    tsd &= ~0x7ull; //tsd å’Œ 0x7ull å–éåçš„æ•°å­—è¿›è¡ŒæŒ‰ä½ä¸æ“ä½œ
#endif
    return (void**)(uintptr_t)tsd;
}
tls_get_direct å‡½æ•°å†…éƒ¨æœ€ç»ˆæ˜¯é€šè¿‡å¯¹çº¿ç¨‹æŒ‡é’ˆå¯„å­˜å™¨ä¸­çš„æ•°æ®ç»è¿‡è¿ç®—åå¾—åˆ°ä¸€ä¸ªå…ƒç´ ä¸º void * å‹æŒ‡é’ˆçš„æ•°ç»„, è¯¥æ•°ç»„çš„ç¬¬ 43 å·å…ƒç´ å³ä¸º hotPage


//******** autoreleaseNoPageæ–¹æ³• ********
static __attribute__((noinline))
id *autoreleaseNoPage(id obj)
{
    // "No page" could mean no pool has been pushed
    // or an empty placeholder pool has been pushed and has no contents yet
    ASSERT(!hotPage());

    bool pushExtraBoundary = false;
    //åˆ¤æ–­æ˜¯å¦æ˜¯ç©ºå ä½ç¬¦ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™å‹æ ˆå“¨å…µæ ‡è¯†ç¬¦ç½®ä¸ºYES
    if (haveEmptyPoolPlaceholder()) {
        // We are pushing a second pool over the empty placeholder pool
        // or pushing the first object into the empty placeholder pool.
        // Before doing that, push a pool boundary on behalf of the pool 
        // that is currently represented by the empty placeholder.
        pushExtraBoundary = true;
    }
    //å¦‚æœå¯¹è±¡ä¸æ˜¯å“¨å…µå¯¹è±¡ï¼Œä¸”æ²¡æœ‰Poolï¼Œåˆ™æŠ¥é”™
    else if (obj != POOL_BOUNDARY  &&  DebugMissingPools) {
        // We are pushing an object with no pool in place, 
        // and no-pool debugging was requested by environment.
        _objc_inform("MISSING POOLS: (%p) Object %p of class %s "
                     "autoreleased with no pool in place - "
                     "just leaking - break on "
                     "objc_autoreleaseNoPool() to debug", 
                     objc_thread_self(), (void*)obj, object_getClassName(obj));
        objc_autoreleaseNoPool(obj);
        return nil;
    }
    //å¦‚æœå¯¹è±¡æ˜¯å“¨å…µå¯¹è±¡ï¼Œä¸”æ²¡æœ‰ç”³è¯·è‡ªåŠ¨é‡Šæ”¾æ± å†…å­˜ï¼Œåˆ™è®¾ç½®ä¸€ä¸ªç©ºå ä½ç¬¦å­˜å‚¨åœ¨tlsä¸­ï¼Œå…¶ç›®çš„æ˜¯ä¸ºäº†èŠ‚çœå†…å­˜
    else if (obj == POOL_BOUNDARY  &&  !DebugPoolAllocation) {//å¦‚æœä¼ å…¥å‚æ•°ä¸ºå“¨å…µ
        // We are pushing a pool with no pool in place,
        // and alloc-per-pool debugging was not requested.
        // Install and return the empty pool placeholder.
        return setEmptyPoolPlaceholder();//è®¾ç½®ç©ºçš„å ä½ç¬¦
    }

    // We are pushing an object or a non-placeholder'd pool.

    // Install the first page.
    //åˆå§‹åŒ–ç¬¬ä¸€é¡µ
    AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);
    //è®¾ç½®pageä¸ºå½“å‰èšç„¦é¡µ
    setHotPage(page);
    
    // Push a boundary on behalf of the previously-placeholder'd pool.
    //å‹æ ˆå“¨å…µçš„æ ‡è¯†ç¬¦ä¸ºYESï¼Œåˆ™å‹æ ˆå“¨å…µå¯¹è±¡
    if (pushExtraBoundary) {
        //å‹æ ˆå“¨å…µ
        page->add(POOL_BOUNDARY);
    }
    
    // Push the requested object or pool.
    //å‹æ ˆå¯¹è±¡
    return page->add(obj);
}

å…¶ä¸­autoreleaseNoPageæ–¹æ³•ä¸­å‘ç°å½“å‰çº¿ç¨‹çš„è‡ªåŠ¨é‡Šæ”¾æ± æ˜¯é€šè¿‡AutoreleasePoolPageåˆ›å»ºçš„ï¼Œ
å…¶å®šä¹‰ä¸­æœ‰æ„é€ æ–¹æ³•ï¼Œè€Œæ„é€ æ–¹æ³•çš„å®ç°æ˜¯é€šè¿‡çˆ¶ç±»AutoreleasePoolPageDataçš„åˆå§‹åŒ–æ–¹æ³•
//**********AutoreleasePoolPageæ„é€ æ–¹æ³•**********
    AutoreleasePoolPage(AutoreleasePoolPage *newParent) :
        AutoreleasePoolPageData(begin(),//å¼€å§‹å­˜å‚¨çš„ä½ç½®
                                objc_thread_self(),//ä¼ çš„æ˜¯å½“å‰çº¿ç¨‹ï¼Œå½“å‰çº¿ç¨‹æ—¶é€šè¿‡tlsè·å–çš„
                                newParent,
                                newParent ? 1+newParent->depth : 0,//å¦‚æœæ˜¯ç¬¬ä¸€é¡µæ·±åº¦ä¸º0ï¼Œå¾€åæ˜¯å‰ä¸€ä¸ªçš„æ·±åº¦+1
                                newParent ? newParent->hiwat : 0)
{ 
    if (parent) {
        parent->check();
        ASSERT(!parent->child);
        parent->unprotect();
        //this è¡¨ç¤º æ–°å»ºé¡µé¢ï¼Œå°†å½“å‰é¡µé¢çš„å­èŠ‚ç‚¹ èµ‹å€¼ä¸ºæ–°å»ºé¡µé¢
        parent->child = this;
        parent->protect();
    }
    protect();
}

//**********AutoreleasePoolPageDataåˆå§‹åŒ–æ–¹æ³•**********
AutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat)
        : magic(), next(_next), thread(_thread),
          parent(_parent), child(nil),
          depth(_depth), hiwat(_hiwat)
    {
    }

å…¶ä¸­AutoreleasePoolPageDataæ–¹æ³•ä¼ å…¥çš„å‚æ•°å«ä¹‰ä¸º:
begin()è¡¨ç¤ºå‹æ ˆçš„ä½ç½®ï¼ˆå³ä¸‹ä¸€ä¸ªè¦é‡Šæ”¾å¯¹è±¡çš„å‹æ ˆåœ°å€ï¼‰ã€‚
å¯ä»¥é€šè¿‡æºç è°ƒè¯•beginï¼Œå‘ç°å…¶å…·ä½“å®ç°ç­‰äºé¡µé¦–åœ°å€+56ï¼Œå…¶ä¸­çš„56å°±æ˜¯ç»“æ„ä½“AutoreleasePoolPageDataçš„å†…å­˜å¤§å°
//********begin()********
//é¡µçš„å¼€å§‹ä½ç½®
id * begin() {
    //ç­‰äº é¦–åœ°å€+56ï¼ˆAutoreleasePoolPageç±»æ‰€å å†…å­˜å¤§å°ï¼‰
    return (id *) ((uint8_t *)this+sizeof(*this));
}

objc_thread_self() è¡¨ç¤ºçš„æ˜¯å½“å‰çº¿ç¨‹ï¼Œè€Œå½“å‰çº¿ç¨‹æ—¶é€šè¿‡tlsè·å–çš„
__attribute__((const))
static inline pthread_t objc_thread_self()
{
    //é€šè¿‡tlsè·å–å½“å‰çº¿ç¨‹
    return (pthread_t)tls_get_direct(_PTHREAD_TSD_SLOT_PTHREAD_SELF);
}
tls_get_direct() å‡½æ•°å†…éƒ¨ç»“åˆçº¿ç¨‹IDå’Œ AUTORELEASE_POOL_KEY(43) ä¸¤ä¸ªä¿¡æ¯æœ€ç»ˆæ‰¾å‡ºè¯¥çº¿ç¨‹å¯¹åº”çš„ hotPage.

newParentè¡¨ç¤ºçˆ¶èŠ‚ç‚¹

åç»­ä¸¤ä¸ªå‚æ•°æ˜¯é€šè¿‡çˆ¶èŠ‚ç‚¹çš„æ·±åº¦ã€æœ€å¤§å…¥æ ˆä¸ªæ•°è®¡ç®—depthä»¥åŠhiwat



æŸ¥çœ‹è‡ªåŠ¨é‡Šæ”¾æ± å†…å­˜ç»“æ„:
ç”±äºåœ¨ARCæ¨¡å¼ä¸‹ï¼Œæ˜¯æ— æ³•æ‰‹åŠ¨è°ƒç”¨autoreleaseï¼Œæ‰€ä»¥å°†Demoåˆ‡æ¢è‡³MRCæ¨¡å¼ï¼ˆBuild Settings -> Objectice-C Automatic Reference Countingè®¾ç½®ä¸ºNOï¼‰
//************æ‰“å°è‡ªåŠ¨é‡Šæ”¾æ± ç»“æ„************
extern void _objc_autoreleasePoolPrint(void);

//************è¿è¡Œä»£ç ************
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        //å¾ªç¯åˆ›å»ºå¯¹è±¡ï¼Œå¹¶åŠ å…¥è‡ªåŠ¨é‡Šæ”¾æ± 
        for (int i = 0; i < 5; i++) {
             NSObject *objc = [[NSObject alloc] autorelease];
        }
        //è°ƒç”¨
        _objc_autoreleasePoolPrint();
    }
}

å‘ç°æ˜¯6ä¸ªï¼Œä½†æ˜¯æˆ‘ä»¬å‹æ ˆçš„å¯¹è±¡å…¶å®åªæœ‰5ä¸ªï¼Œå…¶ä¸­çš„POOLè¡¨ç¤ºå“¨å…µï¼Œå³è¾¹ç•Œï¼Œå…¶ç›®çš„æ˜¯ä¸ºäº†é˜²æ­¢è¶Šç•Œ
æŸ¥çœ‹è‡ªåŠ¨é‡Šæ”¾æ± çš„å†…å­˜ç»“æ„ï¼Œå‘ç°ï¼Œé¡µçš„é¦–åœ°å€ä¸å“¨å…µå¯¹è±¡ç›¸å·®0x38ï¼Œè½¬æ¢æˆåè¿›åˆ¶åˆšå¥½æ˜¯56ï¼Œä¹Ÿå°±æ˜¯ AutoreleasePoolPageè‡ªå·±æœ¬èº«çš„å†…å­˜å¤§å°

å°†ä¸Šè¿°çš„æµ‹è¯•ä»£ç çš„æ•°æ®æ”¹ä¸º505ï¼Œå…¶å†…å­˜ç»“æ„å¦‚ä¸‹ï¼Œå‘ç°ç¬¬ä¸€é¡µæ»¡äº†ï¼Œå­˜å‚¨äº†504ä¸ªè¦é‡Šæ”¾çš„å¯¹è±¡ï¼Œç¬¬äºŒé¡µåªå­˜å‚¨äº†ä¸€ä¸ª
åœ¨å°†æ•°æ®æ”¹ä¸º505+506ï¼Œæ¥éªŒè¯ç¬¬äºŒé¡µæ˜¯å¦ä¹Ÿæ˜¯å­˜å‚¨504ä¸ªå¯¹è±¡
é€šè¿‡è¿è¡Œå‘ç°ï¼Œç¬¬ä¸€é¡µå­˜å‚¨504ï¼Œç¬¬äºŒé¡µå­˜å‚¨505ï¼Œç¬¬ä¸‰é¡µå­˜å‚¨2ä¸ª

æ‰€ä»¥é€šè¿‡ä¸Šè¿°æµ‹è¯•ï¼Œå¯ä»¥å¾—å‡ºä»¥ä¸‹ç»“è®º:
ç¬¬ä¸€é¡µå¯ä»¥å­˜æ”¾504ä¸ªå¯¹è±¡ï¼Œä¸”åªæœ‰ç¬¬ä¸€é¡µæœ‰å“¨å…µï¼Œå½“ä¸€é¡µå‹æ ˆæ»¡äº†ï¼Œå°±ä¼šå¼€è¾Ÿæ–°çš„ä¸€é¡µ
ç¬¬äºŒé¡µå¼€å§‹ï¼Œæœ€å¤šå¯ä»¥å­˜æ”¾505ä¸ªå¯¹è±¡
ä¸€é¡µçš„å¤§å°ç­‰äº 505 * 8 = 4040
è¿™ä¸ªç»“è®ºåŒæ ·å¯ä»¥é€šè¿‡AutoreleasePoolPageä¸­çš„SIZEæ¥å¾—åˆ°å°è¯ï¼Œä»å…¶å®šä¹‰ä¸­æˆ‘ä»¬å¯ä»¥å¾—å‡ºï¼Œä¸€é¡µçš„å¤§å°æ˜¯4096å­—èŠ‚
è€Œåœ¨å…¶æ„é€ å‡½æ•°ä¸­å¯¹è±¡çš„å‹æ ˆä½ç½®ï¼Œæ˜¯ä»é¦–åœ°å€+56å¼€å§‹çš„ï¼Œæ‰€ä»¥å¯ä»¥ä¸€é¡µä¸­å®é™…å¯ä»¥å­˜å‚¨4096-56 = 4040å­—èŠ‚
è½¬æ¢æˆå¯¹è±¡æ˜¯4040 / 8 = 505ä¸ª,å³ä¸€é¡µæœ€å¤šå¯ä»¥å­˜å‚¨505ä¸ªå¯¹è±¡ï¼Œå…¶ä¸­ç¬¬ä¸€é¡µæœ‰å“¨å…µå¯¹è±¡åªèƒ½å­˜å‚¨504ä¸ª


é¢è¯•é¢˜ï¼šå“¨å…µåœ¨ä¸€ä¸ªè‡ªåŠ¨é‡Šæ”¾æ± æœ‰å‡ ä¸ªï¼Ÿ
åªæœ‰ä¸€ä¸ªå“¨å…µå¯¹è±¡ï¼Œä¸”å“¨å…µåœ¨ç¬¬ä¸€é¡µ
ç¬¬ä¸€é¡µæœ€å¤šå¯ä»¥å­˜504ä¸ªå¯¹è±¡ï¼Œç¬¬äºŒé¡µå¼€å§‹æœ€å¤šå­˜ 505ä¸ª



2ã€å‹æ ˆå¯¹è±¡ autoreleaseFast:
è¿›å…¥autoreleaseFastæºç ï¼Œä¸»è¦æœ‰ä»¥ä¸‹å‡ æ­¥:
    è·å–å½“å‰æ“ä½œé¡µï¼Œå¹¶åˆ¤æ–­é¡µæ˜¯å¦å­˜åœ¨ä»¥åŠæ˜¯å¦æ»¡äº†
    å¦‚æœé¡µå­˜åœ¨ï¼Œä¸”æœªæ»¡ï¼Œåˆ™é€šè¿‡addæ–¹æ³•å‹æ ˆå¯¹è±¡
    å¦‚æœé¡µå­˜åœ¨ï¼Œä¸”æ»¡äº†ï¼Œåˆ™é€šè¿‡autoreleaseFullPageæ–¹æ³•å®‰æ’æ–°çš„é¡µé¢
    å¦‚æœé¡µä¸å­˜åœ¨ï¼Œåˆ™é€šè¿‡autoreleaseNoPageæ–¹æ³•åˆ›å»ºæ–°é¡µ

static inline id *autoreleaseFast(id obj)
{
    //è·å–å½“å‰æ“ä½œé¡µ
    AutoreleasePoolPage *page = hotPage();
    //åˆ¤æ–­é¡µæ˜¯å¦æ»¡äº†
    if (page && !page->full()) {
        //å¦‚æœæœªæ»¡ï¼Œåˆ™å‹æ ˆ
        return page->add(obj);
    } else if (page) {
        //å¦‚æœæ»¡äº†ï¼Œåˆ™å®‰æ’æ–°çš„é¡µé¢
        return autoreleaseFullPage(obj, page);
    } else {
        //é¡µä¸å­˜åœ¨ï¼Œåˆ™æ–°å»ºé¡µ
        return autoreleaseNoPage(obj);
    }
}


autoreleaseFullPage æ–¹æ³•:
è¿™ä¸ªæ–¹æ³•ä¸»è¦æ˜¯ç”¨äºåˆ¤æ–­å½“å‰é¡µæ˜¯å¦å·²ç»å­˜å‚¨æ»¡äº†ï¼Œå¦‚æœå½“å‰é¡µå·²ç»æ»¡äº†ï¼Œé€šè¿‡do-whileå¾ªç¯æŸ¥æ‰¾å­èŠ‚ç‚¹å¯¹åº”çš„é¡µï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆ™æ–°å»ºé¡µï¼Œå¹¶å‹æ ˆå¯¹è±¡

//æ·»åŠ è‡ªåŠ¨é‡Šæ”¾å¯¹è±¡ï¼Œå½“é¡µæ»¡çš„æ—¶å€™è°ƒç”¨è¿™ä¸ªæ–¹æ³•
static __attribute__((noinline))
id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)
{
    // The hot page is full. 
    // Step to the next non-full page, adding a new page if necessary.
    // Then add the object to that page.
    ASSERT(page == hotPage());
    ASSERT(page->full()  ||  DebugPoolAllocation);
    
    //do-whileéå†å¾ªç¯æŸ¥æ‰¾ç•Œé¢æ˜¯å¦æ»¡äº†
    do {
        //å¦‚æœå­é¡µé¢å­˜åœ¨ï¼Œåˆ™å°†é¡µé¢æ›¿æ¢ä¸ºå­é¡µé¢
        if (page->child) page = page->child;
        //å¦‚æœå­é¡µé¢ä¸å­˜åœ¨ï¼Œåˆ™æ–°å»ºé¡µé¢
        else page = new AutoreleasePoolPage(page);
    } while (page->full());

    //è®¾ç½®ä¸ºå½“å‰æ“ä½œé¡µé¢
    setHotPage(page);
    //å¯¹è±¡å‹æ ˆ
    return page->add(obj);
}
ä»AutoreleasePoolPageåˆå§‹åŒ–æ–¹æ³•ä¸­å¯ä»¥çœ‹å‡ºï¼Œä¸»è¦æ˜¯é€šè¿‡æ“ä½œchildå¯¹è±¡ï¼Œå°†å½“å‰é¡µçš„childæŒ‡å‘æ–°å»ºé¡µé¢ï¼Œç”±æ­¤å¯ä»¥å¾—å‡ºé¡µæ˜¯é€šè¿‡åŒå‘é“¾è¡¨è¿æ¥


add æ–¹æ³•:
è¿™ä¸ªæ–¹æ³•ä¸»è¦æ˜¯æ·»åŠ é‡Šæ”¾å¯¹è±¡ï¼Œå…¶åº•å±‚æ˜¯å®ç°æ˜¯é€šè¿‡nextæŒ‡é’ˆå­˜å‚¨é‡Šæ”¾å¯¹è±¡ï¼Œå¹¶å°†nextæŒ‡é’ˆé€’å¢ï¼Œè¡¨ç¤ºä¸‹ä¸€ä¸ªé‡Šæ”¾å¯¹è±¡å­˜å‚¨çš„ä½ç½®ã€‚
ä»è¿™é‡Œå¯ä»¥çœ‹å‡ºé¡µæ˜¯é€šè¿‡æ ˆç»“æ„å­˜å‚¨



3ã€autorelease åº•å±‚åˆ†æ:
ä»¬é€šè¿‡autoreleaseæ–¹æ³•ï¼Œåœ¨MRCæ¨¡å¼ä¸‹ï¼Œå°†å¯¹è±¡å‹æ ˆåˆ°è‡ªåŠ¨é‡Šæ”¾æ± ï¼Œä¸‹é¢æ¥åˆ†æå…¶åº•å±‚å®ç°

æŸ¥çœ‹autoreleaseæ–¹æ³•æºç :
å¦‚æœä¸æ˜¯å¯¹è±¡ æˆ–è€… æ˜¯å°å¯¹è±¡ï¼Œåˆ™ç›´æ¥è¿”å›
å¦‚æœæ˜¯å¯¹è±¡ï¼Œåˆ™è°ƒç”¨å¯¹è±¡çš„autoreleaseè¿›è¡Œé‡Šæ”¾
__attribute__((aligned(16), flatten, noinline))
id
objc_autorelease(id obj)
{
    //å¦‚æœä¸æ˜¯å¯¹è±¡ï¼Œåˆ™ç›´æ¥è¿”å›
    if (!obj) return obj;
    //å¦‚æœæ˜¯å°å¯¹è±¡ï¼Œä¹Ÿç›´æ¥è¿”å›
    if (obj->isTaggedPointer()) return obj;
    return obj->autorelease();
}


è¿›å…¥å¯¹è±¡çš„autoreleaseå®ç°
ğŸ‘‡
inline id 
objc_object::autorelease()
{
    ASSERT(!isTaggedPointer());
    //åˆ¤æ–­æ˜¯å¦æ˜¯è‡ªå®šä¹‰ç±»
    if (fastpath(!ISA()->hasCustomRR())) {
        return rootAutorelease();
    }

    return ((id(*)(objc_object *, SEL))objc_msgSend)(this, @selector(autorelease));
}
ğŸ‘‡
inline id 
objc_object::rootAutorelease()
{
    //å¦‚æœæ˜¯å°å¯¹è±¡ï¼Œç›´æ¥è¿”å›
    if (isTaggedPointer()) return (id)this;
    if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this;

    return rootAutorelease2();
}
ğŸ‘‡
__attribute__((noinline,used))
id 
objc_object::rootAutorelease2()
{
    ASSERT(!isTaggedPointer());
    return AutoreleasePoolPage::autorelease((id)this);
}
ğŸ‘‡
static inline id autorelease(id obj)
{
    ASSERT(obj);
    ASSERT(!obj->isTaggedPointer());
    //autoreleaseFast å‹æ ˆæ“ä½œ
    id *dest __unused = autoreleaseFast(obj);
    ASSERT(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);
    return obj;
}
æ— è®ºæ˜¯å‹æ ˆå“¨å…µå¯¹è±¡ï¼Œè¿˜æ˜¯æ™®é€šå¯¹è±¡ï¼Œéƒ½ä¼šæ¥åˆ°autoreleaseFastæ–¹æ³•ï¼Œåªæ˜¯åŒºåˆ«æ ‡è¯†ä¸åŒè€Œä»¥


objc_autoreleasePoolPop æºç åˆ†æ:
åœ¨objc_autoreleasePoolPopæ–¹æ³•ä¸­æœ‰ä¸ªå‚æ•°ï¼Œåœ¨clangåˆ†ææ—¶ï¼Œå‘ç°ä¼ å…¥çš„å‚æ•°æ˜¯pushå‹æ ˆåè¿”å›çš„å“¨å…µå¯¹è±¡ï¼Œå³ctxtï¼Œå…¶ç›®çš„æ˜¯é¿å…å‡ºæ ˆæ··ä¹±ï¼Œé˜²æ­¢å°†åˆ«çš„å¯¹è±¡å‡ºæ ˆ

è¿›å…¥popæºç å®ç°ï¼Œä¸»è¦ç”±ä»¥ä¸‹å‡ æ­¥:
ç©ºé¡µé¢çš„å¤„ç†ï¼Œå¹¶æ ¹æ®tokenè·å–page
å®¹é”™å¤„ç†
é€šè¿‡popPageå‡ºæ ˆé¡µ

//å‡ºæ ˆ
static inline void
pop(void *token)
{
    AutoreleasePoolPage *page;
    id *stop;
   //åˆ¤æ–­å¯¹è±¡æ˜¯å¦æ˜¯ç©ºå ä½ç¬¦
    if (token == (void*)EMPTY_POOL_PLACEHOLDER) {
        //å¦‚æœå½“æ˜¯ç©ºå ä½ç¬¦
        // Popping the top-level placeholder pool.
        //è·å–å½“å‰é¡µ
        page = hotPage();
        if (!page) {
            // Pool was never used. Clear the placeholder.
            //å¦‚æœå½“å‰é¡µä¸å­˜åœ¨ï¼Œåˆ™æ¸…é™¤ç©ºå ä½ç¬¦
            return setHotPage(nil);
        }
        // Pool was used. Pop its contents normally.
        // Pool pages remain allocated for re-use as usual.
        //å¦‚æœå½“å‰é¡µå­˜åœ¨ï¼Œåˆ™å°†å½“å‰é¡µè®¾ç½®ä¸ºcoldPage,tokenè®¾ç½®ä¸ºcoldPageçš„å¼€å§‹ä½ç½®
        page = coldPage();
        token = page->begin();
    } else {
        //è·å–tokenæ‰€åœ¨çš„é¡µ
        page = pageForPointer(token);
    }
    
    stop = (id *)token;
    //åˆ¤æ–­æœ€åä¸€ä¸ªä½ç½®ï¼Œæ˜¯å¦æ˜¯å“¨å…µ
    if (*stop != POOL_BOUNDARY) {
        //æœ€åä¸€ä¸ªä½ç½®ä¸æ˜¯å“¨å…µï¼Œå³æœ€åä¸€ä¸ªä½ç½®æ˜¯ä¸€ä¸ªå¯¹è±¡
        if (stop == page->begin()  &&  !page->parent) {
            //å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªä½ç½®ï¼Œä¸”æ²¡æœ‰çˆ¶èŠ‚ç‚¹ï¼Œä»€ä¹ˆä¹Ÿä¸åš
            // Start of coldest page may correctly not be POOL_BOUNDARY:
            // 1. top-level pool is popped, leaving the cold page in place
            // 2. an object is autoreleased with no pool
        } else {
            //å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªä½ç½®ï¼Œä¸”æœ‰çˆ¶èŠ‚ç‚¹ï¼Œåˆ™å‡ºç°äº†æ··ä¹±
            // Error. For bincompat purposes this is not 
            // fatal in executables built with old SDKs.
            return badPop(token);
        }
    }

    if (slowpath(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) {
        return popPageDebug(token, page, stop);
    }
    //å‡ºæ ˆé¡µ
    return popPage<false>(token, page, stop);
}

è¿›å…¥popPageæºç ï¼Œå…¶ä¸­ä¼ å…¥çš„allowDebugä¸ºfalseï¼Œåˆ™é€šè¿‡releaseUntilå‡ºæ ˆå½“å‰é¡µstopä½ç½®ä¹‹å‰çš„æ‰€æœ‰å¯¹è±¡ï¼Œå³å‘æ ˆä¸­çš„å¯¹è±¡å‘é€releaseæ¶ˆæ¯ï¼Œç›´åˆ°é‡åˆ°ä¼ å…¥çš„å“¨å…µå¯¹è±¡

//å‡ºæ ˆé¡µé¢
template<bool allowDebug>
    static void
    popPage(void *token, AutoreleasePoolPage *page, id *stop)
{
    if (allowDebug && PrintPoolHiwat) printHiwat();
    //å‡ºæ ˆå½“å‰æ“ä½œé¡µé¢å¯¹è±¡
    page->releaseUntil(stop);

    // memory: delete empty children åˆ é™¤ç©ºå­é¡¹
    if (allowDebug && DebugPoolAllocation  &&  page->empty()) {
        // special case: delete everything during page-per-pool debugging
        //è°ƒè¯•æœŸé—´åˆ é™¤æ¯ä¸ªç‰¹æ®Šæƒ…å†µä¸‹çš„æ‰€æœ‰æ± 
        //è·å–å½“å‰é¡µé¢çš„çˆ¶èŠ‚ç‚¹
        AutoreleasePoolPage *parent = page->parent;
        //å°†å½“å‰é¡µé¢æ€æ‰
        page->kill();
        //è®¾ç½®æ“ä½œé¡µé¢ä¸ºçˆ¶èŠ‚ç‚¹é¡µé¢
        setHotPage(parent);
    }
    else if (allowDebug && DebugMissingPools  &&  page->empty()  &&  !page->parent) {
        // special case: delete everything for pop(top)
        // when debugging missing autorelease pools
        //ç‰¹æ®Šæƒ…å†µï¼šè°ƒè¯•ä¸¢å¤±çš„è‡ªåŠ¨é‡Šæ”¾æ± æ—¶åˆ é™¤popï¼ˆtopï¼‰çš„æ‰€æœ‰å†…å®¹
        page->kill();
        setHotPage(nil);
    }
    else if (page->child) {
        // hysteresis: keep one empty child if page is more than half full å¦‚æœé¡µé¢å·²æ»¡ä¸€åŠä»¥ä¸Šï¼Œåˆ™ä¿ç•™ä¸€ä¸ªç©ºå­çº§
        if (page->lessThanHalfFull()) {
            page->child->kill();
        }
        else if (page->child->child) {
            page->child->child->kill();
        }
    }
}

è¿›å…¥releaseUntilå®ç°ï¼Œä¸»è¦æ˜¯é€šè¿‡å¾ªç¯éå†ï¼Œåˆ¤æ–­å¯¹è±¡æ˜¯å¦ç­‰äºstopï¼Œå…¶ç›®çš„æ˜¯é‡Šæ”¾stopä¹‹å‰çš„æ‰€æœ‰çš„å¯¹è±¡ï¼Œ
é¦–å…ˆé€šè¿‡è·å–pageçš„nexté‡Šæ”¾å¯¹è±¡ï¼ˆå³pageçš„æœ€åä¸€ä¸ªå¯¹è±¡ï¼‰ï¼Œå¹¶å¯¹nextè¿›è¡Œé€’å‡ï¼Œè·å–ä¸Šä¸€ä¸ªå¯¹è±¡
åˆ¤æ–­æ˜¯å¦æ˜¯å“¨å…µå¯¹è±¡ï¼Œå¦‚æœä¸æ˜¯åˆ™è‡ªåŠ¨è°ƒç”¨objc_releaseé‡Šæ”¾
//é‡Šæ”¾åˆ°stopä½ç½®ä¹‹å‰çš„æ‰€æœ‰å¯¹è±¡
void releaseUntil(id *stop) 
{
    // Not recursive: we don't want to blow out the stack  ä¸æ˜¯é€’å½’çš„ï¼šæˆ‘ä»¬ä¸æƒ³ç ´åå †æ ˆ
    // if a thread accumulates a stupendous amount of garbage
    //åˆ¤æ–­ä¸‹ä¸€ä¸ªå¯¹è±¡æ˜¯å¦ç­‰äºstopï¼Œå¦‚æœä¸ç­‰äºï¼Œåˆ™è¿›å…¥whileå¾ªç¯
    while (this->next != stop) {
        // Restart from hotPage() every time, in case -release 
        // autoreleased more objects æ¯æ¬¡ä»hotPageï¼ˆï¼‰é‡æ–°å¯åŠ¨ï¼Œä»¥é˜²-releaseè‡ªåŠ¨é‡Šæ”¾æ›´å¤šå¯¹è±¡
        //è·å–å½“å‰æ“ä½œé¡µé¢ï¼Œå³hoté¡µé¢
        AutoreleasePoolPage *page = hotPage();

        // fixme I think this `while` can be `if`, but I can't prove it
        //å¦‚æœå½“å‰é¡µæ˜¯ç©ºçš„
        while (page->empty()) {
            //å°†pageèµ‹å€¼ä¸ºçˆ¶èŠ‚ç‚¹é¡µ
            page = page->parent;
            //å¹¶è®¾ç½®å½“å‰é¡µä¸ºçˆ¶èŠ‚ç‚¹é¡µ
            setHotPage(page);
        }

        page->unprotect();
        //nextè¿›è¡Œ--æ“ä½œï¼Œå³å‡ºæ ˆ
        id obj = *--page->next;
        //å°†é¡µç´¢å¼•ä½ç½®ç½®ä¸ºSCRIBBLEï¼Œè¡¨ç¤ºå·²ç»è¢«é‡Šæ”¾
        memset((void*)page->next, SCRIBBLE, sizeof(*page->next));
        page->protect();

        if (obj != POOL_BOUNDARY) {
            //é‡Šæ”¾
            objc_release(obj);
        }
    }
    //è®¾ç½®å½“å‰é¡µ
    setHotPage(this);

#if DEBUG
    // we expect any children to be completely empty
    for (AutoreleasePoolPage *page = child; page; page = page->child) {
        ASSERT(page->empty());
    }
#endif
}

è¿›å…¥killå®ç°ï¼Œä¸»è¦æ˜¯é”€æ¯å½“å‰é¡µï¼Œå°†å½“å‰é¡µèµ‹å€¼ä¸ºçˆ¶èŠ‚ç‚¹é¡µï¼Œå¹¶å°†çˆ¶èŠ‚ç‚¹é¡µçš„childå¯¹è±¡æŒ‡é’ˆç½®ä¸ºnil
//é”€æ¯
void kill() 
{
    // Not recursive: we don't want to blow out the stack 
    // if a thread accumulates a stupendous amount of garbage
    AutoreleasePoolPage *page = this;
    //è·å–æœ€åä¸€ä¸ªé¡µ
    while (page->child) page = page->child;

    AutoreleasePoolPage *deathptr;
    do {
        deathptr = page;
        //å­èŠ‚ç‚¹ å˜æˆ çˆ¶èŠ‚ç‚¹
        page = page->parent;
        if (page) {
            page->unprotect();
            //å­èŠ‚ç‚¹ä¸ºnil
            page->child = nil;
            page->protect();
        }
        delete deathptr;
    } while (deathptr != this);
}


é’ˆå¯¹è‡ªåŠ¨é‡Šæ”¾æ± çš„pushå’Œpopï¼Œæ€»ç»“å¦‚ä¸‹:
åœ¨è‡ªåŠ¨é‡Šæ”¾æ± çš„å‹æ ˆï¼ˆå³pushï¼‰æ“ä½œä¸­
    å½“æ²¡æœ‰poolï¼Œå³åªæœ‰ç©ºå ä½ç¬¦ï¼ˆå­˜å‚¨åœ¨tlsä¸­ï¼‰æ—¶ï¼Œåˆ™åˆ›å»ºé¡µï¼Œå‹æ ˆå“¨å…µå¯¹è±¡
    åœ¨é¡µä¸­å‹æ ˆæ™®é€šå¯¹è±¡ä¸»è¦æ˜¯é€šè¿‡nextæŒ‡é’ˆé€’å¢è¿›è¡Œçš„ï¼Œ
    å½“é¡µæ»¡äº†æ—¶ï¼Œéœ€è¦è®¾ç½®é¡µçš„childå¯¹è±¡ä¸ºæ–°å»ºé¡µ
åœ¨è‡ªåŠ¨é‡Šæ”¾æ± çš„å‡ºæ ˆï¼ˆå³popï¼‰æ“ä½œä¸­
    åœ¨é¡µä¸­å‡ºæ ˆæ™®é€šå¯¹è±¡ä¸»è¦æ˜¯é€šè¿‡nextæŒ‡é’ˆé€’å‡è¿›è¡Œçš„ï¼Œ
    å½“é¡µç©ºäº†æ—¶ï¼Œéœ€è¦èµ‹å€¼é¡µçš„parentå¯¹è±¡ä¸ºå½“å‰é¡µ





==================================================RunLoop
RunLoopæ˜¯äº‹ä»¶æ¥æ”¶å’Œåˆ†å‘æœºåˆ¶çš„ä¸€ä¸ªå®ç°ï¼Œæ˜¯çº¿ç¨‹ç›¸å…³çš„åŸºç¡€æ¡†æ¶çš„ä¸€éƒ¨åˆ†ï¼Œä¸€ä¸ªRunLoopå°±æ˜¯ä¸€ä¸ªäº‹ä»¶å¤„ç†çš„å¾ªç¯ï¼Œç”¨æ¥ä¸åœçš„è°ƒåº¦å·¥ä½œä»¥åŠå¤„ç†è¾“å…¥äº‹ä»¶ã€‚

RunLoopæœ¬è´¨æ˜¯ä¸€ä¸ª do-whileå¾ªç¯ï¼Œæ²¡äº‹åšå°±ä¼‘æ¯ï¼Œæ¥æ´»äº†å°±å¹²æ´»ã€‚ä¸æ™®é€šçš„whileå¾ªç¯æ˜¯æœ‰åŒºåˆ«çš„ï¼Œ
æ™®é€šçš„whileå¾ªç¯ä¼šå¯¼è‡´CPUè¿›å…¥å¿™ç­‰å¾…çŠ¶æ€ï¼Œå³ä¸€ç›´æ¶ˆè€—cpuï¼Œè€ŒRunLoopåˆ™ä¸ä¼šï¼Œ
RunLoopæ˜¯ä¸€ç§é—²ç­‰å¾…ï¼Œå³RunLoopå…·å¤‡ä¼‘çœ åŠŸèƒ½ã€‚

RunLoopçš„ä½œç”¨:
ä¿æŒç¨‹åºçš„æŒç»­è¿è¡Œ
å¤„ç†Appä¸­çš„å„ç§äº‹ä»¶ï¼ˆè§¦æ‘¸ã€å®šæ—¶å™¨ã€performSelectorï¼‰
èŠ‚çœcpuèµ„æºï¼Œæä¾›ç¨‹åºçš„æ€§èƒ½ï¼Œè¯¥åšäº‹å°±åšäº‹ï¼Œè¯¥ä¼‘æ¯å°±ä¼‘æ¯

RunLoopçš„è·å–ä¸»è¦æœ‰ä»¥ä¸‹ä¸¤ç§æ–¹å¼:
// ä¸»è¿è¡Œå¾ªç¯
CFRunLoopRef mainRunloop = CFRunLoopGetMain();
// å½“å‰è¿è¡Œå¾ªç¯
CFRunLoopRef currentRunloop = CFRunLoopGetCurrent();

CFRunLoopRef CFRunLoopGetMain(void) {
    CHECK_FOR_FORK();
    static CFRunLoopRef __main = NULL; // no retain needed
    //pthread_main_thread_np ä¸»çº¿ç¨‹
    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed
    return __main;
}

// should only be called by Foundation
// t==0 is a synonym for "main thread" that always works
CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) {
    //å¦‚æœtä¸å­˜åœ¨ï¼Œåˆ™æ ‡è®°ä¸ºä¸»çº¿ç¨‹ï¼ˆå³é»˜è®¤æƒ…å†µï¼Œé»˜è®¤æ˜¯ä¸»çº¿ç¨‹ï¼‰
    if (pthread_equal(t, kNilPthreadT)) {
        t = pthread_main_thread_np();
    }
    __CFSpinLock(&loopsLock);
    if (!__CFRunLoops) {
        __CFSpinUnlock(&loopsLock);
        
        //åˆ›å»ºå…¨å±€å­—å…¸ï¼Œæ ‡è®°ä¸ºkCFAllocatorSystemDefault
        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &kCFTypeDictionaryValueCallBacks);
        //é€šè¿‡ä¸»çº¿ç¨‹ åˆ›å»ºä¸»è¿è¡Œå¾ªç¯
        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());
        //åˆ©ç”¨dictï¼Œè¿›è¡Œkey-valueç»‘å®šæ“ä½œï¼Œå³å¯ä»¥è¯´æ˜ï¼Œçº¿ç¨‹å’Œrunloopæ˜¯ä¸€ä¸€å¯¹åº”çš„
        // dict : key value
        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);
        
        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&__CFRunLoops)) {
            CFRelease(dict);
        }
        
        CFRelease(mainLoop);
        __CFSpinLock(&loopsLock);
    }
    //é€šè¿‡å…¶ä»–çº¿ç¨‹è·å–runloop
    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));
    __CFSpinUnlock(&loopsLock);
    if (!loop) {
        //å¦‚æœæ²¡æœ‰è·å–åˆ°ï¼Œåˆ™æ–°å»ºä¸€ä¸ªè¿è¡Œå¾ªç¯
        CFRunLoopRef newLoop = __CFRunLoopCreate(t);
        __CFSpinLock(&loopsLock);
        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));
        if (!loop) {
            //å°†æ–°å»ºçš„runloop ä¸ çº¿ç¨‹è¿›è¡Œkey-valueç»‘å®š
            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);
            loop = newLoop;
        }
        // don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it
        __CFSpinUnlock(&loopsLock);
        CFRelease(newLoop);
    }
    if (pthread_equal(t, pthread_self())) {
        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);
        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) {
            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);
        }
    }
    return loop;
}

Runloopåªæœ‰ä¸¤ç§ï¼Œä¸€ç§æ˜¯ä¸»çº¿ç¨‹çš„ï¼Œ ä¸€ä¸ªæ˜¯å…¶ä»–çº¿ç¨‹çš„ã€‚å³runloopå’Œçº¿ç¨‹æ˜¯ä¸€ä¸€å¯¹åº”çš„

RunLoopçš„åˆ›å»º:
static CFRunLoopRef __CFRunLoopCreate(pthread_t t) {
    CFRunLoopRef loop = NULL;
    CFRunLoopModeRef rlm;
    uint32_t size = sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase);
    loop = (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopTypeID, size, NULL);
    //å¦‚æœloopä¸ºç©ºï¼Œåˆ™ç›´æ¥è¿”å›NULL
    if (NULL == loop) {
        return NULL;
    }
    //runloopå±æ€§é…ç½®
    (void)__CFRunLoopPushPerRunData(loop);
    __CFRunLoopLockInit(&loop->_lock);
    loop->_wakeUpPort = __CFPortAllocate();
    if (CFPORT_NULL == loop->_wakeUpPort) HALT;
    __CFRunLoopSetIgnoreWakeUps(loop);
    loop->_commonModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
    CFSetAddValue(loop->_commonModes, kCFRunLoopDefaultMode);
    loop->_commonModeItems = NULL;
    loop->_currentMode = NULL;
    loop->_modes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
    loop->_blocks_head = NULL;
    loop->_blocks_tail = NULL;
    loop->_counterpart = NULL;
    loop->_pthread = t;
#if DEPLOYMENT_TARGET_WINDOWS
    loop->_winthread = GetCurrentThreadId();
#else
    loop->_winthread = 0;
#endif
    rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);
    if (NULL != rlm) __CFRunLoopModeUnlock(rlm);
    return loop;
}

å…¶å®RunLoopä¹Ÿæ˜¯ä¸€ä¸ªå¯¹è±¡ã€‚æ˜¯__CFRunLoopç»“æ„ä½“çš„æŒ‡é’ˆç±»å‹

typedef struct __CFRunLoop * CFRunLoopRef;
ğŸ‘‡
struct __CFRunLoop {
    CFRuntimeBase _base;
    pthread_mutex_t _lock;            /* locked for accessing mode list */
    __CFPort _wakeUpPort;            // used for CFRunLoopWakeUp
    Boolean _unused;
    volatile _per_run_data *_perRunData;              // reset for runs of the run loop
    pthread_t _pthread;
    uint32_t _winthread;
    CFMutableSetRef _commonModes;
    CFMutableSetRef _commonModeItems;
    CFRunLoopModeRef _currentMode;
    CFMutableSetRef _modes;
    struct _block_item *_blocks_head;
    struct _block_item *_blocks_tail;
    CFTypeRef _counterpart;
};
ä¸€ä¸ªRunLoopä¾èµ–äºå¤šä¸ªModeï¼Œæ„å‘³ç€ä¸€ä¸ªRunLoopéœ€è¦å¤„ç†å¤šä¸ªäº‹åŠ¡ï¼Œå³ä¸€ä¸ªModeå¯¹åº”å¤šä¸ªItemï¼Œè€Œä¸€ä¸ªitemä¸­ï¼ŒåŒ…å«äº†timerã€sourceã€observer

Modeç±»å‹:
å…¶ä¸­modeåœ¨è‹¹æœæ–‡æ¡£ä¸­æåŠçš„æœ‰äº”ä¸ªï¼Œè€Œåœ¨iOSä¸­å…¬å¼€æš´éœ²å‡ºæ¥çš„åªæœ‰ NSDefaultRunLoopMode å’Œ NSRunLoopCommonModesã€‚
NSRunLoopCommonModes å®é™…ä¸Šæ˜¯ä¸€ä¸ª Mode çš„é›†åˆï¼Œé»˜è®¤åŒ…æ‹¬ NSDefaultRunLoopMode å’Œ NSEventTrackingRunLoopModeã€‚
NSDefaultRunLoopModeï¼šé»˜è®¤çš„modeï¼Œæ­£å¸¸æƒ…å†µä¸‹éƒ½æ˜¯åœ¨è¿™ä¸ªmode
NSConnectionReplyMode
NSModalPanelRunLoopMode
NSEventTrackingRunLoopModeï¼šä½¿ç”¨è¿™ä¸ªModeå»è·Ÿè¸ªæ¥è‡ªç”¨æˆ·äº¤äº’çš„äº‹ä»¶ï¼ˆæ¯”å¦‚UITableViewä¸Šä¸‹æ»‘åŠ¨ï¼‰
NSRunLoopCommonModesï¼šä¼ªæ¨¡å¼ï¼Œçµæ´»æ€§æ›´å¥½

Source & Timer & Observer:
Sourceè¡¨ç¤ºå¯ä»¥å”¤é†’RunLoopçš„ä¸€äº›äº‹ä»¶ï¼Œä¾‹å¦‚ç”¨æˆ·ç‚¹å‡»äº†å±å¹•ï¼Œä¸»è¦åˆ†ä¸ºSource0å’ŒSource1
Source0 è¡¨ç¤º éç³»ç»Ÿäº‹ä»¶ï¼Œå³ç”¨æˆ·è‡ªå®šä¹‰çš„äº‹ä»¶
Source1 è¡¨ç¤ºç³»ç»Ÿäº‹ä»¶ï¼Œä¸»è¦è´Ÿè´£åº•å±‚çš„é€šè®¯ï¼Œå…·å¤‡å”¤é†’èƒ½åŠ›
Timer å°±æ˜¯å¸¸ç”¨NSTimerå®šæ—¶å™¨è¿™ä¸€ç±»
Observer ä¸»è¦ç”¨äºç›‘å¬RunLoopçš„çŠ¶æ€å˜åŒ–ï¼Œå¹¶ä½œå‡ºä¸€å®šå“åº”ï¼Œä¸»è¦æœ‰ä»¥ä¸‹ä¸€äº›çŠ¶æ€
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    //è¿›å…¥RunLoop
    kCFRunLoopEntry = (1UL << 0),
    //å³å°†å¤„ç†Timers
    kCFRunLoopBeforeTimers = (1UL << 1),
    //å³å°†å¤„ç†Source
    kCFRunLoopBeforeSources = (1UL << 2),
    //å³å°†è¿›å…¥ä¼‘çœ 
    kCFRunLoopBeforeWaiting = (1UL << 5),
    //è¢«å”¤é†’
    kCFRunLoopAfterWaiting = (1UL << 6),
    //é€€å‡ºRunLoop
    kCFRunLoopExit = (1UL << 7),
    kCFRunLoopAllActivities = 0x0FFFFFFFU
};


RunLoopå’Œmodeæ˜¯ä¸€å¯¹å¤š
runloopåœ¨è¿è¡Œæ—¶çš„modeåªæœ‰ä¸€ä¸ª

modeå’ŒItemä¹Ÿæ˜¯ä¸€å¯¹å¤š

åœ¨RunLoopæºç ä¸­æŸ¥çœ‹Itemç±»å‹ï¼Œæœ‰ä»¥ä¸‹å‡ ç§:
blockåº”ç”¨:__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__
è°ƒç”¨timer:__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__
å“åº”source0: __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__
å“åº”source1: __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__
GCDä¸»é˜Ÿåˆ—:__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__
observeræº: __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__


åœ¨è¿™é‡Œä»¥Timerä¸ºä¾‹ï¼Œä¸€èˆ¬åˆå§‹åŒ–timeræ—¶ï¼Œéƒ½ä¼šå°†timeré€šè¿‡addTimer:forMode:æ–¹æ³•æ·»åŠ åˆ°Runloopä¸­ï¼Œ
äºæ˜¯åœ¨æºç ä¸­æŸ¥æ‰¾addTimerçš„ç›¸å…³æ–¹æ³•ï¼Œå³CFRunLoopAddTimeræ–¹æ³•ï¼Œ
å…¶æºç å®ç°å¦‚ä¸‹ï¼Œå…¶å®ç°ä¸»è¦åˆ¤æ–­æ˜¯å¦æ˜¯kCFRunLoopCommonModesï¼Œç„¶åæŸ¥æ‰¾runloopçš„modeè¿›è¡ŒåŒ¹é…å¤„ç†

å…¶ä¸­kCFRunLoopCommonModes ä¸æ˜¯ä¸€ç§æ¨¡å¼ï¼Œæ˜¯ä¸€ç§æŠ½è±¡çš„ä¼ªæ¨¡å¼ï¼Œæ¯”defaultModeæ›´åŠ çµæ´»
é€šè¿‡CFSetAddValue(rl->_commonModeItems, rlt);å¯ä»¥å¾—çŸ¥ï¼Œrunloopä¸mode æ˜¯ä¸€å¯¹å¤šçš„ï¼ŒåŒæ—¶å¯ä»¥å¾—å‡ºmode ä¸ item ä¹Ÿæ˜¯ä¸€å¯¹å¤šçš„
void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) {
    CHECK_FOR_FORK();
    if (__CFRunLoopIsDeallocating(rl)) return;
    if (!__CFIsValid(rlt) || (NULL != rlt->_runLoop && rlt->_runLoop != rl)) return;
    __CFRunLoopLock(rl);
    
    // é‡ç‚¹ : kCFRunLoopCommonModes
    if (modeName == kCFRunLoopCommonModes) {
        //å¦‚æœæ˜¯kCFRunLoopCommonModes ç±»å‹
       
        CFSetRef set = rl->_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl->_commonModes) : NULL;
        
        if (NULL == rl->_commonModeItems) {
            rl->_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
        }
        //runloopä¸mode æ˜¯ä¸€å¯¹å¤šçš„ï¼Œ modeä¸itemä¹Ÿæ˜¯ä¸€å¯¹å¤šçš„
        CFSetAddValue(rl->_commonModeItems, rlt);
        if (NULL != set) {
            CFTypeRef context[2] = {rl, rlt};
            /* add new item to all common-modes */
            //æ‰§è¡Œ
            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);
            CFRelease(set);
        }
    } else {
        //å¦‚æœæ˜¯écommonModeç±»å‹
        //æŸ¥æ‰¾runloopçš„æ¨¡å‹
        CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);
        if (NULL != rlm) {
            if (NULL == rlm->_timers) {
                CFArrayCallBacks cb = kCFTypeArrayCallBacks;
                cb.equal = NULL;
                rlm->_timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &cb);
            }
        }
        //åˆ¤æ–­modeæ˜¯å¦åŒ¹é…
        if (NULL != rlm && !CFSetContainsValue(rlt->_rlModes, rlm->_name)) {
            __CFRunLoopTimerLock(rlt);
            if (NULL == rlt->_runLoop) {
                rlt->_runLoop = rl;
            } else if (rl != rlt->_runLoop) {
                __CFRunLoopTimerUnlock(rlt);
                __CFRunLoopModeUnlock(rlm);
                __CFRunLoopUnlock(rl);
                return;
            }
            // å¦‚æœåŒ¹é…ï¼Œåˆ™å°†runloopåŠ è¿›å»ï¼Œè€Œrunloopçš„æ‰§è¡Œä¾èµ–äº  [runloop run]
            CFSetAddValue(rlt->_rlModes, rlm->_name);
            __CFRunLoopTimerUnlock(rlt);
            __CFRunLoopTimerFireTSRLock();
            __CFRepositionTimerInMode(rlm, rlt, false);
            __CFRunLoopTimerFireTSRUnlock();
            if (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) {
                // Normally we don't do this on behalf of clients, but for
                // backwards compatibility due to the change in timer handling...
                if (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);
            }
        }
        if (NULL != rlm) {
            __CFRunLoopModeUnlock(rlm);
        }
    }
   
    __CFRunLoopUnlock(rl);
}


RunLoopæ‰§è¡Œ:
RunLoopçš„æ‰§è¡Œä¾èµ–äºrunæ–¹æ³•ï¼Œå…¶åº•å±‚æ‰§è¡Œçš„æ˜¯__CFRunLoopRunæ–¹æ³•
è¿›å…¥__CFRunLoopRunæºç ï¼Œé’ˆå¯¹ä¸åŒçš„å¯¹è±¡ï¼Œæœ‰ä¸åŒçš„å¤„ç†
å¦‚æœæœ‰observerï¼Œåˆ™è°ƒç”¨ __CFRunLoopDoObservers
å¦‚æœæœ‰blockï¼Œåˆ™è°ƒç”¨__CFRunLoopDoBlocks
å¦‚æœæœ‰timerï¼Œåˆ™è°ƒç”¨ __CFRunLoopDoTimers
å¦‚æœæ˜¯source0ï¼Œåˆ™è°ƒç”¨__CFRunLoopDoSources0
å¦‚æœæ˜¯source1ï¼Œåˆ™è°ƒç”¨__CFRunLoopDoSource1


/* rl, rlm are locked on entrance and exit */
static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {
    ...
    
    do{
        ...
         //é€šçŸ¥ Observers: å³å°†å¤„ç†timeräº‹ä»¶
        if (rlm->_observerMask & kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);
        //é€šçŸ¥ Observers: å³å°†å¤„ç†Sourceäº‹ä»¶
        if (rlm->_observerMask & kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);
        //å¤„ç†Blocks
        __CFRunLoopDoBlocks(rl, rlm);
        //å¤„ç†sources0
        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);
        //å¤„ç†sources0è¿”å›ä¸ºYES
        if (sourceHandledThisLoop) {
            // å¤„ç†Blocks
            __CFRunLoopDoBlocks(rl, rlm);
        }
        
        ...
        
        //å¦‚æœæ˜¯timer
        else if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {
            CFRUNLOOP_WAKEUP_FOR_TIMER();
            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {
                // Re-arm the next timer, because we apparently fired early
                __CFArmNextTimerInMode(rlm, rl);
            }
        }
        
        ...
        
        //å¦‚æœæ˜¯source1
        CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);
        if (rls) {
#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
            mach_msg_header_t *reply = NULL;
            sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg->msgh_size, &reply) || sourceHandledThisLoop;
            if (NULL != reply) {
                (void)mach_msg(reply, MACH_SEND_MSG, reply->msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);
                CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);
            }
#elif DEPLOYMENT_TARGET_WINDOWS
            sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;
#endif
        }
        ...
    
    }while (0 == retVal);
    
    ...
}

è¿›å…¥__CFRunLoopDoTimersæºç ï¼Œä¸»è¦æ˜¯é€šè¿‡forå¾ªç¯ï¼Œå¯¹å•ä¸ªtimerè¿›è¡Œå¤„ç†

static Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR) {    /* DOES CALLOUT */
    ...
    //å¾ªç¯éå†ï¼Œåšä¸‹å±‚å•ä¸ªtimerçš„æ‰§è¡Œ
    for (CFIndex idx = 0, cnt = timers ? CFArrayGetCount(timers) : 0; idx < cnt; idx++) {
        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx);
        Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt);
        timerHandled = timerHandled || did;
    }
    ...
}

è¿›å…¥__CFRunLoopDoTimeræºç ï¼Œä¸»è¦é€»è¾‘æ˜¯timeræ‰§è¡Œå®Œæ¯•åï¼Œ
ä¼šä¸»åŠ¨è°ƒç”¨__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__å‡½æ•°ï¼Œæ­£å¥½ä¸timerå †æ ˆè°ƒç”¨ä¸­çš„ä¸€è‡´

timeræ‰§è¡Œæ€»ç»“:
ä¸ºè‡ªå®šä¹‰çš„timerï¼Œè®¾ç½®Modeï¼Œå¹¶å°†å…¶åŠ å…¥RunLoopä¸­
åœ¨RunLoopçš„runæ–¹æ³•æ‰§è¡Œæ—¶ï¼Œä¼šè°ƒç”¨__CFRunLoopDoTimersæ‰§è¡Œæ‰€æœ‰timer
åœ¨__CFRunLoopDoTimersæ–¹æ³•ä¸­ï¼Œä¼šé€šè¿‡forå¾ªç¯æ‰§è¡Œå•ä¸ªtimerçš„æ“ä½œ
åœ¨__CFRunLoopDoTimeræ–¹æ³•ä¸­ï¼Œtimeræ‰§è¡Œå®Œæ¯•åï¼Œä¼šæ‰§è¡Œå¯¹åº”çš„timerå›è°ƒå‡½æ•°
å¯¹äºobserverã€blockã€source0ã€source1ï¼Œå…¶æ‰§è¡ŒåŸç†ä¸timeræ˜¯ç±»ä¼¼çš„


RunLoop åº•å±‚åŸç†:
CFRunLoopRun -> __CFRunLoopRun

void CFRunLoopRun(void) {    /* DOES CALLOUT */
    int32_t result;
    do {
        // å…¶ä¸­ä¼ å…¥çš„å‚æ•°1.0e10ï¼ˆç§‘å­¦è®¡æ•°ï¼‰ ç­‰äº 1* e^10ï¼Œç”¨äºè¡¨ç¤ºè¶…æ—¶æ—¶é—´
        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);
        CHECK_FOR_FORK();
    } while (kCFRunLoopRunStopped != result && kCFRunLoopRunFinished != result);
}

è¿›å…¥CFRunLoopRunSpecificæºç ï¼Œé¦–å…ˆæ ¹æ®modeNameæ‰¾åˆ°å¯¹åº”çš„modeï¼Œç„¶åä¸»è¦åˆ†ä¸ºä¸‰ç§æƒ…å†µï¼š
å¦‚æœæ˜¯entryï¼Œåˆ™é€šçŸ¥observerï¼Œå³å°†è¿›å…¥runloop
å¦‚æœæ˜¯exitï¼Œåˆ™é€šè¿‡observerï¼Œå³å°†é€€å‡ºrunloop
å¦‚æœæ˜¯å…¶ä»–ä¸­é—´çŠ¶æ€ï¼Œä¸»è¦æ˜¯é€šè¿‡runloopå¤„ç†å„ç§æº

SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {     /* DOES CALLOUT */
    CHECK_FOR_FORK();
    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;
    __CFRunLoopLock(rl);
    
    //é¦–å…ˆæ ¹æ®modeNameæ‰¾åˆ°å¯¹åº”mode
    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);
    
    // é€šçŸ¥ Observers: RunLoop å³å°†è¿›å…¥ loopã€‚
    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);
    
    // å†…éƒ¨å‡½æ•°ï¼Œè¿›å…¥loop
    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);
    
    // é€šçŸ¥ Observers: RunLoop å³å°†é€€å‡ºã€‚
    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);
    
    return result;
    
}


å…¥__CFRunLoopRunæºç ,å…¶ä¸»è¦é€»è¾‘æ˜¯æ ¹æ®ä¸åŒçš„äº‹ä»¶æºè¿›è¡Œä¸åŒçš„å¤„ç†ï¼Œå½“RunLoopä¼‘çœ æ—¶ï¼Œå¯ä»¥é€šè¿‡ç›¸åº”çš„äº‹ä»¶å”¤é†’RunLoop
//æ ¸å¿ƒå‡½æ•°
/* rl, rlm are locked on entrance and exit */
static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode){
    
    //é€šè¿‡GCDå¼€å¯ä¸€ä¸ªå®šæ—¶å™¨ï¼Œç„¶åå¼€å§‹è·‘åœˆ
    dispatch_source_t timeout_timer = NULL;
    ...
    dispatch_resume(timeout_timer);
    
    int32_t retVal = 0;
    
    //å¤„ç†äº‹åŠ¡,å³å¤„ç†items
    do {
        
        // é€šçŸ¥ Observers: å³å°†å¤„ç†timeräº‹ä»¶
        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);
        
        // é€šçŸ¥ Observers: å³å°†å¤„ç†Sourceäº‹ä»¶
        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources)
        
        // å¤„ç†Blocks
        __CFRunLoopDoBlocks(rl, rlm);
        
        // å¤„ç†sources0
        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);
        
        // å¤„ç†sources0è¿”å›ä¸ºYES
        if (sourceHandledThisLoop) {
            // å¤„ç†Blocks
            __CFRunLoopDoBlocks(rl, rlm);
        }
        
        // åˆ¤æ–­æœ‰æ— ç«¯å£æ¶ˆæ¯(Source1)
        if (__CFRunLoopWaitForMultipleObjects(NULL, &dispatchPort, 0, 0, &livePort, NULL)) {
            // å¤„ç†æ¶ˆæ¯
            goto handle_msg;
        }
        
        
        // é€šçŸ¥ Observers: å³å°†è¿›å…¥ä¼‘çœ 
        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);
        __CFRunLoopSetSleeping(rl);
        
        // ç­‰å¾…è¢«å”¤é†’
        __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY);
        
        // user callouts now OK again
        __CFRunLoopUnsetSleeping(rl);
        
        // é€šçŸ¥ Observers: è¢«å”¤é†’ï¼Œç»“æŸä¼‘çœ 
        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);
        
        
    handle_msg:
        if (è¢«timerå”¤é†’) {
            // å¤„ç†Timers
            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time())ï¼›
        }else if (è¢«GCDå”¤é†’){
            // å¤„ç†gcd
            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);
        }else if (è¢«source1å”¤é†’){
            // è¢«Source1å”¤é†’ï¼Œå¤„ç†Source1
            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg->msgh_size, &reply)
        }
        
        // å¤„ç†block
        __CFRunLoopDoBlocks(rl, rlm);
        
        if (sourceHandledThisLoop && stopAfterHandle) {
            retVal = kCFRunLoopRunHandledSource;//å¤„ç†æº
        } else if (timeout_context->termTSR < mach_absolute_time()) {
            retVal = kCFRunLoopRunTimedOut;//è¶…æ—¶
        } else if (__CFRunLoopIsStopped(rl)) {
            __CFRunLoopUnsetStopped(rl);
            retVal = kCFRunLoopRunStopped;//åœæ­¢
        } else if (rlm->_stopped) {
            rlm->_stopped = false;
            retVal = kCFRunLoopRunStopped;//åœæ­¢
        } else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {
            retVal = kCFRunLoopRunFinished;//ç»“æŸ
        }
        
        
        
    }while (0 == retVal);
    
    return retVal;
}


==================================================AutoreleasePool ç›¸å…³
ä¸´æ—¶å˜é‡ä»€ä¹ˆæ—¶å€™é‡Šæ”¾ï¼Ÿ
å¦‚æœåœ¨æ­£å¸¸æƒ…å†µä¸‹ï¼Œä¸€èˆ¬æ˜¯è¶…å‡ºå…¶ä½œç”¨åŸŸå°±ä¼šç«‹å³é‡Šæ”¾
å¦‚æœå°†ä¸´æ—¶å˜é‡åŠ å…¥äº†è‡ªåŠ¨é‡Šæ”¾æ± ï¼Œä¼šå»¶è¿Ÿé‡Šæ”¾ï¼Œå³åœ¨runloopä¼‘çœ æˆ–è€…autoreleasepoolä½œç”¨åŸŸä¹‹åé‡Šæ”¾


AutoreleasePoolåŸç†ï¼Ÿ
è‡ªåŠ¨é‡Šæ”¾æ± çš„æœ¬è´¨æ˜¯ä¸€ä¸ªAutoreleasePoolPageç»“æ„ä½“å¯¹è±¡ï¼Œæ˜¯ä¸€ä¸ªæ ˆç»“æ„å­˜å‚¨çš„é¡µï¼Œæ¯ä¸€ä¸ªAutoreleasePoolPageéƒ½æ˜¯ä»¥åŒå‘é“¾è¡¨çš„å½¢å¼è¿æ¥
è‡ªåŠ¨é‡Šæ”¾æ± çš„å‹æ ˆå’Œå‡ºæ ˆä¸»è¦æ˜¯é€šè¿‡ç»“æ„ä½“çš„æ„é€ å‡½æ•°å’Œææ„å‡½æ•°è°ƒç”¨åº•å±‚çš„objc_autoreleasePoolPushå’Œobjc_autoreleasePoolPopï¼Œå®é™…ä¸Šæ˜¯è°ƒç”¨AutoreleasePoolPageçš„pushå’Œpopä¸¤ä¸ªæ–¹æ³•
æ¯æ¬¡è°ƒç”¨pushæ“ä½œå…¶å®å°±æ˜¯åˆ›å»ºä¸€ä¸ªæ–°çš„AutoreleasePoolPageï¼Œè€ŒAutoreleasePoolPageçš„å…·ä½“æ“ä½œå°±æ˜¯æ’å…¥ä¸€ä¸ªPOOL_BOUNDARYï¼Œå¹¶è¿”å›æ’å…¥POOL_BOUNDARYçš„å†…å­˜åœ°å€ã€‚è€Œpushå†…éƒ¨è°ƒç”¨autoreleaseFastæ–¹æ³•å¤„ç†ï¼Œä¸»è¦æœ‰ä»¥ä¸‹ä¸‰ç§æƒ…å†µ
    å½“pageå­˜åœ¨ï¼Œä¸”ä¸æ»¡æ—¶ï¼Œè°ƒç”¨addæ–¹æ³•å°†å¯¹è±¡æ·»åŠ è‡³pageçš„nextæŒ‡é’ˆå¤„ï¼Œå¹¶nexté€’å¢
    å½“pageå­˜åœ¨ï¼Œä¸”å·²æ»¡æ—¶ï¼Œè°ƒç”¨autoreleaseFullPageåˆå§‹åŒ–ä¸€ä¸ªæ–°çš„pageï¼Œç„¶åè°ƒç”¨addæ–¹æ³•å°†å¯¹è±¡æ·»åŠ è‡³pageæ ˆä¸­
    å½“pageä¸å­˜åœ¨æ—¶ï¼Œè°ƒç”¨autoreleaseNoPageåˆ›å»ºä¸€ä¸ªhotPageï¼Œç„¶åè°ƒç”¨addæ–¹æ³•å°†å¯¹è±¡æ·»åŠ è‡³pageæ ˆä¸­
å½“æ‰§è¡Œpopæ“ä½œæ—¶ï¼Œä¼šä¼ å…¥ä¸€ä¸ªå€¼ï¼Œè¿™ä¸ªå€¼å°±æ˜¯pushæ“ä½œçš„è¿”å›å€¼ï¼Œå³POOL_BOUNDARYçš„å†…å­˜åœ°å€tokenã€‚æ‰€ä»¥popå†…éƒ¨çš„å®ç°å°±æ˜¯æ ¹æ®tokenæ‰¾åˆ°å“¨å…µå¯¹è±¡æ‰€å¤„çš„pageä¸­ï¼Œç„¶åä½¿ç”¨ objc_release é‡Šæ”¾ tokenä¹‹å‰çš„å¯¹è±¡ï¼Œå¹¶æŠŠnext æŒ‡é’ˆåˆ°æ­£ç¡®ä½ç½®



==================================================RunLoopç›¸å…³
å½“å‰æœ‰ä¸ªå­çº¿ç¨‹ï¼Œå­çº¿ç¨‹ä¸­æœ‰ä¸ªtimerã€‚timeræ˜¯å¦èƒ½å¤Ÿæ‰§è¡Œ å¹¶è¿›è¡ŒæŒç»­çš„æ‰“å°ï¼Ÿ
CJLThread *thread = [[CJLThread alloc] initWithBlock:^{

// thread.name = nil å› ä¸ºè¿™ä¸ªå˜é‡åªæ˜¯æ•æ‰
// CJLThread *thread = nil
// thread = åˆå§‹åŒ– æ•æ‰ä¸€ä¸ªnilè¿›æ¥
NSLog(@"%@---%@",[NSThread currentThread],[[NSThread currentThread] name]);
[NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {
    NSLog(@"hello word");            // é€€å‡ºçº¿ç¨‹--ç»“æœrunloopä¹Ÿåœæ­¢äº†
    if (self.isStopping) {
        [NSThread exit];
    }
}];
}];

thread.name = @"lgcode.com";
[thread start];

ä¸å¯ä»¥ï¼Œå› ä¸ºå­çº¿ç¨‹çš„runloopé»˜è®¤ä¸å¯åŠ¨ï¼Œ éœ€è¦runloop runå¯åŠ¨ï¼Œéœ€è¦å°†ä¸Šè¿°ä»£ç æ”¹æˆä¸‹é¢è¿™æ ·ï¼š

//æ”¹æˆ
CJLThread *thread = [[CJLThread alloc] initWithBlock:^{

// thread.name = nil å› ä¸ºè¿™ä¸ªå˜é‡åªæ˜¯æ•æ‰
// CJLThread *thread = nil
// thread = åˆå§‹åŒ– æ•æ‰ä¸€ä¸ªnilè¿›æ¥
NSLog(@"%@---%@",[NSThread currentThread],[[NSThread currentThread] name]);
[NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {
    NSLog(@"hello word");            // é€€å‡ºçº¿ç¨‹--ç»“æœrunloopä¹Ÿåœæ­¢äº†
    if (self.isStopping) {
        [NSThread exit];
    }
}];
    [[NSRunLoop currentRunLoop] run];
}];

thread.name = @"lgcode.com";
[thread start];



RunLoopå’Œçº¿ç¨‹çš„å…³ç³»ï¼Ÿ
æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰ä¸€ä¸ªä¸ä¹‹å¯¹åº”çš„RunLoopï¼Œæ‰€ä»¥RunLoopä¸çº¿ç¨‹æ˜¯ä¸€ä¸€å¯¹åº”çš„ï¼Œå…¶ç»‘å®šå…³ç³»é€šè¿‡ä¸€ä¸ªå…¨å±€çš„DIctionaryå­˜å‚¨ï¼Œçº¿ç¨‹ä¸ºkeyï¼Œrunloopä¸ºvalueã€‚
çº¿ç¨‹ä¸­çš„RunLoopä¸»è¦æ˜¯ç”¨æ¥ç®¡ç†çº¿ç¨‹çš„ï¼Œå½“çº¿ç¨‹çš„RunLoopå¼€å¯åï¼Œä¼šåœ¨æ‰§è¡Œå®Œä»»åŠ¡åè¿›è¡Œä¼‘çœ çŠ¶æ€ï¼Œå½“æœ‰äº‹ä»¶è§¦å‘å”¤é†’æ—¶ï¼Œåˆå¼€å§‹å·¥ä½œï¼Œå³æœ‰æ´»æ—¶å¹²æ´»ï¼Œæ²¡æ´»å°±ä¼‘æ¯
ä¸»çº¿ç¨‹çš„RunLoopæ˜¯é»˜è®¤å¼€å¯çš„ï¼Œåœ¨ç¨‹åºå¯åŠ¨ä¹‹åï¼Œä¼šä¸€ç›´è¿è¡Œï¼Œä¸ä¼šé€€å‡º
å…¶ä»–çº¿ç¨‹çš„RunLoopé»˜è®¤æ˜¯ä¸å¼€å¯çš„ï¼Œå¦‚æœéœ€è¦ï¼Œåˆ™æ‰‹åŠ¨å¼€å¯



NSRunLoop å’Œ CFRunLoopRef åŒºåˆ«ï¼Ÿ
NSRunLoopæ˜¯åŸºäºCFRunLoopRefé¢å‘å¯¹è±¡çš„APIï¼Œæ˜¯ä¸å®‰å…¨çš„
CFRunLoopRefæ˜¯åŸºäºCè¯­è¨€ï¼Œæ˜¯çº¿ç¨‹å®‰å…¨çš„



Runloopçš„modeä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ
modeä¸»è¦æ˜¯ç”¨äºæŒ‡å®šRunLoopä¸­äº‹ä»¶ä¼˜å…ˆçº§çš„


ä»¥+scheduledTimerWithTimeInterval:çš„æ–¹å¼è§¦å‘çš„timerï¼Œåœ¨æ»‘åŠ¨é¡µé¢ä¸Šçš„åˆ—è¡¨æ—¶ï¼Œtimerä¼šæš‚åœå›è°ƒï¼Œ ä¸ºä»€ä¹ˆï¼Ÿå¦‚ä½•è§£å†³ï¼Ÿ
timeråœæ­¢çš„åŸå› æ˜¯å› ä¸ºæ»‘åŠ¨scrollViewæ—¶ï¼Œä¸»çº¿ç¨‹çš„RunLoopä¼šä»NSDefaultRunLoopModeåˆ‡æ¢åˆ°UITrackingRunLoopModeï¼Œè€Œtimeræ˜¯æ·»åŠ åœ¨NSDefaultRunLoopModeã€‚æ‰€ä»¥timerä¸ä¼šæ‰§è¡Œ
å°†timeræ”¾å…¥NSRunLoopCommonModesä¸­æ‰§è¡Œ