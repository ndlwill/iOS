self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(fireHome) userInfo:nil repeats:YES];
[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];
Runloopå¯¹timerçš„å¼ºæŒæœ‰


NSLog(@"%ld",CFGetRetainCount((__bridge CFTypeRef)self));// 8
__weak typeof(self) weakSelf = self;
NSLog(@"%ld",CFGetRetainCount((__bridge CFTypeRef)self));// 8

weakSelfä¼šå¯¹å¼•ç”¨è®¡æ•°è¿›è¡Œ+1æ“ä½œå—ï¼Ÿ
weakSelfæ²¡æœ‰å¯¹å†…å­˜è¿›è¡Œ+1æ“ä½œ

#####
weakSelf å’Œ self çš„æŒ‡é’ˆåœ°å€ç›¸åŒå—ï¼Œæ˜¯æŒ‡å‘åŒä¸€ç‰‡å†…å­˜å—ï¼Ÿ
po weakSelf
po self
po &weakSelf
po &self
ä»æ‰“å°ç»“æœå¯ä»¥çœ‹å‡ºï¼Œå½“å‰selfå–åœ°å€ å’Œ weakSelfå–åœ°å€çš„å€¼æ˜¯ä¸ä¸€æ ·çš„ã€‚
æ„å‘³ç€æœ‰ä¸¤ä¸ªæŒ‡é’ˆåœ°å€ï¼ŒæŒ‡å‘çš„æ˜¯åŒä¸€ç‰‡å†…å­˜ç©ºé—´ï¼Œå³weakSelf å’Œ self çš„å†…å­˜åœ°å€æ˜¯ä¸ä¸€æ ·ï¼Œéƒ½æŒ‡å‘åŒä¸€ç‰‡å†…å­˜ç©ºé—´çš„
#####


æ­¤æ—¶timeræ•è·çš„æ˜¯<LGTimerViewController: 0x7f890741f5b0>ï¼Œæ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œæ‰€ä»¥æ— æ³•é€šè¿‡weakSelfæ¥è§£å†³å¼ºæŒæœ‰ã€‚
å³å¼•ç”¨é“¾å…³ç³»ä¸ºï¼šNSRunLoop -> timer -> weakSelfï¼ˆ<LGTimerViewController: 0x7f890741f5b0>ï¼‰ã€‚æ‰€ä»¥RunLoopå¯¹æ•´ä¸ª å¯¹è±¡çš„ç©ºé—´æœ‰å¼ºæŒæœ‰ï¼Œrunloopæ²¡åœï¼Œtimer å’Œ weakSelfæ˜¯æ— æ³•é‡Šæ”¾çš„
åœ¨BlockåŸç†ä¸­æåŠçš„blockçš„å¾ªç¯å¼•ç”¨ï¼Œä¸timerçš„æ˜¯æœ‰åŒºåˆ«çš„ã€‚
é€šè¿‡blockåº•å±‚åŸç†çš„æ–¹æ³•__Block_object_assignå¯çŸ¥ï¼Œblockæ•è·çš„æ˜¯ å¯¹è±¡çš„æŒ‡é’ˆåœ°å€ï¼Œå³weakself æ˜¯ ä¸´æ—¶å˜é‡çš„æŒ‡é’ˆåœ°å€ï¼Œè·Ÿselfæ²¡æœ‰å…³ç³»ï¼Œå› ä¸ºweakSelfæ˜¯æ–°çš„åœ°å€ç©ºé—´ã€‚
æ‰€ä»¥æ­¤æ—¶çš„weakSelfç›¸å½“äºä¸­é—´å€¼ã€‚å…¶å¼•ç”¨å…³ç³»é“¾ä¸ºself -> block -> weakSelfï¼ˆä¸´æ—¶å˜é‡çš„æŒ‡é’ˆåœ°å€ï¼‰ï¼Œå¯ä»¥é€šè¿‡åœ°å€æ‹¿åˆ°æŒ‡é’ˆ


åŒºåˆ«ä¸‹blockå’Œtimerå¾ªç¯å¼•ç”¨çš„æ¨¡å‹
timeræ¨¡å‹ï¼šself -> timer -> weakSelf -> self,å½“å‰çš„timeræ•è·çš„æ˜¯Bç•Œé¢çš„å†…å­˜ï¼Œå³vcå¯¹è±¡çš„å†…å­˜ï¼Œå³weakSelfè¡¨ç¤ºçš„æ˜¯vcå¯¹è±¡
Blockæ¨¡å‹ï¼šself -> block -> weakSelf -> selfï¼Œå½“å‰çš„blockæ•è·çš„æ˜¯æŒ‡é’ˆåœ°å€ï¼Œå³weakSelfè¡¨ç¤ºçš„æ˜¯æŒ‡å‘selfçš„ä¸´æ—¶å˜é‡çš„æŒ‡é’ˆåœ°å€

è§£å†³ å¼ºå¼•ç”¨:
æ€è·¯ä¸€ï¼špopæ—¶åœ¨å…¶ä»–æ–¹æ³•ä¸­é”€æ¯timer
didMoveToParentViewController

æ€è·¯äºŒï¼šä¸­ä»‹è€…æ¨¡å¼ï¼Œå³ä¸ä½¿ç”¨selfï¼Œä¾èµ–äºå…¶ä»–å¯¹è±¡
//**********1ã€å®šä¹‰å…¶ä»–å¯¹è±¡**********
@property (nonatomic, strong) id            target;

//**********1ã€ä¿®æ”¹target**********
self.target = [[NSObject alloc] init];
class_addMethod([NSObject class], @selector(fireHome), (IMP)fireHomeObjc, "v@:");
self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self.target selector:@selector(fireHome) userInfo:nil repeats:YES];

//**********3ã€imp**********
void fireHomeObjc(id obj){
    NSLog(@"%s -- %@",__func__,obj);
}

æ€è·¯ä¸‰ï¼šè‡ªå®šä¹‰å°è£…timer
è¿™ç§æ–¹å¼æ˜¯æ ¹æ®æ€è·¯äºŒçš„åŸç†

æ€è·¯å››ï¼šåˆ©ç”¨NSProxyè™šåŸºç±»çš„å­ç±»
å³ä½¿ç”¨NSProxyä½œä¸ºä¸­é—´ä»£ç†ã€ä¸­é—´è€…


==================================================AutoReleasePool è‡ªåŠ¨é‡Šæ”¾æ± 
https://www.jianshu.com/u/5c9dfddcd1dd

è‡ªåŠ¨é‡Šæ”¾æ± å®é™…ä¸Šæ˜¯ä¸€ä¸ªç”± AutoreleasePoolPage ç»„æˆçš„åŒå‘é“¾è¡¨ç»“æ„, ä¸€ä¸ªè‡ªåŠ¨é‡Šæ”¾æ± ä¸­æœ‰ä¸€ä¸ªæˆ–å¤šä¸ª AutoreleasePoolPage èŠ‚ç‚¹


è‡ªåŠ¨é‡Šæ”¾æ± æ˜¯OCä¸­çš„ä¸€ç§å†…å­˜è‡ªåŠ¨å›æ”¶æœºåˆ¶ï¼Œå®ƒå¯ä»¥å°†åŠ å…¥AutoreleasePoolä¸­çš„å˜é‡releaseçš„æ—¶æœºå»¶è¿Ÿï¼Œç®€å•æ¥è¯´ï¼Œå°±æ˜¯å½“åˆ›å»ºä¸€ä¸ªå¯¹è±¡ï¼Œåœ¨æ­£å¸¸æƒ…å†µä¸‹ï¼Œå˜é‡ä¼šåœ¨è¶…å‡ºå…¶ä½œç”¨åŸŸçš„æ—¶ç«‹å³releaseã€‚
å¦‚æœå°†å¯¹è±¡åŠ å…¥åˆ°äº†è‡ªåŠ¨é‡Šæ”¾æ± ä¸­ï¼Œè¿™ä¸ªå¯¹è±¡å¹¶ä¸ä¼šç«‹å³é‡Šæ”¾ï¼Œä¼šç­‰åˆ°runloopä¼‘çœ /è¶…å‡ºautoreleasepoolä½œç”¨åŸŸ{}ä¹‹åæ‰ä¼šè¢«é‡Šæ”¾ã€‚

1ã€ä»ç¨‹åºå¯åŠ¨åˆ°åŠ è½½å®Œæˆï¼Œä¸»çº¿ç¨‹å¯¹åº”çš„runloopä¼šå¤„äºä¼‘çœ çŠ¶æ€ï¼Œç­‰å¾…ç”¨æˆ·äº¤äº’æ¥å”¤é†’runloop
2ã€ç”¨æˆ·çš„æ¯ä¸€æ¬¡äº¤äº’éƒ½ä¼šå¯åŠ¨ä¸€æ¬¡runloopï¼Œç”¨äºå¤„ç†ç”¨æˆ·çš„æ‰€æœ‰ç‚¹å‡»ã€è§¦æ‘¸äº‹ä»¶ç­‰
3ã€runloopåœ¨ç›‘å¬åˆ°äº¤äº’äº‹ä»¶åï¼Œå°±ä¼šåˆ›å»ºè‡ªåŠ¨é‡Šæ”¾æ± ï¼Œå¹¶å°†æ‰€æœ‰å»¶è¿Ÿé‡Šæ”¾çš„å¯¹è±¡æ·»åŠ åˆ°è‡ªåŠ¨é‡Šæ”¾æ± ä¸­
4ã€åœ¨ä¸€æ¬¡å®Œæ•´çš„runloopç»“æŸä¹‹å‰ï¼Œä¼šå‘è‡ªåŠ¨é‡Šæ”¾æ± ä¸­æ‰€æœ‰å¯¹è±¡å‘é€releaseæ¶ˆæ¯ï¼Œç„¶åé”€æ¯è‡ªåŠ¨é‡Šæ”¾æ± 



Clangåˆ†æ:
å…ˆé€šè¿‡clangæ¥åˆ†æ:
int main(int argc, const char * argv[]) {
    @autoreleasepool {
    }
}

struct __AtAutoreleasePool {
    //æ„é€ å‡½æ•°
    __AtAutoreleasePool() {
            atautoreleasepoolobj = objc_autoreleasePoolPush();
    }
    //ææ„å‡½æ•°
    ~__AtAutoreleasePool() {
            objc_autoreleasePoolPop(atautoreleasepoolobj);
     }
      void * atautoreleasepoolobj;
};

int main(int argc, const char * argv[]) {
   { 
        //æ˜¯ä¸€ä¸ªç»“æ„ä½“
         __AtAutoreleasePool __autoreleasepool; 
    }
    return 0;
}
è‡ªåŠ¨é‡Šæ”¾æ± å…¶æœ¬è´¨ä¹Ÿæ˜¯ä¸€ä¸ªå¯¹è±¡
@autoreleasepool {}
//ç­‰ä»·äº
{__AtAutoreleasePool __autoreleasepool; }

__AtAutoreleasePoolæ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œæœ‰æ„é€ å‡½æ•° + ææ„å‡½æ•°ï¼Œç»“æ„ä½“å®šä¹‰çš„å¯¹è±¡åœ¨ä½œç”¨åŸŸç»“æŸåï¼Œä¼šè‡ªåŠ¨è°ƒç”¨ææ„å‡½æ•°
å…¶ä¸­{} æ˜¯ ä½œç”¨åŸŸ ï¼Œä¼˜ç‚¹æ˜¯ç»“æ„æ¸…æ™°ï¼Œå¯è¯»æ€§å¼ºï¼Œå¯ä»¥åŠæ—¶åˆ›å»ºé”€æ¯

è¯¥è‡ªåŠ¨é‡Šæ”¾æ± ä» objc_autoreleasePoolPush() å¼€å§‹, æœŸé—´çš„ autorelease ç±»å‹çš„å¯¹è±¡éƒ½ä¼šåŠ å…¥åˆ°è¿™ä¸ªè‡ªåŠ¨é‡Šæ”¾æ± ä¸­, æœ€ååœ¨ objc_autoreleasePoolPop() è°ƒç”¨æ—¶, é‡Šæ”¾æ‰æ± ä¸­æ‰€æœ‰çš„ autorelease å¯¹è±¡.


struct CJLTest{
    CJLTest
(){
        printf("1123 - %s\n", __func__);
    }
    ~CJLTest(){
        printf("5667 - %s\n", __func__);
    }
};

int main(int argc, const char * argv[]) {
    {
        CJLTest test;
    }
}

//**********è¿è¡Œç»“æœ**********
1123 - CJLTest
5667 - ~CJLTest
åœ¨CJLTeståˆ›å»ºå¯¹è±¡æ—¶ï¼Œä¼šè‡ªåŠ¨è°ƒç”¨æ„é€ å‡½æ•°ï¼Œåœ¨å‡ºäº†{}ä½œç”¨åŸŸåï¼Œä¼šè‡ªåŠ¨è°ƒç”¨ææ„å‡½æ•°


æ±‡ç¼–åˆ†æ:
é€šè¿‡è°ƒè¯•ç»“æœå‘ç°ï¼Œè¯æ˜äº†æˆ‘ä»¬clangåˆ†æçš„ç»“æœ

æ€»ç»“:
autoreleasepoolå…¶æœ¬è´¨æ˜¯ä¸€ä¸ªç»“æ„ä½“å¯¹è±¡ï¼Œä¸€ä¸ªè‡ªåŠ¨é‡Šæ”¾æ± å¯¹è±¡å°±æ˜¯é¡µï¼Œæ˜¯æ ˆç»“æ„å­˜å‚¨ï¼Œç¬¦åˆå…ˆè¿›åå‡ºçš„åŸåˆ™å³å¯
é¡µçš„æ ˆåº•æ˜¯ä¸€ä¸ª56å­—èŠ‚å¤§å°çš„ç©ºå ä½ç¬¦ï¼Œä¸€é¡µæ€»å¤§å°ä¸º4096å­—èŠ‚
åªæœ‰ç¬¬ä¸€é¡µæœ‰å“¨å…µå¯¹è±¡ï¼Œæœ€å¤šå­˜å‚¨504ä¸ªå¯¹è±¡ï¼Œä»ç¬¬äºŒé¡µå¼€å§‹æœ€å¤šå­˜å‚¨505ä¸ªå¯¹è±¡
autoreleasepoolåœ¨åŠ å…¥è¦é‡Šæ”¾çš„å¯¹è±¡æ—¶ï¼Œåº•å±‚è°ƒç”¨çš„æ˜¯objc_autoreleasePoolPushæ–¹æ³•
autoreleasepoolåœ¨è°ƒç”¨ææ„å‡½æ•°é‡Šæ”¾æ—¶ï¼Œå†…éƒ¨çš„å®ç°æ˜¯è°ƒç”¨objc_autoreleasePoolPopæ–¹æ³•



å®å®šä¹‰å’Œé™æ€å¸¸é‡:
#   define EMPTY_POOL_PLACEHOLDER ((id*)1) //pool ä¸­æ²¡æœ‰å¯¹è±¡å­˜å…¥
#   define POOL_BOUNDARY nil //å“¨å…µå¯¹è±¡, ç”¨æ¥æ ‡è¯†é‡Šæ”¾è¾¹ç•Œ
static pthread_key_t const key = AUTORELEASE_POOL_KEY; //é”®å€¼å¯¹ä¸­çš„key, å€¼ä¸º AutoreleasePoolPage * ç±»å‹æŒ‡é’ˆ
static uint8_t const SCRIBBLE = 0xA3; //é‡Šæ”¾åçš„ä½ç½®ä¼šç½®ä¸º 0xA3A3A3A3
static size_t const SIZE = PAGE_MAX_SIZE; //æ¯ä¸ª page çš„å¤§å°, 4096 ä¸ªå­—èŠ‚(Page å¯¹è±¡æœ¬èº«å  56 ä¸ªå­—èŠ‚)
static size_t const COUNT = SIZE / sizeof(id); //page ä¸­èƒ½å­˜æ”¾çš„å¯¹è±¡ä¸ªæ•°

æˆå‘˜å˜é‡:
magic_t const magic; //ç”¨äºæ ¡éªŒ AutoreleasePoolPage çš„ç»“æ„
id *next; //ä¸‹ä¸€ä¸ªå¯¹è±¡è¦æ’å…¥çš„ä½ç½®
pthread_t const thread; //æ‰€å±çº¿ç¨‹å¥æŸ„
AutoreleasePoolPage * const parent; //åŒå‘é“¾è¡¨çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹
AutoreleasePoolPage *child; //åŒå‘é“¾è¡¨çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
uint32_t const depth; //é“¾è¡¨æ·±åº¦
uint32_t hiwat; //AutoreleasePool ä¸­å­˜å‚¨å¯¹è±¡ä¸ªæ•°çš„æœ€å¤§å€¼


å®å®šä¹‰å’Œé™æ€å¸¸é‡:
EMPTY_POOL_PLACEHOLDER
æ ¹æ®æ³¨é‡Šä»¥åŠä»£ç åˆ†æ, å¯ä»¥å¤§è‡´å¾—å‡ºè¿™ä¸ªå®å®šä¹‰ç”¨ä½œ pool ä¸­æ²¡æœ‰ add å…¥å¯¹è±¡æ—¶çš„æ ‡è®°. 
å½“ä¸€ä¸ªè‡ªåŠ¨é‡Šæ”¾æ± è¢«åˆ›å»ºä½†æ˜¯æ²¡æœ‰åŠ å…¥ä»»ä½• Autorelease å¯¹è±¡æ—¶, ä¼šè®©è¿™ä¸ªè‡ªåŠ¨é‡Šæ”¾æ± çš„å¥æŸ„ç­‰äº EMPTY_POOL_PLACEHOLDER, å¹¶ä¸ä¸ºå…¶åˆ†é…å†…å­˜.

POOL_BOUNDARY ä¼šåœ¨å»ºç«‹æ–°çš„è‡ªåŠ¨é‡Šæ”¾æ± æ—¶ä½œä¸ºç¬¬ä¸€ä¸ªå¯¹è±¡åŠ å…¥åˆ°æ± ä¸­, è¢«ç§°ä¸ºå“¨å…µå¯¹è±¡
@autoreleasepool {} æ˜¯åœ¨ä½œç”¨åŸŸçš„å¼€å§‹ä½¿ç”¨ push() æ–¹æ³•æ¥åˆ›å»ºè‡ªåŠ¨é‡Šæ”¾æ± , åœ¨ä½œç”¨åŸŸç»“æŸæ—¶, ä½¿ç”¨ pop() æ–¹æ³•æ¥é”€æ¯è‡ªåŠ¨é‡Šæ”¾æ± 
åœ¨åµŒå¥—ç»“æ„ä¸­ push() æ–¹æ³•ä¸ä¸€å®šä¼šåˆ›å»ºæ–°çš„ page èŠ‚ç‚¹, å¦‚æœå½“å‰èŠ‚ç‚¹æœªæ»¡åˆ™ä¼šç›´æ¥æ’å…¥ä¸€ä¸ªå“¨å…µå¯¹è±¡, å¦‚æœå½“å‰èŠ‚ç‚¹å·²æ»¡åˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„ page èŠ‚ç‚¹å¹¶ä¸”æ’å…¥ä¸€ä¸ªå“¨å…µå¯¹è±¡
push() å‡½æ•°çš„è¿”å›å€¼å°±æ˜¯è¿™ä¸ªå“¨å…µå¯¹è±¡çš„åœ°å€(å“¨å…µå¯¹è±¡çš„å€¼æ˜¯ nil, ä½†å“¨å…µå¯¹è±¡çš„åœ°å€ä¸ä¸º nil)
ç„¶ååœ¨ pop() æ–¹æ³•è°ƒç”¨æ—¶, ä¼ å…¥è¿™ä¸ªå“¨å…µå¯¹è±¡çš„åœ°å€, å¯¹è¿™ä¸ªåœ°å€ä¹‹åçš„ Autorelease å¯¹è±¡å‘é€ release æ–¹æ³•.

SCRIBBLE çš„å€¼ä¸º 0xA3. åœ¨ pop() æ–¹æ³•è¢«æ‰§è¡Œæ—¶, ä¼šç»™å¯¹åº”çš„å“¨å…µå¯¹è±¡ä¹‹åçš„æ‰€æœ‰å¯¹è±¡éƒ½å‘é€ release æ¶ˆæ¯, 
åŒæ—¶ä» page èŠ‚ç‚¹ä¸­ç§»é™¤è¿™äº›å¯¹è±¡, ç§»é™¤çš„æ–¹æ³•å°±æ˜¯ä½¿ç”¨ memset() å‡½æ•°ç»™åŸæ¥å­˜å‚¨å¯¹è±¡åœ°å€çš„åœ°æ–¹, 
å­˜å…¥SCRIBBLE(memset() ä¼šä¸º 8 ä¸ªå­—èŠ‚çš„åœ°å€éƒ½å­˜å…¥ 0xA3, å³ä¸º 0xA3A3A3A3A3A3A3A3).

SIZE = PAGE_MAX_SIZE, å®å®šä¹‰ PAGE_MAX_SIZE çš„æœ€ç»ˆå€¼ä¸º 4096(å•ä½æ˜¯å­—èŠ‚), è¿™ä¸ªé™æ€å¸¸é‡è¡¨ç¤ºä¸€ä¸ª AutoreleasePoolPage ä¸­ç”¨äºå­˜å‚¨å¯¹è±¡æŒ‡é’ˆçš„å†…å­˜å¤§å°.

COUNT å³æ¯ä¸ª page èŠ‚ç‚¹èƒ½å­˜å‚¨çš„ Autorelease å¯¹è±¡ä¸ªæ•°, åœ¨ 64 ä½æ“ä½œç³»ç»Ÿä¸‹, 4096 ä¸ªå­—èŠ‚å¯ä»¥å­˜å‚¨ 8 å­—èŠ‚çš„æŒ‡é’ˆå…± 512 ä¸ª, å³ä¸€ä¸ª page èŠ‚ç‚¹èƒ½å­˜å‚¨ 512 ä¸ªå¯¹è±¡. page å¯¹è±¡æœ¬èº«å  56 ä¸ªå­—èŠ‚, æ‰€ä»¥å®é™…èƒ½å­˜å‚¨ Autorelease å¯¹è±¡ä¸ªæ•°ä¸º 505 ä¸ª.
COUNT åœ¨ä»£ç ä¸­å¹¶æ²¡æœ‰å®é™…ç”¨é€”, åªæ˜¯é…åˆ depth å’Œ hiwat åœ¨è°ƒè¯•è¾“å‡ºæ—¶ä½¿ç”¨.

æˆå‘˜å˜é‡:
magic

next
æŒ‡å‘ page ä¸­ä¸‹ä¸€ä¸ªå°†è¦å­˜æ”¾ Autorelease å¯¹è±¡çš„åœ°å€, 
é€šå¸¸é€šè¿‡ *next++ = obj æ¥å®ç°å¯¹è±¡çš„å­˜å…¥å’Œ next æŒ‡é’ˆçš„ç´¯åŠ , ç”¨ *--next æ¥å–å‡ºè¦ release çš„å¯¹è±¡å’Œå®ç° next çš„é€’å‡.

thread
å½“å‰ page èŠ‚ç‚¹æ‰€å±çš„çº¿ç¨‹å¥æŸ„

parent å’Œ child
parent æ˜¯åŒå‘é“¾è¡¨ç»“æ„ä¸­æŒ‡å‘ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ, child æ˜¯åŒå‘é“¾è¡¨ä¸­æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ.

depth å’Œ hiwat
depth æ˜¯é“¾è¡¨çš„æ·±åº¦(å³æ€»å…±çš„èŠ‚ç‚¹æ•°), hiwat æ˜¯å¯¹åº”çš„è‡ªåŠ¨é‡Šæ”¾æ± ä¸­å­˜å‚¨å¯¹è±¡ä¸ªæ•°çš„æœ€å¤§å€¼(æ¯”å¦‚æ›¾ç»å­˜å‚¨è¿‡100ä¸ª, ç°åœ¨åªå‰©50ä¸ª, hiwat å°±æ˜¯ 100)
ä¸ºäº†è°ƒè¯•æ—¶è¾“å‡º AutoreleasePool ä¿¡æ¯


åº•å±‚åˆ†æ:
åœ¨objcæºç ä¸­ï¼Œå¯¹AutoreleasePoolçš„è§£é‡Šå¦‚ä¸‹
Autorelease pool implementation
- A thread's autorelease pool is a stack of pointers. 
çº¿ç¨‹çš„è‡ªåŠ¨é‡Šæ”¾æ± æ˜¯æŒ‡é’ˆçš„å †æ ˆ

- Each pointer is either an object to release, or POOL_BOUNDARY which is an autorelease pool boundary.
æ¯ä¸ªæŒ‡é’ˆéƒ½æ˜¯è¦é‡Šæ”¾çš„å¯¹è±¡ï¼Œæˆ–è€…æ˜¯POOL_BOUNDARYï¼Œå®ƒæ˜¯è‡ªåŠ¨é‡Šæ”¾æ± çš„è¾¹ç•Œã€‚

- A pool token is a pointer to the POOL_BOUNDARY for that pool. When the pool is popped, every object hotter than the sentinel is released.
æ± ä»¤ç‰Œæ˜¯æŒ‡å‘è¯¥æ± çš„POOL_BOUNDARYçš„æŒ‡é’ˆã€‚å¼¹å‡ºæ± åï¼Œå°†é‡Šæ”¾æ¯”å“¨ç‚¹æ›´çƒ­çš„æ¯ä¸ªå¯¹è±¡ã€‚

- The stack is divided into a doubly-linked list of pages. Pages are added and deleted as necessary. 
å †æ ˆåˆ†ä¸ºä¸¤ä¸ªåŒå‘é“¾æ¥çš„é¡µé¢åˆ—è¡¨ã€‚æ ¹æ®éœ€è¦æ·»åŠ å’Œåˆ é™¤é¡µé¢ã€‚

- Thread-local storage points to the hot page, where newly autoreleased objects are stored. 
çº¿ç¨‹æœ¬åœ°å­˜å‚¨æŒ‡å‘çƒ­é¡µé¢ï¼Œè¯¥é¡µé¢å­˜å‚¨æ–°è‡ªåŠ¨é‡Šæ”¾çš„å¯¹è±¡ã€‚

1ã€è‡ªåŠ¨é‡Šæ”¾æ±  æ˜¯ä¸€ä¸ª å…³äºæŒ‡é’ˆçš„æ ˆç»“æ„
2ã€å…¶ä¸­çš„æŒ‡é’ˆæ˜¯æŒ‡è¦é‡Šæ”¾çš„å¯¹è±¡æˆ–è€… pool_boundary å“¨å…µï¼ˆç°åœ¨ç»å¸¸è¢«ç§°ä¸º è¾¹ç•Œï¼‰
3ã€è‡ªåŠ¨é‡Šæ”¾æ± æ˜¯ä¸€ä¸ªé¡µçš„ç»“æ„ï¼ˆè™šæ‹Ÿå†…å­˜ä¸­æåŠè¿‡ï¼‰ ï¼Œè€Œä¸”è¿™ä¸ªé¡µæ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨ï¼ˆè¡¨ç¤ºæœ‰çˆ¶èŠ‚ç‚¹ å’Œ å­èŠ‚ç‚¹ï¼Œåœ¨ç±»ä¸­æåŠè¿‡ï¼Œå³ç±»çš„ç»§æ‰¿é“¾ï¼‰
4ã€è‡ªåŠ¨é‡Šæ”¾æ± å’Œçº¿ç¨‹æœ‰å…³ç³»


AutoreleasePoolPage:
//***********pushæ–¹æ³•***********
void *
objc_autoreleasePoolPush(void)
{
    return AutoreleasePoolPage::push();
}

//***********popæ–¹æ³•***********
void
objc_autoreleasePoolPop(void *ctxt)
{
    AutoreleasePoolPage::pop(ctxt);
}



//************å®å®šä¹‰************
#define PAGE_MIN_SIZE           PAGE_SIZE
#define PAGE_SIZE               I386_PGBYTES
#define I386_PGBYTES            4096            /* bytes per 80386 page */

//************ç±»å®šä¹‰************
class AutoreleasePoolPage : private AutoreleasePoolPageData
{
    friend struct thread_data_t;

public:
    //é¡µçš„å¤§å°
    static size_t const SIZE =
#if PROTECT_AUTORELEASEPOOL
        PAGE_MAX_SIZE;  // must be multiple of vm page size
#else
        PAGE_MIN_SIZE;  // size and alignment, power of 2
#endif

private:
    
    ...
    
    //æ„é€ å‡½æ•°
    AutoreleasePoolPage(AutoreleasePoolPage *newParent) :
        AutoreleasePoolPageData(begin(),//å¼€å§‹å­˜å‚¨çš„ä½ç½®
                                objc_thread_self(),//ä¼ çš„æ˜¯å½“å‰çº¿ç¨‹ï¼Œå½“å‰çº¿ç¨‹æ—¶é€šè¿‡tlsè·å–çš„
                                newParent,
                                newParent ? 1+newParent->depth : 0,//å¦‚æœæ˜¯ç¬¬ä¸€é¡µæ·±åº¦ä¸º0ï¼Œå¾€åæ˜¯å‰ä¸€ä¸ªçš„æ·±åº¦+1
                                newParent ? newParent->hiwat : 0)
    {...}
    
    //ææ„å‡½æ•°
    ~AutoreleasePoolPage() {...}
    
    ...
    
    //é¡µçš„å¼€å§‹ä½ç½®
    id * begin() {...}
    
    //é¡µçš„ç»“æŸä½ç½®
    id * end() {...}
   
    //é¡µæ˜¯å¦ä¸ºç©º
    bool empty() {...}
    
    //é¡µæ˜¯å¦æ»¡äº†
    bool full() {...}
   
    //é¡µçš„å­˜å‚¨æ˜¯å¦å°‘äºä¸€åŠ
    bool lessThanHalfFull() {...}
     
     //æ·»åŠ é‡Šæ”¾å¯¹è±¡
    id *add(id obj){...}
    
    //é‡Šæ”¾æ‰€æœ‰å¯¹è±¡
    void releaseAll() {...}
    
    //é‡Šæ”¾åˆ°stopä½ç½®ä¹‹å‰çš„æ‰€æœ‰å¯¹è±¡
    void releaseUntil(id *stop) {...}
    
    //æ€æ‰
    void kill() {...}
    
    //é‡Šæ”¾æœ¬åœ°çº¿ç¨‹å­˜å‚¨ç©ºé—´
    static void tls_dealloc(void *p) {...}
    
    //è·å–AutoreleasePoolPage
    static AutoreleasePoolPage *pageForPointer(const void *p) {...}
    static AutoreleasePoolPage *pageForPointer(uintptr_t p)  {...}
    
    //æ˜¯å¦æœ‰ç©ºæ± å ä½ç¬¦
    static inline bool haveEmptyPoolPlaceholder() {...}
    
    //è®¾ç½®ç©ºæ± å ä½ç¬¦
    static inline id* setEmptyPoolPlaceholder(){...}
    
    //è·å–å½“å‰æ“ä½œé¡µ
    static inline AutoreleasePoolPage *hotPage(){...}
    
    //è®¾ç½®å½“å‰æ“ä½œé¡µ
    static inline void setHotPage(AutoreleasePoolPage *page) {...}
    
    //è·å–coldPage
    static inline AutoreleasePoolPage *coldPage() {...}
    
    //å¿«é€Ÿé‡Šæ”¾
    static inline id *autoreleaseFast(id obj){...}
   
   //æ·»åŠ è‡ªåŠ¨é‡Šæ”¾å¯¹è±¡ï¼Œå½“é¡µæ»¡çš„æ—¶å€™è°ƒç”¨è¿™ä¸ªæ–¹æ³•
    static __attribute__((noinline))
    id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) {...}
    
    //æ·»åŠ è‡ªåŠ¨é‡Šæ”¾å¯¹è±¡ï¼Œå½“æ²¡é¡µçš„æ—¶å€™ä½¿ç”¨è¿™ä¸ªæ–¹æ³•
    static __attribute__((noinline))
    id *autoreleaseNoPage(id obj){...}
   
   //åˆ›å»ºæ–°é¡µ
    static __attribute__((noinline))
    id *autoreleaseNewPage(id obj) {...}
    
public:
    //è‡ªåŠ¨é‡Šæ”¾
    static inline id autorelease(id obj){...}
   
    //å…¥æ ˆ
    static inline void *push() {...}
    
    //å…¼å®¹è€çš„ SDK å‡ºæ ˆæ–¹æ³•
    __attribute__((noinline, cold))
    static void badPop(void *token){...}
    
    //å‡ºæ ˆé¡µé¢
    template<bool allowDebug>
    static void
    popPage(void *token, AutoreleasePoolPage *page, id *stop){...}
    __attribute__((noinline, cold))
    static void
    popPageDebug(void *token, AutoreleasePoolPage *page, id *stop){...}
    
    //å‡ºæ ˆ
    static inline void
    pop(void *token){...}
    
    static void init(){...}
    
    //æ‰“å°
    __attribute__((noinline, cold))
    void print(){...}
    
    //æ‰“å°æ‰€æœ‰
    __attribute__((noinline, cold))
    static void printAll(){...}
    
    //æ‰“å°Hiwat
    __attribute__((noinline, cold))
    static void printHiwat(){...}


AutoreleasePoolPageæ˜¯ç»§æ‰¿è‡ªAutoreleasePoolPageData,ä¸”è¯¥ç±»çš„å±æ€§ä¹Ÿæ˜¯æ¥è‡ªçˆ¶ç±»ï¼Œä»¥ä¸‹æ˜¯AutoreleasePoolPageDataçš„å®šä¹‰ï¼Œ

è‡ªåŠ¨é‡Šæ”¾æ± é™¤äº†æ˜¯ä¸€ä¸ªé¡µï¼Œè¿˜æ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨ç»“æ„
class AutoreleasePoolPage;
struct AutoreleasePoolPageData
{
    //ç”¨æ¥æ ¡éªŒAutoreleasePoolPageçš„ç»“æ„æ˜¯å¦å®Œæ•´
    magic_t const magic;//16ä¸ªå­—èŠ‚
    //æŒ‡å‘æœ€æ–°æ·»åŠ çš„autoreleasedå¯¹è±¡çš„ä¸‹ä¸€ä¸ªä½ç½®ï¼Œåˆå§‹åŒ–æ—¶æŒ‡å‘begin()
    __unsafe_unretained id *next;//8å­—èŠ‚
    //æŒ‡å‘å½“å‰çº¿ç¨‹
    pthread_t const thread;//8å­—èŠ‚
    //æŒ‡å‘çˆ¶èŠ‚ç‚¹ï¼Œç¬¬ä¸€ä¸ªç»“ç‚¹çš„parentå€¼ä¸ºnil
    AutoreleasePoolPage * const parent;//8å­—èŠ‚
    //æŒ‡å‘å­èŠ‚ç‚¹ï¼Œæœ€åä¸€ä¸ªç»“ç‚¹çš„childå€¼ä¸ºnil
    AutoreleasePoolPage *child;//8å­—èŠ‚
    //è¡¨ç¤ºæ·±åº¦ï¼Œä»0å¼€å§‹ï¼Œå¾€åé€’å¢1
    uint32_t const depth;//4å­—èŠ‚
    //è¡¨ç¤ºhigh water mark æœ€å¤§å…¥æ ˆæ•°é‡æ ‡è®°
    uint32_t hiwat;//4å­—èŠ‚

    //åˆå§‹åŒ–
    AutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat)
        : magic(), next(_next), thread(_thread),
          parent(_parent), child(nil),
          depth(_depth), hiwat(_hiwat)
    {
    }
};

å…¶ä¸­AutoreleasePoolPageDataç»“æ„ä½“çš„å†…å­˜å¤§å°ä¸º56å­—èŠ‚:
å±æ€§magic çš„ç±»å‹æ˜¯magic_tç»“æ„ä½“ï¼Œæ‰€å å†…å­˜å¤§å°ä¸ºm[4];æ‰€å å†…å­˜ï¼ˆå³4*4=16å­—èŠ‚ï¼‰
å±æ€§nextï¼ˆæŒ‡é’ˆï¼‰ã€threadï¼ˆå¯¹è±¡ï¼‰ã€parentï¼ˆå¯¹è±¡ï¼‰ã€childï¼ˆå¯¹è±¡ï¼‰å‡å 8å­—èŠ‚ï¼ˆå³4*8=32å­—èŠ‚ï¼‰
å±æ€§depthã€hiwatç±»å‹ä¸ºuint32_tï¼Œå®é™…ç±»å‹æ˜¯unsigned intç±»å‹ï¼Œå‡å 4å­—èŠ‚ï¼ˆå³2*4=8å­—èŠ‚ï¼‰


--------------------------------------------------objc_autoreleasePoolPush æºç åˆ†æ:
//å…¥æ ˆ
static inline void *push() 
{
    id *dest;
    //åˆ¤æ–­æ˜¯å¦æœ‰pool
    // DebugPoolAllocation æ˜¯ç”¨åœ¨è°ƒè¯•æ¨¡å¼ä¸‹çš„, è°ƒè¯•æ¨¡å¼ä¸‹ä¼šç›´æ¥ç”Ÿæˆæ–°çš„ page èŠ‚ç‚¹
    if (slowpath(DebugPoolAllocation)) {
        // Each autorelease pool starts on a new pool page.è‡ªåŠ¨é‡Šæ”¾æ± ä»æ–°æ± é¡µé¢å¼€å§‹
        //å¦‚æœæ²¡æœ‰ï¼Œåˆ™åˆ›å»º
        dest = autoreleaseNewPage(POOL_BOUNDARY);
    } else {
        //å‹æ ˆä¸€ä¸ªPOOL_BOUNDARYï¼Œå³å‹æ ˆå“¨å…µ
        dest = autoreleaseFast(POOL_BOUNDARY);
    }
    ASSERT(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);
    return dest;
}

è¿›å…¥pushæºç å®ç°:
åˆ¤æ–­æ˜¯å¦ä¸ºæœ‰ pool
å¦‚æœæ²¡æœ‰ï¼Œåˆ™é€šè¿‡autoreleaseNewPageæ–¹æ³•åˆ›å»º
å¦‚æœæœ‰ï¼Œåˆ™é€šè¿‡autoreleaseFastå‹æ ˆå“¨å…µå¯¹è±¡


1ã€åˆ›å»ºé¡µ autoreleaseNewPage
è¿›å…¥objc_autoreleasePoolPush -> push -> autoreleaseNewPageæºç å®ç°ï¼Œä¸»è¦æ˜¯é€šè¿‡hotPage`è·å–å½“å‰é¡µï¼Œåˆ¤æ–­å½“å‰é¡µæ˜¯å¦å­˜åœ¨
å¦‚æœå­˜åœ¨ï¼Œåˆ™é€šè¿‡autoreleaseFullPageæ–¹æ³•å‹æ ˆå¯¹è±¡
å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™é€šè¿‡autoreleaseNoPageæ–¹æ³•åˆ›å»ºé¡µ

//åˆ›å»ºæ–°é¡µ
static __attribute__((noinline))
id *autoreleaseNewPage(id obj)
{
    //è·å–å½“å‰æ“ä½œé¡µ
    AutoreleasePoolPage *page = hotPage();
    //å¦‚æœå­˜åœ¨ï¼Œåˆ™å‹æ ˆå¯¹è±¡
    if (page) return autoreleaseFullPage(obj, page);
    //å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºé¡µ
    else return autoreleaseNoPage(obj);
}

//******** hotPageæ–¹æ³• ********
//è·å–å½“å‰æ“ä½œé¡µ
static inline AutoreleasePoolPage *hotPage() 
{
    //è·å–å½“å‰é¡µ
    AutoreleasePoolPage *result = (AutoreleasePoolPage *)
        tls_get_direct(key);
    //å¦‚æœæ˜¯ä¸€ä¸ªç©ºæ± ï¼Œåˆ™è¿”å›nilï¼Œå¦åˆ™ï¼Œè¿”å›å½“å‰çº¿ç¨‹çš„è‡ªåŠ¨é‡Šæ”¾æ± 
    if ((id *)result == EMPTY_POOL_PLACEHOLDER) return nil;
    if (result) result->fastcheck();
    return result;
}


//******** autoreleaseNoPageæ–¹æ³• ********
static __attribute__((noinline))
id *autoreleaseNoPage(id obj)
{
    // "No page" could mean no pool has been pushed
    // or an empty placeholder pool has been pushed and has no contents yet
    ASSERT(!hotPage());

    bool pushExtraBoundary = false;
    //åˆ¤æ–­æ˜¯å¦æ˜¯ç©ºå ä½ç¬¦ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™å‹æ ˆå“¨å…µæ ‡è¯†ç¬¦ç½®ä¸ºYES
    if (haveEmptyPoolPlaceholder()) {
        // We are pushing a second pool over the empty placeholder pool
        // or pushing the first object into the empty placeholder pool.
        // Before doing that, push a pool boundary on behalf of the pool 
        // that is currently represented by the empty placeholder.
        pushExtraBoundary = true;
    }
    //å¦‚æœå¯¹è±¡ä¸æ˜¯å“¨å…µå¯¹è±¡ï¼Œä¸”æ²¡æœ‰Poolï¼Œåˆ™æŠ¥é”™
    else if (obj != POOL_BOUNDARY  &&  DebugMissingPools) {
        // We are pushing an object with no pool in place, 
        // and no-pool debugging was requested by environment.
        _objc_inform("MISSING POOLS: (%p) Object %p of class %s "
                     "autoreleased with no pool in place - "
                     "just leaking - break on "
                     "objc_autoreleaseNoPool() to debug", 
                     objc_thread_self(), (void*)obj, object_getClassName(obj));
        objc_autoreleaseNoPool(obj);
        return nil;
    }
    //å¦‚æœå¯¹è±¡æ˜¯å“¨å…µå¯¹è±¡ï¼Œä¸”æ²¡æœ‰ç”³è¯·è‡ªåŠ¨é‡Šæ”¾æ± å†…å­˜ï¼Œåˆ™è®¾ç½®ä¸€ä¸ªç©ºå ä½ç¬¦å­˜å‚¨åœ¨tlsä¸­ï¼Œå…¶ç›®çš„æ˜¯ä¸ºäº†èŠ‚çœå†…å­˜
    else if (obj == POOL_BOUNDARY  &&  !DebugPoolAllocation) {//å¦‚æœä¼ å…¥å‚æ•°ä¸ºå“¨å…µ
        // We are pushing a pool with no pool in place,
        // and alloc-per-pool debugging was not requested.
        // Install and return the empty pool placeholder.
        return setEmptyPoolPlaceholder();//è®¾ç½®ç©ºçš„å ä½ç¬¦
    }

    // We are pushing an object or a non-placeholder'd pool.

    // Install the first page.
    //åˆå§‹åŒ–ç¬¬ä¸€é¡µ
    AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);
    //è®¾ç½®pageä¸ºå½“å‰èšç„¦é¡µ
    setHotPage(page);
    
    // Push a boundary on behalf of the previously-placeholder'd pool.
    //å‹æ ˆå“¨å…µçš„æ ‡è¯†ç¬¦ä¸ºYESï¼Œåˆ™å‹æ ˆå“¨å…µå¯¹è±¡
    if (pushExtraBoundary) {
        //å‹æ ˆå“¨å…µ
        page->add(POOL_BOUNDARY);
    }
    
    // Push the requested object or pool.
    //å‹æ ˆå¯¹è±¡
    return page->add(obj);
}

å…¶ä¸­autoreleaseNoPageæ–¹æ³•ä¸­å‘ç°å½“å‰çº¿ç¨‹çš„è‡ªåŠ¨é‡Šæ”¾æ± æ˜¯é€šè¿‡AutoreleasePoolPageåˆ›å»ºçš„ï¼Œ
å…¶å®šä¹‰ä¸­æœ‰æ„é€ æ–¹æ³•ï¼Œè€Œæ„é€ æ–¹æ³•çš„å®ç°æ˜¯é€šè¿‡çˆ¶ç±»AutoreleasePoolPageDataçš„åˆå§‹åŒ–æ–¹æ³•
//**********AutoreleasePoolPageæ„é€ æ–¹æ³•**********
    AutoreleasePoolPage(AutoreleasePoolPage *newParent) :
        AutoreleasePoolPageData(begin(),//å¼€å§‹å­˜å‚¨çš„ä½ç½®
                                objc_thread_self(),//ä¼ çš„æ˜¯å½“å‰çº¿ç¨‹ï¼Œå½“å‰çº¿ç¨‹æ—¶é€šè¿‡tlsè·å–çš„
                                newParent,
                                newParent ? 1+newParent->depth : 0,//å¦‚æœæ˜¯ç¬¬ä¸€é¡µæ·±åº¦ä¸º0ï¼Œå¾€åæ˜¯å‰ä¸€ä¸ªçš„æ·±åº¦+1
                                newParent ? newParent->hiwat : 0)
{ 
    if (parent) {
        parent->check();
        ASSERT(!parent->child);
        parent->unprotect();
        //this è¡¨ç¤º æ–°å»ºé¡µé¢ï¼Œå°†å½“å‰é¡µé¢çš„å­èŠ‚ç‚¹ èµ‹å€¼ä¸ºæ–°å»ºé¡µé¢
        parent->child = this;
        parent->protect();
    }
    protect();
}

//**********AutoreleasePoolPageDataåˆå§‹åŒ–æ–¹æ³•**********
AutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat)
        : magic(), next(_next), thread(_thread),
          parent(_parent), child(nil),
          depth(_depth), hiwat(_hiwat)
    {
    }

å…¶ä¸­AutoreleasePoolPageDataæ–¹æ³•ä¼ å…¥çš„å‚æ•°å«ä¹‰ä¸º:
begin()è¡¨ç¤ºå‹æ ˆçš„ä½ç½®ï¼ˆå³ä¸‹ä¸€ä¸ªè¦é‡Šæ”¾å¯¹è±¡çš„å‹æ ˆåœ°å€ï¼‰ã€‚
å¯ä»¥é€šè¿‡æºç è°ƒè¯•beginï¼Œå‘ç°å…¶å…·ä½“å®ç°ç­‰äºé¡µé¦–åœ°å€+56ï¼Œå…¶ä¸­çš„56å°±æ˜¯ç»“æ„ä½“AutoreleasePoolPageDataçš„å†…å­˜å¤§å°
//********begin()********
//é¡µçš„å¼€å§‹ä½ç½®
id * begin() {
    //ç­‰äº é¦–åœ°å€+56ï¼ˆAutoreleasePoolPageç±»æ‰€å å†…å­˜å¤§å°ï¼‰
    return (id *) ((uint8_t *)this+sizeof(*this));
}

objc_thread_self() è¡¨ç¤ºçš„æ˜¯å½“å‰çº¿ç¨‹ï¼Œè€Œå½“å‰çº¿ç¨‹æ—¶é€šè¿‡tlsè·å–çš„
__attribute__((const))
static inline pthread_t objc_thread_self()
{
    //é€šè¿‡tlsè·å–å½“å‰çº¿ç¨‹
    return (pthread_t)tls_get_direct(_PTHREAD_TSD_SLOT_PTHREAD_SELF);
}
tls_get_direct() å‡½æ•°å†…éƒ¨ç»“åˆçº¿ç¨‹IDå’Œ AUTORELEASE_POOL_KEY(43) ä¸¤ä¸ªä¿¡æ¯æœ€ç»ˆæ‰¾å‡ºè¯¥çº¿ç¨‹å¯¹åº”çš„ hotPage.

newParentè¡¨ç¤ºçˆ¶èŠ‚ç‚¹

åç»­ä¸¤ä¸ªå‚æ•°æ˜¯é€šè¿‡çˆ¶èŠ‚ç‚¹çš„æ·±åº¦ã€æœ€å¤§å…¥æ ˆä¸ªæ•°è®¡ç®—depthä»¥åŠhiwat



æŸ¥çœ‹è‡ªåŠ¨é‡Šæ”¾æ± å†…å­˜ç»“æ„:
ç”±äºåœ¨ARCæ¨¡å¼ä¸‹ï¼Œæ˜¯æ— æ³•æ‰‹åŠ¨è°ƒç”¨autoreleaseï¼Œæ‰€ä»¥å°†Demoåˆ‡æ¢è‡³MRCæ¨¡å¼ï¼ˆBuild Settings -> Objectice-C Automatic Reference Countingè®¾ç½®ä¸ºNOï¼‰
//************æ‰“å°è‡ªåŠ¨é‡Šæ”¾æ± ç»“æ„************
extern void _objc_autoreleasePoolPrint(void);

//************è¿è¡Œä»£ç ************
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        //å¾ªç¯åˆ›å»ºå¯¹è±¡ï¼Œå¹¶åŠ å…¥è‡ªåŠ¨é‡Šæ”¾æ± 
        for (int i = 0; i < 5; i++) {
             NSObject *objc = [[NSObject alloc] autorelease];
        }
        //è°ƒç”¨
        _objc_autoreleasePoolPrint();
    }
}

å‘ç°æ˜¯6ä¸ªï¼Œä½†æ˜¯æˆ‘ä»¬å‹æ ˆçš„å¯¹è±¡å…¶å®åªæœ‰5ä¸ªï¼Œå…¶ä¸­çš„POOLè¡¨ç¤ºå“¨å…µï¼Œå³è¾¹ç•Œï¼Œå…¶ç›®çš„æ˜¯ä¸ºäº†é˜²æ­¢è¶Šç•Œ
æŸ¥çœ‹è‡ªåŠ¨é‡Šæ”¾æ± çš„å†…å­˜ç»“æ„ï¼Œå‘ç°ï¼Œé¡µçš„é¦–åœ°å€ä¸å“¨å…µå¯¹è±¡ç›¸å·®0x38ï¼Œè½¬æ¢æˆåè¿›åˆ¶åˆšå¥½æ˜¯56ï¼Œä¹Ÿå°±æ˜¯ AutoreleasePoolPageè‡ªå·±æœ¬èº«çš„å†…å­˜å¤§å°

å°†ä¸Šè¿°çš„æµ‹è¯•ä»£ç çš„æ•°æ®æ”¹ä¸º505ï¼Œå…¶å†…å­˜ç»“æ„å¦‚ä¸‹ï¼Œå‘ç°ç¬¬ä¸€é¡µæ»¡äº†ï¼Œå­˜å‚¨äº†504ä¸ªè¦é‡Šæ”¾çš„å¯¹è±¡ï¼Œç¬¬äºŒé¡µåªå­˜å‚¨äº†ä¸€ä¸ª
åœ¨å°†æ•°æ®æ”¹ä¸º505+506ï¼Œæ¥éªŒè¯ç¬¬äºŒé¡µæ˜¯å¦ä¹Ÿæ˜¯å­˜å‚¨504ä¸ªå¯¹è±¡
é€šè¿‡è¿è¡Œå‘ç°ï¼Œç¬¬ä¸€é¡µå­˜å‚¨504ï¼Œç¬¬äºŒé¡µå­˜å‚¨505ï¼Œç¬¬ä¸‰é¡µå­˜å‚¨2ä¸ª

æ‰€ä»¥é€šè¿‡ä¸Šè¿°æµ‹è¯•ï¼Œå¯ä»¥å¾—å‡ºä»¥ä¸‹ç»“è®º:
ç¬¬ä¸€é¡µå¯ä»¥å­˜æ”¾504ä¸ªå¯¹è±¡ï¼Œä¸”åªæœ‰ç¬¬ä¸€é¡µæœ‰å“¨å…µï¼Œå½“ä¸€é¡µå‹æ ˆæ»¡äº†ï¼Œå°±ä¼šå¼€è¾Ÿæ–°çš„ä¸€é¡µ
ç¬¬äºŒé¡µå¼€å§‹ï¼Œæœ€å¤šå¯ä»¥å­˜æ”¾505ä¸ªå¯¹è±¡
ä¸€é¡µçš„å¤§å°ç­‰äº 505 * 8 = 4040
è¿™ä¸ªç»“è®ºåŒæ ·å¯ä»¥é€šè¿‡AutoreleasePoolPageä¸­çš„SIZEæ¥å¾—åˆ°å°è¯ï¼Œä»å…¶å®šä¹‰ä¸­æˆ‘ä»¬å¯ä»¥å¾—å‡ºï¼Œä¸€é¡µçš„å¤§å°æ˜¯4096å­—èŠ‚
è€Œåœ¨å…¶æ„é€ å‡½æ•°ä¸­å¯¹è±¡çš„å‹æ ˆä½ç½®ï¼Œæ˜¯ä»é¦–åœ°å€+56å¼€å§‹çš„ï¼Œæ‰€ä»¥å¯ä»¥ä¸€é¡µä¸­å®é™…å¯ä»¥å­˜å‚¨4096-56 = 4040å­—èŠ‚
è½¬æ¢æˆå¯¹è±¡æ˜¯4040 / 8 = 505ä¸ª,å³ä¸€é¡µæœ€å¤šå¯ä»¥å­˜å‚¨505ä¸ªå¯¹è±¡ï¼Œå…¶ä¸­ç¬¬ä¸€é¡µæœ‰å“¨å…µå¯¹è±¡åªèƒ½å­˜å‚¨504ä¸ª


é¢è¯•é¢˜ï¼šå“¨å…µåœ¨ä¸€ä¸ªè‡ªåŠ¨é‡Šæ”¾æ± æœ‰å‡ ä¸ªï¼Ÿ
åªæœ‰ä¸€ä¸ªå“¨å…µå¯¹è±¡ï¼Œä¸”å“¨å…µåœ¨ç¬¬ä¸€é¡µ
ç¬¬ä¸€é¡µæœ€å¤šå¯ä»¥å­˜504ä¸ªå¯¹è±¡ï¼Œç¬¬äºŒé¡µå¼€å§‹æœ€å¤šå­˜ 505ä¸ª



2ã€å‹æ ˆå¯¹è±¡ autoreleaseFast:
è¿›å…¥autoreleaseFastæºç ï¼Œä¸»è¦æœ‰ä»¥ä¸‹å‡ æ­¥:
    è·å–å½“å‰æ“ä½œé¡µï¼Œå¹¶åˆ¤æ–­é¡µæ˜¯å¦å­˜åœ¨ä»¥åŠæ˜¯å¦æ»¡äº†
    å¦‚æœé¡µå­˜åœ¨ï¼Œä¸”æœªæ»¡ï¼Œåˆ™é€šè¿‡addæ–¹æ³•å‹æ ˆå¯¹è±¡
    å¦‚æœé¡µå­˜åœ¨ï¼Œä¸”æ»¡äº†ï¼Œåˆ™é€šè¿‡autoreleaseFullPageæ–¹æ³•å®‰æ’æ–°çš„é¡µé¢
    å¦‚æœé¡µä¸å­˜åœ¨ï¼Œåˆ™é€šè¿‡autoreleaseNoPageæ–¹æ³•åˆ›å»ºæ–°é¡µ

static inline id *autoreleaseFast(id obj)
{
    //è·å–å½“å‰æ“ä½œé¡µ
    AutoreleasePoolPage *page = hotPage();
    //åˆ¤æ–­é¡µæ˜¯å¦æ»¡äº†
    if (page && !page->full()) {
        //å¦‚æœæœªæ»¡ï¼Œåˆ™å‹æ ˆ
        return page->add(obj);
    } else if (page) {
        //å¦‚æœæ»¡äº†ï¼Œåˆ™å®‰æ’æ–°çš„é¡µé¢
        return autoreleaseFullPage(obj, page);
    } else {
        //é¡µä¸å­˜åœ¨ï¼Œåˆ™æ–°å»ºé¡µ
        return autoreleaseNoPage(obj);
    }
}


autoreleaseFullPage æ–¹æ³•:
è¿™ä¸ªæ–¹æ³•ä¸»è¦æ˜¯ç”¨äºåˆ¤æ–­å½“å‰é¡µæ˜¯å¦å·²ç»å­˜å‚¨æ»¡äº†ï¼Œå¦‚æœå½“å‰é¡µå·²ç»æ»¡äº†ï¼Œé€šè¿‡do-whileå¾ªç¯æŸ¥æ‰¾å­èŠ‚ç‚¹å¯¹åº”çš„é¡µï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆ™æ–°å»ºé¡µï¼Œå¹¶å‹æ ˆå¯¹è±¡

//æ·»åŠ è‡ªåŠ¨é‡Šæ”¾å¯¹è±¡ï¼Œå½“é¡µæ»¡çš„æ—¶å€™è°ƒç”¨è¿™ä¸ªæ–¹æ³•
static __attribute__((noinline))
id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)
{
    // The hot page is full. 
    // Step to the next non-full page, adding a new page if necessary.
    // Then add the object to that page.
    ASSERT(page == hotPage());
    ASSERT(page->full()  ||  DebugPoolAllocation);
    
    //do-whileéå†å¾ªç¯æŸ¥æ‰¾ç•Œé¢æ˜¯å¦æ»¡äº†
    do {
        //å¦‚æœå­é¡µé¢å­˜åœ¨ï¼Œåˆ™å°†é¡µé¢æ›¿æ¢ä¸ºå­é¡µé¢
        if (page->child) page = page->child;
        //å¦‚æœå­é¡µé¢ä¸å­˜åœ¨ï¼Œåˆ™æ–°å»ºé¡µé¢
        else page = new AutoreleasePoolPage(page);
    } while (page->full());

    //è®¾ç½®ä¸ºå½“å‰æ“ä½œé¡µé¢
    setHotPage(page);
    //å¯¹è±¡å‹æ ˆ
    return page->add(obj);
}
ä»AutoreleasePoolPageåˆå§‹åŒ–æ–¹æ³•ä¸­å¯ä»¥çœ‹å‡ºï¼Œä¸»è¦æ˜¯é€šè¿‡æ“ä½œchildå¯¹è±¡ï¼Œå°†å½“å‰é¡µçš„childæŒ‡å‘æ–°å»ºé¡µé¢ï¼Œç”±æ­¤å¯ä»¥å¾—å‡ºé¡µæ˜¯é€šè¿‡åŒå‘é“¾è¡¨è¿æ¥


add æ–¹æ³•:
è¿™ä¸ªæ–¹æ³•ä¸»è¦æ˜¯æ·»åŠ é‡Šæ”¾å¯¹è±¡ï¼Œå…¶åº•å±‚æ˜¯å®ç°æ˜¯é€šè¿‡nextæŒ‡é’ˆå­˜å‚¨é‡Šæ”¾å¯¹è±¡ï¼Œå¹¶å°†nextæŒ‡é’ˆé€’å¢ï¼Œè¡¨ç¤ºä¸‹ä¸€ä¸ªé‡Šæ”¾å¯¹è±¡å­˜å‚¨çš„ä½ç½®ã€‚
ä»è¿™é‡Œå¯ä»¥çœ‹å‡ºé¡µæ˜¯é€šè¿‡æ ˆç»“æ„å­˜å‚¨



3ã€autorelease åº•å±‚åˆ†æ:
ä»¬é€šè¿‡autoreleaseæ–¹æ³•ï¼Œåœ¨MRCæ¨¡å¼ä¸‹ï¼Œå°†å¯¹è±¡å‹æ ˆåˆ°è‡ªåŠ¨é‡Šæ”¾æ± ï¼Œä¸‹é¢æ¥åˆ†æå…¶åº•å±‚å®ç°

æŸ¥çœ‹autoreleaseæ–¹æ³•æºç :
å¦‚æœä¸æ˜¯å¯¹è±¡ æˆ–è€… æ˜¯å°å¯¹è±¡ï¼Œåˆ™ç›´æ¥è¿”å›
å¦‚æœæ˜¯å¯¹è±¡ï¼Œåˆ™è°ƒç”¨å¯¹è±¡çš„autoreleaseè¿›è¡Œé‡Šæ”¾
__attribute__((aligned(16), flatten, noinline))
id
objc_autorelease(id obj)
{
    //å¦‚æœä¸æ˜¯å¯¹è±¡ï¼Œåˆ™ç›´æ¥è¿”å›
    if (!obj) return obj;
    //å¦‚æœæ˜¯å°å¯¹è±¡ï¼Œä¹Ÿç›´æ¥è¿”å›
    if (obj->isTaggedPointer()) return obj;
    return obj->autorelease();
}


è¿›å…¥å¯¹è±¡çš„autoreleaseå®ç°
ğŸ‘‡
inline id 
objc_object::autorelease()
{
    ASSERT(!isTaggedPointer());
    //åˆ¤æ–­æ˜¯å¦æ˜¯è‡ªå®šä¹‰ç±»
    if (fastpath(!ISA()->hasCustomRR())) {
        return rootAutorelease();
    }

    return ((id(*)(objc_object *, SEL))objc_msgSend)(this, @selector(autorelease));
}
ğŸ‘‡
inline id 
objc_object::rootAutorelease()
{
    //å¦‚æœæ˜¯å°å¯¹è±¡ï¼Œç›´æ¥è¿”å›
    if (isTaggedPointer()) return (id)this;
    if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this;

    return rootAutorelease2();
}
ğŸ‘‡
__attribute__((noinline,used))
id 
objc_object::rootAutorelease2()
{
    ASSERT(!isTaggedPointer());
    return AutoreleasePoolPage::autorelease((id)this);
}
ğŸ‘‡
static inline id autorelease(id obj)
{
    ASSERT(obj);
    ASSERT(!obj->isTaggedPointer());
    //autoreleaseFast å‹æ ˆæ“ä½œ
    id *dest __unused = autoreleaseFast(obj);
    ASSERT(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);
    return obj;
}
æ— è®ºæ˜¯å‹æ ˆå“¨å…µå¯¹è±¡ï¼Œè¿˜æ˜¯æ™®é€šå¯¹è±¡ï¼Œéƒ½ä¼šæ¥åˆ°autoreleaseFastæ–¹æ³•ï¼Œåªæ˜¯åŒºåˆ«æ ‡è¯†ä¸åŒè€Œä»¥


objc_autoreleasePoolPop æºç åˆ†æ:
åœ¨objc_autoreleasePoolPopæ–¹æ³•ä¸­æœ‰ä¸ªå‚æ•°ï¼Œåœ¨clangåˆ†ææ—¶ï¼Œå‘ç°ä¼ å…¥çš„å‚æ•°æ˜¯pushå‹æ ˆåè¿”å›çš„å“¨å…µå¯¹è±¡ï¼Œå³ctxtï¼Œå…¶ç›®çš„æ˜¯é¿å…å‡ºæ ˆæ··ä¹±ï¼Œé˜²æ­¢å°†åˆ«çš„å¯¹è±¡å‡ºæ ˆ

è¿›å…¥popæºç å®ç°ï¼Œä¸»è¦ç”±ä»¥ä¸‹å‡ æ­¥:
ç©ºé¡µé¢çš„å¤„ç†ï¼Œå¹¶æ ¹æ®tokenè·å–page
å®¹é”™å¤„ç†
é€šè¿‡popPageå‡ºæ ˆé¡µ

//å‡ºæ ˆ
static inline void
pop(void *token)
{
    AutoreleasePoolPage *page;
    id *stop;
   //åˆ¤æ–­å¯¹è±¡æ˜¯å¦æ˜¯ç©ºå ä½ç¬¦
    if (token == (void*)EMPTY_POOL_PLACEHOLDER) {
        //å¦‚æœå½“æ˜¯ç©ºå ä½ç¬¦
        // Popping the top-level placeholder pool.
        //è·å–å½“å‰é¡µ
        page = hotPage();
        if (!page) {
            // Pool was never used. Clear the placeholder.
            //å¦‚æœå½“å‰é¡µä¸å­˜åœ¨ï¼Œåˆ™æ¸…é™¤ç©ºå ä½ç¬¦
            return setHotPage(nil);
        }
        // Pool was used. Pop its contents normally.
        // Pool pages remain allocated for re-use as usual.
        //å¦‚æœå½“å‰é¡µå­˜åœ¨ï¼Œåˆ™å°†å½“å‰é¡µè®¾ç½®ä¸ºcoldPage,tokenè®¾ç½®ä¸ºcoldPageçš„å¼€å§‹ä½ç½®
        page = coldPage();
        token = page->begin();
    } else {
        //è·å–tokenæ‰€åœ¨çš„é¡µ
        page = pageForPointer(token);
    }
    
    stop = (id *)token;
    //åˆ¤æ–­æœ€åä¸€ä¸ªä½ç½®ï¼Œæ˜¯å¦æ˜¯å“¨å…µ
    if (*stop != POOL_BOUNDARY) {
        //æœ€åä¸€ä¸ªä½ç½®ä¸æ˜¯å“¨å…µï¼Œå³æœ€åä¸€ä¸ªä½ç½®æ˜¯ä¸€ä¸ªå¯¹è±¡
        if (stop == page->begin()  &&  !page->parent) {
            //å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªä½ç½®ï¼Œä¸”æ²¡æœ‰çˆ¶èŠ‚ç‚¹ï¼Œä»€ä¹ˆä¹Ÿä¸åš
            // Start of coldest page may correctly not be POOL_BOUNDARY:
            // 1. top-level pool is popped, leaving the cold page in place
            // 2. an object is autoreleased with no pool
        } else {
            //å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªä½ç½®ï¼Œä¸”æœ‰çˆ¶èŠ‚ç‚¹ï¼Œåˆ™å‡ºç°äº†æ··ä¹±
            // Error. For bincompat purposes this is not 
            // fatal in executables built with old SDKs.
            return badPop(token);
        }
    }

    if (slowpath(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) {
        return popPageDebug(token, page, stop);
    }
    //å‡ºæ ˆé¡µ
    return popPage<false>(token, page, stop);
}

è¿›å…¥popPageæºç ï¼Œå…¶ä¸­ä¼ å…¥çš„allowDebugä¸ºfalseï¼Œåˆ™é€šè¿‡releaseUntilå‡ºæ ˆå½“å‰é¡µstopä½ç½®ä¹‹å‰çš„æ‰€æœ‰å¯¹è±¡ï¼Œå³å‘æ ˆä¸­çš„å¯¹è±¡å‘é€releaseæ¶ˆæ¯ï¼Œç›´åˆ°é‡åˆ°ä¼ å…¥çš„å“¨å…µå¯¹è±¡

//å‡ºæ ˆé¡µé¢
template<bool allowDebug>
    static void
    popPage(void *token, AutoreleasePoolPage *page, id *stop)
{
    if (allowDebug && PrintPoolHiwat) printHiwat();
    //å‡ºæ ˆå½“å‰æ“ä½œé¡µé¢å¯¹è±¡
    page->releaseUntil(stop);

    // memory: delete empty children åˆ é™¤ç©ºå­é¡¹
    if (allowDebug && DebugPoolAllocation  &&  page->empty()) {
        // special case: delete everything during page-per-pool debugging
        //è°ƒè¯•æœŸé—´åˆ é™¤æ¯ä¸ªç‰¹æ®Šæƒ…å†µä¸‹çš„æ‰€æœ‰æ± 
        //è·å–å½“å‰é¡µé¢çš„çˆ¶èŠ‚ç‚¹
        AutoreleasePoolPage *parent = page->parent;
        //å°†å½“å‰é¡µé¢æ€æ‰
        page->kill();
        //è®¾ç½®æ“ä½œé¡µé¢ä¸ºçˆ¶èŠ‚ç‚¹é¡µé¢
        setHotPage(parent);
    }
    else if (allowDebug && DebugMissingPools  &&  page->empty()  &&  !page->parent) {
        // special case: delete everything for pop(top)
        // when debugging missing autorelease pools
        //ç‰¹æ®Šæƒ…å†µï¼šè°ƒè¯•ä¸¢å¤±çš„è‡ªåŠ¨é‡Šæ”¾æ± æ—¶åˆ é™¤popï¼ˆtopï¼‰çš„æ‰€æœ‰å†…å®¹
        page->kill();
        setHotPage(nil);
    }
    else if (page->child) {
        // hysteresis: keep one empty child if page is more than half full å¦‚æœé¡µé¢å·²æ»¡ä¸€åŠä»¥ä¸Šï¼Œåˆ™ä¿ç•™ä¸€ä¸ªç©ºå­çº§
        if (page->lessThanHalfFull()) {
            page->child->kill();
        }
        else if (page->child->child) {
            page->child->child->kill();
        }
    }
}

è¿›å…¥releaseUntilå®ç°ï¼Œä¸»è¦æ˜¯é€šè¿‡å¾ªç¯éå†ï¼Œåˆ¤æ–­å¯¹è±¡æ˜¯å¦ç­‰äºstopï¼Œå…¶ç›®çš„æ˜¯é‡Šæ”¾stopä¹‹å‰çš„æ‰€æœ‰çš„å¯¹è±¡ï¼Œ
é¦–å…ˆé€šè¿‡è·å–pageçš„nexté‡Šæ”¾å¯¹è±¡ï¼ˆå³pageçš„æœ€åä¸€ä¸ªå¯¹è±¡ï¼‰ï¼Œå¹¶å¯¹nextè¿›è¡Œé€’å‡ï¼Œè·å–ä¸Šä¸€ä¸ªå¯¹è±¡
åˆ¤æ–­æ˜¯å¦æ˜¯å“¨å…µå¯¹è±¡ï¼Œå¦‚æœä¸æ˜¯åˆ™è‡ªåŠ¨è°ƒç”¨objc_releaseé‡Šæ”¾
//é‡Šæ”¾åˆ°stopä½ç½®ä¹‹å‰çš„æ‰€æœ‰å¯¹è±¡
void releaseUntil(id *stop) 
{
    // Not recursive: we don't want to blow out the stack  ä¸æ˜¯é€’å½’çš„ï¼šæˆ‘ä»¬ä¸æƒ³ç ´åå †æ ˆ
    // if a thread accumulates a stupendous amount of garbage
    //åˆ¤æ–­ä¸‹ä¸€ä¸ªå¯¹è±¡æ˜¯å¦ç­‰äºstopï¼Œå¦‚æœä¸ç­‰äºï¼Œåˆ™è¿›å…¥whileå¾ªç¯
    while (this->next != stop) {
        // Restart from hotPage() every time, in case -release 
        // autoreleased more objects æ¯æ¬¡ä»hotPageï¼ˆï¼‰é‡æ–°å¯åŠ¨ï¼Œä»¥é˜²-releaseè‡ªåŠ¨é‡Šæ”¾æ›´å¤šå¯¹è±¡
        //è·å–å½“å‰æ“ä½œé¡µé¢ï¼Œå³hoté¡µé¢
        AutoreleasePoolPage *page = hotPage();

        // fixme I think this `while` can be `if`, but I can't prove it
        //å¦‚æœå½“å‰é¡µæ˜¯ç©ºçš„
        while (page->empty()) {
            //å°†pageèµ‹å€¼ä¸ºçˆ¶èŠ‚ç‚¹é¡µ
            page = page->parent;
            //å¹¶è®¾ç½®å½“å‰é¡µä¸ºçˆ¶èŠ‚ç‚¹é¡µ
            setHotPage(page);
        }

        page->unprotect();
        //nextè¿›è¡Œ--æ“ä½œï¼Œå³å‡ºæ ˆ
        id obj = *--page->next;
        //å°†é¡µç´¢å¼•ä½ç½®ç½®ä¸ºSCRIBBLEï¼Œè¡¨ç¤ºå·²ç»è¢«é‡Šæ”¾
        memset((void*)page->next, SCRIBBLE, sizeof(*page->next));
        page->protect();

        if (obj != POOL_BOUNDARY) {
            //é‡Šæ”¾
            objc_release(obj);
        }
    }
    //è®¾ç½®å½“å‰é¡µ
    setHotPage(this);

#if DEBUG
    // we expect any children to be completely empty
    for (AutoreleasePoolPage *page = child; page; page = page->child) {
        ASSERT(page->empty());
    }
#endif
}

è¿›å…¥killå®ç°ï¼Œä¸»è¦æ˜¯é”€æ¯å½“å‰é¡µï¼Œå°†å½“å‰é¡µèµ‹å€¼ä¸ºçˆ¶èŠ‚ç‚¹é¡µï¼Œå¹¶å°†çˆ¶èŠ‚ç‚¹é¡µçš„childå¯¹è±¡æŒ‡é’ˆç½®ä¸ºnil
//é”€æ¯
void kill() 
{
    // Not recursive: we don't want to blow out the stack 
    // if a thread accumulates a stupendous amount of garbage
    AutoreleasePoolPage *page = this;
    //è·å–æœ€åä¸€ä¸ªé¡µ
    while (page->child) page = page->child;

    AutoreleasePoolPage *deathptr;
    do {
        deathptr = page;
        //å­èŠ‚ç‚¹ å˜æˆ çˆ¶èŠ‚ç‚¹
        page = page->parent;
        if (page) {
            page->unprotect();
            //å­èŠ‚ç‚¹ä¸ºnil
            page->child = nil;
            page->protect();
        }
        delete deathptr;
    } while (deathptr != this);
}


é’ˆå¯¹è‡ªåŠ¨é‡Šæ”¾æ± çš„pushå’Œpopï¼Œæ€»ç»“å¦‚ä¸‹:
åœ¨è‡ªåŠ¨é‡Šæ”¾æ± çš„å‹æ ˆï¼ˆå³pushï¼‰æ“ä½œä¸­
    å½“æ²¡æœ‰poolï¼Œå³åªæœ‰ç©ºå ä½ç¬¦ï¼ˆå­˜å‚¨åœ¨tlsä¸­ï¼‰æ—¶ï¼Œåˆ™åˆ›å»ºé¡µï¼Œå‹æ ˆå“¨å…µå¯¹è±¡
    åœ¨é¡µä¸­å‹æ ˆæ™®é€šå¯¹è±¡ä¸»è¦æ˜¯é€šè¿‡nextæŒ‡é’ˆé€’å¢è¿›è¡Œçš„ï¼Œ
    å½“é¡µæ»¡äº†æ—¶ï¼Œéœ€è¦è®¾ç½®é¡µçš„childå¯¹è±¡ä¸ºæ–°å»ºé¡µ
åœ¨è‡ªåŠ¨é‡Šæ”¾æ± çš„å‡ºæ ˆï¼ˆå³popï¼‰æ“ä½œä¸­
    åœ¨é¡µä¸­å‡ºæ ˆæ™®é€šå¯¹è±¡ä¸»è¦æ˜¯é€šè¿‡nextæŒ‡é’ˆé€’å‡è¿›è¡Œçš„ï¼Œ
    å½“é¡µç©ºäº†æ—¶ï¼Œéœ€è¦èµ‹å€¼é¡µçš„parentå¯¹è±¡ä¸ºå½“å‰é¡µ



==================================================