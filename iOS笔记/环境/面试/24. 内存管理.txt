#####
retainã€retainCountã€releaseã€deallocçš„åº•å±‚æºç åˆ†æ
#####

iOSä¸­çš„å†…å­˜ç®¡ç†æ–¹æ¡ˆï¼Œå¤§è‡´å¯ä»¥åˆ†ä¸ºä¸¤ç±»ï¼šMRCï¼ˆæ‰‹åŠ¨å†…å­˜ç®¡ç†ï¼‰å’ŒARCï¼ˆè‡ªåŠ¨å†…å­˜ç®¡ç†ï¼‰

MRC:
åœ¨MRCæ—¶ä»£ï¼Œç³»ç»Ÿæ˜¯é€šè¿‡å¯¹è±¡çš„å¼•ç”¨è®¡æ•°æ¥åˆ¤æ–­ä¸€ä¸ªæ˜¯å¦é”€æ¯ï¼Œæœ‰ä»¥ä¸‹è§„åˆ™
å¯¹è±¡è¢«åˆ›å»ºæ—¶å¼•ç”¨è®¡æ•°éƒ½ä¸º1
å½“å¯¹è±¡è¢«å…¶ä»–æŒ‡é’ˆå¼•ç”¨æ—¶ï¼Œéœ€è¦æ‰‹åŠ¨è°ƒç”¨[objc retain]ï¼Œä½¿å¯¹è±¡çš„å¼•ç”¨è®¡æ•°+1
å½“æŒ‡é’ˆå˜é‡ä¸å†ä½¿ç”¨å¯¹è±¡æ—¶ï¼Œéœ€è¦æ‰‹åŠ¨è°ƒç”¨[objc release]æ¥é‡Šæ”¾å¯¹è±¡ï¼Œä½¿å¯¹è±¡çš„å¼•ç”¨è®¡æ•°-1
å½“ä¸€ä¸ªå¯¹è±¡çš„å¼•ç”¨è®¡æ•°ä¸º0æ—¶ï¼Œç³»ç»Ÿå°±ä¼šé”€æ¯è¿™ä¸ªå¯¹è±¡
æ‰€ä»¥ï¼Œåœ¨MRCæ¨¡å¼ä¸‹ï¼Œå¿…é¡»éµå®ˆï¼šè°åˆ›å»ºï¼Œè°é‡Šæ”¾ï¼Œè°å¼•ç”¨ï¼Œè°ç®¡ç†

ARC:
ARCæ¨¡å¼æ˜¯åœ¨WWDC2011å’ŒiOS5å¼•å…¥çš„è‡ªåŠ¨ç®¡ç†æœºåˆ¶ï¼Œå³è‡ªåŠ¨å¼•ç”¨è®¡æ•°ã€‚æ˜¯ç¼–è¯‘å™¨çš„ä¸€ç§ç‰¹æ€§ã€‚
å…¶è§„åˆ™ä¸MRCä¸€è‡´ï¼ŒåŒºåˆ«åœ¨äºï¼ŒARCæ¨¡å¼ä¸‹ä¸éœ€è¦æ‰‹åŠ¨retainã€releaseã€autoreleaseã€‚ç¼–è¯‘å™¨ä¼šåœ¨é€‚å½“çš„ä½ç½®æ’å…¥releaseå’Œautoreleaseã€‚


å†…å­˜å¸ƒå±€:
å†…å­˜çš„äº”å¤§åŒºã€‚å…¶å®é™¤äº†å†…å­˜åŒºï¼Œè¿˜æœ‰å†…æ ¸åŒºå’Œä¿ç•™åŒº
å†…æ ¸åŒºï¼šç³»ç»Ÿç”¨æ¥è¿›è¡Œå†…æ ¸å¤„ç†æ“ä½œçš„åŒºåŸŸ
ä¿ç•™åŒºï¼šé¢„ç•™ç»™ç³»ç»Ÿå¤„ç†nilç­‰

ä¸ºä»€ä¹ˆäº”å¤§åŒºçš„æœ€åå†…å­˜åœ°å€æ˜¯ä»0x00400000å¼€å§‹çš„ã€‚å…¶ä¸»è¦åŸå› æ˜¯0x00000000è¡¨ç¤ºnilï¼Œä¸èƒ½ç›´æ¥ç”¨nilè¡¨ç¤ºä¸€ä¸ªæ®µï¼Œæ‰€ä»¥å•ç‹¬ç»™äº†ä¸€æ®µå†…å­˜ç”¨äºå¤„ç†nilç­‰æƒ…å†µ


å…¨å±€å˜é‡å’Œå±€éƒ¨å˜é‡åœ¨å†…å­˜ä¸­æ˜¯å¦æœ‰åŒºåˆ«ï¼Ÿå¦‚æœæœ‰ï¼Œæ˜¯ä»€ä¹ˆåŒºåˆ«ï¼Ÿ
æœ‰åŒºåˆ«
å…¨å±€å˜é‡ä¿å­˜åœ¨å†…å­˜çš„å…¨å±€å­˜å‚¨åŒºï¼ˆå³bss+dataæ®µï¼‰ï¼Œå ç”¨é™æ€çš„å­˜å‚¨å•å…ƒ
å±€éƒ¨å˜é‡ä¿å­˜åœ¨æ ˆä¸­ï¼Œåªæœ‰åœ¨æ‰€åœ¨å‡½æ•°è¢«è°ƒç”¨æ—¶æ‰åŠ¨æ€çš„ä¸ºå˜é‡åˆ†é…å­˜å‚¨å•å…ƒ


Blockä¸­å¯ä»¥ä¿®æ”¹å…¨å±€å˜é‡ï¼Œå…¨å±€é™æ€å˜é‡ï¼Œå±€éƒ¨é™æ€å˜é‡ï¼Œå±€éƒ¨å˜é‡å—ï¼Ÿ
å¯ä»¥ä¿®æ”¹å…¨å±€å˜é‡ï¼Œå…¨å±€é™æ€å˜é‡ï¼Œå› ä¸ºå…¨å±€å˜é‡ å’Œ é™æ€å…¨å±€å˜é‡æ˜¯å…¨å±€çš„ï¼Œä½œç”¨åŸŸå¾ˆå¹¿
å¯ä»¥ä¿®æ”¹å±€éƒ¨é™æ€å˜é‡ï¼Œä¸å¯ä»¥ä¿®æ”¹å±€éƒ¨å˜é‡
å±€éƒ¨é™æ€å˜é‡ï¼ˆstaticä¿®é¥°çš„ï¼‰ å’Œ å±€éƒ¨å˜é‡ï¼Œè¢«blockä»å¤–é¢æ•è·ï¼Œæˆä¸º __main_block_impl_0è¿™ä¸ªç»“æ„ä½“çš„æˆå‘˜å˜é‡
å±€éƒ¨å˜é‡æ˜¯ä»¥å€¼æ–¹å¼ä¼ é€’åˆ°blockçš„æ„é€ å‡½æ•°ä¸­çš„ï¼Œåªä¼šæ•è·blockä¸­ä¼šç”¨åˆ°çš„å˜é‡ï¼Œç”±äºåªæ•è·äº†å˜é‡çš„å€¼ï¼Œå¹¶éå†…å­˜åœ°å€ï¼Œæ‰€ä»¥åœ¨blockå†…éƒ¨ä¸èƒ½æ”¹å˜å±€éƒ¨å˜é‡çš„å€¼
å±€éƒ¨é™æ€å˜é‡æ˜¯ä»¥æŒ‡é’ˆå½¢å¼ï¼Œè¢«blockæ•è·çš„ï¼Œç”±äºæ•è·çš„æ˜¯æŒ‡é’ˆï¼Œæ‰€ä»¥å¯ä»¥ä¿®æ”¹å±€éƒ¨é™æ€å˜é‡çš„å€¼
ARCç¯å¢ƒä¸‹ï¼Œä¸€æ—¦ä½¿ç”¨__blockä¿®é¥°å¹¶åœ¨blockä¸­ä¿®æ”¹ï¼Œå°±ä¼šè§¦å‘copyï¼Œblockå°±ä¼šä»æ ˆåŒºcopyåˆ°å †åŒºï¼Œæ­¤æ—¶çš„blockæ˜¯å †åŒºblock
ARCæ¨¡å¼ä¸‹ï¼ŒBlockä¸­å¼•ç”¨idç±»å‹çš„æ•°æ®ï¼Œæ— è®ºæœ‰æ²¡æœ‰__blockä¿®é¥°ï¼Œéƒ½ä¼šretainï¼Œå¯¹äºåŸºç¡€æ•°æ®ç±»å‹ï¼Œæ²¡æœ‰__blockå°±æ— æ³•ä¿®æ”¹å˜é‡å€¼ï¼›å¦‚æœæœ‰__blockä¿®é¥°ï¼Œä¹Ÿæ˜¯åœ¨åº•å±‚ä¿®æ”¹__Block_byref_a_0ç»“æ„ä½“ï¼Œå°†å…¶å†…éƒ¨çš„forwardingæŒ‡é’ˆæŒ‡å‘copyåçš„åœ°å€ï¼Œæ¥è¾¾åˆ°å€¼çš„ä¿®æ”¹



å†…å­˜ç®¡ç†æ–¹æ¡ˆ:
é™¤äº†å‰æ–‡æåŠçš„MRCå’ŒARCï¼Œè¿˜æœ‰ä»¥ä¸‹ä¸‰ç§
Tagged Pointerï¼šä¸“é—¨ç”¨æ¥å¤„ç†å°å¯¹è±¡ï¼Œä¾‹å¦‚NSNumberã€NSDateã€å°NSStringç­‰
Nonpointer_isaï¼šéæŒ‡é’ˆç±»å‹çš„isaï¼Œä¸»è¦æ˜¯ç”¨æ¥ä¼˜åŒ–64ä½åœ°å€
SideTablesï¼šæ•£åˆ—è¡¨ï¼Œåœ¨æ•£åˆ—è¡¨ä¸­ä¸»è¦æœ‰ä¸¤ä¸ªè¡¨ï¼Œåˆ†åˆ«æ˜¯å¼•ç”¨è®¡æ•°è¡¨ã€å¼±å¼•ç”¨è¡¨


//*********ä»£ç 1*********
- (void)taggedPointerDemo {
  self.queue = dispatch_queue_create("com.cjl.cn", DISPATCH_QUEUE_CONCURRENT);
    
    for (int i = 0; i<10000; i++) {
        dispatch_async(self.queue, ^{
            self.nameStr = [NSString stringWithFormat:@"CJL"];  // alloc å † iOSä¼˜åŒ– - taggedpointer
             NSLog(@"%@",self.nameStr);
        });
    }
}

//*********ä»£ç 2*********
- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    NSLog(@"æ¥äº†");
    for (int i = 0; i<10000; i++) {
        dispatch_async(self.queue, ^{
            self.nameStr = [NSString stringWithFormat:@"CJL_è¶ŠåŠªåŠ›ï¼Œè¶Šå¹¸è¿ï¼ï¼ï¼"];
            NSLog(@"%@",self.nameStr);
        });
    }
}
å‘ç°taggedPointerDemoå•ç‹¬è¿è¡Œæ²¡æœ‰é—®é¢˜ï¼Œå½“è§¦å‘touchesBeganæ–¹æ³•åã€‚ç¨‹åºä¼šå´©æºƒï¼Œå´©æºƒçš„åŸå› æ˜¯å¤šæ¡çº¿ç¨‹åŒæ—¶å¯¹ä¸€ä¸ªå¯¹è±¡è¿›è¡Œé‡Šæ”¾ï¼Œå¯¼è‡´äº† è¿‡æ¸¡é‡Šæ”¾æ‰€ä»¥å´©æºƒã€‚
å…¶æ ¹æœ¬åŸå› æ˜¯å› ä¸ºnameStråœ¨åº•å±‚çš„ç±»å‹ä¸ä¸€è‡´å¯¼è‡´çš„ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒè¯•çœ‹å‡º

taggedPointerDemoæ–¹æ³•ä¸­çš„nameStrç±»å‹æ˜¯ NSTaggedPointerStringï¼Œå­˜å‚¨åœ¨å¸¸é‡åŒºã€‚å› ä¸ºnameStråœ¨allocåˆ†é…æ—¶åœ¨å †åŒºï¼Œç”±äºè¾ƒå°ï¼Œæ‰€ä»¥ç»è¿‡xcodeä¸­iOSçš„ä¼˜åŒ–ï¼Œæˆäº†NSTaggedPointerStringç±»å‹ï¼Œå­˜å‚¨åœ¨å¸¸é‡åŒº
touchesBeganæ–¹æ³•ä¸­çš„nameStrç±»å‹æ˜¯ NSCFStringç±»å‹ï¼Œå­˜å‚¨åœ¨å †ä¸Š


NSStringçš„å†…å­˜ç®¡ç†:
æˆ‘ä»¬å¯ä»¥é€šè¿‡NSStringåˆå§‹åŒ–çš„ä¸¤ç§æ–¹å¼ï¼Œæ¥æµ‹è¯•NSStringçš„å†…å­˜ç®¡ç†
é€šè¿‡ WithString + @""æ–¹å¼åˆå§‹åŒ–
é€šè¿‡ WithFormatæ–¹å¼åˆå§‹åŒ–
#define KLog(_c) NSLog(@"%@ -- %p -- %@",_c,_c,[_c class]);

- (void)testNSString{
    //åˆå§‹åŒ–æ–¹å¼ä¸€ï¼šé€šè¿‡ WithString + @""æ–¹å¼
    NSString *s1 = @"1";
    NSString *s2 = [[NSString alloc] initWithString:@"222"];
    NSString *s3 = [NSString stringWithString:@"33"];
    
    KLog(s1);// __NSCFConstantString
    KLog(s2);// __NSCFConstantString
    KLog(s3);// __NSCFConstantString
    
    //åˆå§‹åŒ–æ–¹å¼äºŒï¼šé€šè¿‡ WithFormat
    //å­—ç¬¦ä¸²é•¿åº¦åœ¨9ä»¥å†…
    NSString *s4 = [NSString stringWithFormat:@"123456789"];
    NSString *s5 = [[NSString alloc] initWithFormat:@"123456789"];
    
    //å­—ç¬¦ä¸²é•¿åº¦å¤§äº9
    NSString *s6 = [NSString stringWithFormat:@"1234567890"];
    NSString *s7 = [[NSString alloc] initWithFormat:@"1234567890"];
    
    KLog(s4);// NSTaggedPointerString
    KLog(s5);// NSTaggedPointerString
    KLog(s6);// __NSCFString
    KLog(s7);// __NSCFString
}

ä»ä¸Šé¢å¯ä»¥æ€»ç»“å‡ºï¼ŒNSStringçš„å†…å­˜ç®¡ç†ä¸»è¦åˆ†ä¸º3ç§
__NSCFConstantStringï¼šå­—ç¬¦ä¸²å¸¸é‡ï¼Œæ˜¯ä¸€ç§ç¼–è¯‘æ—¶å¸¸é‡ï¼ŒretainCountå€¼å¾ˆå¤§ï¼Œå¯¹å…¶æ“ä½œï¼Œä¸ä¼šå¼•èµ·å¼•ç”¨è®¡æ•°å˜åŒ–ï¼Œå­˜å‚¨åœ¨å­—ç¬¦ä¸²å¸¸é‡åŒº
__NSCFStringï¼šæ˜¯åœ¨è¿è¡Œæ—¶åˆ›å»ºçš„NSStringå­ç±»ï¼Œåˆ›å»ºåå¼•ç”¨è®¡æ•°ä¼šåŠ 1ï¼Œå­˜å‚¨åœ¨å †ä¸Š
NSTaggedPointerStringï¼šæ ‡ç­¾æŒ‡é’ˆï¼Œæ˜¯è‹¹æœåœ¨64ä½ç¯å¢ƒä¸‹å¯¹NSStringã€NSNumberç­‰å¯¹è±¡åšçš„ä¼˜åŒ–ã€‚å¯¹äºNSStringå¯¹è±¡æ¥è¯´
å½“å­—ç¬¦ä¸²æ˜¯ç”±æ•°å­—ã€è‹±æ–‡å­—æ¯ç»„åˆä¸”é•¿åº¦å°äºç­‰äº9æ—¶ï¼Œä¼šè‡ªåŠ¨æˆä¸ºNSTaggedPointerStringç±»å‹ï¼Œå­˜å‚¨åœ¨å¸¸é‡åŒº
å½“æœ‰ä¸­æ–‡æˆ–è€…å…¶ä»–ç‰¹æ®Šç¬¦å·æ—¶ï¼Œä¼šç›´æ¥æˆä¸º__NSCFStringç±»å‹ï¼Œå­˜å‚¨åœ¨å †åŒº


Tagged Pointer å°å¯¹è±¡:
æ¢ç´¢å°å¯¹è±¡çš„å¼•ç”¨è®¡æ•°å¤„ç†ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦è¿›å…¥objcæºç ä¸­æŸ¥çœ‹retainã€releaseæºç  ä¸­å¯¹ Tagged Pointerå°å¯¹è±¡çš„å¤„ç†

å°å¯¹è±¡çš„å¼•ç”¨è®¡æ•°å¤„ç†åˆ†æ:
æŸ¥çœ‹setProperty -> reallySetPropertyæºç ï¼Œå…¶ä¸­æ˜¯å¯¹æ–°å€¼retainï¼Œæ—§å€¼release
è¿›å…¥objc_retainã€objc_releaseæºç ,åœ¨è¿™é‡Œéƒ½åˆ¤æ–­æ˜¯å¦æ˜¯å°å¯¹è±¡ï¼Œå¦‚æœæ˜¯å°å¯¹è±¡ï¼Œåˆ™ä¸ä¼šè¿›è¡Œretainæˆ–è€…releaseï¼Œä¼šç›´æ¥è¿”å›ã€‚å› æ­¤å¯ä»¥å¾—å‡ºä¸€ä¸ªç»“è®ºï¼šå¦‚æœå¯¹è±¡æ˜¯å°å¯¹è±¡ï¼Œä¸ä¼šè¿›è¡Œretain å’Œ release

å°å¯¹è±¡çš„åœ°å€åˆ†æ:
ç»§ç»­ä»¥NSStringä¸ºä¾‹ï¼Œå¯¹äºNSStringæ¥è¯´
ä¸€èˆ¬çš„NSStringå¯¹è±¡æŒ‡é’ˆï¼Œéƒ½æ˜¯stringå€¼ + æŒ‡é’ˆåœ°å€ï¼Œä¸¤è€…æ˜¯åˆ†å¼€çš„
å¯¹äºTagged PointeræŒ‡é’ˆï¼Œå…¶æŒ‡é’ˆ+å€¼ï¼Œéƒ½èƒ½åœ¨å°å¯¹è±¡ä¸­ä½“ç°ã€‚
æ‰€ä»¥Tagged Pointer æ—¢åŒ…å«æŒ‡é’ˆï¼Œä¹ŸåŒ…å«å€¼

å…¶ä¸­çš„_read_imagesæºç æœ‰ä¸€ä¸ªæ–¹æ³•å¯¹å°å¯¹è±¡è¿›è¡Œäº†å¤„ç†ï¼Œå³initializeTaggedPointerObfuscatoræ–¹æ³•
è¿›å…¥_read_images -> initializeTaggedPointerObfuscatoræºç å®ç°
static void
initializeTaggedPointerObfuscator(void)
{
    
    if (sdkIsOlderThan(10_14, 12_0, 12_0, 5_0, 3_0) ||
        // Set the obfuscator to zero for apps linked against older SDKs,
        // in case they're relying on the tagged pointer representation.
        DisableTaggedPointerObfuscation) {
        objc_debug_taggedpointer_obfuscator = 0;
    }
    //åœ¨iOS14ä¹‹åï¼Œå¯¹å°å¯¹è±¡è¿›è¡Œäº†æ··æ·†ï¼Œé€šè¿‡ä¸æ“ä½œ+_OBJC_TAG_MASKæ··æ·†
    else {
        // Pull random data into the variable, then shift away all non-payload bits.
        arc4random_buf(&objc_debug_taggedpointer_obfuscator,
                       sizeof(objc_debug_taggedpointer_obfuscator));
        objc_debug_taggedpointer_obfuscator &= ~_OBJC_TAG_MASK;
    }
}
åœ¨iOS14ä¹‹åï¼ŒTagged Pointeré‡‡ç”¨äº†æ··æ·†å¤„ç†
æˆ‘ä»¬å¯ä»¥åœ¨æºç ä¸­é€šè¿‡objc_debug_taggedpointer_obfuscatoræŸ¥æ‰¾taggedPointerçš„ç¼–ç å’Œè§£ç ï¼Œæ¥æŸ¥çœ‹åº•å±‚æ˜¯å¦‚ä½•æ··æ·†å¤„ç†çš„

//ç¼–ç 
static inline void * _Nonnull
_objc_encodeTaggedPointer(uintptr_t ptr)
{
    return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);
}
//ç¼–ç 
static inline uintptr_t
_objc_decodeTaggedPointer(const void * _Nullable ptr)
{
    return (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator;
}

é€šè¿‡å®ç°ï¼Œæˆ‘ä»¬å¯ä»¥å¾—çŸ¥ï¼Œåœ¨ç¼–ç å’Œè§£ç éƒ¨åˆ†ï¼Œç»è¿‡äº†ä¸¤å±‚å¼‚æˆ–ï¼Œå…¶ç›®çš„æ˜¯å¾—åˆ°å°å¯¹è±¡è‡ªå·±ï¼Œä¾‹å¦‚ä»¥ 1010 0001ä¸ºä¾‹ï¼Œå‡è®¾maskä¸º 0101 1000
    1010 0001 
   ^0101 1000 maskï¼ˆç¼–ç ï¼‰
    1111 1001
   ^0101 1000 maskï¼ˆè§£ç ï¼‰
    1010 0001

[NSString stringWithFormat:@"b"];
æ‰€ä»¥åœ¨å¤–ç•Œï¼Œä¸ºäº†è·å–å°å¯¹è±¡çš„çœŸå®åœ°å€ï¼Œæˆ‘ä»¬å¯ä»¥å°†è§£ç çš„æºç æ‹·è´åˆ°å¤–é¢ï¼Œå°†NSStringæ··æ·†éƒ¨åˆ†è¿›è¡Œè§£ç 
å¾—åˆ° 0xa000000000000621
è§‚å¯Ÿè§£ç åçš„å°å¯¹è±¡åœ°å€ï¼Œå…¶ä¸­çš„62è¡¨ç¤ºbçš„ASCIIç 

åˆ°è¿™é‡Œï¼Œæˆ‘ä»¬éªŒè¯äº†å°å¯¹è±¡æŒ‡é’ˆåœ°å€ä¸­ç¡®å®å­˜å‚¨äº†å€¼ï¼Œé‚£ä¹ˆå°å¯¹è±¡åœ°å€é«˜ä½å…¶ä¸­çš„0xaã€0xbåˆæ˜¯ä»€ä¹ˆå«ä¹‰å‘¢ï¼Ÿ
//NSString
0xa000000000000621

//NSNumber
0xb000000000000012
0xb000000000000025

éœ€è¦å»æºç ä¸­æŸ¥çœ‹_objc_isTaggedPointeræºç ï¼Œä¸»è¦æ˜¯é€šè¿‡ä¿ç•™æœ€é«˜ä½çš„å€¼ï¼ˆå³64ä½çš„å€¼ï¼‰ï¼Œåˆ¤æ–­æ˜¯å¦ç­‰äº_OBJC_TAG_MASKï¼ˆå³2^63ï¼‰,æ¥åˆ¤æ–­æ˜¯å¦æ˜¯å°å¯¹è±¡
static inline bool 
_objc_isTaggedPointer(const void * _Nullable ptr)
{
    //ç­‰ä»·äº ptr & 1å·¦ç§»63ï¼Œå³2^63ï¼Œç›¸å½“äºé™¤äº†64ä½ï¼Œå…¶ä»–ä½éƒ½ä¸º0ï¼Œå³åªæ˜¯ä¿ç•™äº†æœ€é«˜ä½çš„å€¼
    return ((uintptr_t)ptr & _OBJC_TAG_MASK) == _OBJC_TAG_MASK;
}

æ‰€ä»¥0xaã€0xbä¸»è¦æ˜¯ç”¨äºåˆ¤æ–­æ˜¯å¦æ˜¯å°å¯¹è±¡taggedpointerï¼Œå³åˆ¤æ–­æ¡ä»¶ï¼Œåˆ¤æ–­ç¬¬64ä½ä¸Šæ˜¯å¦ä¸º1ï¼ˆtaggedpointeræŒ‡é’ˆåœ°å€å³è¡¨ç¤ºæŒ‡é’ˆåœ°å€ï¼Œä¹Ÿè¡¨ç¤ºå€¼ï¼‰
0xa è½¬æ¢æˆäºŒè¿›åˆ¶ä¸º 1 010ï¼ˆ64ä¸ºä¸º1ï¼Œ63~61åä¸‰ä½è¡¨ç¤º tagTypeç±»å‹ - 2ï¼‰ï¼Œè¡¨ç¤ºNSStringç±»å‹
0xb è½¬æ¢ä¸ºäºŒè¿›åˆ¶ä¸º 1 011ï¼ˆ64ä¸ºä¸º1ï¼Œ63~61åä¸‰ä½è¡¨ç¤º tagTypeç±»å‹ - 3ï¼‰ï¼Œè¡¨ç¤ºNSNumberç±»å‹ï¼Œè¿™é‡Œéœ€è¦æ³¨æ„ä¸€ç‚¹ï¼Œå¦‚æœNSNumberçš„å€¼æ˜¯-1ï¼Œå…¶åœ°å€ä¸­çš„å€¼æ˜¯ç”¨è¡¥ç è¡¨ç¤ºçš„
è¿™é‡Œå¯ä»¥é€šè¿‡_objc_makeTaggedPointeræ–¹æ³•çš„å‚æ•°tagç±»å‹objc_tag_index_tè¿›å…¥å…¶æšä¸¾ï¼Œå…¶ä¸­ 2è¡¨ç¤ºNSStringï¼Œ3è¡¨ç¤ºNSNumber
æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªNSDateå¯¹è±¡ï¼Œæ¥éªŒè¯å…¶tagTypeæ˜¯å¦ä¸º6


Tagged Pointer æ€»ç»“:
Tagged Pointerå°å¯¹è±¡ç±»å‹ï¼ˆç”¨äºå­˜å‚¨NSNumberã€NSDateã€å°NSStringï¼‰ï¼Œå°å¯¹è±¡æŒ‡é’ˆä¸å†æ˜¯ç®€å•çš„åœ°å€ï¼Œè€Œæ˜¯åœ°å€ + å€¼ï¼Œå³çœŸæ­£çš„å€¼ï¼Œæ‰€ä»¥ï¼Œå®é™…ä¸Šå®ƒä¸å†æ˜¯ä¸€ä¸ªå¯¹è±¡äº†ï¼Œå®ƒåªæ˜¯ä¸€ä¸ªæŠ«ç€å¯¹è±¡çš®çš„æ™®é€šå˜é‡è€Œä»¥ã€‚æ‰€ä»¥å¯ä»¥ç›´æ¥è¿›è¡Œè¯»å–ã€‚ä¼˜ç‚¹æ˜¯å ç”¨ç©ºé—´å° èŠ‚çœå†…å­˜
Tagged Pointerå°å¯¹è±¡ ä¸ä¼šè¿›å…¥retain å’Œ releaseï¼Œè€Œæ˜¯ç›´æ¥è¿”å›äº†ï¼Œæ„å‘³ç€ä¸éœ€è¦ARCè¿›è¡Œç®¡ç†ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥è¢«ç³»ç»Ÿè‡ªä¸»çš„é‡Šæ”¾å’Œå›æ”¶
Tagged Pointerçš„å†…å­˜å¹¶ä¸å­˜å‚¨åœ¨å †ä¸­ï¼Œè€Œæ˜¯åœ¨å¸¸é‡åŒºä¸­ï¼Œä¹Ÿä¸éœ€è¦mallocå’Œfreeï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥è¯»å–ï¼Œç›¸æ¯”å­˜å‚¨åœ¨å †åŒºçš„æ•°æ®è¯»å–ï¼Œæ•ˆç‡ä¸Šå¿«äº†3å€å·¦å³ã€‚åˆ›å»ºçš„æ•ˆç‡ç›¸æ¯”å †åŒºå¿«äº†è¿‘100å€å·¦å³
æ‰€ä»¥ï¼Œç»¼åˆæ¥è¯´ï¼ŒtaggedPointerçš„å†…å­˜ç®¡ç†æ–¹æ¡ˆï¼Œæ¯”å¸¸è§„çš„å†…å­˜ç®¡ç†ï¼Œè¦å¿«å¾ˆå¤š
Tagged Pointerçš„64ä½åœ°å€ä¸­ï¼Œå‰4ä½ä»£è¡¨ç±»å‹ï¼Œå4ä½ä¸»è¦é€‚ç”¨äºç³»ç»Ÿåšä¸€äº›å¤„ç†ï¼Œä¸­é—´56ä½ç”¨äºå­˜å‚¨å€¼
ä¼˜åŒ–å†…å­˜å»ºè®®ï¼šå¯¹äºNSStringæ¥è¯´ï¼Œå½“å­—ç¬¦ä¸²è¾ƒå°æ—¶ï¼Œå»ºè®®ç›´æ¥é€šè¿‡@""åˆå§‹åŒ–ï¼Œå› ä¸ºå­˜å‚¨åœ¨å¸¸é‡åŒºï¼Œå¯ä»¥ç›´æ¥è¿›è¡Œè¯»å–ã€‚ä¼šæ¯”WithFormatåˆå§‹åŒ–æ–¹å¼æ›´åŠ å¿«é€Ÿ



SideTables æ•£åˆ—è¡¨:
å½“å¼•ç”¨è®¡æ•°å­˜å‚¨åˆ°ä¸€å®šå€¼æ—¶ï¼Œå¹¶ä¸ä¼šå†å­˜å‚¨åˆ°Nonpointer_isaçš„ä½åŸŸçš„extra_rcä¸­ï¼Œè€Œæ˜¯ä¼šå­˜å‚¨åˆ°SideTables æ•£åˆ—è¡¨ä¸­


æ¢ç´¢å¼•ç”¨è®¡æ•°retainçš„åº•å±‚å®ç°
retain æºç åˆ†æ:
ALWAYS_INLINE id 
objc_object::rootRetain(bool tryRetain, bool handleOverflow)
{
    if (isTaggedPointer()) return (id)this;

    bool sideTableLocked = false;
    bool transcribeToSideTable = false;
    //ä¸ºä»€ä¹ˆæœ‰isaï¼Ÿå› ä¸ºéœ€è¦å¯¹å¼•ç”¨è®¡æ•°+1ï¼Œå³retain+1ï¼Œè€Œå¼•ç”¨è®¡æ•°å­˜å‚¨åœ¨isaçš„bitsä¸­ï¼Œéœ€è¦è¿›è¡Œæ–°æ—§isaçš„æ›¿æ¢
    isa_t oldisa;
    isa_t newisa;
    //é‡ç‚¹
    do {
        transcribeToSideTable = false;
        oldisa = LoadExclusive(&isa.bits);
        newisa = oldisa;
        //åˆ¤æ–­æ˜¯å¦ä¸ºnonpointer isa
        if (slowpath(!newisa.nonpointer)) {
            //å¦‚æœä¸æ˜¯ nonpointer isaï¼Œç›´æ¥æ“ä½œæ•£åˆ—è¡¨sidetable
            ClearExclusive(&isa.bits);
            if (rawISA()->isMetaClass()) return (id)this;
            if (!tryRetain && sideTableLocked) sidetable_unlock();
            if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;
            else return sidetable_retain();
        }
        // don't check newisa.fast_rr; we already called any RR overrides
        //deallocæºç 
        if (slowpath(tryRetain && newisa.deallocating)) {
            ClearExclusive(&isa.bits);
            if (!tryRetain && sideTableLocked) sidetable_unlock();
            return nil;
        }
        
        
        uintptr_t carry;
        //æ‰§è¡Œå¼•ç”¨è®¡æ•°+1æ“ä½œï¼Œå³å¯¹bitsä¸­çš„ 1ULL<<45ï¼ˆarm64ï¼‰ å³extra_rcï¼Œç”¨äºè¯¥å¯¹è±¡å­˜å‚¨å¼•ç”¨è®¡æ•°å€¼
        newisa.bits = addc(newisa.bits, RC_ONE, 0, &carry);  // extra_rc++
        //åˆ¤æ–­extra_rcæ˜¯å¦æ»¡äº†ï¼Œcarryæ˜¯æ ‡è¯†ç¬¦
        if (slowpath(carry)) {
            // newisa.extra_rc++ overflowed
            if (!handleOverflow) {
                ClearExclusive(&isa.bits);
                return rootRetain_overflow(tryRetain);
            }
            // Leave half of the retain counts inline and 
            // prepare to copy the other half to the side table.
            if (!tryRetain && !sideTableLocked) sidetable_lock();
            sideTableLocked = true;
            transcribeToSideTable = true;
            //å¦‚æœextra_rcæ»¡äº†ï¼Œåˆ™ç›´æ¥å°†æ»¡çŠ¶æ€çš„ä¸€åŠæ‹¿å‡ºæ¥å­˜åˆ°extra_rc
            newisa.extra_rc = RC_HALF;
            //ç»™ä¸€ä¸ªæ ‡è¯†ç¬¦ä¸ºYESï¼Œè¡¨ç¤ºéœ€è¦å­˜å‚¨åˆ°æ•£åˆ—è¡¨
            newisa.has_sidetable_rc = true;
        }
    } while (slowpath(!StoreExclusive(&isa.bits, oldisa.bits, newisa.bits)));

    if (slowpath(transcribeToSideTable)) {
        // Copy the other half of the retain counts to the side table.
        //å°†å¦ä¸€åŠå­˜åœ¨æ•£åˆ—è¡¨çš„rc_halfä¸­ï¼Œå³æ»¡çŠ¶æ€ä¸‹æ˜¯8ä½ï¼Œä¸€åŠå°±æ˜¯1å·¦ç§»7ä½ï¼Œå³é™¤ä»¥2
        //è¿™ä¹ˆæ“ä½œçš„ç›®çš„åœ¨äºæé«˜æ€§èƒ½ï¼Œå› ä¸ºå¦‚æœéƒ½å­˜åœ¨æ•£åˆ—è¡¨ä¸­ï¼Œå½“éœ€è¦release-1æ—¶ï¼Œéœ€è¦å»è®¿é—®æ•£åˆ—è¡¨ï¼Œæ¯æ¬¡éƒ½éœ€è¦å¼€è§£é”ï¼Œæ¯”è¾ƒæ¶ˆè€—æ€§èƒ½ã€‚extra_rcå­˜å‚¨ä¸€åŠçš„è¯ï¼Œå¯ä»¥ç›´æ¥æ“ä½œextra_rcå³å¯ï¼Œä¸éœ€è¦æ“ä½œæ•£åˆ—è¡¨ã€‚æ€§èƒ½ä¼šæé«˜å¾ˆå¤š
        sidetable_addExtraRC_nolock(RC_HALF);
    }

    if (slowpath(!tryRetain && sideTableLocked)) sidetable_unlock();
    return (id)this;
}

è¿›å…¥objc_retain -> retain -> rootRetainæºç å®ç°ï¼Œä¸»è¦æœ‰ä»¥ä¸‹å‡ éƒ¨åˆ†é€»è¾‘ï¼š
ã€ç¬¬ä¸€æ­¥ã€‘åˆ¤æ–­æ˜¯å¦ä¸ºNonpointer_isa
ã€ç¬¬äºŒæ­¥ã€‘æ“ä½œå¼•ç”¨è®¡æ•°
1ã€å¦‚æœä¸æ˜¯Nonpointer_isaï¼Œåˆ™ç›´æ¥æ“ä½œSideTablesæ•£åˆ—è¡¨ï¼Œæ­¤æ—¶çš„æ•£åˆ—è¡¨å¹¶ä¸æ˜¯åªæœ‰ä¸€å¼ ï¼Œè€Œæ˜¯æœ‰å¾ˆå¤šå¼ 
2ã€åˆ¤æ–­æ˜¯å¦æ­£åœ¨é‡Šæ”¾ï¼Œå¦‚æœæ­£åœ¨é‡Šæ”¾ï¼Œåˆ™æ‰§è¡Œdeallocæµç¨‹
3ã€æ‰§è¡Œextra_rc+1ï¼Œå³å¼•ç”¨è®¡æ•°+1æ“ä½œï¼Œå¹¶ç»™ä¸€ä¸ªå¼•ç”¨è®¡æ•°çš„çŠ¶æ€æ ‡è¯†carryï¼Œç”¨äºè¡¨ç¤ºextra_rcæ˜¯å¦æ»¡äº†
4ã€å¦‚æœcarrayçš„çŠ¶æ€è¡¨ç¤ºextra_rcçš„å¼•ç”¨è®¡æ•°æ»¡äº†ï¼Œæ­¤æ—¶éœ€è¦æ“ä½œæ•£åˆ—è¡¨ï¼Œå³ å°†æ»¡çŠ¶æ€çš„ä¸€åŠæ‹¿å‡ºæ¥å­˜åˆ°extra_rcï¼Œå¦ä¸€åŠå­˜åœ¨ æ•£åˆ—è¡¨çš„rc_halfã€‚
è¿™ä¹ˆåšçš„åŸå› æ˜¯å› ä¸ºå¦‚æœéƒ½å­˜å‚¨åœ¨æ•£åˆ—è¡¨ï¼Œæ¯æ¬¡å¯¹æ•£åˆ—è¡¨æ“ä½œéƒ½éœ€è¦å¼€è§£é”ï¼Œæ“ä½œè€—æ—¶ï¼Œæ¶ˆè€—æ€§èƒ½å¤§ï¼Œè¿™ä¹ˆå¯¹åŠåˆ†æ“ä½œçš„ç›®çš„åœ¨äºæé«˜æ€§èƒ½


é—®é¢˜1ï¼šæ•£åˆ—è¡¨ä¸ºä»€ä¹ˆåœ¨å†…å­˜æœ‰å¤šå¼ ï¼Ÿæœ€å¤šèƒ½å¤Ÿå¤šå°‘å¼ ï¼Ÿ
å¦‚æœæ•£åˆ—è¡¨åªæœ‰ä¸€å¼ è¡¨ï¼Œæ„å‘³ç€å…¨å±€æ‰€æœ‰çš„å¯¹è±¡éƒ½ä¼šå­˜å‚¨åœ¨ä¸€å¼ è¡¨ä¸­ï¼Œéƒ½ä¼šè¿›è¡Œå¼€é”è§£é”ï¼ˆé”æ˜¯é”æ•´ä¸ªè¡¨çš„è¯»å†™ï¼‰ã€‚å½“å¼€é”æ—¶ï¼Œç”±äºæ‰€æœ‰æ•°æ®éƒ½åœ¨ä¸€å¼ è¡¨ï¼Œåˆ™æ„å‘³ç€æ•°æ®ä¸å®‰å…¨
å¦‚æœæ¯ä¸ªå¯¹è±¡éƒ½å¼€ä¸€ä¸ªè¡¨ï¼Œä¼šè€—è´¹æ€§èƒ½ï¼Œæ‰€ä»¥ä¹Ÿä¸èƒ½æœ‰æ— æ•°ä¸ªè¡¨
æ•£åˆ—è¡¨çš„ç±»å‹æ˜¯SideTableï¼Œæœ‰å¦‚ä¸‹å®šä¹‰
struct SideTable {
    spinlock_t slock;//å¼€/è§£é”
    RefcountMap refcnts;//å¼•ç”¨è®¡æ•°è¡¨
    weak_table_t weak_table;//å¼±å¼•ç”¨è¡¨
    
    ....
}

é€šè¿‡æŸ¥çœ‹sidetable_unlockæ–¹æ³•å®šä½SideTablesï¼Œå…¶å†…éƒ¨æ˜¯é€šè¿‡SideTablesMapçš„getæ–¹æ³•è·å–ã€‚è€ŒSideTablesMapæ˜¯é€šè¿‡StripedMap<SideTable>å®šä¹‰çš„
void 
objc_object::sidetable_unlock()
{
    //SideTablesæ•£åˆ—è¡¨å¹¶ä¸åªæ˜¯ä¸€å¼ ï¼Œè€Œæ˜¯å¾ˆå¤šå¼ ï¼Œä¸å…³è”å¯¹è±¡è¡¨ç±»ä¼¼
    SideTable& table = SideTables()[this];
    table.unlock();
}

static StripedMap<SideTable>& SideTables() {
    return SideTablesMap.get();
}

static objc::ExplicitInit<StripedMap<SideTable>> SideTablesMap;
ä»è€Œè¿›å…¥StripedMapçš„å®šä¹‰ï¼Œä»è¿™é‡Œå¯ä»¥çœ‹å‡ºï¼ŒåŒä¸€æ—¶é—´ï¼ŒçœŸæœºä¸­æ•£åˆ—è¡¨æœ€å¤šåªèƒ½æœ‰8å¼ 


é—®é¢˜2ï¼šä¸ºä»€ä¹ˆåœ¨ç”¨æ•£åˆ—è¡¨ï¼Œè€Œä¸ç”¨æ•°ç»„ã€é“¾è¡¨ï¼Ÿ
æ•°ç»„ï¼šç‰¹ç‚¹åœ¨äºæŸ¥è¯¢æ–¹ä¾¿ï¼ˆå³é€šè¿‡ä¸‹æ ‡è®¿é—®ï¼‰ï¼Œå¢åˆ æ¯”è¾ƒéº»çƒ¦ï¼ˆç±»ä¼¼äºä¹‹å‰è®²è¿‡çš„methodListï¼Œé€šè¿‡memcopyã€memmoveå¢åˆ ï¼Œéå¸¸éº»çƒ¦ï¼‰ï¼Œæ‰€ä»¥æ•°æ®çš„ç‰¹æ€§æ˜¯è¯»å–å¿«ï¼Œå­˜å‚¨ä¸æ–¹ä¾¿
é“¾è¡¨ï¼šç‰¹ç‚¹åœ¨äºå¢åˆ æ–¹ä¾¿ï¼ŒæŸ¥è¯¢æ…¢ï¼ˆéœ€è¦ä»å¤´èŠ‚ç‚¹å¼€å§‹éå†æŸ¥è¯¢ï¼‰ï¼Œæ‰€ä»¥é“¾è¡¨çš„ç‰¹æ€§æ˜¯å­˜å‚¨å¿«ï¼Œè¯»å–æ…¢
æ•£åˆ—è¡¨çš„æœ¬è´¨å°±æ˜¯ä¸€å¼ å“ˆå¸Œè¡¨ï¼Œå“ˆå¸Œè¡¨é›†åˆäº†æ•°ç»„å’Œé“¾è¡¨çš„é•¿å¤„ï¼Œå¢åˆ æ”¹æŸ¥éƒ½æ¯”è¾ƒæ–¹ä¾¿ï¼Œä¾‹å¦‚æ‹‰é“¾å“ˆå¸Œè¡¨ï¼ˆé”çš„tlsçš„å­˜å‚¨ç»“æ„å°±æ˜¯æ‹‰é“¾å½¢å¼çš„ï¼‰

å¯ä»¥ä»SideTables -> StripedMap -> indexForPointerä¸­éªŒè¯æ˜¯é€šè¿‡å“ˆå¸Œå‡½æ•°è®¡ç®—å“ˆå¸Œä¸‹æ ‡ ä»¥åŠsideTablesä¸ºä»€ä¹ˆå¯ä»¥ä½¿ç”¨[]çš„åŸå› 

æ€»ç»“ï¼šretain å®Œæ•´å›ç­”:
retainåœ¨åº•å±‚é¦–å…ˆä¼šåˆ¤æ–­æ˜¯å¦æ˜¯ Nonpointer isaï¼Œå¦‚æœä¸æ˜¯ï¼Œåˆ™ç›´æ¥æ“ä½œæ•£åˆ—è¡¨ è¿›è¡Œ+1æ“ä½œ
å¦‚æœæ˜¯Nonpointer isaï¼Œè¿˜éœ€è¦åˆ¤æ–­æ˜¯å¦æ­£åœ¨é‡Šæ”¾ï¼Œå¦‚æœæ­£åœ¨é‡Šæ”¾ï¼Œåˆ™æ‰§è¡Œdeallocæµç¨‹ï¼Œé‡Šæ”¾å¼±å¼•ç”¨è¡¨å’Œå¼•ç”¨è®¡æ•°è¡¨ï¼Œæœ€åfreeé‡Šæ”¾å¯¹è±¡å†…å­˜
å¦‚æœä¸æ˜¯æ­£åœ¨é‡Šæ”¾ï¼Œåˆ™å¯¹Nonpointer isaè¿›è¡Œå¸¸è§„çš„å¼•ç”¨è®¡æ•°+1.
è¿™é‡Œéœ€è¦æ³¨æ„ä¸€ç‚¹çš„æ˜¯ï¼Œextra_rcåœ¨çœŸæœºä¸Šåªæœ‰8ä½ç”¨äºå­˜å‚¨å¼•ç”¨è®¡æ•°çš„å€¼ï¼Œå½“å­˜å‚¨æ»¡äº†æ—¶ï¼Œéœ€è¦å€ŸåŠ©æ•£åˆ—è¡¨ç”¨äºå­˜å‚¨ã€‚
éœ€è¦å°†æ»¡äº†çš„extra_rcå¯¹åŠåˆ†ï¼Œä¸€åŠï¼ˆå³2^7ï¼‰å­˜å‚¨åœ¨æ•£åˆ—è¡¨ä¸­ã€‚
å¦ä¸€åŠè¿˜æ˜¯å­˜å‚¨åœ¨extra_rcä¸­ï¼Œç”¨äºå¸¸è§„çš„å¼•ç”¨è®¡æ•°çš„+1æˆ–è€…-1æ“ä½œï¼Œç„¶åå†è¿”å›



release æºç åˆ†æ:
é€šè¿‡setProperty -> reallySetProperty -> objc_release -> release -> rootRelease
è¿›å…¥rootReleaseæºç ï¼Œå…¶æ“ä½œä¸retain ç›¸å
åˆ¤æ–­æ˜¯å¦æ˜¯Nonpointer isaï¼Œå¦‚æœä¸æ˜¯ï¼Œåˆ™ç›´æ¥å¯¹æ•£åˆ—è¡¨è¿›è¡Œ-1æ“ä½œ
å¦‚æœæ˜¯Nonpointer isaï¼Œåˆ™å¯¹extra_rcä¸­çš„å¼•ç”¨è®¡æ•°å€¼è¿›è¡Œ-1æ“ä½œï¼Œå¹¶å­˜å‚¨æ­¤æ—¶çš„extra_rcçŠ¶æ€åˆ°carryä¸­
å¦‚æœæ­¤æ—¶çš„çŠ¶æ€carrayä¸º0ï¼Œåˆ™èµ°åˆ°underflowæµç¨‹
underflowæµç¨‹æœ‰ä»¥ä¸‹å‡ æ­¥:
åˆ¤æ–­æ•£åˆ—è¡¨ä¸­æ˜¯å¦å­˜å‚¨äº†ä¸€åŠçš„å¼•ç”¨è®¡æ•°
å¦‚æœæ˜¯ï¼Œåˆ™ä»æ•£åˆ—è¡¨ä¸­å–å‡ºå­˜å‚¨çš„ä¸€åŠå¼•ç”¨è®¡æ•°ï¼Œè¿›è¡Œ-1æ“ä½œï¼Œç„¶åå­˜å‚¨åˆ°extra_rcä¸­
å¦‚æœæ­¤æ—¶extra_rcæ²¡æœ‰å€¼ï¼Œæ•£åˆ—è¡¨ä¸­ä¹Ÿæ˜¯ç©ºçš„ï¼Œåˆ™ç›´æ¥è¿›è¡Œææ„ï¼Œå³deallocæ“ä½œï¼Œå±äºè‡ªåŠ¨è§¦å‘

ALWAYS_INLINE bool 
objc_object::rootRelease(bool performDealloc, bool handleUnderflow)
{
    if (isTaggedPointer()) return false;

    bool sideTableLocked = false;

    isa_t oldisa;
    isa_t newisa;

 retry:
    do {
        oldisa = LoadExclusive(&isa.bits);
        newisa = oldisa;
        //åˆ¤æ–­æ˜¯å¦æ˜¯Nonpointer isa
        if (slowpath(!newisa.nonpointer)) {
            //å¦‚æœä¸æ˜¯ï¼Œåˆ™ç›´æ¥æ“ä½œæ•£åˆ—è¡¨-1
            ClearExclusive(&isa.bits);
            if (rawISA()->isMetaClass()) return false;
            if (sideTableLocked) sidetable_unlock();
            return sidetable_release(performDealloc);
        }
        // don't check newisa.fast_rr; we already called any RR overrides
        uintptr_t carry;
        //è¿›è¡Œå¼•ç”¨è®¡æ•°-1æ“ä½œï¼Œå³extra_rc-1
        newisa.bits = subc(newisa.bits, RC_ONE, 0, &carry);  // extra_rc--
        //å¦‚æœæ­¤æ—¶extra_rcçš„å€¼ä¸º0äº†ï¼Œåˆ™èµ°åˆ°underflow
        if (slowpath(carry)) {
            // don't ClearExclusive()
            goto underflow;
        }
    } while (slowpath(!StoreReleaseExclusive(&isa.bits, 
                                             oldisa.bits, newisa.bits)));

    if (slowpath(sideTableLocked)) sidetable_unlock();
    return false;

 underflow:
    // newisa.extra_rc-- underflowed: borrow from side table or deallocate

    // abandon newisa to undo the decrement
    newisa = oldisa;
    //åˆ¤æ–­æ•£åˆ—è¡¨ä¸­æ˜¯å¦å­˜å‚¨äº†ä¸€åŠçš„å¼•ç”¨è®¡æ•°
    if (slowpath(newisa.has_sidetable_rc)) {
        if (!handleUnderflow) {
            ClearExclusive(&isa.bits);
            return rootRelease_underflow(performDealloc);
        }

        // Transfer retain count from side table to inline storage.

        if (!sideTableLocked) {
            ClearExclusive(&isa.bits);
            sidetable_lock();
            sideTableLocked = true;
            // Need to start over to avoid a race against 
            // the nonpointer -> raw pointer transition.
            goto retry;
        }

        // Try to remove some retain counts from the side table.
        //ä»æ•£åˆ—è¡¨ä¸­å–å‡ºå­˜å‚¨çš„ä¸€åŠå¼•ç”¨è®¡æ•°
        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);

        // To avoid races, has_sidetable_rc must remain set 
        // even if the side table count is now zero.

        if (borrowed > 0) {
            // Side table retain count decreased.
            // Try to add them to the inline count.
            //è¿›è¡Œ-1æ“ä½œï¼Œç„¶åå­˜å‚¨åˆ°extra_rcä¸­
            newisa.extra_rc = borrowed - 1;  // redo the original decrement too
            bool stored = StoreReleaseExclusive(&isa.bits, 
                                                oldisa.bits, newisa.bits);
            if (!stored) {
                // Inline update failed. 
                // Try it again right now. This prevents livelock on LL/SC 
                // architectures where the side table access itself may have 
                // dropped the reservation.
                isa_t oldisa2 = LoadExclusive(&isa.bits);
                isa_t newisa2 = oldisa2;
                if (newisa2.nonpointer) {
                    uintptr_t overflow;
                    newisa2.bits = 
                        addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &overflow);
                    if (!overflow) {
                        stored = StoreReleaseExclusive(&isa.bits, oldisa2.bits, 
                                                       newisa2.bits);
                    }
                }
            }

            if (!stored) {
                // Inline update failed.
                // Put the retains back in the side table.
                sidetable_addExtraRC_nolock(borrowed);
                goto retry;
            }

            // Decrement successful after borrowing from side table.
            // This decrement cannot be the deallocating decrement - the side 
            // table lock and has_sidetable_rc bit ensure that if everyone 
            // else tried to -release while we worked, the last one would block.
            sidetable_unlock();
            return false;
        }
        else {
            // Side table is empty after all. Fall-through to the dealloc path.
        }
    }
    //æ­¤æ—¶extra_rcä¸­å€¼ä¸º0ï¼Œæ•£åˆ—è¡¨ä¸­ä¹Ÿæ˜¯ç©ºçš„ï¼Œåˆ™ç›´æ¥è¿›è¡Œææ„ï¼Œå³è‡ªåŠ¨è§¦å‘deallocæµç¨‹
    // Really deallocate.
    //è§¦å‘deallocçš„æ—¶æœº
    if (slowpath(newisa.deallocating)) {
        ClearExclusive(&isa.bits);
        if (sideTableLocked) sidetable_unlock();
        return overrelease_error();
        // does not actually return
    }
    newisa.deallocating = true;
    if (!StoreExclusive(&isa.bits, oldisa.bits, newisa.bits)) goto retry;

    if (slowpath(sideTableLocked)) sidetable_unlock();

    __c11_atomic_thread_fence(__ATOMIC_ACQUIRE);

    if (performDealloc) {
        //å‘é€ä¸€ä¸ªdeallocæ¶ˆæ¯
        ((void(*)(objc_object *, SEL))objc_msgSend)(this, @selector(dealloc));
    }
    return true;
}



dealloc æºç åˆ†æ:
åœ¨retainå’Œreleaseçš„åº•å±‚å®ç°ä¸­ï¼Œéƒ½æåŠäº†deallocææ„å‡½æ•°ï¼Œä¸‹é¢æ¥åˆ†ædeallocçš„åº•å±‚çš„å®ç°

è¿›å…¥dealloc -> _objc_rootDealloc -> rootDeallocæºç å®ç°ï¼Œä¸»è¦æœ‰ä¸¤ä»¶äº‹ï¼š
æ ¹æ®æ¡ä»¶åˆ¤æ–­æ˜¯å¦æœ‰isaã€cxxã€å…³è”å¯¹è±¡ã€å¼±å¼•ç”¨è¡¨ã€å¼•ç”¨è®¡æ•°è¡¨ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™ç›´æ¥freeé‡Šæ”¾å†…å­˜
å¦‚æœæœ‰ï¼Œåˆ™è¿›å…¥object_disposeæ–¹æ³•

inline void
objc_object::rootDealloc()
{
    //å¯¹è±¡è¦é‡Šæ”¾ï¼Œéœ€è¦åšå“ªäº›äº‹æƒ…ï¼Ÿ
    //1ã€isa - cxx - å…³è”å¯¹è±¡ - å¼±å¼•ç”¨è¡¨ - å¼•ç”¨è®¡æ•°è¡¨
    //2ã€free
    if (isTaggedPointer()) return;  // fixme necessary?

    //å¦‚æœæ²¡æœ‰è¿™äº›ï¼Œåˆ™ç›´æ¥free
    if (fastpath(isa.nonpointer  &&  
                 !isa.weakly_referenced  &&  
                 !isa.has_assoc  &&  
                 !isa.has_cxx_dtor  &&  
                 !isa.has_sidetable_rc))
    {
        assert(!sidetable_present());
        free(this);
    } 
    else {
        //å¦‚æœæœ‰
        object_dispose((id)this);
    }
}

è¿›å…¥object_disposeæºç ï¼Œå…¶ç›®çš„æœ‰ä»¥ä¸‹å‡ ä¸ª:
é”€æ¯å®ä¾‹ï¼Œä¸»è¦æœ‰ä»¥ä¸‹æ“ä½œ
    è°ƒç”¨c++ææ„å‡½æ•°
    åˆ é™¤å…³è”å¼•ç”¨
    é‡Šæ”¾æ•£åˆ—è¡¨
    æ¸…ç©ºå¼±å¼•ç”¨è¡¨
freeé‡Šæ”¾å†…å­˜

id 
object_dispose(id obj)
{
    if (!obj) return nil;
    //é”€æ¯å®ä¾‹è€Œä¸ä¼šé‡Šæ”¾å†…å­˜
    objc_destructInstance(obj);
    //é‡Šæ”¾å†…å­˜
    free(obj);

    return nil;
}
ğŸ‘‡
void *objc_destructInstance(id obj) 
{
    if (obj) {
        // Read all of the flags at once for performance.
        bool cxx = obj->hasCxxDtor();
        bool assoc = obj->hasAssociatedObjects();

        // This order is important.
        //è°ƒç”¨C ++ææ„å‡½æ•°
        if (cxx) object_cxxDestruct(obj);
        //åˆ é™¤å…³è”å¼•ç”¨
        if (assoc) _object_remove_assocations(obj);
        //é‡Šæ”¾
        obj->clearDeallocating();
    }

    return obj;
}
ğŸ‘‡
inline void 
objc_object::clearDeallocating()
{
    //åˆ¤æ–­æ˜¯å¦ä¸ºnonpointer isa
    if (slowpath(!isa.nonpointer)) {
        // Slow path for raw pointer isa.
        //å¦‚æœä¸æ˜¯ï¼Œåˆ™ç›´æ¥é‡Šæ”¾æ•£åˆ—è¡¨
        sidetable_clearDeallocating();
    }
    //å¦‚æœæ˜¯ï¼Œæ¸…ç©ºå¼±å¼•ç”¨è¡¨ + æ•£åˆ—è¡¨
    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) {
        // Slow path for non-pointer isa with weak refs and/or side table data.
        clearDeallocating_slow();
    }

    assert(!sidetable_present());
}
ğŸ‘‡
NEVER_INLINE void
objc_object::clearDeallocating_slow()
{
    ASSERT(isa.nonpointer  &&  (isa.weakly_referenced || isa.has_sidetable_rc));

    SideTable& table = SideTables()[this];
    table.lock();
    if (isa.weakly_referenced) {
        //æ¸…ç©ºå¼±å¼•ç”¨è¡¨
        weak_clear_no_lock(&table.weak_table, (id)this);
    }
    if (isa.has_sidetable_rc) {
        //æ¸…ç©ºå¼•ç”¨è®¡æ•°
        table.refcnts.erase(this);
    }
    table.unlock();
}



retainCount æºç åˆ†æ:
é¢è¯•é¢˜ï¼šallocåˆ›å»ºçš„å¯¹è±¡çš„å¼•ç”¨è®¡æ•°ä¸ºå¤šå°‘ï¼Ÿ
NSObject *objc = [NSObject alloc];
NSLog(@"%ld",CFGetRetainCount((__bridge CFTypeRef)objc));// 1

è¿›å…¥retainCount -> _objc_rootRetainCount -> rootRetainCountæºç 
- (NSUInteger)retainCount {
    return _objc_rootRetainCount(self);
}
ğŸ‘‡
uintptr_t
_objc_rootRetainCount(id obj)
{
    ASSERT(obj);

    return obj->rootRetainCount();
}
ğŸ‘‡
inline uintptr_t 
objc_object::rootRetainCount()
{
    if (isTaggedPointer()) return (uintptr_t)this;

    sidetable_lock();
    isa_t bits = LoadExclusive(&isa.bits);
    ClearExclusive(&isa.bits);
    //å¦‚æœæ˜¯nonpointer isaï¼Œæ‰æœ‰å¼•ç”¨è®¡æ•°çš„ä¸‹å±‚å¤„ç†
    if (bits.nonpointer) {
        //allocåˆ›å»ºçš„å¯¹è±¡å¼•ç”¨è®¡æ•°ä¸º0ï¼ŒåŒ…æ‹¬sideTable,æ‰€ä»¥å¯¹äºallocæ¥è¯´ï¼Œæ˜¯ 0+1=1ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆé€šè¿‡retaincountè·å–çš„å¼•ç”¨è®¡æ•°ä¸º1çš„åŸå› 
        uintptr_t rc = 1 + bits.extra_rc;
        if (bits.has_sidetable_rc) {
            rc += sidetable_getExtraRC_nolock();
        }
        sidetable_unlock();
        return rc;
    }
    //å¦‚æœä¸æ˜¯ï¼Œåˆ™æ­£å¸¸è¿”å›
    sidetable_unlock();
    return sidetable_retainCount();
}

æˆ‘ä»¬å¯ä»¥é€šè¿‡æºç æ–­ç‚¹è°ƒè¯•ï¼Œæ¥æŸ¥çœ‹æ­¤æ—¶çš„extra_rcçš„å€¼

ç­”æ¡ˆï¼š
ç»¼ä¸Šæ‰€è¿°ï¼Œallocåˆ›å»ºçš„å¯¹è±¡å®é™…çš„å¼•ç”¨è®¡æ•°ä¸º0ï¼Œå…¶å¼•ç”¨è®¡æ•°æ‰“å°ç»“æœä¸º1ï¼Œæ˜¯å› ä¸ºåœ¨åº•å±‚rootRetainCountæ–¹æ³•ä¸­ï¼Œå¼•ç”¨è®¡æ•°é»˜è®¤+1äº†
ä½†æ˜¯è¿™é‡Œåªæœ‰å¯¹å¼•ç”¨è®¡æ•°çš„è¯»å–æ“ä½œï¼Œæ˜¯æ²¡æœ‰å†™å…¥æ“ä½œçš„
ç®€å•æ¥è¯´å°±æ˜¯ï¼šä¸ºäº†é˜²æ­¢allocåˆ›å»ºçš„å¯¹è±¡è¢«é‡Šæ”¾ï¼ˆå¼•ç”¨è®¡æ•°ä¸º0ä¼šè¢«é‡Šæ”¾ï¼‰ï¼Œæ‰€ä»¥åœ¨ç¼–è¯‘é˜¶æ®µï¼Œç¨‹åºåº•å±‚é»˜è®¤è¿›è¡Œäº†+1æ“ä½œã€‚å®é™…ä¸Šåœ¨extra_rcä¸­çš„å¼•ç”¨è®¡æ•°ä»ç„¶ä¸º0

æ€»ç»“:
allocåˆ›å»ºçš„å¯¹è±¡æ²¡æœ‰retainå’Œrelease
allocåˆ›å»ºå¯¹è±¡çš„å¼•ç”¨è®¡æ•°ä¸º0ï¼Œä¼šåœ¨ç¼–è¯‘æ—¶æœŸï¼Œç¨‹åºé»˜è®¤åŠ 1ï¼Œæ‰€ä»¥è¯»å–å¼•ç”¨è®¡æ•°æ—¶ä¸º1


==================================================ç®€å•çš„å“ˆå¸Œè¡¨å®ç°
// é“¾åœ°å€æ³•
class HashTable<Key: Hashable, Value> {
    private var buckets: [Bucket?]
    private let capacity: Int
    
    init(capacity: Int) {
        self.capacity = capacity
        self.buckets = Array<Bucket?>(repeating: nil, count: capacity)
    }
    
    func insert(key: Key, value: Value) {
        let index = self.index(for: key)
        let newBucket = Bucket(key: key, value: value)
        
        if let existingBucket = buckets[index] {
            var bucket = existingBucket
            while bucket.next != nil {
                bucket = bucket.next!
            }
            bucket.next = newBucket
        } else {
            buckets[index] = newBucket
        }
    }
    
    func value(for key: Key) -> Value? {
        let index = self.index(for: key)
        var bucket = buckets[index]
        
        while bucket != nil {
            if bucket!.key == key {
                return bucket!.value
            }
            bucket = bucket!.next
        }
        
        return nil
    }
    
    private func index(for key: Key) -> Int {
        return abs(key.hashValue) % capacity
    }
    
    private class Bucket {
        let key: Key
        var value: Value
        var next: Bucket?
        
        init(key: Key, value: Value, next: Bucket? = nil) {
            self.key = key
            self.value = value
            self.next = next
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
let hashTable = HashTable<String, Int>(capacity: 10)
hashTable.insert(key: "one", value: 1)
hashTable.insert(key: "two", value: 2)
hashTable.insert(key: "three", value: 3)

if let value = hashTable.value(for: "two") {
    print("Value for 'two': \(value)")
} else {
    print("'two' not found")
}

å…¶ä¸­ Key æ˜¯å“ˆå¸Œè¡¨çš„é”®ï¼ŒValue æ˜¯å€¼ã€‚æˆ‘ä»¬ä½¿ç”¨é“¾åœ°å€æ³•æ¥å¤„ç†å†²çªï¼Œæ¯ä¸ªæ¡¶ï¼ˆBucketï¼‰æ˜¯ä¸€ä¸ªé“¾è¡¨èŠ‚ç‚¹ã€‚



// å¸¸è§çš„æ¢æµ‹æ–¹æ³•åŒ…æ‹¬çº¿æ€§æ¢æµ‹ï¼ˆLinear Probingï¼‰ã€äºŒæ¬¡æ¢æµ‹ï¼ˆQuadratic Probingï¼‰å’ŒåŒé‡æ•£åˆ—ï¼ˆDouble Hashingï¼‰ã€‚
// å¼€æ”¾åœ°å€æ³•ï¼ˆOpen Addressingï¼‰ 
// ä»¥ä¸‹æ˜¯ä½¿ç”¨çº¿æ€§æ¢æµ‹çš„å“ˆå¸Œè¡¨
class OpenAddressingHashTable<Key: Hashable, Value> {
    private var buckets: [Bucket?]
    private let capacity: Int
    
    init(capacity: Int) {
        self.capacity = capacity
        self.buckets = Array<Bucket?>(repeating: nil, count: capacity)
    }
    
    func insert(key: Key, value: Value) {
        var index = self.index(for: key)
        
        while let bucket = buckets[index], bucket.key != key {
            index = (index + 1) % capacity
        }
        
        buckets[index] = Bucket(key: key, value: value)
    }
    
    func value(for key: Key) -> Value? {
        var index = self.index(for: key)
        
        while let bucket = buckets[index] {
            if bucket.key == key {
                return bucket.value
            }
            index = (index + 1) % capacity
        }
        
        return nil
    }
    
    private func index(for key: Key) -> Int {
        return abs(key.hashValue) % capacity
    }
    
    private class Bucket {
        let key: Key
        var value: Value
        
        init(key: Key, value: Value) {
            self.key = key
            self.value = value
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
let hashTable = OpenAddressingHashTable<String, Int>(capacity: 10)
hashTable.insert(key: "one", value: 1)
hashTable.insert(key: "two", value: 2)
hashTable.insert(key: "three", value: 3)

if let value = hashTable.value(for: "two") {
    print("Value for 'two': \(value)")
} else {
    print("'two' not found")
}

æ¯ä¸ªæ•°ç»„å…ƒç´ æ˜¯ä¸€ä¸ªç›´æ¥å­˜å‚¨é”®å€¼å¯¹çš„æ¡¶ï¼ˆBucketï¼‰ã€‚
å½“å‘ç”Ÿå†²çªæ—¶ï¼Œçº¿æ€§æ¢æµ‹ä¼šä¾æ¬¡æ£€æŸ¥ä¸‹ä¸€ä¸ªä½ç½®ï¼Œç›´åˆ°æ‰¾åˆ°ç©ºä½ç½®æˆ–è€…åŒ¹é…çš„é”®ã€‚è¿™ä¸ªæ–¹æ³•é€šè¿‡å°†å†²çªå¤„ç†é€»è¾‘å†…åµŒåœ¨å“ˆå¸Œè¡¨å†…éƒ¨ï¼Œé¿å…äº†é“¾è¡¨çš„é¢å¤–å†…å­˜å¼€é”€ï¼Œä½†åœ¨å¤§é‡å†²çªæ—¶å¯èƒ½å¯¼è‡´æ€§èƒ½ä¸‹é™ã€‚


==================================================StripedMapæ˜¯ä¸€ç§ç”¨äºå®ç°çº¿ç¨‹å®‰å…¨çš„å“ˆå¸Œè¡¨çš„è®¾è®¡æ¨¡å¼ã€‚
å®ƒçš„æ ¸å¿ƒæ€æƒ³æ˜¯å°†å“ˆå¸Œè¡¨åˆ’åˆ†ä¸ºå¤šä¸ªç‹¬ç«‹çš„éƒ¨åˆ†ï¼ˆæˆ–â€œæ¡çº¹â€ï¼‰ï¼Œæ¯ä¸ªéƒ¨åˆ†éƒ½ç”±ä¸€ä¸ªç‹¬ç«‹çš„é”æ¥ä¿æŠ¤ã€‚
è¿™æ ·å¯ä»¥æé«˜å¹¶å‘è®¿é—®çš„æ•ˆç‡ï¼Œå› ä¸ºå¯¹ä¸åŒéƒ¨åˆ†çš„è®¿é—®å¯ä»¥å¹¶è¡Œè¿›è¡Œï¼Œä»è€Œå‡å°‘é”ç«äº‰ã€‚

StripedMapçš„å·¥ä½œåŸç†å¦‚ä¸‹ï¼š
åˆ†åŒºï¼ˆStripingï¼‰ï¼šå°†æ•´ä¸ªå“ˆå¸Œè¡¨åˆ’åˆ†ä¸ºå¤šä¸ªå°çš„å­è¡¨ï¼ˆsegmentsï¼‰ï¼Œæ¯ä¸ªå­è¡¨ç”±ä¸€ä¸ªç‹¬ç«‹çš„é”ä¿æŠ¤ã€‚å“ˆå¸Œè¡¨çš„å¤§å°å’Œé”çš„æ•°é‡å¯ä»¥æ ¹æ®å…·ä½“æƒ…å†µè¿›è¡Œè°ƒæ•´ã€‚
å“ˆå¸Œæ˜ å°„ï¼šåœ¨è¿›è¡Œæ’å…¥ã€åˆ é™¤æˆ–æŸ¥æ‰¾æ“ä½œæ—¶ï¼Œé¦–å…ˆè®¡ç®—å‡ºç›®æ ‡é”®çš„å“ˆå¸Œå€¼ï¼Œç„¶åå°†å…¶æ˜ å°„åˆ°å¯¹åº”çš„å­è¡¨ä¸­ã€‚æ¯ä¸ªå­è¡¨çš„ç´¢å¼•é€šå¸¸æ˜¯é€šè¿‡å¯¹å“ˆå¸Œå€¼è¿›è¡Œå–æ¨¡è¿ç®—å¾—åˆ°çš„ã€‚
é”å®šç²’åº¦ï¼šç”±äºæ¯ä¸ªå­è¡¨éƒ½æœ‰è‡ªå·±çš„é”ï¼Œåªæœ‰åœ¨è®¿é—®åŒä¸€ä¸ªå­è¡¨æ—¶æ‰ä¼šå‡ºç°é”ç«äº‰ã€‚è¿™æ ·å¯ä»¥æ˜¾è‘—æé«˜å¹¶å‘è®¿é—®çš„æ•ˆç‡ï¼Œå› ä¸ºåŒæ—¶è®¿é—®ä¸åŒå­è¡¨çš„æ“ä½œå¯ä»¥å¹¶è¡Œè¿›è¡Œï¼Œè€Œä¸ä¼šç›¸äº’é˜»å¡ã€‚


import Foundation

class StripedMap<Key: Hashable, Value> {
    private var buckets: [Dictionary<Key, Value>]
    private var locks: [NSLock]
    private let bucketCount: Int
    
    init(bucketCount: Int) {
        self.bucketCount = bucketCount
        self.buckets = Array(repeating: Dictionary<Key, Value>(), count: bucketCount)
        self.locks = Array(repeating: NSLock(), count: bucketCount)
    }
    
    private func getBucketIndex(for key: Key) -> Int {
        return abs(key.hashValue) % bucketCount
    }
    
    func put(key: Key, value: Value) {
        let index = getBucketIndex(for: key)
        locks[index].lock()
        defer { locks[index].unlock() }
        buckets[index][key] = value
    }
    
    func get(key: Key) -> Value? {
        let index = getBucketIndex(for: key)
        locks[index].lock()
        defer { locks[index].unlock() }
        return buckets[index][key]
    }
    
    func remove(key: Key) {
        let index = getBucketIndex(for: key)
        locks[index].lock()
        defer { locks[index].unlock() }
        buckets[index].removeValue(forKey: key)
    }
}

bucketCount å†³å®šäº†å“ˆå¸Œè¡¨è¢«åˆ’åˆ†æˆå¤šå°‘ä¸ªå­è¡¨ï¼ˆæˆ–æ¡çº¹ï¼‰ã€‚
æ¯ä¸ªå­è¡¨ï¼ˆbucketsä¸­çš„ä¸€ä¸ªå…ƒç´ ï¼‰éƒ½æœ‰ä¸€ä¸ªç‹¬ç«‹çš„é”ï¼ˆlocksä¸­çš„ä¸€ä¸ªå…ƒç´ ï¼‰ã€‚
putã€get å’Œ remove æ“ä½œéƒ½é¦–å…ˆè®¡ç®—ç›®æ ‡é”®çš„å“ˆå¸Œå€¼å¹¶æ˜ å°„åˆ°ç›¸åº”çš„å­è¡¨ï¼Œç„¶åä½¿ç”¨ç›¸åº”çš„é”æ¥ä¿æŠ¤æ“ä½œçš„åŸå­æ€§ã€‚
StripedMap æ˜¯ä¸€ç§æé«˜å¹¶å‘æ€§èƒ½çš„æœ‰æ•ˆæ–¹æ³•ï¼Œç‰¹åˆ«é€‚ç”¨äºè¯»å†™é¢‘ç¹ä¸”å¹¶å‘è®¿é—®çš„åœºæ™¯ã€‚