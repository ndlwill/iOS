//
//  Shaders4.metal
//  TestMetal
//
//  Created by youdun on 2023/8/30.
//

#include "ShaderTypes4.h"
#include <metal_stdlib>
using namespace metal;

/**
 Vertex shader outputs and per-fragment inputs.
 Includes clip-space position and vertex outputs interpolated by rasterizer and fed to each fragment generated by clip-space primitives.
 */
struct RasterizerData4
{
    /**
     The [[position]] attribute qualifier of this member indicates this value is the clip space position of the vertex wen this structure is returned from the vertex shader
     */
    float4 clipSpacePosition [[position]];

    /**
     Since this member does not have a special attribute qualifier,
     the rasterizer will interpolate its value with values of other vertices making up the triangle and pass that interpolated value to the fragment shader for each fragment in that triangle;
     */
    float2 textureCoordinate;
};

// Vertex Function
vertex RasterizerData4
vertexShader4(uint                   vertexID             [[ vertex_id ]],
              constant Vertex4       *vertexArray         [[ buffer(VertexInputIndex4Vertices) ]],
              constant vector_uint2  *viewportSizePointer [[ buffer(VertexInputIndex4ViewportSize) ]])
{

    RasterizerData4 out;

    float2 pixelSpacePosition = vertexArray[vertexID].position.xy;

    float2 viewportSize = float2(*viewportSizePointer);

    // convert the pixel positions into normalized device coordinates.
    
    /**
     The output position of every vertex shader is in clip space (also known as normalized device coordinate space, or NDC).
     A value of (-1.0, -1.0) in clip-space represents the lower-left corner of the viewport whereas (1.0, 1.0) represents the upper-right corner of the viewport.
     */
    // In order to convert from positions in pixel space to positions in clip space, divide the pixel coordinates by half the size of the viewport.
    out.clipSpacePosition.xy = pixelSpacePosition / (viewportSize / 2.0);
    out.clipSpacePosition.z = 0.0;
    out.clipSpacePosition.w = 1.0;

    // Pass the input textureCoordinate straight to the output RasterizerData. This value will be interpolated with the other textureCoordinate values in the vertices that make up the triangle.
    out.textureCoordinate = vertexArray[vertexID].textureCoordinate;

    return out;
}

// Fragment function
fragment float4 samplingShader4(RasterizerData4  in           [[stage_in]],
                                texture2d<half>  colorTexture [[ texture(TextureIndex4Output) ]])
{
    constexpr sampler textureSampler (mag_filter::linear,
                                      min_filter::linear);

    // Sample the texture and return the color to colorSample
    const half4 colorSample = colorTexture.sample(textureSampler, in.textureCoordinate);
    return float4(colorSample);
}

// MARK: - Write a Compute Function
/**
 This sample uses a compute function, also known as a compute kernel, to convert the texture’s pixels from color to grayscale.
 The compute function in this sample processes the texture’s pixels independently and concurrently.
 Its signature is shown below:
 
 The function takes the following resource arguments:
 inTexture: A read-only, 2D texture that contains the input color pixels
 outTexture: A write-only, 2D texture that contains the output grayscale pixels
 
 The sample specifies the read access qualifier for inTexture because it reads from the texture using the read() function,
 and the write access qualifier for outTexture because it writes to the texture using the write() function.
 
 A compute function operates on a 1D, 2D, or 3D grid of threads, and part of designing any compute function is deciding the grid’s dimensions and how threads in the grid correspond to input and output data.
 The sample operates on 2D texture data, so it uses a 2D grid with each thread processing a different pixel in the source texture.
 
 The function’s gid argument provides the grid coordinates for each thread.
 The argument’s uint2 type specifies that the grid uses 2D coordinates.
 The [[thread_position_in_grid]] attribute qualifier specifies that the GPU should generate and pass each thread’s grid coordinates into the function.

 A grayscale pixel has the same value for each of its RGB components.
 The sample calculates this value by applying weights to each component.
 The sample uses the Rec. 709 luma coefficients for the color-to-grayscale conversion.
 First, the function reads a pixel from the texture, using the thread’s grid coordinates to identify which pixel each thread receives.
 After performing the conversion, it uses the same coordinates to write the converted pixel to the output texture.
 */
// Rec. 709 luma values for grayscale image conversion
constant half3 kRec709Luma = half3(0.2126, 0.7152, 0.0722);

// Grayscale compute kernel
kernel void
grayscaleKernel4(texture2d<half, access::read>  inTexture  [[ texture(TextureIndex4Input) ]],
                 texture2d<half, access::write> outTexture [[ texture(TextureIndex4Output) ]],
                 uint2                          gid        [[ thread_position_in_grid ]])
{
    // Check if the pixel is within the bounds of the output texture
    if((gid.x >= outTexture.get_width()) || (gid.y >= outTexture.get_height()))
    {
        // Return early if the pixel is out of bounds
        return;
    }

    half4 inColor  = inTexture.read(gid);
    half  gray     = dot(inColor.rgb, kRec709Luma);
    outTexture.write(half4(gray, gray, gray, 1.0), gid);
}
