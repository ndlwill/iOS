//
//  Renderer1.m
//  TestMetal
//
//  Created by youdun on 2023/8/25.
//

#import "Renderer1.h"
#import "ShaderTypes.h"
@import simd;
@import MetalKit;

// MARK: - Experiment with the Color Interpolation
/**
 attribute  qualifier: f v属性限定符
 In this sample, color values were interpolated across the triangle.
 That’s often what you want, but sometimes you want a value to be generated by one vertex and remain constant across the whole primitive.
 Specify the flat attribute qualifier on an output of the vertex function to do this.
 Try this now. Find the definition of RasterizerData in the sample project and add the [[flat]] qualifier to its color field.
 float4 color [[flat]];
 
 Run the sample again.
 The render pipeline uses the color value from the first vertex (called the provoking vertex) uniformly across the triangle, and it ignores the colors from the other two vertices.
 You can use a mix of flat shaded and interpolated values, simply by adding or omitting the flat qualifier on your vertex function’s outputs.
 
 The Metal Shading Language specification defines other attribute qualifiers you can also use to modify the rasterization behavior.
 https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf
 */

@implementation Renderer1
{
    id<MTLDevice> _device;
    id<MTLCommandQueue> _commandQueue;
    
    // The render pipeline generated from the vertex and fragment shaders in the .metal shader file.
    id<MTLRenderPipelineState> _pipelineState;
    
    // The current size of the view, used as an input to the vertex shader.
    vector_uint2 _viewportSize;
}

- (nonnull instancetype)initWithMetalKitView:(nonnull MTKView *)mtkView {
    self = [super init];
    if (self) {
        _device = mtkView.device;
        
        // Load all the shader files with a .metal file extension in the project.
        id<MTLLibrary> defaultLibrary = [_device newDefaultLibrary];
        id<MTLFunction> vertexFunction = [defaultLibrary newFunctionWithName:@"vertexShader"];
        id<MTLFunction> fragmentFunction = [defaultLibrary newFunctionWithName:@"fragmentShader"];
        
        // Configure a pipeline descriptor that is used to create a pipeline state.
        /**
         Render pipelines have more stages to configure, so you use an MTLRenderPipelineDescriptor to configure the pipeline.
         
         In addition to specifying the vertex and fragment functions, you also declare the pixel format of all render targets that the pipeline will draw into.
         A pixel format (MTLPixelFormat) defines the memory layout of pixel data.
         For simple formats, this definition includes the number of bytes per pixel, the number of channels of data stored in a pixel, and the bit layout of those channels.
         Since this sample only has one render target and it is provided by the view, copy the view’s pixel format into the render pipeline descriptor.
         Your render pipeline state must use a pixel format that is compatible with the one specified by the render pass.
         In this sample, the render pass and the pipeline state object both use the view’s pixel format, so they are always the same.
         
         When Metal creates the render pipeline state object, the pipeline is configured to convert the fragment function’s output into the render target’s pixel format.
         If you want to target a different pixel format, you need to create a different pipeline state object.
         You can reuse the same shaders in multiple pipelines targeting different pixel formats.
         */
        MTLRenderPipelineDescriptor *pipelineStateDescriptor = [[MTLRenderPipelineDescriptor alloc] init];
        pipelineStateDescriptor.label = @"TestPipeline";
        pipelineStateDescriptor.vertexFunction = vertexFunction;
        pipelineStateDescriptor.fragmentFunction = fragmentFunction;
        pipelineStateDescriptor.colorAttachments[0].pixelFormat = mtkView.colorPixelFormat;
        
        NSError *error;
        // MARK: - Create a Render Pipeline State Object
        _pipelineState = [_device newRenderPipelineStateWithDescriptor:pipelineStateDescriptor
                                                                 error:&error];
        /**
         Pipeline State creation could fail if the pipeline descriptor isn't set up properly. If the Metal API validation is enabled, you can find out more information about what went wrong.  (Metal API validation is enabled by default when a debug build is run from Xcode.)
         */
        NSAssert(_pipelineState, @"Failed to create pipeline state: %@", error);
        
        _commandQueue = [_device newCommandQueue];
    }
    
    return self;
}

- (void)drawInMTKView:(MTKView *)view {
    NSLog(@"%s", __FUNCTION__);
    
    id<MTLCommandBuffer> commandBuffer = [_commandQueue commandBuffer];
    commandBuffer.label = @"TestCommandBuffer";
    
    MTLRenderPassDescriptor *renderPassDescriptor = view.currentRenderPassDescriptor;
    if (renderPassDescriptor == nil) {
        NSLog(@"renderPassDescriptor == nil");
        return;
    }
    
    static const CustomVertex triangleVertices[] =
    {
        // 2D positions,    RGBA colors
        { {  250,  -250 }, { 1, 0, 0, 1 } },// 右下 红
        { { -250,  -250 }, { 0, 1, 0, 1 } },// 左下 绿
        { {    0,   250 }, { 0, 0, 1, 1 } },// 顶点 蓝
    };
    
    // Create a render command encoder.
    /**
     MTLRenderCommandEncoder:
     The object to use for encoding commands for a render pass.
     */
    id<MTLRenderCommandEncoder> renderEncoder = [commandBuffer renderCommandEncoderWithDescriptor:renderPassDescriptor];
    renderEncoder.label = @"MyRenderEncoder";

    // MARK: - Set a Viewport
    /**
     Now that you have the render pipeline state object for the pipeline, you’ll render the triangle.
     You do this using a render command encoder.
     First, set the viewport, so that Metal knows which part of the render target you want to draw into.
     */
    // Set the region of the drawable to draw into. ##The viewport used for transformations and clipping.##
    [renderEncoder setViewport:(MTLViewport){0.0, 0.0, _viewportSize.x, _viewportSize.y, 0.0, 1.0 }];
    
    // Set the render pipeline state for the pipeline you want to use.
    // Now that you have the render pipeline state object for the pipeline, you’ll render the triangle.
    [renderEncoder setRenderPipelineState:_pipelineState];
    
    // Pass in the parameter data.
    // Send Argument Data to the Vertex Function
    /**
     Often, you use buffers (MTLBuffer) to pass data to shaders.
     However, when you need to pass only a small amount of data to the vertex function, as is the case here, copy the data directly into the command buffer.
     
     The sample copies data for both parameters into the command buffer.
     The vertex data is copied from an array defined in the sample.
     The viewport data is copied from the same variable that you used to set the viewport.
     
     In this sample, the fragment function uses only the data it receives from the rasterizer, so there are no arguments to set.
     */
    [renderEncoder setVertexBytes:triangleVertices
                           length:sizeof(triangleVertices)
                          atIndex:VertexInputIndexVertices];
    
    [renderEncoder setVertexBytes:&_viewportSize
                           length:sizeof(_viewportSize)
                          atIndex:VertexInputIndexViewportSize];

    // Draw the triangle.
    // MARK: - Encode the Drawing Command
    /**
     Drawing starts with the first vertex at the array element with index vertexStart and ends at the array element with index vertexStart + vertexCount - 1.
     
     Specify the kind of primitive, the starting index, and the number of vertices.
     When the triangle is rendered, the vertex function is called with values of 0, 1, and 2 for the vertexID argument.
     
     As with Drawing to the Screen Using Metal, you end the encoding process and commit the command buffer.
     However, you could encode more render commands using the same set of steps.
     The final image is rendered as if the commands were processed in the order they were specified.
     (For performance, the GPU is allowed to process commands or even parts of commands in parallel, so long as the final result appears to have been rendered in order.)
     */
    [renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:3];

    [renderEncoder endEncoding];

    // Schedule a present once the framebuffer is complete using the current drawable.
    [commandBuffer presentDrawable:view.currentDrawable];
    
    // Finalize rendering here & push the command buffer to the GPU.
    [commandBuffer commit];
}

- (void)mtkView:(MTKView *)view drawableSizeWillChange:(CGSize)size {
    NSLog(@"%s width = %lf height = %lf", __FUNCTION__, size.width, size.height);
    
    _viewportSize.x = size.width;
    _viewportSize.y = size.height;
}

@end
