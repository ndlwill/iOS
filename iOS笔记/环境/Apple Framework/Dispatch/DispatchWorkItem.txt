DispatchWorkItem åœ¨éœ€è¦æ§åˆ¶å’Œç®¡ç†ä»»åŠ¡æ—¶æ›´å¥½,å¦‚æœåªæ˜¯ç®€å•ä¸¢ä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡ï¼Œç”¨åŸæ¥çš„ block åè€Œæ›´è½»é‡ã€ç›´è§‚ã€‚

DispatchWorkItem â‰ˆ â€œå¯ç®¡ç†çš„ blockâ€
blockï¼šä¸€æ¬¡æ€§åŒ¿åä»»åŠ¡
work itemï¼šæœ‰ã€Œèº«ä»½ã€çš„ä»»åŠ¡å¯¹è±¡

DispatchWorkItem æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼š
å¯èƒ½è¢« retain
å¯èƒ½äº§ç”Ÿå¼•ç”¨ç¯ï¼ˆæ³¨æ„ selfï¼‰

DispatchWorkItem æ¯” block å¥½åœ¨å“ªé‡Œï¼Ÿ
1ï¸âƒ£ å¯ä»¥ å–æ¶ˆï¼ˆcancelï¼‰
let item = DispatchWorkItem {
    if item.isCancelled { return }
    doWork()
}

queue.async(execute: item)
item.cancel()

cancel ä¸ä¼šå¼ºåˆ¶ç»ˆæ­¢æ­£åœ¨æ‰§è¡Œçš„ä»£ç 
åªæ˜¯è®¾ç½®ä¸€ä¸ªçŠ¶æ€ä½
éœ€è¦ä½ åœ¨ä»»åŠ¡å†…éƒ¨ä¸»åŠ¨æ£€æŸ¥

2ï¸âƒ£ å¯ä»¥ çŸ¥é“ä»»åŠ¡æ˜¯å¦æ‰§è¡Œå®Œ
item.notify(queue: .main) {
    print("ä»»åŠ¡å®Œæˆ")
}

3ï¸âƒ£ å¯ä»¥å¤ç”¨ / ä¿å­˜å¼•ç”¨
self.currentWorkItem = item
è¿™ä½¿å¾—ä½ å¯ä»¥ï¼š
ä¸­é€”å–æ¶ˆæ—§ä»»åŠ¡
æ›¿æ¢æ–°ä»»åŠ¡ï¼ˆé˜²æŠ– / èŠ‚æµï¼‰
é¿å…é‡å¤æ‰§è¡Œ

4ï¸âƒ£ é€‚åˆåšã€Œå¯æ§å¹¶å‘æ¨¡å‹ã€
class TaskController {
    private var item: DispatchWorkItem?

    func start() {
        item?.cancel()
        let newItem = DispatchWorkItem { ... }
        item = newItem
        queue.async(execute: newItem)
    }
}


åœ¨ Swift Concurrency å‡ºæ¥ä¹‹åï¼š
| åœºæ™¯           | æ¨è                  |
| ------------ | ------------------- |
| ç®€å•å¼‚æ­¥         | `Task {}`           |
| å¯å–æ¶ˆ          | `Task`ï¼ˆåŸç”Ÿæ”¯æŒ cancelï¼‰ |
| æ—§ç³»ç»Ÿ / GCD    | `DispatchWorkItem`  |
| iOS 13+ å¤æ‚å¹¶å‘ | `async/await`       |
å¦‚æœä½ æ˜¯ï¼š
iOS 15+
æ–°ä»£ç 
ğŸ‘‰ ä¼˜å…ˆ Taskï¼Œå…¶æ¬¡ DispatchWorkItemï¼Œæœ€åè£¸ block


==================================================
1. é˜²æŠ–ï¼ˆDebounceï¼‰â€”â€”â€œåœä¸‹æ¥å†åšâ€

æœç´¢æ¡†è¾“å…¥è”æƒ³
ç”¨æˆ·è¿ç»­è¾“å…¥ï¼šs â†’ sw â†’ swi â†’ swif â†’ swift
åªåœ¨ç”¨æˆ·åœé¡¿ 300ms åå‘èµ·ä¸€æ¬¡è¯·æ±‚

ç”¨ DispatchWorkItem å®ç°é˜²æŠ–
class SearchDebouncer {

    private let queue = DispatchQueue.main
    private var workItem: DispatchWorkItem?

    func input(text: String) {
        // 1. å–æ¶ˆä¸Šä¸€æ¬¡è¿˜æ²¡æ‰§è¡Œçš„ä»»åŠ¡
        workItem?.cancel()

        // 2. åˆ›å»ºæ–°ä»»åŠ¡
        let item = DispatchWorkItem { [weak self] in
            guard let self else { return }
            self.performSearch(text)
        }

        workItem = item

        // 3. å»¶è¿Ÿæ‰§è¡Œ
        queue.asyncAfter(deadline: .now() + 0.3, execute: item)
    }

    private func performSearch(_ text: String) {
        print("ğŸ” search:", text)
    }
}

æ¯æ¬¡è¾“å…¥éƒ½ä¼š cancel ä¸Šä¸€ä¸ªä»»åŠ¡
åªæœ‰â€œæœ€åä¸€ä¸ª WorkItemâ€èƒ½æ´»åˆ°æ‰§è¡Œ
ğŸ‘‰ è¿™å°±æ˜¯â€œæ›¿æ¢æ–°ä»»åŠ¡â€

2. èŠ‚æµï¼ˆThrottleï¼‰â€”â€”â€œä¸€æ®µæ—¶é—´åªåšä¸€æ¬¡â€
æ»šåŠ¨æ—¶ä¸ŠæŠ¥åŸ‹ç‚¹ / åˆ·æ–° UI:
æ»šåŠ¨å¾ˆé¢‘ç¹
500ms å†…æœ€å¤šæ‰§è¡Œä¸€æ¬¡

ç”¨ DispatchWorkItem å®ç°èŠ‚æµï¼ˆleading edgeï¼‰

class Throttler {

    private let queue = DispatchQueue.main
    private let interval: TimeInterval = 0.5
    private var workItem: DispatchWorkItem?
    private var lastFireTime: Date = .distantPast

    func call(_ block: @escaping () -> Void) {
        let now = Date()
        guard now.timeIntervalSince(lastFireTime) > interval else {
            return
        }

        lastFireTime = now

        let item = DispatchWorkItem(block: block)
        workItem = item
        queue.async(execute: item)
    }
}

throttler.call {
    print("ğŸ”¥ fire")
}


æ›´è´´è¿‘â€œæ›¿æ¢ä»»åŠ¡â€çš„èŠ‚æµï¼ˆtrailing edgeï¼‰
class TrailingThrottler {

    private let queue = DispatchQueue.main
    private var workItem: DispatchWorkItem?

    func call(_ block: @escaping () -> Void) {
        workItem?.cancel()

        let item = DispatchWorkItem(block: block)
        workItem = item

        queue.asyncAfter(deadline: .now() + 0.5, execute: item)
    }
}
è¿™æœ¬è´¨ä¸Šï¼š
ä¹Ÿæ˜¯ä¸æ–­ å–æ¶ˆæ—§ä»»åŠ¡
ç”¨æ–°ä»»åŠ¡æ›¿æ¢æ—§ä»»åŠ¡
å’Œé˜²æŠ–éå¸¸æ¥è¿‘ï¼ˆåŒºåˆ«åœ¨è¯­ä¹‰ï¼‰


ä¸ºä»€ä¹ˆè¯´ DispatchWorkItem éå¸¸é€‚åˆâ€œæ›¿æ¢ä»»åŠ¡â€
æ ¸å¿ƒèƒ½åŠ›åªæœ‰ä¸€å¥è¯ï¼š
ä»»åŠ¡æ˜¯ä¸€ä¸ªâ€œå¯¹è±¡â€ï¼Œè€Œä¸æ˜¯ä¸€æ¬¡æ€§çš„ä»£ç å—
ä½ å¯ä»¥ï¼š
ä¿å­˜å®ƒ
å–æ¶ˆå®ƒ
ç”¨æ–°çš„è¦†ç›–æ—§çš„


å¦‚æœæ”¾åˆ° Swift Concurrency é‡Œ
åŒä¸€ä¸ªé˜²æŠ–ï¼Œç”¨ Task ä¼šæ›´è‡ªç„¶ï¼š
var task: Task<Void, Never>?

func input(text: String) {
    task?.cancel()
    task = Task {
        try? await Task.sleep(nanoseconds: 300_000_000) // è¿™æ˜¯ä¾‹å­ï¼Œä¸æ˜¯æœ€ä¼˜çš„å†™æ³•
        performSearch(text)
    }
}



var task: Task<Void, Never>?

func input(text: String) {
    task?.cancel()

    task = Task {
        do {
            try await Task.sleep(nanoseconds: 300_000_000)
            try Task.checkCancellation()
            performSearch(text)
        } catch {
            // cancelled, do nothing
        }
    }
}
