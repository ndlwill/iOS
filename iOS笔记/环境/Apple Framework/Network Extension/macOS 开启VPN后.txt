路由表中的一条显示结果（路由项）
default via 10.0.0.2 dev utun0 // 一条默认路由（default route）
意思是：
“把所有出站流量都交给隧道另一端（10.0.0.2）去转发。”

于是：
应用发起请求（比如访问 8.8.8.8）
系统查路由 → 匹配到 default via 10.0.0.2 // 因此出接口是 utun0。于是系统决定：“源 IP 应该是 utun0 的本地地址（10.0.0.1）”
把包发往 10.0.0.2（通过 utun0）// VPN 客户端不会真的把包发给 10.0.0.2。它看到这是隧道流量，于是会**封装（encapsulate）**成一个新的外层包。
VPN 客户端把这包加密，封装发给真正的 VPN 服务器（公网地址）
VPN 服务器解密，再帮你发到 8.8.8.8

隧道里的流量：
[Inner IP]  Src=10.0.0.1  Dst=8.8.8.8 // #####被 VPN 捕获#####
经过 VPN 封装后，外层包变成：
[Outer IP]  Src=203.0.113.5  Dst=1.2.3.4
（203.0.113.5 是你的真实公网 IP，1.2.3.4 是 VPN 服务器公网 IP）

VPN 客户端会用 UDP / TCP 等协议，把上面的“Inner包”加密后塞进“Outer包”里发送给服务器。

#####
在路由表中，via 10.0.0.2 是给内核看的逻辑“网关”；
在实际网络上传输中，封装后的外层包是从你的真实 IP 发往 VPN 服务器的公网 IP；
而内层包的目标，才是你真正想访问的 8.8.8.8。
#####


| 部分             | 含义                                                                   |
| -------------- | -------------------------------------------------------------------- |
| `default`      | 目标网络：代表**所有目的地址（0.0.0.0/0）**，即“任何非特定的目的IP”都匹配这条规则。                   |
| `via 10.0.0.2` | 下一跳（next hop）：表示数据包应该通过 `10.0.0.2` 这个网关转发出去。                         |
| `dev utun0`    | 出口设备（interface）：指定这条路由通过哪个网络接口发送，比如 `utun0` 是一个**虚拟隧道接口**（通常用于 VPN）。 |


意思总结：
“把所有未匹配到其他路由的流量（默认路由）都通过 utun0 接口，发给网关 10.0.0.2。”


==================================================物理网卡 & 虚拟网卡
default 192.168.254.1 UGScg en1
default：默认路由（匹配所有目标地址）。
192.168.254.1：下一跳（网关 IP），也就是你路由器的局域网地址。
en1：Wi-Fi 网卡。
流程：
App → 系统网络栈 → 根据路由表查找 default → 把 IP 包交给 en1 → 发到 192.168.254.1（物理路由器）。
物理上，这个包真的是直接发给 192.168.254.1 这个网关。


VPN 开启时的路由表
default via 10.0.0.2 dev utun0
这里的情况就完全不同了。
这时：
utun0 是系统创建的 虚拟网卡（TUN 接口）。
10.0.0.2 是 VPN 服务器端的虚拟 IP 地址（不是公网 IP！）。
10.0.0.1 通常是本地虚拟接口的地址（客户端的虚拟 IP）。
所以这条路由的语义是：
对系统来说，所有流量都“发送到 10.0.0.2，通过 utun0 接口出去”。
但是注意：
“发送到 10.0.0.2” 只是逻辑层面（虚拟隧道内的 IP）。
并不是物理层面真实的网络下一跳！


为什么要这么设计？
VPN 的本质是“隧道（Tunnel）”。

macOS/iOS 的网络栈在发送 IP 包时，只看到：
目标：142.250.183.78（例如 Google）
路由：default via 10.0.0.2 dev utun0

系统于是把这个包交给了 utun0。
utun0 的驱动（或 Packet Tunnel Provider）会把这个包：
封装成一个新的外层包；
外层的目标 IP 才是 VPN 服务器的公网地址，比如 1.2.3.4；
通过物理网卡（如 en1）发出。

| 层次        | 数据包目标                 | 发往接口  |
| --------- | --------------------- | ----- |
| 应用视角      | 142.250.183.78        | -     |
| 系统路由层     | 10.0.0.2（虚拟）          | utun0 |
| 物理层（真实发送） | 1.2.3.4（VPN 服务器公网 IP） | en1   |

这条路由并不是告诉系统“下一跳在公网是 10.0.0.2”，
而是告诉系统：
#####
“所有流量都交给 utun0 这个虚拟接口，它内部负责转发到真正的 VPN 服务器。”
#####
10.0.0.2 在这里只是一个逻辑占位符，表示虚拟隧道的对端地址，方便系统有一个 IP 层的“下一跳”概念。

App
 ↓
系统网络栈查路由（default via 10.0.0.2 dev utun0）
 ↓
VPN 虚拟网卡 utun0 收到数据包
 ↓
VPN Provider 封装（外层IP=VPN服务器公网IP）
 ↓
物理网卡 en1 发出（比如到 1.2.3.4）
 ↓
VPN 服务器解封装 → 把内层原始包发往真实目标


真正物理发送的下一跳是 VPN 服务器的公网 IP（例如 1.2.3.4），由 VPN 进程负责封装和转发。


==================================================
虚拟网卡（Virtual Network Interface / Virtual Network Adapter）本质上就是“软件实现的网卡”。
虚拟网卡 = 一块“系统认为存在”的网卡，
但它其实不连物理线，而是和软件或另一虚拟接口通信。

| 项目      | 实体网卡（物理网卡）         | 虚拟网卡（软件网卡）                                |
| ------- | ------------------ | ----------------------------------------- |
| 存在形式    | 硬件设备（芯片、电路）        | 内核或用户态的软件逻辑                               |
| 驱动层面    | 通过物理驱动与 PCIe 等总线通信 | 通过虚拟驱动（TUN/TAP、utun、veth 等）注册到系统          |
| 数据来源/去向 | 数据真正流入/流出主机        | 数据其实是流入/流出**另一段软件程序**（比如 VPN 客户端、虚拟机、容器等） |
| 作用      | 连接主机与真实网络          | 连接主机与“虚拟网络”或“用户空间程序”                      |


当你启动 VPN 隧道（比如使用 utun4）时，系统会被虚拟出一张“假网卡”，例如：
utun4: flags=8051<UP,POINTOPOINT,RUNNING,MULTICAST> mtu 1400
	inet 10.253.243.182 --> 10.253.240.1 netmask 0xff000000 // #####并不表示“你的 app 要把数据包转发到 10.253.240.1”，而是表示 虚拟隧道（TUN）内部的两端地址映射关系。#####
它来自 ifconfig 命令，显示的是 macOS 上 VPN 虚拟网卡（utun4）的配置

#####
这个箭头 仅仅代表这是一个“点对点（POINTOPOINT）”链路，// 表示点对点链路关系，不代表真实传输方向
并不是说系统要真的“发包到 10.253.240.1”。
#####


| 角色   | 地址         | 含义                           |
| ---- | ---------- | ---------------------------- |
| 本地地址 | `10.253.243.182` | 你这台设备（VPN 客户端）在隧道里的 IP       |
| 对端地址 | `10.253.240.1` | VPN 服务器（或 VPN 隧道另一端）在隧道里的 IP |

它们其实是一对“点对点地址（point-to-point link）”
#####
VPN 隧道不是一个传统的局域网，而是一个**点到点（Point-to-Point）**的虚拟链路。
#####
就像两台设备用一根虚拟网线直连一样：
你本地的 utun4: 10.253.243.182  <——虚拟隧道——>  服务器的隧道接口: 10.253.240.1
所以：
你看到的“下一跳（via 10.253.240.1）”，其实就是VPN 隧道另一头；
它是你“在隧道中能到达的唯一对端 IP”。


utun4 是一个 虚拟隧道接口（TUN interface），由 macOS 的网络扩展（比如 VPN 客户端或 NetworkExtension 框架）创建。
它用于在用户态（你的 VPN app）和内核网络栈之间传递 IP 数据包。

第一行：接口状态
表示这个虚拟网卡的状态：
| 标志              | 含义                                             |
| --------------- | ---------------------------------------------- |
| **UP**          | 接口已启用（即“已打开”）                                  |
| **POINTOPOINT** | 这是一个点对点（Point-to-Point）链路，没有广播地址，例如常见于 VPN、PPP |
| **RUNNING**     | 接口正在运行且可传输数据                                   |
| **MULTICAST**   | 支持多播（通常 VPN 并不真的用到）                            |
说明：这个接口已经处于工作状态，可以收发封装后的 IP 数据。

第二行：IP 地址配置
inet 10.253.243.182 --> 10.253.240.1 netmask 0xff000000
| 字段                      | 含义                                    |
| ----------------------- | ------------------------------------- |
| **inet 10.253.243.182** | 本地虚拟网卡（你的设备）在 VPN 虚拟网段中的 IP 地址        |
| **--> 10.253.240.1**    | 对端（VPN 网关 / 服务器）地址                    |
| **netmask 0xff000000**  | 子网掩码 `255.0.0.0`（即 `/8`），用于标识这个虚拟网段范围 |


你的设备 (macOS)
 10.253.243.182
      │
      │ utun4（虚拟隧道接口）
      │
      ▼
 VPN 网关
 10.253.240.1 // 10.253.240.1 通常就是 VPN 服务器在隧道内的虚拟网卡地址

所有通过 VPN 的流量，都会被封装、通过这个点对点通道发送到对端 10.253.240.1。
实际上，10.253.243.182 和 10.253.240.1 并非真正的公网地址，而是 隧道内虚拟分配的地址。
对端（10.253.240.1）通常是 VPN 服务端在隧道内的 IP，它会解封装数据包并转发到真实目标。


MTU 1400
mtu 1400 表示最大传输单元为 1400 字节；
这比常规以太网（1500）略小，是因为 VPN 隧道会加上加密封装（IP + UDP/TCP + VPN header），需要留出空间。






VPN 隧道的两端都有“虚拟 IP”:
当你连接 VPN 时，系统会在客户端（macOS）和服务端（VPN 服务器）之间建立一个「虚拟的点对点网络」。

inet 10.253.243.182 --> 10.253.240.1
| 角色          | 设备            | 虚拟 IP          | 说明         |
| ----------- | ------------- | -------------- | ---------- |
| 客户端（你的 Mac） | utun4         | 10.253.243.182 | 你的本地虚拟网卡   |
| 服务端（VPN 网关） | tunX（或内部虚拟接口） | 10.253.240.1   | 服务端虚拟网卡的地址 |

所以整个 VPN 隧道内部就像是这条点对点链路：
10.253.243.182 (你的 Mac)
      ⇅
   [VPN 隧道]
      ⇅
10.253.240.1 (VPN 服务器)



VPN 的“虚拟 IP”并非公网 IP:
这两个地址（10.x.x.x）都来自 私有网段（RFC1918 内部地址空间），它们只存在于 VPN 隧道内部。
      外部世界（比如 ISP、互联网）看不到这些地址；
      实际通信是封装在真实网络包里发到 VPN 服务器的；

例如： 
外层 IP（真实物理传输）：
203.0.113.5 → 198.51.100.10 

内层 IP（VPN 隧道内部）： 
10.253.243.182 → 10.253.240.1


#####这边要注意:
内层 IP（VPN 隧道内部）： 
10.253.243.182 → 10.253.240.1

这是 你的设备（客户端）和 VPN 服务器之间的隧道通信。
这个是虚拟网卡的点对点地址对（client → server）。
这部分只是 “隧道承载层”，主要用于封装和传递实际用户数据。 // #####

举个例子:
VPN 隧道里的“用户真实流量”层
真正的用户请求，比如 Safari 访问 Google:
10.253.243.182 → 142.250.183.78（Google）

这才是 隧道内封装的实际 payload，VPN 客户端把这个 IP 包：
src = 10.253.243.182
dst = 142.250.183.78
再封装在一个新的外层包中发送给 VPN 服务器：// 封装层	实际通过公网 IP（比如 TCP/UDP over IPsec, OpenVPN, WireGuard 等）传输
外层：203.0.113.5 → 198.51.100.10
VPN 服务器收到后解封，取出内层包，再通过自己的物理网卡发到真正的公网：
203.0.113.10（服务器出口） → 142.250.183.78

所以:
前面写的「10.253.243.182 → 10.253.240.1」描述的是 VPN 隧道接口本身的点对点连接（控制通道）。
而不是用户实际流量的封装内容。
| 类型                 | 示例                              | 用途               |
| ------------------ | ------------------------------- | ---------------- |
| **隧道控制层（TUN 点对点）** | 10.253.243.182 → 10.253.240.1   | VPN 接口通信（用于封装转发） |
| **隧道内数据层（用户流量）**   | 10.253.243.182 → 142.250.183.78 | 用户访问真实网站的 IP 包   |
#####