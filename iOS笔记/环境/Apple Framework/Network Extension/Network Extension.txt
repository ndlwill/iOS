https://kean.blog/post/networking-101
https://kean.blog/post/vpn-configuration-manager
https://kean.blog/post/packet-tunnel-provider


Debugging a Network Extension Provider:
https://developer.apple.com/forums/thread/725805


Also, consider doing your bring up on the Mac even if your final target is iOS. 
macOS has a bunch of handy tools for debugging networking issues, including:
dig for DNS queries
nc for TCP and UDP connections
netstat to display the state of the networking stack
tcpdump for recording a packet trace

dig → 查 DNS
nc → 测 TCP/UDP连通性
netstat → 查看网络状态
tcpdump → 抓包分析

/*
dig 只检查域名能否正确解析，也就是把域名（如 api.example.com）解析成 IP 地址。

dig 是在 macOS 上查询 DNS 的工具。
当你在开发 iOS App 时，App 可能会发起网络请求（HTTP、HTTPS、API 请求等）。
在 Mac 上用 dig 可以：
检查 App 访问的域名是否能解析。
验证 DNS 解析是否符合预期。
排查 iOS 网络问题前，先确认 DNS 没问题。

dig api.example.com
可以模拟 iOS App 的请求目标，看看返回的 IP 地址、TTL 是否正确。
如果你在使用自定义 DNS 或 VPN，也可以用 dig 指定服务器：
dig @8.8.8.8 api.example.com

配合 nc、netstat、tcpdump，可以形成完整的网络调试流程：
dig → 检查 DNS
nc → 测端口可达性
netstat → 看网络状态
tcpdump → 抓包分析流量
*/
dig（Domain Information Groper）
用途：查询 DNS 信息。
功能：
可以查某个域名对应的 IP 地址。
可以查询 MX（邮件）、TXT（文本记录）、NS（域名服务器）等各种 DNS 记录。
示例：
dig apple.com
输出会显示 apple.com 的 A 记录（IPv4 地址）、TTL 等信息。
作用：帮你检查 DNS 是否解析正确，排查域名解析失败的问题。

/*
nc（netcat）在调试 iOS App 网络问题时，是 紧接在 dig 之后的第二步，作用是检查 网络连通性。
测试 TCP/UDP 端口是否可达
比如你的 iOS App 要访问 api.example.com:443（HTTPS），先用 dig 确认域名解析没问题，再用 nc 看端口是否能连接。

假设 App 要访问 HTTPS API：
dig api.example.com
# 确认解析得到 IP，比如 17.253.144.10
nc -vz 17.253.144.10 443
Connection to 17.253.144.10 port 443 [tcp/https] succeeded!
-v → verbose，显示详细信息
-z → 只扫描端口，不发送数据 // 不发送实际数据，只做“端口探测”
成功表示 TCP 层连通，可以进一步用 App 请求

nc -z 的作用是 只检查端口是否开放/监听，不建立完整的会话或发送应用数据。
它测试的是 TCP 或 UDP 服务是否在目标端口上正常运行。

不加-vz，尝试建立到目标 IP 的指定端口的连接
不加 -z → 会真正建立连接，可以发送和接收数据
也就是说，这条命令会：
向 17.253.144.10 的 443 端口发起 TCP 三次握手（建立连接）
建立成功后，终端就可以直接输入内容发送到服务器（比如手工测试 HTTP 请求）
连接关闭前，可以接收服务器返回的数据

| 命令                        | 作用                        |
| ------------------------- | ------------------------- |
| `nc -z 17.253.144.10 443` | **只探测端口是否开放**，不发送数据       |
| `nc 17.253.144.10 443`    | **建立实际 TCP 连接**，可以发送/接收数据 |
*/
nc（netcat）
用途：测试 TCP 和 UDP 连接。
功能：
可以快速连接远程主机的端口，看是否通。
可以作为简单的 TCP/UDP 服务器或客户端。
示例：
nc google.com 80
会尝试连接 google.com 的 80 端口，如果连接成功就说明网络通。
作用：排查端口是否可达，或者测试服务是否响应。

/*
netstat 的作用是 检查本机网络连接和端口状态，属于 TCP/IP 层面的“状态查看工具”

可以列出当前所有 TCP/UDP 连接和监听端口
看到 App 是否成功建立了网络连接，或者连接失败的原因
netstat -an
tcp4       0      0  192.168.1.100.54321   17.253.144.10.80     ESTABLISHED
tcp4       0      0  *.443                 *.*                  LISTEN
ESTABLISHED → 已成功建立连接
LISTEN → 本地有服务在监听端口

查看路由和接口信息
可以检查默认网关、网络接口状态
netstat -rn
对调试 VPN、代理或者多网卡环境特别有用
*/
netstat
用途：显示网络连接和网络状态。
功能：
查看当前的 TCP/UDP 连接。
显示监听的端口。
显示路由表和网络接口状态。
示例：
netstat -an
可以列出所有网络连接及端口状态。
作用：帮助你理解当前网络栈的状态，比如某个端口是否被占用、连接是否建立。

/*
tcpdump 可以看到网络包的“内容”，而 netstat 只能看到连接的“存在”。
*/
tcpdump
用途：抓包工具。
功能：
可以捕获经过网卡的数据包。
可以指定端口、协议、IP 等过滤条件。
示例：
sudo tcpdump -i en0 port 80
捕获本机 en0 网卡的 80 端口流量。
作用：帮助你记录和分析网络流量，排查网络协议问题、包丢失、错误数据等。

完整例子：
dig apple.com // 17.253.144.10

// 80 端口（HTTP），就可以直接用 nc 发送文本 HTTP 请求了，因为 80 是明文 HTTP，不需要加 TLS/SSL
// 443 是 HTTPS，服务器期待 TLS 握手，然后才接受 HTTP 请求。因此你直接发的文本被服务器忽略了，没有任何响应，也没有错误提示
nc 17.253.144.10 80 
然后输入
GET / HTTP/1.1
Host: apple.com
// 这里是空行
（注意最后必须空一行，表示请求结束）
就会得到响应

如果你用普通 nc 17.253.144.10 80（不加 -z）建立了真实连接：（后续不输入GET / HTTP/1.1这些，终端处于类似等待输入状态）
netstat 可以显示本机到目标服务器的 TCP 连接是否已经 ESTABLISHED
netstat -an | grep 17.253.144.10 
tcp4       0      0  10.253.253.168.61652   17.253.144.10.80       ESTABLISHED
-a → 显示 所有连接和监听端口
-n → 数字显示，直接显示 IP 和端口，不解析成域名
tcp4 → 使用 IPv4 TCP
10.253.253.168.61652 → 本机 IP + 本地端口
17.253.144.10.80 → 远程 IP + 远程端口
ESTABLISHED → TCP 连接已经成功建立
| 列                     | 含义                                    |
| --------------------- | ------------------------------------- |
| `tcp4`                | 使用 IPv4 TCP 协议                        |
| `0`（第一个）              | **发送队列（Send-Q）**，即本地待发送的数据字节数         |
| `0`（第二个）              | **接收队列（Recv-Q）**，即已到达但还未被本地应用读取的数据字节数 |
| `192.168.1.100.54321` | 本地 IP 和端口                             |
| `17.253.144.10.443`   | 远程 IP 和端口                             |
| `ESTABLISHED`         | TCP 连接状态，已建立                          |

一个终端执行
tcpdump -i en1 host 17.253.144.10
另一个执行
nc 17.253.144.10
得到
15:17:57.161708 IP 192.168.254.66.62581 > apple.com.ai.http: Flags [S], seq 1982345212, win 65535, options [mss 1460,nop,wscale 6,nop,nop,TS val 1575256189 ecr 0,sackOK,eol], length 0
15:17:57.189607 IP apple.com.ai.http > 192.168.254.66.62581: Flags [S.], seq 1083412561, ack 1982345213, win 31856, options [mss 1380,sackOK,TS val 3180845247 ecr 1575256189,nop,wscale 9], length 0
15:17:57.189806 IP 192.168.254.66.62581 > apple.com.ai.http: Flags [.], ack 1, win 2052, options [nop,nop,TS val 1575256217 ecr 3180845247], length 0
这就是典型的 TCP 三次握手
| 字段                                              | 含义                                           |
| ----------------------------------------------- | -------------------------------------------- |
| **15:17:57.161708**                             | 抓包时间                                         |
| **IP 192.168.254.66.62581 > apple.com.ai.http** | 本机 (源端口 62581) → 服务器 (`apple.com` 的 HTTP 服务) |
| **Flags [S]**                                   | SYN（请求建立连接）                                  |
| **seq 1982345212**                              | 客户端的初始序列号，TCP 序列号（Sequence Number）——告诉对方“我的数据序列起点”                                    |
| **win 65535**                                   | 初始接收窗口大小 ，TCP 窗口大小（Window Size）——告诉对方我当前可接收的字节数                                  |
| **options [...]**                               | TCP 选项（现代 TCP 会携带）                           |
| **length 0**                                    | 没有应用层数据，TCP 负载长度，此处为 0，因为 SYN 包通常不携带数据                                      |
| 选项                          | 含义                                                       |
| --------------------------- | -------------------------------------------------------- |
| **mss 1460**                | 最大分段大小 (MSS)：告诉对方「我每次能接收的最大 TCP payload 是 1460 字节」       |
| **nop**                     | 填充（No Operation），用于选项字节对齐                                |
| **wscale 6**                | 窗口缩放系数 (Window Scale) = 2⁶ = 64，用于支持超过 64KB 的窗口          |
| **TS val 1575256189 ecr 0** | TCP 时间戳选项（Timestamp）：`val` 是当前时间戳，`ecr=0` 因为第一次通信对方时间戳未知 |
| **sackOK**                  | 支持 SACK（Selective Acknowledgment，可选择性确认）                 |
| **eol**                     | End of Options List（选项结束标志）                              |

| 字段                 | 含义                                 |
| ------------------ | ---------------------------------- |
| **Flags [S.]**     | SYN + ACK（服务器确认客户端 SYN，并发送自己的 SYN），. = ACK（确认） |
| **seq 1083412561** | 服务器的初始序列号                          |
| **ack 1982345213** | 确认号 = 客户端 seq + 1，表示“我收到了你的 SYN”   |
| **win 31856**      | 服务器的接收窗口大小（未缩放）                    |
| **options [...]**  | 服务器返回的 TCP 选项                      |
| **length 0**       | 仍然没有应用层数据                          |
| 选项                                   | 含义                                    |
| ------------------------------------ | ------------------------------------- |
| **mss 1380**                         | 服务器允许的最大报文段（因为 MTU 可能更小）              |
| **sackOK**                           | 同样支持 SACK                             |
| **TS val 3180845247 ecr 1575256189** | 时间戳：`val` = 服务器时间戳，`ecr` = 对客户端时间戳的回显 |
| **wscale 9**                         | 窗口缩放系数 2⁹ = 512，服务器也支持窗口扩展            |

ack 1 实际上是相对序列号（tcpdump 默认在启用“relative sequence numbers”模式下显示）。
TCP 窗口大小（win）从 65535 减小到了 2052
win（Window Size）表示：
当前一方的接收端缓冲区（Receive Window）还能接受多少字节的数据。
它是 TCP 实现 流量控制 (Flow Control) 的关键机制。
简单说：
值越大，说明接收端还能装更多数据；
值越小，说明接收端现在有点“忙”，暂时别发太多。
对 tcpdump 的输出来说，确实就是 2052；
但对 TCP 协议栈实际行为 来说，它是 2052 × 2^wscale。
| 字段               | 含义                              |
| ---------------- | ------------------------------- |
| **Flags [.]**    | 只有 ACK，表示确认前一个 SYN+ACK          |
| **ack 1**        | 确认号 = 服务器 seq + 1（确认收到服务器的 SYN） |
| **win 2052**     | 当前窗口值（已应用 wscale 缩放）            |
| **TS val / ecr** | 时间戳回显，对上一个包的 `val` 进行确认         |
| **length 0**     | 未携带数据，连接刚刚建立完成                  |

| 选项            | 全称                       | 作用                     |
| ------------- | ------------------------ | ---------------------- |
| **MSS**       | Maximum Segment Size     | 告诉对方单个 TCP 段最大 payload |
| **WSCALE**    | Window Scale             | 扩大窗口范围以支持高速网络          |
| **TS**        | Timestamp                | 提高 RTT 精度，避免旧包混入       |
| **SACK**      | Selective Acknowledgment | 支持“只重传丢失的片段”           |
| **NOP / EOL** | 对齐 / 结束                  | 选项填充控制                 |


netstat 只告诉你 “连接已建立”，
tcpdump 则能告诉你 “连接是怎么建立的、有没有丢包、有没有 TLS 握手失败”。

| 命令                                       | 作用                         |
| ---------------------------------------- | -------------------------- |
| `sudo tcpdump -i en1`                    | 抓取 Wi-Fi 接口的所有包            |
| `sudo tcpdump -i en1 host 17.253.144.10` | 只抓与目标 IP 的通信               |
| `sudo tcpdump -i utun4`                  | 抓 VPN 接口的包（常用于 iOS VPN 调试） |
| `sudo tcpdump -i en1 port 443`           | 只抓 HTTPS 流量                |
| `sudo tcpdump -A -i en1 port 80`         | 抓 HTTP 明文内容                |


Your Friend the System Log
https://developer.apple.com/forums/thread/705868

Get started with a supervised iPhone or iPad
https://support.apple.com/en-us/HT202837

Recording a Packet Trace
https://developer.apple.com/documentation/network/recording-a-packet-trace


==============================NEDNSProxyProvider
NEDNSProxyProvider is only available on supervised devices

==============================
http://www.openradar.me/page/1

==============================Personal VPN 
The NEVPNManager (iOS 8+) API gives apps the ability to create and manage a VPN configuration (one per app).
NEVPNManager
An object to create and manage a Personal VPN configuration.

==============================Network Tunneling Protocol Client
The NETunnelProvider APIs allow apps to implement the client side of a custom network tunneling protocol (e.g. VPN protocols).

https://developer.apple.com/documentation/networkextension/nepackettunnelprovider
NEPacketTunnelProvider (iOS 9+) gives its subclasses access to reading and writing to a virtual network interface. 
In general, you would establish the connection with a VPN server, configure the tunnel, 
and start reading ###IP packets### coming from the virtual network interface and sending them to the VPN server.

https://developer.apple.com/documentation/networkextension/neappproxyprovider
NEAppProxyProvider (iOS 9+, supervised devices, managed apps only) is very similar to the NEPacketTunnelProvider, 
but operates on a TCP/UDP level instead of IP level.

The provider subclass should be added inside a special app extension target. 
The app extension will be automatically started by the system when necessary. 
In some cases, e.g. always-on VPN, the process running an extension will run indefinitely and will automatically be started even after the system restart.

You won’t be able to run any of these app extensions in a simulator, and to run in on a device you will need to create an entitlement.

==============================On-Device Network Content Filter
The NEFilterProvider (iOS 9+, supervised devices) APIs give the ability to filter network traffic on iOS devices. 
This API was designed primarily for devices owned by schools. 
In general, most schools have some sort of content filtering enabled on their local WiFi networks, 
but that doesn’t work with mobile networks. With NEFilterProvider the traffic filtering is going to work regardless of which network the device is connected to.

==============================DNS Proxy
The NEDNSProxyProvider (iOS 11+, supervised devices) API allows apps to intercept all of the network traffic coming from the device. 
This allows apps to send DNS queries to preferred DNS servers, use custom DNS protocols (e.g. DNS over HTTPS which is supported by recently introduced Cloudflare DNS, by Google Public DNS and other DNS services), and more. One of the reasons to use custom (and encrypted) DNS protocols is to avoid DNS hijacking, which is a common practice among US mobile network operators.

https://developers.google.com/speed/public-dns/docs/doh/json?hl=zh-cn

==============================Wi-Fi Hotspot Authentication and Configuration
The NEHotspotHelper (iOS 9+) API gives apps the ability to perform custom authentication for Wi-Fi Hotspots. It can also give users a way to seamlessly connect to a large network of Wi-Fi Hotspots. The NEHotspotConfiguration (iOS 11+) API lets apps configure these hotspots.

==============================SimpleTunnel
https://developer.apple.com/library/archive/samplecode/SimpleTunnel/Introduction/Intro.html

==============================DNS hijacking
https://www.dnsoverride.com/dns-hijacking-by-some-mobile-carriers/


https://github.com/kean/VPN

https://github.com/kean/Pulse

https://github.com/kean/Nuke


==============================VPN Profiles
https://kean.blog/post/vpn-configuration-manager

You don’t need a Personal VPN entitlement which allows apps to create and control a custom system VPN configuration using NEVPNManager. 
The Packet Tunnel Provider entitlements are classified as enterprise VPNs and only require Network Extension entitlement.

The primary interface for managing VPN configurations that use a custom VPN protocols is NETunnelProviderManager, which is a sublcass of NEVPNManager.

You can use NEVPNManager without the tunnel provider to create and manage personal VPN configurations that use one of the built-in VPN protocols (IPsec or IKEv2).

1. The first thing that you want to do when your app starts is read the exiting configuration.
NETunnelProviderManager.loadAllFromPreferences { managers, error in
    // Where managers: [NETunnelProviderManager]
}
This method reads all of the VPN configurations created by the calling app that have previously been saved to the Network Extension preferences. 
The completion closure gives you the list of “managers”, each represents a single saved VPN configuration.

Installing VPN Profile:
private func makeManager() -> NETunnelProviderManager {
    let manager = NETunnelProviderManager()
    manager.localizedDescription = "BestVPN"

    // Configure a VPN protocol to use a Packet Tunnel Provider
    let proto = NETunnelProviderProtocol()
    // This must match an app extension bundle identifier
    proto.providerBundleIdentifier = "com.github.kean.vpn-client.vpn-tunnel"
    // Replace with an actual VPN server address
    proto.serverAddress = "127.0.0.1:4009"
    // Pass additional information to the tunnel
    proto.providerConfiguration = [:]

    manager.protocolConfiguration = proto

    // Enable the manager by default
    manager.isEnabled = true

    return manager
}

Once you created an instance of NETunnelProviderManager, you can save it:
let manager = makeManager()
manager.saveToPreferences { error in
    if error == nil {
        // Success
    }
}

I would sometimes encounter an issue where I would not be able to start a VPN tunnel right after saving it. 
A workaround seems to be to reload the manager using loadFromPreferences() method right after saving it.

https://developer.apple.com/forums/


Managing VPN:
Now that the profile is installed, the same NETunnelProviderManager instance can be used to update it and to manage the connection status.

Enabled VPN configuration have isEnabled flag set to true.


https://developer.apple.com/documentation/networkextension/netunnelprovidermanager#1661690
Configuration Model:
Each NETunnelProviderManager instance corresponds to a single VPN configuration stored in the Network Extension preferences. 
Multiple VPN configurations can be created and managed by creating multiple NETunnelProviderManager instances.

VPN configurations created using NETunnelProviderManager are classified as regular enterprise VPN configurations (as opposed to the Personal VPN configurations created by NEVPNManager).
Only one enterprise VPN configuration can be enabled on the system at a time.
If both a Personal VPN and an enterprise VPN are active on the system simultaneously, the enterprise VPN takes precedence, 
meaning that if the routes for the two VPNs conflict then the routes for the enterprise VPN will take precedence.
The Personal VPN will remain active and connected while the enterprise VPN is active and connected, and any traffic that is routed to the Personal VPN and is not routed to the enterprise VPN will continue to traverse the Personal VPN.



To detect configuration changes, use NEVPNConfigurationChange notification.
VPN Settings:
If you go to Settings / General / VPN, you are going to see your VPN configuration registered there.

The settings screen allow user to switch between configurations (isEnabled), start/stop VPN, and even remove the configuration. 
This is why it is important to use .NEVPNConfigurationChange and .NEVPNStatusDidChange notification to update your app UI accordingly.