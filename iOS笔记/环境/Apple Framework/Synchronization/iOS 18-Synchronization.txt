帮助开发者在多线程环境中实现线程安全

1. Mutex：现代化的互斥锁
特点：
线程竞争时，其他线程必须等待锁释放。
类比：
想象你家有一把钥匙（Mutex），房间里一次只能一个人进去操作桌子上的东西。别人必须等你出来才能进去。

Mutex 是一种用于实现互斥访问的同步原语，确保同一时刻只有一个线程可以访问共享资源。
与传统的 NSLock 或 DispatchSemaphore 相比，Mutex 提供了更轻量级的同步机制，特别适用于需要同步访问非 Sendable 类型（如 NSBezierPath）的场景。
它是 Swift Concurrency 的一部分，支持与 async/await 协同工作。

import Synchronization

let counter = Mutex(0)

Task {
    await counter.withLock { value in // withLock 方法确保在访问 counter 时不会发生数据竞争。
        print("Current value: \(value)")
    }
}


2. Atomics：原子操作原语 
本质：Atomics 是无锁的原子操作，使用 CPU 提供的 原子指令 来保证操作不会被中断。// 利用 CPU 原子指令保证一致性，无需锁。
特点：
无需显式锁，性能更高。
只能安全操作简单数据类型（如整数、布尔值、指针）。
每个操作是不可分割的（atomic），保证其他线程看到的值始终是合法的状态。
使用 CAS（Compare-And-Swap）或者类似机制来实现更新。
类比：
想象你在银行柜台存钱，柜台有一台自动机（CPU原子指令），你把钱投入后，机器会自动保证不和别人冲突，别人看到的余额总是更新后的正确值。

Atomics 提供了一组原子操作，允许开发者对共享数据进行无锁的原子更新。
这些操作是不可分割的，确保在多线程环境中数据的一致性。

import Synchronization

let atomicCounter = Atomic(0)

Task {
    atomicCounter.add(1) // add(1) 操作是原子的：要么完整执行加1，要么完全不执行。
    print("Updated value: \(atomicCounter.load())")
}
add 和 load 方法确保对 atomicCounter 的操作是原子的，避免了传统锁机制的开销。


Atomics 如何保证数据一致性（底层机制）：
原子性操作：CPU 提供 lock cmpxchg 或类似指令。
不可分割：在执行操作期间，操作要么全部执行成功，要么不执行，中途不会被切换。
内存可见性：CPU 会确保修改后的值立即对其他线程可见（memory barrier）。
无锁竞争：通过 CAS（Compare-And-Swap）不断尝试更新，直到成功。
CAS 示例（简化版）：
当前值 = 5
线程A希望加1:
  比较当前值是不是5？是 -> 写入6
线程B同时加1:
  比较当前值是不是5？不是 -> 重试 // #####这种机制就是典型的 自旋（spin）。#####
最终结果 = 7，两个线程都生效
CAS 保证了在高并发下，即使没有锁，也不会丢失更新。


什么叫“原子操作”
原子（atomic） 的意思是不可分割，即操作在执行时不会被中断，其他线程不能在中间看到半成品状态。
完整执行：操作从开始到结束，中间不会被打断。
完全不执行：如果因为某种原因操作不能完成，它就不会改变原来的值。


在选择使用 Mutex 或 Atomics 时，开发者应根据具体的应用场景和性能需求进行权衡。
对于需要高性能和无锁操作的场景，Atomics 是更合适的选择；而对于需要同步访问非 Sendable 类型的场景，Mutex 更为适用。



自旋锁（spinlock）指：
当一个线程无法完成操作时，不会立即挂起，而是循环尝试，直到操作成功或达到某种条件。
CPU 会不断检查共享变量的状态，直到可以修改为止。
这种方式避免了线程挂起和唤醒的开销，但如果等待时间长，会浪费 CPU。


| 特性     | Mutex               | Atomics + CAS（自旋） |
| ------ | ------------------- | ----------------- |
| 失败处理   | 阻塞等待锁释放             | 立即重试（自旋）          |
| CPU 占用 | 低（阻塞挂起，不占用 CPU）     | 高（自旋会占用 CPU）      |
| 适用场景   | 复杂数据结构或 async/await | 简单原子变量，高性能短操作     |
