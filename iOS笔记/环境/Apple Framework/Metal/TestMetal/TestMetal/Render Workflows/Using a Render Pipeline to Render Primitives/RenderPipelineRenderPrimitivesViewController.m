//
//  RenderPipelineRenderPrimitivesViewController.m
//  TestMetal
//
//  Created by youdun on 2023/8/25.
//

#import "RenderPipelineRenderPrimitivesViewController.h"
#import "Renderer1.h"
#import <simd/simd.h>
@import MetalKit;

// MARK: - Using a Render Pipeline to Render Primitives
/**
 Render a simple 2D triangle.
 
 This sample shows you how to configure a render pipeline and use it as part of the render pass to draw a simple 2D colored triangle into the view.
 The sample supplies a position and color for each vertex, and the render pipeline uses that data to render the triangle, interpolating color values between the colors specified for the triangle’s vertices.
 
 Understand the Metal Render Pipeline:
 A render pipeline processes drawing commands and writes data into a render pass’s targets.
 A render pipeline has many stages, some programmed using shaders and others with fixed or configurable behavior.
 This sample focuses on the three main stages of the pipeline: the vertex stage, the rasterization stage, and the fragment stage.
 The vertex stage and fragment stage are programmable, so you write functions for them in Metal Shading Language (MSL).
 The rasterization stage has fixed behavior.
 
 Rendering starts with a drawing command, which includes a vertex count and what kind of primitive to render.
 
 The vertex stage provides data for each vertex.
 When enough vertices have been processed, the render pipeline rasterizes the primitive, determining which pixels in the render targets lie within the boundaries of the primitive.
 The fragment stage determines the values to write into the render targets for those pixels.
 
 Decide How Data is Processed by Your Custom Render Pipeline:
 A vertex function generates data for a single vertex and a fragment function generates data for a single fragment, but you decide how they work.
 You configure the stages of the pipeline with a goal in mind, meaning that you know what you want the pipeline to generate and how it generates those results.
 Decide what data to pass into your render pipeline and what data is passed to later stages of the pipeline. There are typically three places where you do this:
 The inputs to the pipeline, which are provided by your app and passed to the vertex stage.
 The outputs of the vertex stage, which is passed to the rasterization stage.
 The inputs to the fragment stage, which are provided by your app or generated by the rasterization stage.
 
 In this sample, the input data for the pipeline is the position of a vertex and its color.
 To demonstrate the kind of transformation you typically perform in a vertex function, input coordinates are defined in a custom coordinate space, measured in pixels from the center of the view.
 These coordinates need to be translated into Metal’s coordinate system.
 
 Declare an CustomVertex structure, using SIMD vector types to hold the position and color data.
 To share a single definition for how the structure is laid out in memory, declare the structure in a common header and import it in both the Metal shader and the app.
 SIMD types are commonplace in Metal Shading Language, and you should also use them in your app using the simd library.
 SIMD types contain multiple channels of a particular data type, so declaring the position as a vector_float2 means it contains two 32-bit float values (which will hold the x and y coordinates.) Colors are stored using a vector_float4, so they have four channels – red, green, blue, and alpha.
 
 In the app, the input data is specified using a constant array
 */
@interface RenderPipelineRenderPrimitivesViewController ()

@end

@implementation RenderPipelineRenderPrimitivesViewController
{
    MTKView *_mtkView;
    Renderer1 *_renderer;
}

- (void)viewDidLoad {
    [super viewDidLoad];
    
    _mtkView = (MTKView *)self.view;
    id<MTLDevice> device = MTLCreateSystemDefaultDevice();
    _mtkView.device = device;
    NSAssert(_mtkView.device, @"Metal is not supported on this device");
    
    _renderer = [[Renderer1 alloc] initWithMetalKitView:_mtkView];
    NSAssert(_renderer, @"Renderer failed initialization");

    _mtkView.delegate = _renderer;
    
}
@end
