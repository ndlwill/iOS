“Model Context Protocol”（MCP）是一个在 AI／大语言模型（LLM, e.g. ChatGPT、Claude 等）领域提出的标准协议，用来统一、标准化模型与外部系统（数据源、工具、应用等）之间的交互方式。

它的目标是：让 AI 模型（或 AI 应用 / Agent）能够 安全、标准地 访问外部数据源、调用工具、执行操作，而不必为每一种外部系统写一套定制连接逻辑。
有人把它比作 AI 世界的 “USB-C 端口” —— 就像 USB-C 提供一个统一接口连接各种外设，MCP 提供一个统一接口连接 AI 模型和各种工具 / 数据源。


MCP 的架构 / 组成部分:
| 角色             | 作用 / 描述                                                                                                                                    |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| **MCP Host**   | 托管模型或 AI 应用的环境，是用户与模型交互的入口（如一个聊天界面、IDE 插件、Agent 等） ([Google Cloud][1])                                                                     |
| **MCP Client** | 在 Host 中作为中介的组件，负责把模型的请求转译为 MCP 协议调用，把服务器回应转回给模型。 ([维基百科][2])                                                                              |
| **MCP Server** | 提供具体的上下文 / 工具 / 数据服务（如数据库查询、文件操作、外部 API 调用等）。模型通过 MCP 客户端调用这些服务器以获得或操作数据。 ([维基百科][2])                                                      |
| **通信协议 / 传输层** | MCP 的通信基于 JSON-RPC 2.0 协议，用于客户端/服务器之间的消息交换。([维基百科][2]) <br> 在本地场景可以用 stdio（标准输入/输出），远程场景可以用 Server-Sent Events（SSE）等机制。([Google Cloud][1]) |

这种分层设计使得模型和工具之间的耦合降低：模型 / AI 应用不必直接知道每一个工具的具体接口，只要通过 MCP 接口调用。


MCP增强模型的能力:
模型不再只能 “凭记忆” 回答问题，它可以实时访问外部数据，调用工具执行操作（如发邮件、执行 SQL、操作文件等）——这让模型更像一个智能 Agent，而不仅仅是一个聊天机器人。


在“智能 Agent（Intelligent Agent）”这个概念里，Agent 不是指某个具体的软件，而是一类具有自主性、目标导向、感知环境并采取行动的系统。
agent: 代理
Agent = 能感知环境、做出决策、执行动作的智能体。

如果普通程序是“听命行事的小工”，
那么 Agent 是“能自己判断、规划、行动的助手”。


Agent 的组成结构:
| 组成部分                              | 作用                       | 举例                          |
| --------------------------------- | ------------------------ | --------------------------- |
| **Perception（感知）**                | 接收外界输入（环境信息、用户输入、API 响应） | 读取网页内容、听取语音命令、分析数据库数据       |
| **Reasoning / Planning（推理 / 计划）** | 根据输入和目标，决定要采取什么行动        | 判断“我现在需要调用哪个工具”             |
| **Action（执行）**                    | 执行具体的操作                  | 发起 HTTP 请求、调用 API、执行命令、返回结果 |
| **Memory（记忆）** *(可选)*             | 存储上下文或历史信息，用于持续性决策       | 记住用户上次的任务、环境状态              |


在 AI / LLM 语境下的 “Agent”:
在大语言模型（LLM，如 ChatGPT、Claude、Gemini）中，
“Agent” 一般指一种 围绕语言模型构建的、可执行任务的智能系统。
它通常具备以下特征：
| 特征                     | 说明                          |
| ---------------------- | --------------------------- |
| **有目标（Goal / Intent）** | 比如：“帮我预定航班”、“生成代码并运行”       |
| **会调用外部工具**            | 如搜索引擎、数据库、日历、API、Shell、文件系统 |
| **能根据上下文自我决策**         | 决定何时调用哪个工具、是否继续推理、是否结束      |
| **可能有记忆**              | 记住用户的历史指令和环境状态              |

当你看到 “MCP 让模型更像一个智能 Agent”，
意思是：
模型不只是一个“语言回答者”，而是能通过标准协议（MCP）访问外部世界、执行操作、形成持续决策循环的智能体。


一个具体例子:
假设你和一个 AI 聊天系统交互：
“帮我查一下明天上海的天气，然后发一封提醒邮件给我。”
如果这个系统是传统的 ChatGPT 模式，它：
只能回答：“明天上海多云 25℃，请记得带伞。”
✅ 能说
❌ 不能做
但如果它是一个 Agent：
它会：
通过 MCP 调用天气 API；
获取数据；
通过 MCP 调用邮件发送服务；
自动发送邮件；
最后告诉你：“已为你发送天气提醒邮件。”
这就是 Agent 模式的区别 ——
它是一个 能行动的智能体（actionable intelligence），不是纯对话机器人。


Agent 的常见类型（LLM 领域）:
| 类型                      | 说明            | 例子                                             |
| ----------------------- | ------------- | ---------------------------------------------- |
| **Tool-using Agent**    | 能调用外部工具的模型    | ChatGPT + Browsing / Python / Code Interpreter |
| **Retrieval Agent**     | 能检索外部知识库      | ChatGPT + 自定义知识库                               |
| **Planning Agent**      | 能规划多步任务       | AutoGPT, BabyAGI                               |
| **Collaborative Agent** | 能与其他 Agent 协作 | 多 Agent 系统（如一个写代码，一个测试）                        |
