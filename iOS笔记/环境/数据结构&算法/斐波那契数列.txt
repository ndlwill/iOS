斐波那契数列求值

斐波那契数列是一个经典的数学问题，同时也是算法中的经典案例
当前数列的元素是由前两个数的和构成

比如 F(0) = 0, F(1) = 1, 那么 F(2) = F(0) + F(1)，也就是说F(2) = 0 + 1 = 2，依次循环得出相关的数列内容。

依据这样的规律特点，我们可以写出下面的递推内容:
F(3) = F(2) + F(1)
F(4) = F(3) + F(2)
F(5) = F(4) + F(3)
F(6) = F(5) + F(4)
......


递归解法:
明显感觉是迭代求值的关系,可以采用最基本的递归的方法去完成求值
func fibRecurrence(_ n: Int) -> Int {
    if n == 0 {
        return 0
    }
    if n == 1 {
        return 1
    }
    return fib(n - 1) + fib(n - 2)
}

当前的时间复杂度，会发现是O(2^n)的

正推法求值:
递归的方法求值实际上是从n往0，反向递推求其值，但是这样有一个不好的地方在于重复计算了已经算过的值
例如在求解F(5)的时候内容如下:
F(5) = F(4) + F(3)
再去求解F(4)的时候，你会发现F(3)重复计算了两次，如下：
F(4) = F(3) + F(2)
按照此内容推下去，计算就会增倍了。

如果按照正向递推的方式的话，就刚好解决了这样的问题，在求解F(5)的时候已经正向求解F(4)与F(3)的结果了，所以直接累加即可得其结果。
所以按照这样的思路，我们可以正向递推求值:

func fibCount(_ n: Int) -> Int {
    if n == 0 {
        return 0
    }
    if n == 1 {
        return 1
    }
    var curValue = 1
    var preValue = 0
    var resValue = curValue + preValue
    for _ in 2...n {
        resValue = curValue + preValue
        preValue = curValue
        curValue = resValue
    }
    return resValue
}
这个时间复杂度是O(n)的


矩阵乘法:
O(n)就是最优解了嘛？答案是否定的，因为有个神级的解法，叫做升维跨越，
可以将其时间复杂度变成O(logn)的，具体做法就是利用矩阵乘法



