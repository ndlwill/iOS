https://github.com/krahets/hello-algo


在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级


算法的时间复杂度，用来度量算法的运行时间，记作: T(n) = O(f(n))。
它表示随着 输入大小n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述

O(1)：常数阶
O(n)：线性阶
对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个
循环的时间复杂度为 O(n×m)

// O(n)
for(int i = 0; i < n; i++) {         // 循环次数为 n
    printf("Hello, World!\n");      // 循环体时间复杂度为 O(1)
}

O(n2)：平方阶
对数阶：
int count = 1;
while(count < n){
  count = count * 2;  
}
因为每次count*2后，距离结束循环更近了。也就是说有多少个2 相乘后大于n，退出循环。
数学公式：2x = n    -->     x = log2n
因此这个循环的时间复杂度为O(logn)


int i;
for(i = 0 ; i < n ; i++){
   for(j = 0 ; j < n ; j++){
    /*时间复杂度为O(1)的程序*/  
    }    
}
对于对于内层循环，它的时间复杂度为O(n)，但是它是包含在外层循环中，再循环n次，因此这段代码的时间复杂度为O(n2)

int i;
for(i = 0 ; i < n ; i++){
   for(j = 0 ; j < m ; j++){
    /*时间复杂度为O(1)的程序*/  
    }    
}
如果内层循环改成了m次，时间复杂度就为O(n*m)

int i;
for(i = 0 ; i < n ; i++){
   for(j = i ; j < n ; j++){
    /*时间复杂度为O(1)的程序*/  
    }    
}
因为i = 0时，内层循环执行了n次，当i=1时，执行了n-1次……当i=n-1时，执行了1次
n + (n-1) + (n-2) + ... + 1 = n + n*(n - 1) / 2 = n(n+1)/2 = (n^2)/2 + n/2
根据大O推导方法，保留最高阶项，n2/2 ，然后去掉这个项相乘的常数，1/2
因此，这段代码的时间复杂度为O(n2)



时间复杂度所耗费的时间从小到大依次是：
O(1 )< O(logn) < O(n) < O(n*logn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

执行次数函数	阶	术语描述
12	O(1)	常数阶
2n+3	O(n)	线性阶
3n2+2n+1	O(n2)	平方阶
5log2n+20	O(log2n)	对数阶
2n+3nlog2n+19	O(nlogn)	nlog2n阶
6n3+2n2+3n+4	O(n3)	立方阶
2n	O(2n)	指数阶


大O推导法：
用常数1取代运行时间中的所有加法常数
在修改后的运行函数中，只保留最高阶项
如果最高阶项存在且不是1，则去除与这个项相乘的常数



对于较为复杂的算法，可以将它们分割成容易估算的几个部分，然后利用O的求和原则得到整个算法的时间复杂度。例如，若算法的两个部分的时间复杂度分别为T1(n)=O(f(n))和T2(n)=O(g(n))，则总的时间复杂度为:
T(n)= T1(n)+ T2(n)=O(max(f(n), g(n)))

对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。
void aFunc(int n) {
    // 第一部分时间复杂度为 O(n^2)
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            printf("Hello, World!\n");
        }
    }
    // 第二部分时间复杂度为 O(n)
    for(int j = 0; j < n; j++) {
        printf("Hello, World!\n");
    }
}
此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)



// O(2^n)
long aFunc(int n) {
    if (n <= 1) {
        return 1;
    } else {
        return aFunc(n - 1) + aFunc(n - 2);
    }
}
显然 T(n) = T(n - 1) + T(n - 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n >= 1 时 T(n) < (5/3)^n，同时当 n > 4 时 T(n) >= (3/2)^n
数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）