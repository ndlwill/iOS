Perfect Hash

Perfect Hash（完美哈希）是一种哈希函数，它能无冲突地将一组固定的键（key）映射到一组连续的整数索引中，常用于查找静态集合（即集合不变时）的键值对，拥有极高的查找效率（通常是 O(1) 时间）。
对于给定的一组不变的键集合 S = {k1, k2, ..., kn}，完美哈希函数 h 满足：
h(ki) ≠ h(kj) for all i ≠ j（无冲突）
h(ki) ∈ [0, n-1]（返回值范围紧凑）

两种主要类型
1. Minimal Perfect Hash Function (MPHF)
特点：将 n 个键映射到 [0, n-1]，没有浪费空间
应用：存储静态关键字表，如编译器关键字、高速查找表
2. Perfect Hash Function (PHF)
特点：仍无冲突，但可能映射到一个大于 n 的区间（如 [0, m-1], m > n）
构造较简单，但会浪费一些空间


常见实现原理（以 MPHF 为例）
✅ 方法：Two-Level Hashing（两级哈希）
这是一种经典方法，用于构建高效的 perfect hash：
第一步：一级哈希函数 h1
将所有键 k 分配到 m 个桶中：h1(k) = i
每个桶 i 包含若干个键（可能冲突）
第二步：为每个桶 i 构造二级哈希 h2i
对每个桶内的键，单独构造一个 无冲突的哈希函数 h2i
通常通过试探法选出一个 h2i，直到桶内无冲突为止
存储结构
一级表：大小为 m，每个元素包含二级哈希表和参数
总体空间约为 O(n)，查询时间为 O(1)


在两级哈希（Two-Level Hashing）中，一级哈希的桶数 m 和元素个数 n 并不一定相等，但常见实现中，通常取 m = n，这样更容易构造出无冲突的二级哈希函数。
举个简单例子来说明：
假设你有一个键集合：
S = { "apple", "banana", "grape", "peach", "lemon" }
也就是说，n = 5。
我们构造一级哈希函数 h1(k)，将每个键分到 m 个桶中。

选项一：取 m = n = 5（常用）
目标是让一级哈希函数尽量把键平均分散（降低冲突）。
每个桶中只包含少量键（甚至最好只有一个键），这样更容易为每个桶构造一个无冲突的二级哈希函数。
如果有的桶中元素比较多，可以在第二层局部地使用暴力试探法来找到一个不冲突的二级哈希函数。


参数	建议设置	原因
m（一级桶数）	通常设为 n	每个桶冲突少，便于构造二级哈希
n（键的个数）	固定	数据集是静态集合
bucket_size	平均为 1	一级哈希尽量分散键


你可以把“桶”理解为：
逻辑意义上的“键的分组”
每个桶都可以看作一个小型集合
不涉及实际内存结构，而是一个分类结构，为了后续处理更容易


应用场景
编译器关键字识别（例如 GCC）
静态数据表查找（如 DNS 厂商的域名表）
字典压缩和去重存储


类型	空间效率	查找效率	是否冲突	支持动态插入
普通哈希	较高	O(1)平均	有可能冲突	支持
Perfect Hash	中等	O(1)	无冲突	不支持（静态）



https://zh.wikipedia.org/wiki/%E5%AE%8C%E7%BE%8E%E6%95%A3%E5%88%97
对集合S的完美散列函数是一个将S的每个元素映射到一系列无冲突的整数的哈希函数。

简单来讲 完美散列函数 是【对输入的字符串列表】【为每个字符串生成一个唯一整数】。