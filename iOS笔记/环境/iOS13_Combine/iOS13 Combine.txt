WWDC2019
https://developer.apple.com/videos/play/wwdc2019

Swift 论坛
https://forums.swift.org/

https://developer.apple.com/documentation/combine

https://stackoverflow.com/questions/tagged/combine

https://heckj.github.io/swiftui-notes/
https://zhiying.space/using-combine/

// ###
https://github.com/heckj/swiftui-notes

Combine:
a declarative Swift API for processing values over time
Combine 是 Apple 用来实现函数响应式编程的库， 类似于 RxSwift。 RxSwift 是 ReactiveX 对 Swift 语言的实现。

函数响应式编程， 也称为数据流编程, 建立在 函数式编程 的概念上。

当你想要设置对各种输入做出反应时，Combine 最合适， 用户界面也非常适合这种模式。
Combine 不限于用户界面。 任何异步操作序列都可以被作为管道，尤其是当每个步骤的结果流向下一步时。

==============================RxSwift 的概念和 API 对应到 Combine 上
https://github.com/CombineCommunity/rxswift-to-combine-cheatsheet

==============================核心概念
Publisher and Subscriber
操作符
Subjects

publisher 和 subscriber，在 Swift 中被描述为协议。
当你谈论编程（尤其是 Swift 和 Combine）时，很多都使用类型描述。 当你说一个函数或方法返回一个值时，该值通常被描述为“此类型之一”。

发布者
当其被订阅之后，根据请求会提供数据， 没有任何订阅请求的发布者不会提供任何数据。 
当你描述一个 Combine 的发布者时，应该用两种相关的类型来描述它：一种用于输出，一种用于失败。

订阅者负责请求数据并接受发布者提供的数据（和可能的失败）。 
订阅者同样被描述为两种关联类型，一种用于输入，一种用于失败。 
订阅者发起数据请求，并控制它接收的数据量。 它可以被认为是在 Combine 中起“驱动作用”的，因为如果没有订阅者，其他组件将保持闲置状态，没有数据会流动起来。

发布者和订阅者是相互连接的，它们构成了 Combine 的核心。 
当你将订阅者连接到发布者时，两种类型都必须匹配：发布者的输出和订阅者的输入以及它们的失败类型。

操作符——一个既像订阅者又像发布者的对象。 操作符是同时实现了 订阅者协议 和 发布者协议 的类。 它们支持订阅发布者，并将结果发送给任何订阅者。
你可以用这些创建成链，用于处理和转换发布者提供的数据和订阅者请求的数据。称这些组合序列为管道。

Back pressure:
Combine 的设计使订阅者控制数据流，因此它也控制着在管道中处理数据的内容和时间。
这意味着由订阅者通过提供其想要或能够接受多少信息量来推动管道内数据的处理。 当订阅者连接到发布者时，它会基于特定的 需求 去请求数据。
特定需求的请求通过组成管道进行传递。 每个操作符依次接受数据请求，然后请求与之相连的发布者提供信息。
有了订阅者驱动数据流这个特性，它允许 Combine 去取消这个过程。 订阅者均遵循 Cancellable 协议。 这意味着它们都有一个 cancel() 函数，可以调用该函数来终止管道并停止所有相关处理。

当管道被取消时，管道是不期望被重新启动的。 相比于重启一个被取消的管道，开发者更应该去创建一个新的管道。

一个 Combine 管道的生命周期:
当调用 .subscribe(_: Subscriber) 时，订阅者被连接到了发布者。
发布者随后调用 receive(subscription: Subscription) 来确认该订阅。
在订阅被确认后，订阅者请求 N 个值，此时调用 request(_: Demand)。
发布者可能随后（当它有值时）发送 N 个或者更少的值，通过调用 receive(_: Input)。 发布者不会发送超过需求量的值。
订阅确认后的任何时间，订阅者都可能调用 .cancel() 来发送 cancellation
发布者可以选择性地发送 completion：receive(completion:)。 完成可以是正常终止，也可以是通过 .failure 完成，可选地传递一个错误类型。 已取消的管道不会发送任何完成事件。

==============================发布者
发布者是数据的提供者。 当订阅者请求数据时， publisher protocol 有严格的返回值类型约定，并有一系列明确的完成信号可能会终止它。

protocol ConnectablePublisher<Output, Failure> : Publisher
当订阅者发出请求时，许多发布者会立即提供数据。 在某些情况下，发布者可能有一个单独的机制，使其能够在订阅后返回数据。 
这是由协议 ConnectablePublisher 来约定实现的。 
遵循 ConnectablePublisher 的发布者将有一个额外的机制，在订阅者发出请求后才启动数据流。 
这可能是对发布者单独的调用 .connect() 来完成。 另一种可能是 .autoconnect()，一旦订阅者请求，它将立即启动数据流。

Combine 之外的一些 Apple API 也提供发布者。
SwiftUI 使用 @Published 和 @ObservedObject 属性包装，由 Combine 提供，含蓄地创建了一个发布者，
用来支持它的声明式 UI 的机制。
Foundation:
URLSession.dataTaskPublisher
.publisher on KVO instance
NotificationCenter
Timer
Result

==============================Subjects
Subjects 是一种遵循 Subject 协议的特殊的发布者。 这个协议要求 subjects 有一个 .send(_:) 方法，来允许开发者发送特定的值给订阅者或管道。
protocol Subject<Output, Failure> : AnyObject, Publisher

Subjects 可以通过调用 .send(_:) 方法来将值“注入”到流中

一个 subject 还可以向多个订阅者广播消息。 
如果多个订阅者连接到一个 subject，它将在调用 send(_:) 时向多个订阅者发送值。 
一个 subject 还经常用于连接或串联多个管道，特别是同时给多个管道发送值时。

Subject 不会盲目地传递其订阅者的需求。 相反，它为需求提供了一个聚合点。 在没有收到订阅消息之前，一个 subject 不会向其连接的发布者发出需求信号。
当它收到订阅者的需求时，它会向它连接的发布者发出 unlimited 需求信号。 虽然 subject 支持多个订阅者，但任何未请求数据的订阅者，在请求之前均不会给它们提供数据。

Combine 中有两种内建的 subject : CurrentValueSubject 和 PassthroughSubject。 它们的行为类似，但不同的是 CurrentValueSubject 需要一个初始值并记住它当前的值，PassthroughSubject 则不会。
当调用 .send() 时，两者都将向它们的订阅者提供更新的值。

final public class PassthroughSubject<Output, Failure> : Subject where Failure : Error
final public class CurrentValueSubject<Output, Failure> : Subject where Failure : Error
@frozen public struct AnyPublisher<Output, Failure> : CustomStringConvertible, CustomPlaygroundDisplayConvertible where Failure : Error

protocol ObservableObject : AnyObject
在给遵循 ObservableObject 协议的对象创建发布者时，CurrentValueSubject 和 PassthroughSubject 也很有用。 SwiftUI 中的多个声明式组件都遵循这个协议。

==============================订阅者
protocol Subscriber<Input, Failure> : CustomCombineIdentifierConvertible

虽然 Subscriber 是用于接收整个管道数据的协议，但通常 the subscriber 指的是管道的末端。
Combine 中有两个内建的订阅者： Assign 和 Sink。 SwiftUI 中有一个订阅者： onReceive。
订阅者支持取消操作，取消时将终止订阅关系以及所有流完成之前，由发布者发送的数据。 Assign 和 Sink 都遵循 Cancellable 协议.

当你存储和自己订阅者的引用以便稍后清理时，你通常希望引用销毁时能自己取消订阅。
AnyCancellable 提供类型擦除的引用，可以将任何订阅者转换为 AnyCancellable 类型，允许在该引用上使用 .cancel()，但无法访问订阅者本身
存储对订阅者的引用非常重要，因为当引用被释放销毁时，它将隐含地取消其操作。

final public class AnyCancellable : Cancellable, Hashable
public protocol Cancellable

Assign 将从发布者传下来的值应用到由 keypath 定义的对象， keypath 在创建管道时被设置。
.assign(to: \.isEnabled, on: signupButton)
final class Assign<Root, Input>

Sink 接受一个闭包，该闭包接收从发布者发送的任何结果值。
final class Sink<Input, Failure> where Failure : Error
.sink { receivedValue in
    print("The end result was \(String(describing: receivedValue))")
}

其他订阅者是其他 Apple 框架的一部分。 例如，SwiftUI 中的几乎每个 control 都可以充当订阅者。 SwiftUI 中的 View 协议 定义了一个 .onReceive(publisher) 函数，可以把视图当作订阅者使用。
onReceive 函数接受一个类似于 sink 接受的闭包，可以操纵 SwiftUI 中的 @State 或 @Bindings。
struct MyView : View {

    @State private var currentStatusValue = "ok"
    var body: some View {
        Text("Current status: \(currentStatusValue)")
            .onReceive(MyPublisher.currentStatusPublisher) { newStatus in
                self.currentStatusValue = newStatus
            }
    }
}

对于任何类型的 UI 对象 (UIKit、AppKit 或者 SwiftUI)， Assign 可以在管道中使用来更新其属性。

==============================有两种更广泛的发布者模式
期望发布者返回单一的值并完成，和期望发布者随着时间的推移返回多个值。
我把第一个称作 “one-shot”（一次性）的发布者或管道。 这些发布者会创建单个响应（或者可能没有响应），然后正常终止。
我把第二个称作 “continuous”（连续）的发布者。 这些发布者和相关管道应始终处于活动状态，并提供处理持续事件的方法。 在这种情况下，管道的寿命要长得多，
而且通常不希望此类管道发生失败或终止。

==============================
使用类型擦除类来包装发布者或订阅者。 这样明确隐藏了 Swift 中从链式函数中构建的类型复杂性。

用于为订阅者和发布者暴露简化类型的两个类是:
AnySubscriber
AnyPublisher

每个发布者还继承了一种便利的方法 eraseToAnyPublisher()，它返回一个 AnyPublisher 实例。 eraseToAnyPublisher() 的使用非常像操作符，通常作为链式管道中的最后一个元素，以简化返回的类型。

==============================管道和线程
Combine 不是一个单线程的结构。 操作符和发布者可以在不同的调度队列或 runloops 中运行。 构建的管道可以在单个队列中，也可以跨多个队列或线程传输数据。
Combine 允许发布者指定线程调度器，不论是从上游的发布者（操作符）接收数据或者向下游的订阅者发送数据，都使用它调度到指定线程。
在与更新 UI 元素的订阅者配合使用时，这一点至关重要，因为更新 UI 始终应该在主线程上。

你可能在代码中看到这样的操作符:
.receive(on: RunLoop.main)

许多操作符可以修改用于进行相关处理的线程或队列。 receive 和 subscribe 是最常见的两个，它们分别负责把调用操作符之后和之前的执行代码调度到对应的线程。

许多其他操作符的参数也包括调度器。 例如 delay, debounce, 和 throttle. 这些也会对执行代码的队列产生影响 - 无论是对自己，还是对于后续在管道中执行的任何操作符。
这些操作符都使用 scheduler 参数，来切换到相应的线程或队列以完成工作。 任何后面连接着他们的操作符也会在其调度器上被调用，从而产生一些影响，如 receive。
如果你想明确指定操作符或后续的操作在哪个线程环境中运行，可以使用 receive 操作符。

==============================
用 Future 来封装异步请求以创建一次性的发布者

如果你想使用发布者提供的数据作为创建此发布者的参数或输入，则有两种通用的方法可以这么做:
使用 flatMap 操作符, 使用传入的数据创建或返回发布者实例。
或者，map 或 tryMap 可被用做创建发布者实例

==========================================================================================###常用模式和方法###
1.使用 sink 创建一个订阅者
要接收来自发布者或管道生成的输出以及错误或者完成消息，你可以使用 sink 创建一个订阅者。

(1)
let cancellablePipeline = publishingSource.sink { someValue in 
    // do what you want with the resulting value passed down
    // be aware that depending on the publisher, this closure
    // may be invoked multiple times.
    print(".sink() received \(someValue)")
})
简单版本的 sink 是非常简洁的，跟了一个尾随闭包来接收从管道发送来的数据。

(2)
带有完成事件和数据的 sink
let cancellablePipeline = publishingSource.sink(receiveCompletion: { completion in 
    switch completion {
    case .finished:
        // no associated data, but you can react to knowing the
        // request has been completed
        break
    case .failure(let anError):
        // do what you want with the error details, presenting,
        // logging, or hiding as appropriate
        print("received the error: ", anError)
        break
    }
}, receiveValue: { someValue in
    // do what you want with the resulting value passed down
    // be aware that depending on the publisher, this closure
    // may be invoked multiple times.
    print(".sink() received \(someValue)")
})

cancellablePipeline.cancel() 

当 sink 在发布者创建或调用时，它通过 subscribe 方法隐式地开始了 发布者和订阅者的生命周期，并请求无限制的数据。

2.使用 assign 创建一个订阅者
使用管道的结果来设置值，这个值通常是位于用户界面或控制组件上的属性，不过任何符合 KVO 的对象都可以提供该值。

Assign 是专门设计用于将来自发布者或管道的数据应用到属性的订阅者，每当它收到数据时都会更新该属性。 
与 sink 一样，它创建时激活并请求无限数据。 Assign 要求将失败类型指定为 <Never>，因此，如果你的管道可能失败（例如使用 tryMap 等操作符），则需要在使用 .assign 之前 错误处理。

(1)简单的 assign 例子
let cancellablePipeline = publishingSource 
    .receive(on: RunLoop.main) 
    .assign(to: \.isEnabled, on: yourButton) 

cancellablePipeline.cancel() 

.assign 通常在创建时链接到发布者，并且返回值是可取消的。
如果 .assign 被用于更新用户界面的元素，则需要确保在主线程更新它。这个调用确保了订阅者是在主线程上接收数据的。
Assign 持有对使用 key path 更新的属性的引用，以及对正在更新的对象的引用。
在任何时候，你都可以调用 cancel() 终止和使管道失效。通常，当把从管道中更新的对象（如 viewController）销毁时，我们会取消管道。

3.使用 dataTaskPublisher 发起网络请求
从 URL 请求 JSON 数据并解码

let myURL = URL(string: "https://postman-echo.com/time/valid?timestamp=2016-10-10")
// checks the validity of a timestamp - this one returns {"valid":true}
// matching the data structure returned from https://postman-echo.com/time/valid
fileprivate struct PostmanEchoTimeStampCheckResponse: Decodable, Hashable { 
    let valid: Bool
}

let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: myURL!) 
    // the dataTaskPublisher output combination is (data: Data, response: URLResponse)
    .map { $0.data } 
    .decode(type: PostmanEchoTimeStampCheckResponse.self, decoder: JSONDecoder()) 

let cancellableSink = remoteDataPublisher
    .sink(receiveCompletion: { completion in
            print(".sink() received the completion", String(describing: completion))
            switch completion {
                case .finished: 
                    break
                case .failure(let anError): 
                    print("received error: ", anError)
            }
    }, receiveValue: { someValue in 
        print(".sink() received \(someValue)")
    })

通常，你将有一个结构体的定义，至少遵循 Decodable 协议（即使没有完全遵循 Codable protocol）。此结构体可以只定义从网络拉取到的 JSON 中你感兴趣的字段。 不需要定义完整的 JSON 结构。
dataTaskPublisher 是从 URLSession 实例化的。 你可以配置你自己的 URLSession，或者使用 shared session.
返回的数据是一个元组：(data: Data, response: URLResponse)。 map 操作符用来获取数据并丢弃 URLResponse，只把 Data 沿管道向下传递。
decode 用于加载数据并尝试解析它。 如果解码失败，它会抛出一个错误。 如果它成功，通过管道传递的对象将是来自 JSON 数据的结构体。
如果解码完成且没有错误，则将触发完成操作，并将值传递给 receiveValue 闭包。
如果发生失败（无论是网络请求还是解码），则错误将被传递到 failure 闭包。
只有当数据请求并解码成功时，才会调用此闭包，并且收到的数据格式将是结构体 PostmanEchoTimeStampCheckResponse 的实例。


4.使用 dataTaskPublisher 进行更严格的请求处理
当 URLSesion 进行连接时，它仅在远程服务器未响应时报告错误。 你可能需要根据状态码将各种响应视为不同的错误。 为此，你可以使用 tryMap 检查 http 响应并在管道中抛出错误。
要对 URL 响应中被认为是失败的操作进行更多控制，可以对 dataTaskPublisher 的元组响应使用 tryMap 操作符。 由于 dataTaskPublisher 将响应数据和 URLResponse 都返回到了管道中，你可以立即检查响应，并在需要时抛出自己的错误。

let myURL = URL(string: "https://postman-echo.com/time/valid?timestamp=2016-10-10")
// checks the validity of a timestamp - this one returns {"valid":true}
// matching the data structure returned from https://postman-echo.com/time/valid
fileprivate struct PostmanEchoTimeStampCheckResponse: Decodable, Hashable {
    let valid: Bool
}
enum TestFailureCondition: Error {
    case invalidServerResponse
}

let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: myURL!)
    .tryMap { data, response -> Data in 
                guard let httpResponse = response as? HTTPURLResponse, 
                    httpResponse.statusCode == 200 else { 
                        throw TestFailureCondition.invalidServerResponse 
                }
                return data 
    }
    .decode(type: PostmanEchoTimeStampCheckResponse.self, decoder: JSONDecoder())

let cancellableSink = remoteDataPublisher
    .sink(receiveCompletion: { completion in
            print(".sink() received the completion", String(describing: completion))
            switch completion {
                case .finished:
                    break
                case .failure(let anError):
                    print("received error: ", anError)
            }
    }, receiveValue: { someValue in
        print(".sink() received \(someValue)")
    })

tryMap，这使我们能够根据返回的内容识别并在管道中抛出错误。

tryMap 仍旧获得元组 (data: Data, response: URLResponse)，并且在这里定义仅返回管道中的 Data 类型。
在 tryMap 的闭包内，我们将响应转换为 HTTPURLResponse 并深入进去，包括查看特定的状态码。
在这个例子中，我们希望将 200 状态码以外的任何响应视为失败。HTTPURLResponse.statusCode 是一种 Int 类型，因此你也可以使用 httpResponse.statusCode > 300 等逻辑。
如果判断条件未满足，则会抛出我们选择的错误实例：在这个例子中，是 invalidServerResponse。
如果没有出现错误，则我们只需传递 Data 以进行进一步处理。

5.标准化 dataTaskPublisher 返回的错误
当在管道上触发错误时，不管错误发生在管道中的什么位置，都会发送 .failure 完成回调，并把错误封装在其中。

此模式可以扩展来返回一个发布者，该发布者使用此通用模式可接受并处理任意数量的特定错误。

enum APIError: Error, LocalizedError { 
    case unknown, apiError(reason: String), parserError(reason: String), networkError(from: URLError)

    var errorDescription: String? {
        switch self {
        case .unknown:
            return "Unknown error"
        case .apiError(let reason), .parserError(let reason):
            return reason
        case .networkError(let from): 
            return from.localizedDescription
        }
    }
}

func fetch(url: URL) -> AnyPublisher<Data, APIError> {
    let request = URLRequest(url: url)

    return URLSession.DataTaskPublisher(request: request, session: .shared) 
        .tryMap { data, response in 
            guard let httpResponse = response as? HTTPURLResponse else {
                throw APIError.unknown
            }
            if (httpResponse.statusCode == 401) {
                throw APIError.apiError(reason: "Unauthorized");
            }
            if (httpResponse.statusCode == 403) {
                throw APIError.apiError(reason: "Resource forbidden");
            }
            if (httpResponse.statusCode == 404) {
                throw APIError.apiError(reason: "Resource not found");
            }
            if (405..<500 ~= httpResponse.statusCode) {
                throw APIError.apiError(reason: "client error");
            }
            if (500..<600 ~= httpResponse.statusCode) {
                throw APIError.apiError(reason: "server error");
            }
            return data
        }
        .mapError { error in 
            // if it's our kind of error already, we can return it directly
            if let error = error as? APIError {
                return error
            }
            // if it is a TestExampleError, convert it into our new error type
            if error is TestExampleError {
                return APIError.parserError(reason: "Our example error")
            }
            // if it is a URLError, we can convert it into our more general error kind
            if let urlerror = error as? URLError {
                return APIError.networkError(from: urlerror)
            }
            // if all else fails, return the unknown error condition
            return APIError.unknown
        }
        .eraseToAnyPublisher() 
}

APIError 是一个错误类型的枚举，我们在此示例中使用该枚举来列举可能发生的所有错误。
.networkError 是 APIError 的一个特定情况，当 URLSession.dataTaskPublisher 返回错误时我们将把错误转换为该类型。
我们使用标准 dataTaskPublisher 开始生成此发布者。
然后，我们将路由到 tryMap 操作符来检查响应，根据服务器响应创建特定的错误。
最后，我们使用 mapError 将任何其他不可忽视的错误类型转换为通用的错误类型 APIError。

6.用 Future 来封装异步请求以创建一次性的发布者
使用 Future 将异步请求转换为发布者，以便在 Combine 管道中使用返回结果。

import Contacts
let futureAsyncPublisher = Future<Bool, Error> { promise in 
    CNContactStore().requestAccess(for: .contacts) { grantedAccess, err in 
        // err is an optional
        if let err = err { 
            return promise(.failure(err))
        }
        return promise(.success(grantedAccess)) 
    }
}.eraseToAnyPublisher()

Future 本身由你定义返回类型，并接受一个闭包。 它给出一个与类型描述相匹配的 Result 对象，你可以与之交互。
只要传入的闭包符合类型要求，任何异步的 API 你都可以调用。
在异步 API 完成的回调中，由你决定什么是失败还是成功。 对 promise(.failure(<FailureType>)) 的调用返回一个失败的结果。
或者调用 promise(.success(<OutputType>)) 返回一个值。

Future 在创建时立即发起其中异步 API 的调用，而不是 当它收到订阅需求时。 这可能不是你想要或需要的行为。 如果你希望在订阅者请求数据时再发起调用，你可能需要用 Deferred 来包装 Future。

如果您想返回一个已经被解析的 promise 作为 Future 发布者，你可以在闭包中立即返回你想要的结果。
以下示例将单个值 true 返回表示成功。 你同样可以简单地返回 false，发布者仍然会将其作为一个成功的 promise。

let resolvedSuccessAsPublisher = Future<Bool, Error> { promise in
    promise(.success(true))
}.eraseToAnyPublisher()

一个返回 Future 发布者的例子，它立即将 promise 解析为错误。
enum ExampleFailure: Error {
    case oneCase
}

let resolvedFailureAsPublisher = Future<Bool, Error> { promise in
    promise(.failure(ExampleFailure.oneCase))
}.eraseToAnyPublisher()

7.有序的异步操作
使用 Combine 的管道来显式地对异步操作进行排序
这类似于一个叫做 "promise chaining" 的概念。
promise 库总是将每个 promise 作为单一结果处理，而 Combine 带来了可能需要处理许多值的复杂性。

任何需要按特定顺序执行的异步（或同步）任务组都可以使用 Combine 管道进行协调管理。 通过使用 Future 操作符，可以捕获完成异步请求的行为，序列操作符提供了这种协调功能的结构。
通过将任何异步 API 请求与 Future 发布者进行封装，然后将其与 flatMap 操作符链接在一起，你可以以特定顺序调用被封装的异步 API 请求。
通过使用 Future 或其他发布者创建多个管道，使用 zip 操作符将它们合并之后等待管道完成，通过这种方法可以创建多个并行的异步请求。

如果你想强制一个 Future 发布者直到另一个发布者完成之后才被调用，你可以把 future 发布者创建在 flatMap 的闭包中，这样它就会等待有值被传入 flatMap 操作符之后才会被创建。

import UIKit
import Combine

class AsyncCoordinatorViewController: UIViewController {

    @IBOutlet weak var startButton: UIButton!

    @IBOutlet weak var step1_button: UIButton!
    @IBOutlet weak var step2_1_button: UIButton!
    @IBOutlet weak var step2_2_button: UIButton!
    @IBOutlet weak var step2_3_button: UIButton!
    @IBOutlet weak var step3_button: UIButton!
    @IBOutlet weak var step4_button: UIButton!
    @IBOutlet weak var activityIndicator: UIActivityIndicatorView!

    var cancellable: AnyCancellable?
    var coordinatedPipeline: AnyPublisher<Bool, Error>?

    @IBAction func doit(_ sender: Any) {
        runItAll()
    }

    func runItAll() {
        if self.cancellable != nil { 
            print("Cancelling existing run")
            cancellable?.cancel()
            self.activityIndicator.stopAnimating()
        }
        print("resetting all the steps")
        self.resetAllSteps() 
        // driving it by attaching it to .sink
        self.activityIndicator.startAnimating() 
        print("attaching a new sink to start things going")
        self.cancellable = coordinatedPipeline? 
            .print()
            .sink(receiveCompletion: { completion in
                print(".sink() received the completion: ", String(describing: completion))
                self.activityIndicator.stopAnimating()
            }, receiveValue: { value in
                print(".sink() received value: ", value)
            })
    }
    // MARK: - helper pieces that would normally be in other files

    // this emulates an async API call with a completion callback
    // it does nothing other than wait and ultimately return with a boolean value
    func randomAsyncAPI(completion completionBlock: @escaping ((Bool, Error?) -> Void)) {
        DispatchQueue.global(qos: .background).async {
            sleep(.random(in: 1...4))
            completionBlock(true, nil)
        }
    }

    /// Creates and returns pipeline that uses a Future to wrap randomAsyncAPI
    /// and then updates a UIButton to represent the completion of the async
    /// work before returning a boolean True.
    /// - Parameter button: button to be updated
    func createFuturePublisher(button: UIButton) -> AnyPublisher<Bool, Error> { 
        return Future<Bool, Error> { promise in
            self.randomAsyncAPI() { (result, err) in
                if let err = err {
                    promise(.failure(err))
                } else {
                    promise(.success(result))
                }
            }
        }
        .receive(on: RunLoop.main)
            // so that we can update UI elements to show the "completion"
            // of this step
        .map { inValue -> Bool in 
            // intentionally side effecting here to show progress of pipeline
            self.markStepDone(button: button)
            return true
        }
        .eraseToAnyPublisher()
    }

    /// highlights a button and changes the background color to green
    /// - Parameter button: reference to button being updated
    func markStepDone(button: UIButton) {
        button.backgroundColor = .systemGreen
        button.isHighlighted = true
    }

    func resetAllSteps() {
        for button in [self.step1_button, self.step2_1_button, self.step2_2_button, self.step2_3_button, self.step3_button, self.step4_button] {
            button?.backgroundColor = .lightGray
            button?.isHighlighted = false
        }
        self.activityIndicator.stopAnimating()
    }

    // MARK: - view setup

    override func viewDidLoad() {
        super.viewDidLoad()
        self.activityIndicator.stopAnimating()

        // Do any additional setup after loading the view.

        coordinatedPipeline = createFuturePublisher(button: self.step1_button) 
            .flatMap { flatMapInValue -> AnyPublisher<Bool, Error> in
            let step2_1 = self.createFuturePublisher(button: self.step2_1_button)
            let step2_2 = self.createFuturePublisher(button: self.step2_2_button)
            let step2_3 = self.createFuturePublisher(button: self.step2_3_button)
            return Publishers.Zip3(step2_1, step2_2, step2_3)
                .map { _ -> Bool in
                    return true
                }
                .eraseToAnyPublisher()
            }
        .flatMap { _ in
            return self.createFuturePublisher(button: self.step3_button)
        }
        .flatMap { _ in
            return self.createFuturePublisher(button: self.step4_button)
        }
        .eraseToAnyPublisher()
    }
}

runItAll 协调此工作流的进行，它从检查当前是否正在执行开始。 如果是，它会在当前的订阅者上调用 cancel()。
resetAllSteps 通过遍历所有表示当前工作流状态的按钮，并将它们重置为灰色和未高亮以回到初始状态。 它还验证 activity indicator 当前未处于动画中。
然后我们开始执行请求，首先开启 activity indicator 的旋转动画。
使用 sink 创建订阅者并存储对工作流的引用。 被订阅的发布者是在该函数外创建的，允许被多次复用。 管道中的 print 操作符用于调试，在触发管道时在控制台显示输出。
每个步骤都由 Future 发布者紧跟管道构建而成，然后立即由管道操作符切换到主线程，然后更新 UIButton 的背景色，以显示该步骤已完成。 这封装在 createFuturePublisher 的调用中，使用 eraseToAnyPublisher 以简化返回的类型。
map 操作符用于创建并更新 UIButton，作为特定的效果以显示步骤已完成。
创建整个管道及其串行和并行任务结构，是结合了对 createFuturePublisher 的调用以及对 flatMap 和 zip 操作符的使用共同完成的。

8.错误处理
如果你正在使用 SwiftUI，并且你希望使用 assign 在按钮上设置 isEnabled 属性，则订阅者将有几个要求:
订阅者应匹配 <Bool, Never> 的类型输出
应该在主线程调用订阅者

如果发布者抛出一个错误（例如 URLSession.dataTaskPublisher ），你需要构建一个管道来转换输出类型，还需要处理管道内的错误，以匹配错误类型 <Never>。

如何处理管道内的错误取决于管道的定义方式。 
如果管道设置为返回单个结果并终止， 一个很好的例子就是 使用 catch 处理一次性管道中的错误。 
如果管道被设置为持续更新，则错误处理要复杂一点。 这种情况下的一个很好的例子是 使用 flatMap 和 catch 在不取消管道的情况下处理错误。

(1)使用 assertNoFailure 验证未发生失败
断言 assertNoFailure 非常有用，可将失败类型转换为 <Never>。 如果断言被触发，该操作符将导致应用程序终止

(2)使用 catch 处理一次性管道中的错误
如果你需要在管道内处理失败，例如在使用 assign 操作符或其他要求失败类型为 <Never> 的操作符之前，你可以使用 catch 来提供适当的逻辑。
catch 处理错误的方式，是将上游发布者替换为另一个发布者，这是你在闭包中用返回值提供的。

URLSession.dataTaskPublisher 是一个一次性的发布者，你可以使用 catch 在发生错误时返回默认值，以确保你得到响应结果。
struct IPInfo: Codable {
    // matching the data structure returned from ip.jsontest.com
    var ip: String
}
let myURL = URL(string: "http://ip.jsontest.com")
// NOTE(heckj): you'll need to enable insecure downloads in your Info.plist for this example
// since the URL scheme is 'http'

let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: myURL!)
    // the dataTaskPublisher output combination is (data: Data, response: URLResponse)
    .map({ (inputTuple) -> Data in
        return inputTuple.data
    })
    .decode(type: IPInfo.self, decoder: JSONDecoder()) 
    .catch { err in 
        return Publishers.Just(IPInfo(ip: "8.8.8.8"))
    }
    .eraseToAnyPublisher()

通常，catch 操作符将被放置在几个可能失败的操作符之后，以便在之前任何可能的操作失败时提供回退或默认值。
使用 catch 时，你可以得到错误类型，并可以检查它以选择如何提供响应。
Just 发布者经常用于启动另一个一次性管道，或在发生失败时直接提供默认的响应。

(3)在发生暂时失败时重试
当 .failure 发生时，retry 操作符可以被包含在管道中以重试订阅。
当向 dataTaskPublisher 请求数据时，请求可能会失败。 在这种情况下，你将收到一个带有 error 的 .failure 事件。 
当失败时，retry 操作符将允许你对相同请求进行一定次数的重试。 当发布者不发送 .failure 事件时，retry 操作符会传递结果值。 
retry 仅在发送 .failure 事件时才在 Combine 管道内做出响应。

当 retry 收到 .failure 结束事件时，它重试的方式是给它所链接的操作符或发布者重新创建订阅。
当尝试请求连接不稳定的网络资源时，通常需要 retry 操作符，或者再次请求时可能会成功的情况。 如果指定的重试次数全部失败，则将 .failure 结束事件传递给订阅者。
我们将 retry 与 delay 操作符相结合使用。 我们使用延迟操作符在下一个请求之前使其出现少量随机延迟。 这使得重试的尝试行为被分隔开，使重试不会快速连续的发生。

let remoteDataPublisher = urlSession.dataTaskPublisher(for: self.URL!)
    .delay(for: DispatchQueue.SchedulerTimeType.Stride(integerLiteral: Int.random(in: 1..<5)), scheduler: backgroundQueue) 
    .retry(3) 
    .tryMap { data, response -> Data in 
        guard let httpResponse = response as? HTTPURLResponse,
            httpResponse.statusCode == 200 else {
                throw TestFailureCondition.invalidServerResponse
        }
        return data
    }
    .decode(type: PostmanEchoTimeStampCheckResponse.self, decoder: JSONDecoder())
    .subscribe(on: backgroundQueue)
    .eraseToAnyPublisher()

delay 操作符将流经过管道的结果保持一小段时间，在这个例子中随机选择1至5秒。通过在管道中添加延迟，即使原始请求成功，重试也始终会发生。
重试被指定为尝试3次。 如果每次尝试都失败，这将导致总共 4 次尝试 - 原始请求和 3 次额外尝试。
tryMap 被用于检查 dataTaskPublisher 返回的数据，如果服务器的响应数据有效，但不是 200 HTTP 响应码，则返回 .failure 完成事件。

(4)使用 flatMap 和 catch 在不取消管道的情况下处理错误
flatMap 操作符可以与 catch 一起使用，以持续处理新发布的值上的错误。
let remoteDataPublisher = Just(self.testURL!) 
    .flatMap { url in 
        URLSession.shared.dataTaskPublisher(for: url) 
        .tryMap { data, response -> Data in 
            guard let httpResponse = response as? HTTPURLResponse,
                httpResponse.statusCode == 200 else {
                    throw TestFailureCondition.invalidServerResponse
            }
            return data
        }
        .decode(type: PostmanEchoTimeStampCheckResponse.self, decoder: JSONDecoder()) 
        .catch {_ in 
            return Just(PostmanEchoTimeStampCheckResponse(valid: false))
        }
    }
    .eraseToAnyPublisher()

Just 以传入一个 URL 作为示例启动此发布者。
flatMap 以 URL 作为输入，闭包继续创建一次性发布者管道。
dataTaskPublisher 使用输入的 url 发出请求。
输出的结果（一个 (Data, URLResponse) 元组）流入 tryMap 以解析其他错误。
decode 尝试将返回的数据转换为本地定义的类型。
如果其中任何一个失败，catch 将把错误转换为一个默认的值。 在这个例子中，是具有预设好 valid = false 属性的对象。

(5)网络受限时从备用 URL 请求数据
// Generalized Publisher for Adaptive URL Loading
func adaptiveLoader(regularURL: URL, lowDataURL: URL) -> AnyPublisher<Data, Error> {
    var request = URLRequest(url: regularURL) 
    request.allowsConstrainedNetworkAccess = false 
    return URLSession.shared.dataTaskPublisher(for: request) 
        .tryCatch { error -> URLSession.DataTaskPublisher in 
            guard error.networkUnavailableReason == .constrained else {
               throw error
            }
            return URLSession.shared.dataTaskPublisher(for: lowDataURL) 
        .tryMap { data, response -> Data in
            guard let httpResponse = response as? HTTPUrlResponse, 
                   httpResponse.statusCode == 200 else {
                       throw MyNetworkingError.invalidServerResponse
            }
            return data
}
.eraseToAnyPublisher() 

request 变量是一个尝试请求数据的 URLRequest。
设置 request.allowsConstrainedNetworkAccess 将导致 dataTaskPublisher 在网络受限时返回错误。
调用 dataTaskPublisher 发起请求。
tryCatch 用于捕获当前的错误状态并检查特定错误（受限的网络）。
如果它发现错误，它会使用备用 URL 创建一个新的一次性发布者。
由此产生的发布者仍可能失败，tryMap 可以基于对应到错误条件的 HTTP 响应码来抛出错误，将此映射为失败。
eraseToAnyPublisher 可在操作符链上进行类型擦除，因此 adaptiveLoader 函数的返回类型为 AnyPublisher<Data, Error>。

如果从原始请求返回的错误不是网络受限的问题，则它会将 .failure 结束事件传到管道中。 如果错误是网络受限，则 tryCatch 操作符会创建对备用 URL 的新请求。

9.和 UIKit 或 AppKit 集成
(1)通过用户输入更新声明式 UI
像 Combine 这样的框架的主要好处之一是建立一个声明性结构，定义界面将如何根据用户输入进行更新。

// @Published is creating a publisher $username of type <String, Never>
@Published var username: String = ""


import UIKit
import Combine

class ViewController: UIViewController {

    @IBOutlet weak var github_id_entry: UITextField! 

    var usernameSubscriber: AnyCancellable?

    // username from the github_id_entry field, updated via IBAction
    // @Published is creating a publisher $username of type <String, Never>
    @Published var username: String = "" 

    // github user retrieved from the API publisher. As it's updated, it
    // is "wired" to update UI elements
    @Published private var githubUserData: [GithubAPIUser] = []

    // MARK - Actions

    @IBAction func githubIdChanged(_ sender: UITextField) {
        username = sender.text ?? "" 
        print("Set username to ", username)
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.

        usernameSubscriber = $username 
            .throttle(for: 0.5, scheduler: myBackgroundQueue, latest: true) 
            // ^^ scheduler myBackGroundQueue publishes resulting elements
            // into that queue, resulting on this processing moving off the
            // main runloop.
            .removeDuplicates() 
            .print("username pipeline: ") // debugging output for pipeline
            .map { username -> AnyPublisher<[GithubAPIUser], Never> in 
                return GithubAPI.retrieveGithubUser(username: username)
            }
            // ^^ type returned by retrieveGithubUser is a Publisher, so we use
            // switchToLatest to resolve the publisher to its value
            // to return down the chain, rather than returning a
            // publisher down the pipeline.
            .switchToLatest() 
            // using a sink to get the results from the API search lets us
            // get not only the user, but also any errors attempting to get it.
            .receive(on: RunLoop.main)
            .assign(to: \.githubUserData, on: self) 

UITextField 是从用户交互推动更新的界面元素。
我们定义了一个 @Published 属性，既能保存数据，又能响应更新。 因为它是一个 @Published 属性，它提供了一个发布者，我们可以使用 Combine 的管道更新界面的其他变量或元素。
我们从 IBAction 内部设置变量 username，如果发布者 $username 有任何订阅者，它反过来就会触发数据流更新。
我们又在发布者 $username 上设置了一个订阅者，以触发进一步的行为。 在这个例子中，它使用更新过的 username 的值从 Github 的 REST API 取回一个 GithubAPIUser 实例。 每次更新用户名值时，它都会发起新的 HTTP 请求。
throttle 在这里是防止每编辑一次 UITextField 都触发一个网络请求。 throttle 操作符保证了每半秒最多可发出 1 个请求。
removeDuplicates 移除重复的更改用户名事件，以便不会连续两次对相同的值发起 API 请求。 如果用户结束编辑时返回的是之前的值，removeDuplicates 可防止发起冗余请求。
map 在此处和 flatMap 处理错误类似，返回一个发布者的实例。 在 map 被调用时，API 对象返回一个发布者。 它不会返回请求的值，而是返回发布者本身。
switchToLatest 操作符接收发布者实例并解析其中的数据。 switchToLatest 将发布者解析为值，并将该值传递到管道中，在这个例子中，是一个 [GithubAPIUser] 的实例。
在管道末尾的 assign 是订阅者，它将值分配到另一个变量：githubUserData。

随着输入值的不断更新，会不断的触发新的网络请求，在这种情况下，我们想要的是最后一次网络请求，这种场景就是使用switchToLatest的最佳时机
switchToLatest的核心思想是保留最后一个publisher，在实际开发中，特别适合用于过滤搜索框的多余的网络请求。

cancellable = subject
    .setFailureType(to: URLError.self)
    .map() { index -> Just<Int> in
        Just(index)
    }
    .switchToLatest()
    .sink(receiveCompletion: {
        print("Complete: \($0)")
    }, receiveValue: { value in
        print("Value: \(value)")
    })

for index in 1...5 {
    DispatchQueue.main.asyncAfter(deadline: .now() + TimeInterval(index / 10)) {
        subject.send(index)
    }
}
Value: 1
Value: 2
Value: 3
Value: 4
Value: 5

(2)级联多个 UI 更新，包括网络请求
由上游的订阅者触发多个 UI 元素更新

以 assign 和 sink 创建的订阅者被存储在 ViewController 实例的 AnyCancellable 变量中。 由于它们是在类实例中定义的，Swift 编译器创建的 deinitializers 会在类被销毁时，取消并清理发布者。

RxSwift 的开发者使用的是 "CancelBag" 对象来存储可取消的引用，并在销毁时取消管道。
这与 Combine 中在 AnyCancellable 类型上调用 store 函数是相似的，它允许你将订阅者的引用保存在一个集合中，例如 Set<AnyCancellable>。

管道使用 subscribe 操作符明确配置为在后台队列中工作。 如果没有该额外的配置，管道将被在主线程调用并执行，因为它们是从 UI 线程上调用的，这可能会导致用户界面响应速度明显减慢。 
同样，当管道的结果分配给或更新 UI 元素时，receive 操作符用于将该工作转移回主线程。

为了让 UI 在 @Published 属性发送的更改事件中不断更新，我们希望确保任何配置的管道都具有 <Never> 的失败类型。 这是 assign 操作符所必需的。 当使用 sink 操作符时，它也是一个潜在的 bug 来源。 
如果来自 @Published 变量的管道以一个接受 Error 失败类型的 sink 结束，如果发生错误，sink 将给管道发送终止信号。 这将停止管道的任何进一步处理，即使有变量仍然被更新。

import Foundation
import Combine

enum APIFailureCondition: Error {
    case invalidServerResponse
}

struct GithubAPIUser: Decodable { 
    // A very *small* subset of the content available about
    //  a github API user for example:
    // https://api.github.com/users/heckj
    let login: String
    let public_repos: Int
    let avatar_url: String
}

struct GithubAPI { 
    // NOTE(heckj): I've also seen this kind of API access
    // object set up with with a class and static methods on the class.
    // I don't know that there's a specific benefit to making this a value
    // type/struct with a function on it.

    /// externally accessible publisher that indicates that network activity is happening in the API proxy
    static let networkActivityPublisher = PassthroughSubject<Bool, Never>() 

    /// creates a one-shot publisher that provides a GithubAPI User
    /// object as the end result. This method was specifically designed to
    /// return a list of 1 object, as opposed to the object itself to make
    /// it easier to distinguish a "no user" result (empty list)
    /// representation that could be dealt with more easily in a Combine
    /// pipeline than an optional value. The expected return type is a
    /// Publisher that returns either an empty list, or a list of one
    /// GithubAPUser, with a failure return type of Never, so it's
    /// suitable for recurring pipeline updates working with a @Published
    /// data source.
    /// - Parameter username: username to be retrieved from the Github API
    static func retrieveGithubUser(username: String) -> AnyPublisher<[GithubAPIUser], Never> { 

        if username.count < 3 { 
            return Just([]).eraseToAnyPublisher()
        }
        let assembledURL = String("https://api.github.com/users/\(username)")
        let publisher = URLSession.shared.dataTaskPublisher(for: URL(string: assembledURL)!)
            .handleEvents(receiveSubscription: { _ in 
                networkActivityPublisher.send(true)
            }, receiveCompletion: { _ in
                networkActivityPublisher.send(false)
            }, receiveCancel: {
                networkActivityPublisher.send(false)
            })
            .tryMap { data, response -> Data in 
                guard let httpResponse = response as? HTTPURLResponse,
                    httpResponse.statusCode == 200 else {
                        throw APIFailureCondition.invalidServerResponse
                }
                return data
            }
            .decode(type: GithubAPIUser.self, decoder: JSONDecoder()) 
            .map {
                [$0] 
            }
            .catch { err in 
                // When I originally wrote this method, I was returning
                // a GithubAPIUser? optional.
                // I ended up converting this to return an empty
                // list as the "error output replacement" so that I could
                // represent that the current value requested didn't *have* a
                // correct github API response.
                return Just([])
            }
            .eraseToAnyPublisher() 
            return publisher
    }
}
此处创建的 decodable 结构体是从 GitHub API 返回的数据的一部分。 在由 decode 操作符处理时，任何未在结构体中定义的字段都将被简单地忽略。
与 GitHub API 交互的代码被放在一个独立的结构体中，我习惯于将其放在一个单独的文件中。 API 结构体中的函数返回一个发布者，然后与 ViewController 中的其他管道进行混合合并。
该结构体还使用 passthroughSubject 暴露了一个发布者，使用布尔值以在发送网络请求时反映其状态。
我最开始创建了一个管道以返回一个可选的 GithubAPIUser 实例，但发现没有一种方便的方法来在失败条件下传递 “nil” 或空对象。 然后我修改了代码以返回一个列表，即使只需要一个实例，它却能更方便地表示一个“空”对象。 这对于想要在对 GithubAPIUser 对象不再存在后，在后续管道中做出响应以擦除现有值的情况很重要 —— 这时可以删除 repositoryCount 和用户头像的数据。
这里的逻辑只是为了防止无关的网络请求，如果请求的用户名少于 3 个字符，则返回空结果。
handleEvents 操作符是我们触发网络请求发布者更新的方式。 我们定义了在订阅和终结（完成和取消）时触发的闭包，它们会在 passthroughSubject 上调用 send()。 这是我们如何作为单独的发布者提供有关管道操作的元数据的示例。
tryMap 添加了对来自 github 的 API 响应的额外检查，以将来自 API 的不是有效用户实例的正确响应转换为管道失败条件。
decode 从响应中获取数据并将其解码为 GithubAPIUser 的单个实例。
map 用于获取单个实例并将其转换为单元素的列表，将类型更改为 GithubAPIUser 的列表：[GithubAPIUser]。
catch 运算符捕获此管道中的错误条件，并在失败时返回一个空列表，同时还将失败类型转换为 Never。
eraseToAnyPublisher 抹去链式操作符的复杂类型，并将整个管道暴露为 AnyPublisher 的一个实例。


import UIKit
import Combine

class ViewController: UIViewController {

    @IBOutlet weak var github_id_entry: UITextField!
    @IBOutlet weak var activityIndicator: UIActivityIndicatorView!
    @IBOutlet weak var repositoryCountLabel: UILabel!
    @IBOutlet weak var githubAvatarImageView: UIImageView!

    var repositoryCountSubscriber: AnyCancellable?
    var avatarViewSubscriber: AnyCancellable?
    var usernameSubscriber: AnyCancellable?
    var headingSubscriber: AnyCancellable?
    var apiNetworkActivitySubscriber: AnyCancellable?

    // username from the github_id_entry field, updated via IBAction
    @Published var username: String = ""

    // github user retrieved from the API publisher. As it's updated, it
    // is "wired" to update UI elements
    @Published private var githubUserData: [GithubAPIUser] = []

    // publisher reference for this is $username, of type <String, Never>
    var myBackgroundQueue: DispatchQueue = DispatchQueue(label: "viewControllerBackgroundQueue")
    let coreLocationProxy = LocationHeadingProxy()

    // MARK - Actions

    @IBAction func githubIdChanged(_ sender: UITextField) {
        username = sender.text ?? ""
        print("Set username to ", username)
    }

    // MARK - lifecycle methods

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.

        let apiActivitySub = GithubAPI.networkActivityPublisher 
        .receive(on: RunLoop.main)
            .sink { doingSomethingNow in
                if (doingSomethingNow) {
                    self.activityIndicator.startAnimating()
                } else {
                    self.activityIndicator.stopAnimating()
                }
        }
        apiNetworkActivitySubscriber = AnyCancellable(apiActivitySub)

        usernameSubscriber = $username 
            .throttle(for: 0.5, scheduler: myBackgroundQueue, latest: true)
            // ^^ scheduler myBackGroundQueue publishes resulting elements
            // into that queue, resulting on this processing moving off the
            // main runloop.
            .removeDuplicates()
            .print("username pipeline: ") // debugging output for pipeline
            .map { username -> AnyPublisher<[GithubAPIUser], Never> in
                return GithubAPI.retrieveGithubUser(username: username)
            }
            // ^^ type returned in the pipeline is a Publisher, so we use
            // switchToLatest to flatten the values out of that
            // pipeline to return down the chain, rather than returning a
            // publisher down the pipeline.
            .switchToLatest()
            // using a sink to get the results from the API search lets us
            // get not only the user, but also any errors attempting to get it.
            .receive(on: RunLoop.main)
            .assign(to: \.githubUserData, on: self)

        // using .assign() on the other hand (which returns an
        // AnyCancellable) *DOES* require a Failure type of <Never>
        repositoryCountSubscriber = $githubUserData 
            .print("github user data: ")
            .map { userData -> String in
                if let firstUser = userData.first {
                    return String(firstUser.public_repos)
                }
                return "unknown"
            }
            .receive(on: RunLoop.main)
            .assign(to: \.text, on: repositoryCountLabel)

        let avatarViewSub = $githubUserData 
            .map { userData -> AnyPublisher<UIImage, Never> in
                guard let firstUser = userData.first else {
                    // my placeholder data being returned below is an empty
                    // UIImage() instance, which simply clears the display.
                    // Your use case may be better served with an explicit
                    // placeholder image in the event of this error condition.
                    return Just(UIImage()).eraseToAnyPublisher()
                }
                return URLSession.shared.dataTaskPublisher(for: URL(string: firstUser.avatar_url)!)
                    // ^^ this hands back (Data, response) objects
                    .handleEvents(receiveSubscription: { _ in
                        DispatchQueue.main.async {
                            self.activityIndicator.startAnimating()
                        }
                    }, receiveCompletion: { _ in
                        DispatchQueue.main.async {
                            self.activityIndicator.stopAnimating()
                        }
                    }, receiveCancel: {
                        DispatchQueue.main.async {
                            self.activityIndicator.stopAnimating()
                        }
                    })
                    .receive(on: self.myBackgroundQueue)
                    // ^^ do this work on a background Queue so we don't impact
                    // UI responsiveness
                    .map { $0.data }
                    // ^^ pare down to just the Data object
                    .map { UIImage(data: $0)!}
                    // ^^ convert Data into a UIImage with its initializer
                    .catch { err in
                        return Just(UIImage())
                    }
                    // ^^ deal the failure scenario and return my "replacement"
                    // image for when an avatar image either isn't available or
                    // fails somewhere in the pipeline here.
                    .eraseToAnyPublisher()
                    // ^^ match the return type here to the return type defined
                    // in the .map() wrapping this because otherwise the return
                    // type would be terribly complex nested set of generics.
            }
            .switchToLatest()
            // ^^ Take the returned publisher that's been passed down the chain
            // and "subscribe it out" to the value within in, and then pass
            // that further down.
            .receive(on: RunLoop.main)
            // ^^ and then switch to receive and process the data on the main
            // queue since we're messing with the UI
            .map { image -> UIImage? in
                image
            }
            // ^^ this converts from the type UIImage to the type UIImage?
            // which is key to making it work correctly with the .assign()
            // operator, which must map the type *exactly*
            .assign(to: \.image, on: self.githubAvatarImageView)

        // convert the .sink to an `AnyCancellable` object that we have
        // referenced from the implied initializers
        avatarViewSubscriber = AnyCancellable(avatarViewSub)

        // KVO publisher of UIKit interface element
        let _ = repositoryCountLabel.publisher(for: \.text) 
            .sink { someValue in
                print("repositoryCountLabel Updated to \(String(describing: someValue))")
        }
    }

}

(3)合并多个管道以更新 UI 元素
观察并响应多个 UI 元素发送的值，并将更新的值联合起来以更新界面。

import UIKit
import Combine

class FormViewController: UIViewController {

    @IBOutlet weak var value1_input: UITextField!
    @IBOutlet weak var value2_input: UITextField!
    @IBOutlet weak var value2_repeat_input: UITextField!
    @IBOutlet weak var submission_button: UIButton!
    @IBOutlet weak var value1_message_label: UILabel!
    @IBOutlet weak var value2_message_label: UILabel!

    @IBAction func value1_updated(_ sender: UITextField) { 
        value1 = sender.text ?? ""
    }
    @IBAction func value2_updated(_ sender: UITextField) {
        value2 = sender.text ?? ""
    }
    @IBAction func value2_repeat_updated(_ sender: UITextField) {
        value2_repeat = sender.text ?? ""
    }

    @Published var value1: String = ""
    @Published var value2: String = ""
    @Published var value2_repeat: String = ""

    var validatedValue1: AnyPublisher<String?, Never> { 
        return $value1.map { value1 in
            guard value1.count > 2 else {
                DispatchQueue.main.async { 
                    self.value1_message_label.text = "minimum of 3 characters required"
                }
                return nil
            }
            DispatchQueue.main.async {
                self.value1_message_label.text = ""
            }
            return value1
        }.eraseToAnyPublisher()
    }

    var validatedValue2: AnyPublisher<String?, Never> { 
        return Publishers.CombineLatest($value2, $value2_repeat)
            .receive(on: RunLoop.main) 
            .map { value2, value2_repeat in
                guard value2_repeat == value2, value2.count > 4 else {
                    self.value2_message_label.text = "values must match and have at least 5 characters"
                    return nil
                }
                self.value2_message_label.text = ""
                return value2
            }.eraseToAnyPublisher()
    }

    var readyToSubmit: AnyPublisher<(String, String)?, Never> { 
        return Publishers.CombineLatest(validatedValue2, validatedValue1)
            .map { value2, value1 in
                guard let realValue2 = value2, let realValue1 = value1 else {
                    return nil
                }
                return (realValue2, realValue1)
            }
            .eraseToAnyPublisher()
    }

    private var cancellableSet: Set<AnyCancellable> = [] 

    override func viewDidLoad() {
        super.viewDidLoad()

        self.readyToSubmit
            .map { $0 != nil } 
            .receive(on: RunLoop.main)
            .assign(to: \.isEnabled, on: submission_button)
            .store(in: &cancellableSet) 
    }
}

此代码的开头遵照了 通过用户输入更新声明式 UI 中的模式. IBAction 消息用于更新 @Published 属性，触发对所连接的任何订阅者的更新。
第一个验证管道使用 map 操作符接收字符串值输入，如果与验证规则不符，则将其转换为 nil。 这也将发布者属性的输出类型从 <String> 转换为可选的 <String?>。 同样的逻辑也用于触发消息文本的更新，以提供有关所需内容的信息。
由于我们正在更新用户界面元素，因此我们明确将这些更新包裹在 DispatchQueue.main.async 中，以在主线程上调用。
combineLatest 将两个发布者合并到一个管道中，该管道的输出类型是每个上游发布者的合并值。 在这个例子中，输出类型是 (<String>, <String>) 的元组。
与其使用 DispatchQueue.main.async，不如使用 receive 操作符明确在主线程上执行下一个操作符，因为它将执行 UI 更新。
两条验证管道通过 combineLatest 相结合，并将经过检查的输出合并为单个元组输出。
我们可以将分配的管道存储为 AnyCancellable? 引用（将其映射到 viewcontroller 的生命周期），但另一种选择是创建一个变量来收集所有可取消的引用。 这从空集合开始，任何 sink 或 assign 的订阅者都可以被添加到其中，以持有对它们的引用，以便他们在 viewcontroller 的整个生命周期内运行。 如果你正在创建多个管道，这可能是保持对所有管道的引用的便捷方式。
如果任何值为 nil，则 map 操作符将向管道传递 false 值。 对 nil 值的检查提供了用于启用（或禁用）提交按钮的布尔值。
store 方法可在 Cancellable 协议上调用，该协议明确设置为支持存储可用于取消管道的引用。

(4)通过包装基于 delegate 的 API 创建重复发布者
Future 发布者非常适合包装现有代码以发出单个请求,但它不适用于产生冗长或可能无限量输出的发布者。
包装 CoreLocation 中 CLManager 的对象并通过 UIKit 的 ViewController 消费其数据的示例。

import Foundation
import Combine
import CoreLocation

final class LocationHeadingProxy: NSObject, CLLocationManagerDelegate {

    let mgr: CLLocationManager 
    private let headingPublisher: PassthroughSubject<CLHeading, Error> 
    var publisher: AnyPublisher<CLHeading, Error> 

    override init() {
        mgr = CLLocationManager()
        headingPublisher = PassthroughSubject<CLHeading, Error>()
        publisher = headingPublisher.eraseToAnyPublisher()

        super.init()
        mgr.delegate = self 
    }

    func enable() {
        mgr.startUpdatingHeading() 
    }

    func disable() {
        mgr.stopUpdatingHeading()
    }
    // MARK - delegate methods

    /*
     *  locationManager:didUpdateHeading:
     *
     *  Discussion:
     *    Invoked when a new heading is available.
     */
    func locationManager(_ manager: CLLocationManager, didUpdateHeading newHeading: CLHeading) {
        headingPublisher.send(newHeading) 
    }

    /*
     *  locationManager:didFailWithError:
     *  Discussion:
     *    Invoked when an error has occurred. Error types are defined in "CLError.h".
     */
    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        headingPublisher.send(completion: Subscribers.Completion.failure(error)) 
    }
}

CLLocationManager 作为 CoreLocation 的一部分，是被包装的核心。 因为要使用该框架，它有其他方法需要被调用，因此我将它暴露为一个 public 的只读属性。 这对于先请求用户许可然后使用位置 API 很有用，框架将该位置 API 暴露为一个在 CLLocationManager 上的方法。
使用一个具有我们要发布的数据类型的 private 的 PassthroughSubject 实例，来提供我们的类内部访问以转发数据。
一个 public 的属性 publisher 将来自上面的 subject 的发布者暴露给外部以供订阅。
其核心是将该类指定为 CLLocationManager 实例的代理，在该实例初始化的尾端进行设置。
CoreLocation API 不会立即开始发送信息。 有些方法需要调用才能启动（并停止）数据流，这些方法被包装并暴露在此 LocationHeadingProxy 对象上。 大多数发布者都设置为订阅并根据订阅驱动消费，因此这有点不符合发布者如何开始生成数据的规范。
在定义代理和激活 CLLocationManager 后，数据将通过在 CLLocationManagerDelegate 上定义的回调提供。 我们为这个包装的对象实现了我们想要的回调，并在其中使用 passthroughSubject .send() 将信息转发给任何现有的订阅者。
虽然没有严格要求，但代理提供了 Error 上报回调，因此我们也将其包括在示例中通过 passthroughSubject 转发。

import UIKit
import Combine
import CoreLocation

class HeadingViewController: UIViewController {

    var headingSubscriber: AnyCancellable?

    let coreLocationProxy = LocationHeadingProxy()
    var headingBackgroundQueue: DispatchQueue = DispatchQueue(label: "headingBackgroundQueue")

    // MARK - lifecycle methods

    @IBOutlet weak var permissionButton: UIButton!
    @IBOutlet weak var activateTrackingSwitch: UISwitch!
    @IBOutlet weak var headingLabel: UILabel!
    @IBOutlet weak var locationPermissionLabel: UILabel!

    @IBAction func requestPermission(_ sender: UIButton) {
        print("requesting corelocation permission")
        let _ = Future<Int, Never> { promise in 
            self.coreLocationProxy.mgr.requestWhenInUseAuthorization()
            return promise(.success(1))
        }
        .delay(for: 2.0, scheduler: headingBackgroundQueue) 
        .receive(on: RunLoop.main)
        .sink { _ in
            print("updating corelocation permission label")
            self.updatePermissionStatus() 
        }
    }

    @IBAction func trackingToggled(_ sender: UISwitch) {
        switch sender.isOn {
        case true:
            self.coreLocationProxy.enable() 
            print("Enabling heading tracking")
        case false:
            self.coreLocationProxy.disable()
            print("Disabling heading tracking")
        }
    }

    func updatePermissionStatus() {
        let x = CLLocationManager.authorizationStatus()
        switch x {
        case .authorizedWhenInUse:
            locationPermissionLabel.text = "Allowed when in use"
        case .notDetermined:
            locationPermissionLabel.text = "notDetermined"
        case .restricted:
            locationPermissionLabel.text = "restricted"
        case .denied:
            locationPermissionLabel.text = "denied"
        case .authorizedAlways:
            locationPermissionLabel.text = "authorizedAlways"
        @unknown default:
            locationPermissionLabel.text = "unknown default"
        }
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.

        // request authorization for the corelocation data
        self.updatePermissionStatus()

        let corelocationsub = coreLocationProxy
            .publisher
            .print("headingSubscriber")
            .receive(on: RunLoop.main)
            .sink { someValue in 
                self.headingLabel.text = String(someValue.trueHeading)
            }
        headingSubscriber = AnyCancellable(corelocationsub)
    }

}
CoreLocation 的特点之一是要向用户请求访问数据的许可。 启动此请求的 API 将立即返回，但即使用户允许或拒绝请求，它并不提供任何详细信息。 CLLocationManager 类包括信息，并在想要获取信息时将其作为类方法暴露给外部，但未提供任何信息来了解用户何时或是否响应了请求。 由于操作不提供任何返回信息，我们将整数提供给管道作为数据，主要表示已发出请求。
由于没有明确的方法来判断用户何时会授予权限，但权限是持久的，因此在尝试获取数据之前，我们简单地使用了 delay 操作符。 此使用只会将值的传递延迟两秒钟。
延迟后，我们调用类方法，并尝试根据当前提供的状态的结果更新界面中的信息。
由于 CoreLocation 需要调用方法来明确启用或禁用数据，因此将我们发布者 proxy 的方法连接到了一个 UISwitch 的 IBAction 开关上。
方位数据在本 sink 订阅者中接收，在此示例中，我们将其写到文本 label 上。

(5)响应 NotificationCenter 的更新
作为发布者接收 NotificationCenter 的通知，以声明式的对所提供的信息做出响应。

let sub = NotificationCenter.default.publisher(for: NSControl.textDidChangeNotification, 
                                               object: filterField) 
    .map { ($0.object as! NSTextField).stringValue }  
    .assign(to: \MyViewModel.filterString, on: myViewModel) 
AppKit 中的 TextField 在值更新时生成 textDidChangeNotification 通知。
一个 AppKit 的应用程序通常可以具有大量可能被更改的 TextField。 包含对发送控件的引用可用于过滤你特别感兴趣的文本的更改通知。
map 操作符可用于获取通知中包含的对象引用，在这个例子中，发送通知的 TextField 的 .stringValue 属性提供了它更新后的值。
由此产生的字符串可以使用可写入的 KeyValue 路径进行 assign。

一个订阅你自己的通知事件的示例：

let cancellable = NotificationCenter.default.publisher(for: .myExampleNotification, object: nil)
    // can't use the object parameter to filter on a value reference, only class references, but
    // filtering on 'nil' only constrains to notification name, so value objects *can* be passed
    // in the notification itself.
    .sink { receivedNotification in
        print("passed through: ", receivedNotification)
        // receivedNotification.name
        // receivedNotification.object - object sending the notification (sometimes nil)
        // receivedNotification.userInfo - often nil
    }

10.和 SwiftUI 集成
(1)使用 ObservableObject 与 SwiftUI 模型作为发布源

SwiftUI 包含 @ObservedObject 和 ObservableObject 协议，它为 SwiftUI 的视图提供了将状态外部化的手段，同时通知 SwiftUI 模型的变化。

SwiftUI 通过将状态外化为类中的属性，并使用 ObservableObject 协议将该类引用到模型中来实现此目的。
两个属性 firstEntry 和 secondEntry 作为字符串使用 @Published 属性包装，允许 SwiftUI 绑定到它们的更新，以及更新它们。
第三个属性 submitAllowed 暴露为 Combine 发布者，可在视图内使用，从而维护视图内部的 @State buttonIsDisabled 状态。
第四个属性 —— 一个 validationMessages 字符串数组 - 在 Combine 管道中将前两个属性进行组合计算，并且使用 @Published 属性包装暴露给 SwiftUI。

import Foundation
import Combine

class ReactiveFormModel : ObservableObject {

    @Published var firstEntry: String = "" {
        didSet {
            firstEntryPublisher.send(self.firstEntry) 
        }
    }
    private let firstEntryPublisher = CurrentValueSubject<String, Never>("") 

    @Published var secondEntry: String = "" {
        didSet {
            secondEntryPublisher.send(self.secondEntry)
        }
    }
    private let secondEntryPublisher = CurrentValueSubject<String, Never>("")

    @Published var validationMessages = [String]()
    private var cancellableSet: Set<AnyCancellable> = []

    var submitAllowed: AnyPublisher<Bool, Never>

    init() {

        let validationPipeline = Publishers.CombineLatest(firstEntryPublisher, secondEntryPublisher) 
            .map { (arg) -> [String] in 
                var diagMsgs = [String]()
                let (value, value_repeat) = arg
                if !(value_repeat == value) {
                    diagMsgs.append("Values for fields must match.")
                }
                if (value.count < 5 || value_repeat.count < 5) {
                    diagMsgs.append("Please enter values of at least 5 characters.")
                }
                return diagMsgs
            }

        submitAllowed = validationPipeline 
            .map { stringArray in
                return stringArray.count < 1
            }
            .eraseToAnyPublisher()

        let _ = validationPipeline 
            .assign(to: \.validationMessages, on: self)
            .store(in: &cancellableSet)
    }
}
firstEntry 和 secondEntry 都使用空字符串作为默认值。
然后，这些属性还用 currentValueSubject 进行镜像，该镜像属性使用来自每个 @Published 属性的 didSet 发送更新事件。这驱动下面定义的 Combine 管道，以便在值从 SwiftUI 视图更改时触发响应式更新。
combineLatest 用于合并来自 firstEntry 或 secondEntry 的更新，以便从任一来源来触发更新。
map 接受输入值并使用它们来确定和发布验证过的消息数组。该数据流 validationPipeline 是两个后续管道的发布源。
第一个后续管道使用验证过的消息数组来确定一个 true 或 false 的布尔值发布者，用于启用或禁用提交按钮。
第二个后续管道接受验证过的消息数组，并更新持有的该 ObservedObject 实例的 validationMessages，以便 SwiftUI 在需要时监听和使用它。

两种不同的状态更新的暴露方法 —— 作为发布者或外部状态，在示例中都进行了展示，以便于你可以更好的利用任一种方法。 提交按钮启用/禁用的选项可作为 @Published 属性进行暴露，验证消息的数组可作为 <String[], Never> 类型的发布者而对外暴露。
如果需要涉及作为显式状态去跟踪用户行为，则通过暴露 @Published 属性可能更清晰、不直接耦合，但任一种机制都是可以使用的。

import SwiftUI

struct ReactiveForm: View {

    @ObservedObject var model: ReactiveFormModel 
    // $model is a ObservedObject<ExampleModel>.Wrapper
    // and $model.objectWillChange is a Binding<ObservableObjectPublisher>
    @State private var buttonIsDisabled = true 
    // $buttonIsDisabled is a Binding<Bool>

    var body: some View {
        VStack {
            Text("Reactive Form")
                .font(.headline)

            Form {
                TextField("first entry", text: $model.firstEntry) 
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .lineLimit(1)
                    .multilineTextAlignment(.center)
                    .padding()

                TextField("second entry", text: $model.secondEntry)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .multilineTextAlignment(.center)
                    .padding()

                VStack {
                    ForEach(model.validationMessages, id: \.self) { msg in 
                        Text(msg)
                            .foregroundColor(.red)
                            .font(.callout)
                    }
                }
            }

            Button(action: {}) {
                Text("Submit")
            }.disabled(buttonIsDisabled)
                .onReceive(model.submitAllowed) { submitAllowed in 
                    self.buttonIsDisabled = !submitAllowed
            }
            .padding()
            .background(RoundedRectangle(cornerRadius: 10)
                .stroke(Color.blue, lineWidth: 1)
            )

            Spacer()
        }
    }
}

struct ReactiveForm_Previews: PreviewProvider {
    static var previews: some View {
        ReactiveForm(model: ReactiveFormModel())
    }
}

数据模型使用 @ObservedObject 暴露给 SwiftUI。
@State buttonIsDisabled 在该视图中被声明为局部变量，有一个默认值 true。
属性包装($model.firstEntry 和 $model.secondEntry) 的预计值用于将绑定传递到 TextField 视图元素。当用户更改值时，Binding 将触发引用模型上的更新，并让 SwiftUI 的组件知道，如果暴露的模型正在被更改，则组件的更改也即将发生。
在数据模型中生成和 assign 的验证消息，作为 Combine 管道的发布者，在这儿对于 SwiftUI 是不可见的。相反，这只能对这些被暴露的值的变化所引起的模型的变化做出反应，而不关心改变这些值的机制。
作为如何使用带有 onReceive 的发布者的示例，使用 onReceive 订阅者来监听引用模型中暴露的发布者。在这个例子中，我们接受值并把它们作为局部变量 @State 存储在 SwiftUI 的视图中，但它也可以在一些转化后使用，如果该逻辑只和视图显示的结果值强相关的话。在这，我们将其与 Button 上的 disabled 一起使用，使 SwiftUI 能够根据 @State 中存储的值启用或禁用该 UI 元素。


11.测试和调试
(1)使用 XCTestExpectation 测试发布者
func testDataTaskPublisher() {
        // setup
        let expectation = XCTestExpectation(description: "Download from \(String(describing: testURL))") 
        let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: self.testURL!)
            // validate
            .sink(receiveCompletion: { fini in
                print(".sink() received the completion", String(describing: fini))
                switch fini {
                case .finished: expectation.fulfill() 
                case .failure: XCTFail() 
                }
            }, receiveValue: { (data, response) in
                guard let httpResponse = response as? HTTPURLResponse else {
                    XCTFail("Unable to parse response an HTTPURLResponse")
                    return
                }
                XCTAssertNotNil(data)
                // print(".sink() data received \(data)")
                XCTAssertNotNil(httpResponse)
                XCTAssertEqual(httpResponse.statusCode, 200) 
                // print(".sink() httpResponse received \(httpResponse)")
            })

        XCTAssertNotNil(remoteDataPublisher)
        wait(for: [expectation], timeout: 5.0) 
    }

Expectation 设置为一个字符串，这样在发生失败时更容易调试。 此字符串仅在测试失败时才能看到。 我们在这里测试的代码是 dataTaskPublisher 从测试前就已定义好的预设的 URL 中取回数据。 发布者通过将 sink 订阅者连接到它开始触发请求。 如果没有 expectation，代码仍将运行，但构建的测试运行结构将不会等到结果返回之后再去检查是否有任何意外。 测试中的 expectation "暂停测试" 去等待响应，让操作符先发挥它们的作用。
在这个例子中，测试期望可以成功完成并正常终止，因此在 receiveCompletion 闭包内调用 expectation.fulfill()，具体是接收到 .finished completion 后调用。
由于我们不期望失败，如果我们收到 .failure completion，我们也明确地调用 XCTFail()。
我们在 receiveValue 中还有一些其他断言。 由于此发布者设置返回单个值然后终止，因此我们可以对收到的数据进行内联断言。 如果我们收到多个值，那么我们可以收集这些值，并就事后收到的内容做出断言。
此测试使用单个 expectation，但你可以包含多个独立的 expectation，去要求它们都被 fulfill()。 它还规定此测试的最长运行时间为 5 秒。 测试并不总是需要五秒钟，因为一旦收到 fulfill，它就会完成。 如果出于某种原因，测试需要超过五秒钟的响应时间，XCTest 将报告测试失败。

(2)使用 PassthroughSubject 测试订阅者
我们可以使用 PassthroughSubject 模拟发布源，明确地控制哪些数据被发送和何时发送。

func testSinkReceiveDataThenError() {

    // setup - preconditions 
    let expectedValues = ["firstStringValue", "secondStringValue"]
    enum TestFailureCondition: Error {
        case anErrorExample
    }
    var countValuesReceived = 0
    var countCompletionsReceived = 0

    // setup
    let simplePublisher = PassthroughSubject<String, Error>() 

    let _ = simplePublisher 
        .sink(receiveCompletion: { completion in
            countCompletionsReceived += 1
            switch completion { 
            case .finished:
                print(".sink() received the completion:", String(describing: completion))
                // no associated data, but you can react to knowing the
                // request has been completed
                XCTFail("We should never receive the completion, the error should happen first")
                break
            case .failure(let anError):
                // do what you want with the error details, presenting,
                // logging, or hiding as appropriate
                print("received the error: ", anError)
                XCTAssertEqual(anError.localizedDescription,
                               TestFailureCondition.anErrorExample.localizedDescription) 
                break
            }
        }, receiveValue: { someValue in 
            // do what you want with the resulting value passed down
            // be aware that depending on the data type being returned,
            // you may get this closure invoked multiple times.
            XCTAssertNotNil(someValue)
            XCTAssertTrue(expectedValues.contains(someValue))
            countValuesReceived += 1
            print(".sink() received \(someValue)")
        })

    // validate
    XCTAssertEqual(countValuesReceived, 0) 
    XCTAssertEqual(countCompletionsReceived, 0)

    simplePublisher.send("firstStringValue") 
    XCTAssertEqual(countValuesReceived, 1)
    XCTAssertEqual(countCompletionsReceived, 0)

    simplePublisher.send("secondStringValue")
    XCTAssertEqual(countValuesReceived, 2)
    XCTAssertEqual(countCompletionsReceived, 0)

    simplePublisher.send(completion: Subscribers.Completion.failure(TestFailureCondition.anErrorExample))  
    XCTAssertEqual(countValuesReceived, 2)
    XCTAssertEqual(countCompletionsReceived, 1)

    // this data will never be seen by anything in the pipeline above because
    // we have already sent a completion
    simplePublisher.send(completion: Subscribers.Completion.finished) 
    XCTAssertEqual(countValuesReceived, 2)
    XCTAssertEqual(countCompletionsReceived, 1)
}

此测试设置了一些变量，以便在测试执行期间捕获和修改它们，用于验证 sink 代码的执行时间和工作方式。 此外，我们在此处定义了一个错误，以便在我们的测试代码中使用它来验证失败的情况。
此代码设置为使用 passthroughSubject 来驱动测试，但我们感兴趣的测试代码是订阅者。
该订阅者被配置在测试下（在这儿是一个标准的 sink）。 我们配置了在接收到数据和 completion 时会触发的代码。
在接收到 completion 时，我们对其调用 switch，添加了一个断言，如果 finish 被调用了，将不通过测试，因为我们期望只会生成 .failure completion。
Swift 中的测试错误是否相等没那么容易，但如果错误是你正在控制的代码，有时你可以使用 localizedDescription 作为测试收到的错误类型的便捷方式。
receiveValue 闭包在考虑如何对收到的值进行断言时更为复杂。 由于我们在此测试过程中会收到多个值，我们有一些额外的逻辑来检查值是否在我们发送的集合内。 与 completion 的处理逻辑一样，我们还是增加测试特定变量，我们将在以后断言这些变量以验证状态和操作顺序。
在我们发送任何数据以仔细检查我们的假设之前，我们先验证计数变量。
在测试中，send() 触发了操作，之后我们就可以立即通过验证我们更新的测试变量来验证所产生的效果了。 在你自己的代码中，你可能无法（或不想要）修改你的订阅者，但你可能能够向对象提供私有/可测试的属性或途径，以类似的方式验证它们。
我们还使用 send() 发送一个 completion，在这个例子中是一个失败的 completion。
最后的 send() 验证刚刚发生的失败事件 —— 当前发送的 finished completion 应该没有被处理，并且应该没有后续的状态更新再发生。

(3)使用从 PassthroughSubject 预定好的发送的事件测试订阅者
func testKVOPublisher() {
    let expectation = XCTestExpectation(description: self.debugDescription)
    let foo = KVOAbleNSObject()
    let q = DispatchQueue(label: self.debugDescription) 

    let _ = foo.publisher(for: \.intValue)
        .print()
        .sink { someValue in
            print("value of intValue updated to: >>\(someValue)<<")
        }

    q.asyncAfter(deadline: .now() + 0.5, execute: { 
        print("Updating to foo.intValue on background queue")
        foo.intValue = 5
        expectation.fulfill() 
    })
    wait(for: [expectation], timeout: 5.0) 
}

这将为你的测试添加 DispatchQueue，并以测试的描述 debugDescription 来命名该队列。 这只在调试中测试失败时显示，并且在还有其它后台线程也在使用时，方便地提醒测试代码中发生了什么情况。
.asyncAfter 和参数 deadline 一起使用，用来定义何时发起请求.
这是将任何相关的断言嵌入到订阅者或其周围的最简单的方式。此外，将 .fulfill() 作为你发送队列的最后一个条目，好让测试知道它现在已完成。
请确保当你设置等待超时时间时，有足够的时间让你的队列被调用。

另一种选择是第三方库，名为 EntwineTest，开发灵感来自 RxTest 库。 EntwineTest 是 Entwine 的一部分，一个提供了一些 helpers 扩展了 Combine 的 Swift 库。
https://github.com/tcldr/Entwine

EntwineTest 中包含的关键元素之一是虚拟时间调度器，以及使用此调度器时安排（TestablePublisher）并收集和记录（TestableSubscriber）结果时间的其他类。
func testExampleUsingVirtualTimeScheduler() {
    let scheduler = TestScheduler(initialClock: 0) 
    var didSink = false
    let cancellable = Just(1) 
        .delay(for: 1, scheduler: scheduler)
        .sink { _ in
            didSink = true
        }

    XCTAssertNotNil(cancellable)
    // where a real scheduler would have triggered when .sink() was invoked
    // the virtual time scheduler requires resume() to commence and runs to
    // completion.
    scheduler.resume() 
    XCTAssertTrue(didSink) 
}
使用虚拟时间调度器需要在测试开始时创建一个，将其时钟初始化为起始值。 EntwineTest 中的虚拟时间调度器将以 200 的值开始订阅，如果管道在时间为 900 时还没完成，则会超时。
你和以往创建任何发布者或订阅者一样，创建你的管道。 EntwineTest 还提供可测试的发布者和订阅者，以供使用。 有关 EntwineTest 这些部分的更多详细信息，请看 使用 EntwineTest 创建可测试的发布器和订阅者.
.resume() 需要在虚拟时间调度器上调用，以开始其工作和触发管道运行。
在管道运行到完成后，对预期的最终结果进行断言。

(4)使用 print 操作符调试管道
为了了解管道中正在发生的事情，查看所有控制事件和数据交互。

usernameSubscriber = $username
    .throttle(for: 0.5, scheduler: myBackgroundQueue, latest: true)
    // ^^ scheduler myBackGroundQueue publishes resulting elements
    // into that queue, resulting on this processing moving off the
    // main runloop.
    .removeDuplicates()
    .print("username pipeline: ") // debugging output for pipeline
    .map { username -> AnyPublisher<[GithubAPIUser], Never> in
        return GithubAPI.retrieveGithubUser(username: username)
    }
    // ^^ type returned in the pipeline is a Publisher, so we use
    // switchToLatest to flatten the values out of that
    // pipeline to return down the chain, rather than returning a
    // publisher down the pipeline.
    .switchToLatest()
    // using a sink to get the results from the API search lets us
    // get not only the user, but also any errors attempting to get it.
    .receive(on: RunLoop.main)
    .assign(to: \.githubUserData, on: self)

// using .assign() on the other hand (which returns an
// AnyCancellable) *DOES* require a Failure type of <Never>
repositoryCountSubscriber = $githubUserData
    .print("github user data: ")
    .map { userData -> String in
        if let firstUser = userData.first {
            return String(firstUser.public_repos)
        }
        return "unknown"
    }
    .receive(on: RunLoop.main)
    .assign(to: \.text, on: repositoryCountLabel)


(5)使用 handleEvents 操作符调试管道
使用断点、打印、记录语句或其他额外的逻辑，以便更有针对性地了解管道内发生的情况。
可以指定的闭包包括:
receiveSubscription
receiveRequest
receiveCancel
receiveOutput
receiveCompletion

.handleEvents(receiveSubscription: { aValue in
    print("receiveSubscription event called with \(String(describing: aValue))") 
}, receiveOutput: { aValue in 
    print("receiveOutput was invoked with \(String(describing: aValue))")
}, receiveCompletion: { aValue in 
    print("receiveCompletion event called with \(String(describing: aValue))")
}, receiveCancel: { 
    print("receiveCancel event invoked")
}, receiveRequest: { aValue in 
    print("receiveRequest event called with \(String(describing: aValue))")
})

==================================================Reference
------------------------------Publishers
output: The one element that the publisher emits.

Just:
Just provides a single result and then terminates, providing a publisher with a failure type of <Never>

Future:
A Future is initialized with a closure that eventually resolves to a single output value or failure completion.
import Contacts
let futureAsyncPublisher = Future<Bool, Error> { promise in 
    CNContactStore().requestAccess(for: .contacts) { grantedAccess, err in 
    // err is an optional
    if let err = err { 
        promise(.failure(err))
    }
    return promise(.success(grantedAccess)) 
}

If you want to wrap an async API that could return many values over time, you should not use Future directly, as it only returns a single value. 
Instead, you should consider creating your own publisher based on passthroughSubject or currentValueSubject, or wrapping the Future publisher with Deferred.
Future creates and invokes its closure to do the asynchronous request at the time of creation, not when the publisher receives a demand request. This can be counter-intuitive, 
as many other publishers invoke their closures when they receive demand. This also means that you can’t directly link a Future publisher to an operator like retry.
If you are wanting repeated requests to a Future (for example, wanting to use a retry operator to retry failed requests), wrap the Future publisher with Deferred.
let deferredPublisher = Deferred { 
    return Future<Bool, Error> { promise in 
        self.asyncAPICall(sabotage: false) { (grantedAccess, err) in
            if let err = err {
                return promise(.failure(err))
            }
            return promise(.success(grantedAccess))
        }
    }
}.eraseToAnyPublisher()

Empty:
empty never publishes any values, and optionally finishes immediately.
let myEmptyPublisher = Empty<String, Never>()

Fail:
Fail immediately terminates publishing with the specified failure.
Initializing Fail by specifying the types
let cancellable = Fail<String, Error>(error: TestFailureCondition.exampleFailure)
Initializing Fail by providing types as parameters:
let cancellable = Fail(outputType: String.self, failure: TestFailureCondition.exampleFailure)

Publishers.Sequence:
Sequence publishes a provided sequence of elements, most often used through convenience initializers.
let initialSequence = ["one", "two", "red", "blue"]
_ = initialSequence.publisher
    .sink {
        print($0)
    }
}

Record:
A publisher that allows for recording a series of inputs and a completion, for later playback to each subscriber.
Record is illustrated in the unit tests

/ creates a recording
let recordedPublisher = Record<String, Never> { example in
    // example : type is Record<String, Never>.Recording
    example.receive("one")
    example.receive("two")
    example.receive("three")
    example.receive(completion: .finished)
}
The resulting instance can be used as a publisher immediately:

let cancellable = recordedPublisher.sink(receiveCompletion: { err in
    print(".sink() received the completion: ", String(describing: err))
    expectation.fulfill()
}, receiveValue: { value in
    print(".sink() received value: ", value)
})

Deferred:
The Deferred publisher waits for a subscriber before running the provided closure to create values for the subscriber.

MakeConnectable:
Creates a or converts a publisher to one that explicitly conforms to the ConnectablePublisher protocol.
The failure type of the publisher must be <Never>
When using connect, the receipt of subscription will be under imperative control. 
Normally when a subscriber is linked to a publisher, the connection is made automatically, subscriptions get sent, 
and demand gets negotiated per the Lifecycle of Publishers and Subscribers. 
With a connectable publisher, in addition to setting up the subscription connect() needs to be explicitly invoked. 
Until connect() is invoked, the subscription won’t be received by the publisher.
var cancellables = Set<AnyCancellable>()
let publisher = Just("woot")
    .makeConnectable()

publisher.sink { value in
    print("Value received in sink: ", value)
}
.store(in: &cancellables)
The above code will not activate the subscription, and in turn show any results. In order to enable the subscription, an explicit connect() is required:

publisher
    .connect()
    .store(in: &cancellables)
One of the primary uses of having a connectable publisher is to coordinate the timing of connecting multiple subscribers with multicast. 

Because multicast only shares existing events and does not replay anything, 
a subscription joining late could miss some data. By explicitly enabling the connect(), 
all subscribers can be attached before any upstream processing begins.

In comparison, autoconnect() makes a Connectable publisher act like a non-connectable one. 
When you enabled autoconnect() on a Connectable publisher, 
it will automate the connection such that the first subscription will activate upstream publishers.

var cancellables = Set<AnyCancellable>()
let publisher = Just("woot")
    .makeConnectable() 
    .autoconnect() 

publisher.sink { value in
    print("Value received in sink: ", value)
}
.store(in: &cancellables)

makeConnectable wraps an existing publisher and makes it explicitly connectable.
autoconnect automates the process of establishing the connection for you; The first subscriber will establish the connection, subscriptions will be forwards and demand negotiated.

Making a publisher connectable and then immediately enabling autoconnect is an odd example, as you typically want one explicit pattern of behavior or the other. The two mechanisms allow you to choose which you want for the needs of your code.
As such, it is extremely unlikely that you would ever want to use makeConnectable() followed immediately by autoconnect().
Both Timer and multicast are examples of connectable publishers.

SwiftUI:
The SwiftUI framework is based upon displaying views from explicit state; as the state changes, the view updates.

SwiftUI uses a variety of property wrappers within its Views to reference and display content from outside of those views. 
@ObservedObject, @EnvironmentObject, and @Published are the most common that relate to Combine. 
SwiftUI uses these property wrappers to create a publisher that will inform SwiftUI when those models have changed, 
creating a objectWillChange publisher. 
Having an object conform to ObservableObject will also get a default objectWillChange publisher.

SwiftUI uses ObservableObject, which has a default concrete class implementation called ObservableObjectPublisher that exposes a publisher for reference objects (classes) marked with @ObservedObject.

----------Binding
SwiftUI does this primarily by tracking the state and changes to the state using the SwiftUI struct Binding. 
A binding is not a Combine pipeline, or even usable as one. 
A Binding is based on closures that are used when you get or set data through the binding. 
When creating a Binding, you can specify the closures, or use the defaults, 
which handles the needs of SwiftUI elements to react when data is set or request data when a view requires it.

There are a number of SwiftUI property wrappers that create bindings:
@State: creates a binding to a local view property, and is intended to be used only in one view
when you create:
@State private var exampleString = ""
then: exampleString is the state itself and the property wrapper creates $exampleString (also known as property wrapper’s projected value) which is of type Binding<String>.

@Binding: is used to reference an externally provided binding that the view wants to use to present itself. You will see there upon occasion when a view is expected to be component, and it is watching for its relevant state data from an enclosing view.
@EnvironmentObject: make state visible and usable across a set of views. @EnvironmentObject is used to inject your own objects or state models into the environment, making them available to be used by any of the views within the current view hierarchy.

@Environment is used to expose environmental information already available from within the frameworks, for example:
@Environment(\.horizontalSizeClass) var horizontalSizeClass

----------SwiftUI and Combine
All of this detail on Binding is important to how SwiftUI works, but irrelevant to Combine - Bindings are not combine pipelines or structures, 
and the classes and structs that SwiftUI uses are directly transformable from Combine publishers or subscribers.

The core of the ObservableObject protocol is a combine publisher objectWillChange, which is used by the SwiftUI framework to know when it needs to invalidate a view based on a model changing. 
The objectWillChange publisher only provides an indicator that something has changed on the model, not which property, or what changed about it. 
The author of the model class can "opt-in" properties into triggering that change using the @Published property wrapper. 
If a model has properties that aren’t wrapped with @Published, then the automatic objectWillChange notification won’t get triggered when those values are modified. 
Typically the model properties will be referenced directly within the View elements. 
When the view is invalidated by a value being published through the objectWillChange publisher, the SwiftUI View will request the data it needs, as it needs it, directly from the various model references.

The other way that Combine fits into SwiftUI is the method onReceive, which is a generic instance method on SwiftUI views.

ObservableObject:
Used with SwiftUI, objects conforming to ObservableObject protocol can provide a publisher.
When a class includes a Published property and conforms to the ObservableObject protocol, this class instances will get a objectWillChange publisher endpoint providing this publisher. 
The objectWillChange publisher will not return any of the changed data, only an indicator that the referenced object has changed.

The output type of ObservableObject.Output is type aliased to Void, so while it is not nil, it will not provide any meaningful data. 
Because the output type does not include what changes on the referenced object, 
the best method for responding to changes is probably best done using sink.

@Published:
A property wrapper that adds a Combine publisher to any property
@Published is part of Combine, but allows you to wrap a property, enabling you to get a publisher that triggers data updates whenever the property is changed. 
The publisher’s output type is inferred from the type of the property, and the error type of the provided publisher is <Never>.

@Published var username: String = "" 

$username 
    .sink { someString in
        print("value of username updated to: ", someString)
    }

$username 
    .assign(\.text, on: myLabel)

@Published private var githubUserData: [GithubAPIUser] = [] 

@Published wraps the property, username, and will generate events whenever the property is changed. If there is a subscriber at initialization time, the subscriber will also receive the initial value being set. The publisher for the property is available at the same scope, and with the same permissions, as the property itself.
The publisher is accessible as $username, of type Published<String>.publisher.
A Published property can have more than one subscriber pipeline triggering from it.

Using @Published should only be done within reference types - that is, within classes

Foundation:
----------NotificationCenter
Foundation’s NotificationCenter added the capability to act as a publisher, providing Notifications to pipelines.
extension Notification.Name {
    static let yourNotification = Notification.Name("your-notification") 
}

let cancellable = NotificationCenter.default.publisher(for: .yourNotification, object: nil) 
    .sink {
        print ($0) 
    }
Notifications are defined by a string for their name. If defining your own, be careful to define the strings uniquely.
A NotificationCenter publisher can be created for a single type of notification, .yourNotification in this case, defined previously in your code.
Notifications are received from the publisher. These include at least their name, and optionally a object reference from the sending object - most commonly provided from Apple frameworks. 
Notifications may also include a userInfo dictionary of arbitrary values, which can be used to pass additional information within your application.

----------Timer
Foundation’s Timer added the capability to act as a publisher, providing a publisher to repeatedly send values to pipelines based on a Timer instance.
Timer.publish returns an instance of Timer.TimerPublisher.
This publisher is a connectable publisher, conforming to ConnectablePublisher.
This means that even when subscribers are connected to it, it will not start producing values until connect() or autoconnect() is invoked on the publisher.
The publisher has an output type of Date and a failure type of <Never>.
If you want the publisher to automatically connect and start receiving values as soon as subscribers are connected and make requests for values, 
then you may include autoconnect() in the pipeline to have it automatically start to generate values as soon as a subscriber requests data.

let cancellable = Timer.publish(every: 1.0, on: RunLoop.main, in: .common)
    .autoconnect()
    .sink { receivedTimeStamp in
        print("passed through: ", receivedTimeStamp)
    }

Alternatively, you can connect up the subscribers, which will receive no values until you invoke connect() on the publisher, which also returns a Cancellable reference.

let timerPublisher = Timer.publish(every: 1.0, on: RunLoop.main, in: .default)
let cancellableSink = timerPublisher
    .sink { receivedTimeStamp in
        print("passed through: ", receivedTimeStamp)
    }
// no values until the following is invoked elsewhere/later:
let cancellablePublisher = timerPublisher.connect()

----------publisher from a KeyValueObserving instance
Foundation added the ability to get a publisher on any NSObject that can be watched with Key Value Observing.
Any key-value-observing instance can produce a publisher. To create this publisher, you call the function publisher on the object, providing it with a single (required) KeyPath value.
private final class KVOAbleNSObject: NSObject {
    @objc dynamic var intValue: Int = 0
    @objc dynamic var boolValue: Bool = false
}

let foo = KVOAbleNSObject()

let _ = foo.publisher(for: \.intValue)
    .sink { someValue in
        print("value updated to: >>\(someValue)<<")
    }

----------URLSession.dataTaskPublisher
Foundation’s URLSession has a publisher specifically for requesting data from URLs: dataTaskPublisher
dataTaskPublisher, on URLSession, has two variants for creating a publisher. The first takes an instance of URL, the second URLRequest. The data returned from the publisher is a tuple of (data: Data, response: URLResponse).

let request = URLRequest(url: regularURL)
return URLSession.shared.dataTaskPublisher(for: request)

----------Result
Foundation also adds Result as a publisher.
Combine augments Result from the swift standard library with a .publisher property, 
returning a publisher with an output type of Success and a failure type of Failure, defined by the Result instance.

Any method that returns an instance of Result can use this property to get a publisher that will provide the resulting value and followed by a .finished completion, or a .failure completion with the relevant Error.

----------RealityKit
https://developer.apple.com/documentation/realitykit/
Use the RealityKit framework to implement high-performance 3D simulation and rendering. 
RealityKit leverages information provided by the ARKit framework to seamlessly integrate virtual objects into the real world.
Scene Publisher (from RealityKit)

------------------------------Operators
1.Mapping elements
(1)scan
Publishers.Scan
struct Scan<Upstream, Output> where Upstream : Publisher

scan acts like an accumulator, collecting and modifying values according to a closure you provide, 
and publishing intermediate results with each change from upstream.
/// Transforms elements from the upstream publisher by providing the current element to a closure along with the last value returned by the closure.
///
///     let pub = (0...5)
///         .publisher
///         .scan(0, { return $0 + $1 })
///         .sink(receiveValue: { print ("\($0)", terminator: " ") })
///      // Prints "0 1 3 6 10 15 ".
///
///
/// - Parameters:
///   - initialResult: The previous result returned by the `nextPartialResult` closure.
///   - nextPartialResult: A closure that takes as its arguments the previous value returned by the closure and the next element emitted from the upstream publisher.
/// - Returns: A publisher that transforms elements by applying a closure that receives its previous return value and the next element from the upstream publisher.

Scan lets you accumulate values or otherwise modify a type as changes flow through the pipeline. 
You can use this to collect values into an array, implement a counter, or any number of other interesting use cases.

If you want to be able to throw an error from within the closure doing the accumulation to indicate an error condition, use the tryScan operator.
If you want to accumulate and process values, but refrain from publishing any results until the upstream publisher completes, consider using the reduce or tryReduce operators.
When you create a scan operator, you provide an initial value (of the type determined by the upstream publisher) and a closure that takes two parameters - the result returned from the previous invocation of the closure and a new value from the upstream publisher. 
You do not need to maintain the type of the upstream publisher, but can convert the type in your closure, 
returning whatever is appropriate to your needs.

(2)tryScan
tryScan is a variant of the scan operator which allows for the provided closure to throw an error and cancel the pipeline. 
The closure provided updates and modifies a value based on any inputs from an upstream publisher and publishing intermediate results.
/// Transforms elements from the upstream publisher by providing the current element to an error-throwing closure along with the last value returned by the closure.
///
/// If the closure throws an error, the publisher fails with the error.
/// - Parameters:
///   - initialResult: The previous result returned by the `nextPartialResult` closure.
///   - nextPartialResult: An error-throwing closure that takes as its arguments the previous value returned by the closure and the next element emitted from the upstream publisher.
/// - Returns: A publisher that transforms elements by applying a closure that receives its previous return value and the next element from the upstream publisher.
tryScan lets you accumulate values or otherwise modify a type as changes flow through the pipeline while also supporting an error state. 
If either the combined and updates values, or the incoming value, matches logic you define within the closure, you can throw an error, terminating the pipeline.

(3)map
map is most commonly used to convert one data type into another along a pipeline.
The map operator does not allow for any additional failures to be thrown and does not transform the failure type. 
If you want to throw an error within your closure, use the tryMap operator.

map takes a single closure where you provide the logic for the map operation.
the URLSession.dataTaskPublisher provides a tuple of (data: Data, response: URLResponse)` as its output. 
You can use map to pass along the data, for example to use with decode.

.map { $0.data } 
the $0 indicates to grab the first parameter passed in, which is a tuple of data and response.
In some cases, the closure may not be able to infer what data type you are returning, 
so you may need to provide a definition to help the compiler. 
For example, if you have an object getting passed down that has a boolean property "isValid" on it, and you want the boolean for your pipeline, you might set that up like:

struct MyStruct {
    isValid: bool = true
}
//
Just(MyStruct())
.map { inValue -> Bool in 
  inValue.isValid 
}
inValue is named as the parameter coming in, and the return type is being explicitly specified to Bool
A single line is an implicit return, in this case it is pulling the isValid property off the struct and passing it down.

(4)tryMap
tryMap is similar to map, except that it also allows you to provide a closure that throws additional errors if your conversion logic is unsuccessful.
tryMap is useful when you have more complex business logic around your map and you want to indicate that the data passed in is an error, 
possibly handling that error later in the pipeline. If you are looking at tryMap to decode JSON, you may want to consider using the decode operator instead, which is set up for that common task.

enum MyFailure: Error {
    case notBigEnough
}

//
Just(5)
.tryMap {
  if inValue < 5 { 
      throw MyFailure.notBigEnough 
  }
  return inValue 
}
You can specify whatever logic is relevant to your use case within tryMap
and throw an error, although throwing an Error isn’t required.
If the error condition doesn’t occur, you do need to pass down data for any further subscribers.

(5)flatMap
Used with error recovery or async operations that might fail (for example Future), flatMap will replace any incoming values with another publisher.
Typically used in error handling scenarios, flatMap takes a closure that allows you to read the incoming data value, 
and provide a publisher that returns a value to the pipeline.

In error handling, this is most frequently used to take the incoming value and create a one-shot pipeline that does some potentially failing operation, 
and then handling the error condition with a catch operator.
arranged to show recovering from a decoding error and returning a placeholder value:
.flatMap { data in
    return Just(data)
    .decode(YourType.self, JSONDecoder())
    .catch {
        return Just(YourType.placeholder)
    }
}
flatMap expects to create a new pipeline within its closure for every input value that it receives. 
The expected result of this internal pipeline is a Publisher with its own output and failure type. 
The output type of the publisher resulting from the internal pipeline defines the output type of the flatMap operator. 
The error type of the internal publisher is often expected to be <Never>.

(6)setFailureType
setFailureType does not send a .failure completion, 
it just changes the Failure type associated with the pipeline. 
Use this publisher type when you need to match the error types for two otherwise mismatched publishers.
The upstream publisher must have a failure type of <Never>.

setFailureType is an operator for transforming the error type within a pipeline, often from <Never> to some error type you may want to produce. 
setFailureType does not induce an error, but changes the types of the pipeline.

This can be especially convenient if you need to match an operator or subscriber that expects a failure type other than <Never> when you are working with a test or single-value publisher such as Just or Sequence.

If you want to return a .failure completion of a specific type into a pipeline, use the Fail operator.

2.Filtering elements
(1)compactMap
compactMap is very similar to the map operator, with the exception that it expects the closure to return an optional value, and drops any nil values from published responses. 
This is the combine equivalent of the compactMap function which iterates through a Sequence and returns a sequence of any non-nil values.

It can also be used to process results from an upstream publisher that produces an optional Output type, 
and collapse those into an unwrapped type. The simplest version of this just returns the incoming value directly, which will filter out the nil values.

.compactMap {
    return $0
}
There is also a variation of this operator, tryCompactMap, 
which allows the provided closure to throw an Error and cancel the stream on invalid conditions.

If you want to convert an optional type into a concrete type, always replacing the nil with an explicit value, 
you should likely use the replaceNil operator.

(2)tryCompactMap
Calls a closure with each received element and publishes any returned optional that has a value, or optionally throw an Error cancelling the pipeline.
.tryCompactMap { someVal -> String? in 
    if (someVal == "boom") {
        throw TestExampleError.example
    }
    return someVal
}
If you specify the return type within the closure, it should be an optional value. 
The operator that invokes the closure is responsible for filtering the non-nil values it publishes.
If you want to convert an optional type into a concrete type, always replacing the nil with an explicit value, 
you should likely use the replaceNil operator.

(3)filter
Filter passes through all instances of the output type that match a provided closure, dropping any that don’t match.
Filter takes a single closure as a parameter that is provided the value from the previous publisher and returns a Bool value. 
If the return from the closure is true, then the operator republishes the value further down the chain. If the return from the closure is false, then the operator drops the value.

If you need a variation of this that will generate an error condition in the pipeline to be handled use the tryFilter operator, 
which allows the closure to throw an error in the evaluation.

(4)tryFilter
tryFilter passes through all instances of the output type that match a provided closure, dropping any that don’t match, and allows generating an error during the evaluation of that closure.

Like filter, tryFilter takes a single closure as a parameter that is provided the value from the previous publisher and returns a Bool value. 
If the return from the closure is true, then the operator republishes the value further down the chain. If the return from the closure is false, 
then the operator drops the value. You can additionally throw an error during the evaluation of tryFilter, 
which will then be propagated as the failure type down the pipeline.

(5)removeDuplicates
removeDuplicates remembers what was previously sent in the pipeline, and only passes forward values that don’t match the current value.
The default usage of removeDuplicates doesn’t require any parameters, and the operator will publish only elements that don’t match the previously sent element.
.removeDuplicates()

A second usage of removeDuplicates takes a single parameter by that accepts a closure that allows you to determine the logic of what will be removed. The parameter version does not have the constraint on the Output type being equatable, but requires you to provide the relevant logic. If the closure returns true, the removeDuplicates predicate will consider the values matched and not forward a the duplicate value.

.removeDuplicates(by: { first, second -> Bool in
    // your logic is required if the output type doesn't conform to equatable.
    first.id == second.id
})
A variation of removeDuplicates exists that allows the predicate closure to throw an error exists: tryRemoveDuplicates

(6)tryRemoveDuplicates
tryRemoveDuplicates is a variant of removeDuplicates that allows the predicate testing equality to throw an error, resulting in an Error completion type.

tryRemoveDuplicates is a variant of removeDuplicates taking a single parameter that can throw an error. 
The parameter is a closure that allows you to determine the logic of what will be removed. 
If the closure returns true, tryRemoveDuplicates will consider the values matched and not forward a the duplicate value. 
If the closure throws an error, a failure completion will be propagated down the chain, and no value is sent.

(7)replaceEmpty
Replaces an empty stream with the provided element. If the upstream publisher finishes without producing any elements, this publisher emits the provided element, then finishes normally.

replaceEmpty will only produce a result if it has not received any values before it receives a .finished completion. 
This operator will not trigger on an error passing through it, so if no value has been received with a .failure completion is triggered, 
it will simply not provide a value. The operator takes a single parameter, with where you specify the replacement value.

.replaceEmpty(with: "-replacement-")
This operator is useful specifically when you want a stream to always provide a value, even if an upstream publisher may not propagate one.

(8)replaceError
A publisher that replaces any errors with an output value that matches the upstream Output type.

Where mapError transforms an error, replaceError captures the error and returns a value that matches the Output type of the upstream publisher. 
If you don’t care about the specifics of the error itself, it can be a more convenient operator than using catch to handle an error condition.

.replaceError(with: "foo")
is more compact than

.catch { err in
    return Just("foo")
}
catch would be the preferable error handler if you wanted to return another publisher rather than a singular value.

(9)replaceNil
Replaces nil elements in the stream with the provided element.

Used when the output type is an optional type, 
the replaceNil operator replaces any nil instances provided by the upstream publisher with a value provided by the user. 
The operator takes a single parameter, with where you specify the replacement value. 
The type of the replacement should be a non-optional version of the type provided by the upstream publisher.

.replaceNil(with: "-replacement-")

This operator can also be viewed as a way of converting an optional type to an explicit type, 
where optional values have a pre-determined placeholder. Put another way, the replaceNil operator is a Combine specific variant of the swift coalescing operator that you might use when unwrapping an optional.

If you want to convert an optional type into a concrete type, simply ignoring or collapsing the nil values, 
you should likely use the compactMap (or tryCompactMap) operator.

3.Reducing elements
(1)collect
Collects all received elements, and emits a single array of the collection when the upstream publisher finishes.
There are two primary forms of collect, one you specify without any parameters, and one you provide a count parameter. 
Collect can also take a more complex form, with a defined strategy for how to buffer and send on items.

For the version without any parameters, for example:

.collect()
The operator will collect all elements from an upstream publisher, holding those in memory until the upstream publisher sends a completion. 
Upon receiving the .finished completion, the operator will publish an array of all the values collected. 
If the upstream publisher fails with an error, the collect operator forwards the error to the downstream receiver instead of sending its output.

This operator uses an unbounded amount of memory to store the received values.
Collect without any parameters will request an unlimited number of elements from its upstream publisher. 
It only sends the collected array to its downstream after a request whose demand is greater than 0 items.

The second variation of collect takes a single parameter (count), 
which influences how many values it buffers and when it sends results.
.collect(3)
This version of collect will buffer up to the specified count number of elements. 
When it has received the count specified, it emits a single array of the collection.

If the upstream publisher finishes before filling the buffer, 
this publisher sends an array of all the items it has received upon receiving a finished completion. This may be fewer than count elements.

If the upstream publisher fails with an error, this publisher forwards the error to the downstream receiver instead of sending its output.

The more complex form of collect operates on a provided strategy of how to collect values and when to emit.
As of iOS 13.3 there are two strategies published in Publishers.TimeGroupingStrategy:
byTime
byTimeOrCount

byTime allows you to specify a scheduler on which to operate, and a time interval stride over which to run. 
It collects all values received within that stride and publishes any values it has received from its upstream publisher during that interval. Like the parameterless version of collect, this will consume an unbounded amount of memory during that stride interval to collect values.

let q = DispatchQueue(label: self.debugDescription)

let cancellable = publisher
    .collect(.byTime(q, 1.0))

byTime operates very similarly to throttle with its defined Scheduler and Stride, but where throttle collapses the values over a sequence of time, collect(.byTime(q, 1.0)) will buffer and capture those values. 
When the time stride interval is exceeded, the collected set will be sent to the operator’s subscriber.

byTimeOrCount also takes a scheduler and a time interval stride, 
and in addition allows you to specify an upper bound on the count of items received before the operator sends the collected values to its subscriber. The ability to provide a count allows you to have some confidence about the maximum amount of memory that the operator will consume while buffering values.

If either of the count or time interval provided are elapsed, the collect operator will forward the currently collected set to its subscribers. 
If a .finished completion is received, the currently collected set will be immediately sent to it’s subscribers. If a .failure completion is received, any currently buffered values are dropped and the failure completion is forwarded to collect’s subscribers.

let q = DispatchQueue(label: self.debugDescription)

let cancellable = publisher
    .collect(.byTimeOrCount(q, 1.0, 5))

(2)ignoreOutput
A publisher that ignores all upstream elements, but passes along a completion state (finish or failed).

If you only want to know if a stream has finished (or failed), then ignoreOutput may be what you want.

.ignoreOutput()
.sink(receiveCompletion: { completion in
    print(".sink() received the completion", String(describing: completion))
    switch completion {
    case .finished: 
        finishReceived = true
        break
    case .failure(let anError): 
        print("received error: ", anError)
        failureReceived = true
        break
    }
}, receiveValue: { _ in 
    print(".sink() data received")
})
No data will ever be presented to a downstream subscriber of ignoreOutput, so the receiveValue closure will never be invoked.
When the stream completes, it will invoke receiveCompletion. You can switch on the case from that completion to respond to the success.
Or you can do further processing based on receiving a failure.

(3)reduce
A publisher that applies a closure to all received elements and produces an accumulated value when the upstream publisher finishes.

Very similar in function to the scan operator, reduce collects values produced within a stream. 
The big difference between scan and reduce is that reduce does not trigger any values until the upstream publisher completes successfully.

When you create a reduce operator, you provide an initial value (of the type determined by the upstream publisher) and a closure that takes two parameters - the result returned from the previous invocation of the closure and a new value from the upstream publisher.

Like scan, you don’t need to maintain the type of the upstream publisher, but can convert the type in your closure, returning whatever is appropriate to your needs.

An example of reduce that collects strings and appends them together:

.reduce("", { prevVal, newValueFromPublisher -> String in
    return prevVal+newValueFromPublisher
})
The reduce operator is excellent at converting a stream that provides many values over time into one that provides a single value upon completion.

(4)tryReduce
A publisher that applies a closure to all received elements and produces an accumulated value when the upstream publisher finishes, while also allowing the closure to throw an exception, terminating the pipeline.

tryReduce is a variation of the reduce operator that allows for the closure to throw an error. If the exception path is taken, the tryReduce operator will not publish any output values to downstream subscribers. 
Like reduce, the tryReduce will only publish a single downstream result upon a .finished completion from the upstream publisher.

4.Mathematic operations on elements
(1)max
Publishes the max value of all values received upon completion of the upstream publisher.
The output type of the upstream publisher must conform to Comparable

max can be set up with either no parameters, or taking a closure. If defined as an operator with no parameters, 
the Output type of the upstream publisher must conform to Comparable.

.max()
If what you are publishing doesn’t conform to Comparable, then you may specify a closure to provide the ordering for the operator.

.max { (struct1, struct2) -> Bool in
    return struct1.property1 < struct2.property1
    // returning boolean true to order struct2 greater than struct1
    // the underlying method parameter for this closure hints to it:
    // `areInIncreasingOrder`
}

The parameter name of the closure hints to how it should be provided, being named areInIncreasingOrder. 
The closure will take two values of the output type of the upstream publisher, and within it you should provide a boolean result indicating if they are in increasing order.

The operator will not provide any results under the upstream published has sent a .finished completion. 
If the upstream publisher sends a failure completion, then no values will be published and the .failure completion will be forwarded.

(2)tryMax
Publishes the max value of all values received upon completion of the upstream publisher.
A variation of the max operator that takes a closure to define ordering, and it also allowed to throw an error.

(3)min
Publishes the minimum value of all values received upon completion of the upstream publisher.

min can be set up with either no parameters, or taking a closure. If defined as an operator with no parameters, the Output type of the upstream publisher must conform to Comparable.

.min()
If what you are publishing doesn’t conform to Comparable, then you may specify a closure to provide the ordering for the operator.

.min { (struct1, struct2) -> Bool in
    return struct1.property1 < struct2.property1
    // returning boolean true to order struct2 greater than struct1
    // the underlying method parameter for this closure hints to it:
    // `areInIncreasingOrder`
}

The parameter name of the closure hints to how it should be provided, being named areInIncreasingOrder. The closure will take two values of the output type of the upstream publisher, and within it you should provide a boolean result indicating if they are in increasing order.

The operator will not provide any results under the upstream published has sent a .finished completion. 
If the upstream publisher sends a .failure completion, then no values will be published and the failure completion will be forwarded.

(4)tryMin
Publishes the minimum value of all values received upon completion of the upstream publisher.
A variation of the min operator that takes a closure to define ordering, and it also allowed to throw an error.

(5)count
count publishes the number of items received from the upstream publisher
The operator will not provide any results under the upstream published has sent a .finished completion. 
If the upstream publisher sends a .failure completion, then no values will be published and the failure completion will be forwarded.

5.Applying matching criteria to elements
(1)allSatisfy
A publisher that publishes a single Boolean value that indicates whether all received elements pass a provided predicate.
similar to the containsWhere operator, this operator is provided with a closure. 
The type of the incoming value to this closure must match the Output type of the upstream publisher, and the closure must return a Boolean.

The operator will compare any incoming values, only responding when the upstream publisher sends a .finished completion. 
At that point, the allSatisfies operator will return a single boolean value indicating if all the values received matched (or not) based on processing through the provided closure.

If the operator receives a .failure completion from the upstream publisher, or throws an error itself, 
then no data values will be published to subscribers. In those cases, the operator will only return (or forward) the .failure completion.

(2)tryAllSatisfy
A publisher that publishes a single Boolean value that indicates whether all received elements pass a given throwing predicate.

similar to the tryContainsWhere operator, you provide this operator with a closure which may also throw an error. The type of the incoming value to this closure must match the Output type of the upstream publisher, and the closure must return a Boolean.

The operator will compare any incoming values, only responding when the upstream publisher sends a .finished completion. At that point, the tryAllSatisfies operator will return a single boolean value indicating if all the values received matched (or not) based on processing through the provided closure.

If the operator receives a .failure completion from the upstream publisher, or throws an error itself, then no data values will be published to subscribers. 
In those cases, the operator will only return (or forward) the .failure completion.

(3)contains
A publisher that emits a Boolean value when a specified element is received from its upstream publisher.
The simplest form of contains accepts a single parameter. The type of this parameter must match the Output type of the upstream publisher.

The operator will compare any incoming values, only responding when the incoming value is equatable to the parameter provided. When it does find a match, the operator returns a single boolean value (true) and then terminates the stream. Any further values published from the upstream provider are then ignored.

If the upstream published sends a .finished completion before any values do match, 
the operator will publish a single boolean (false) and then terminate the stream.

(4)containsWhere
A publisher that emits a Boolean value upon receiving an element that satisfies the predicate closure.

A more flexible version of the contains operator. Instead of taking a single parameter value to match, you provide a closure which takes in a single value (of the type provided by the upstream publisher) and returns a boolean.

Like contains, it will compare multiple incoming values, only responding when the incoming value is equatable to the parameter provided. When it does find a match, the operator returns a single boolean value and terminates the stream. Any further values published from the upstream provider are ignored.

If the upstream published sends a .finished completion before any values do match, the operator will publish a single boolean (false) and terminates the stream.

If you want a variant of this functionality that checks multiple incoming values to determine if all of them match, consider using the allSatisfy operator.

(5)tryContainsWhere
A publisher that emits a Boolean value upon receiving an element that satisfies the throwing predicate closure.

A variation of the tryContainsWhere operator which allows the closure to throw an error. You provide a closure which takes in a single value (of the type provided by the upstream publisher) and returns a boolean. This closure may also throw an error. If the closure throws an error, then the operator will return no values, only the error to any subscribers, terminating the pipeline.

Like contains, it will compare multiple incoming values, only responding when the incoming value is equatable to the parameter provided. When it does find a match, the operator returns a single boolean value and terminates the stream. Any further values published from the upstream provider are ignored.

If the upstream published sends a .finished completion before any values do match, the operator will publish a single boolean (false) and terminates the stream.

If the operator receives a .failure completion from the upstream publisher, or throws an error itself, 
no data values will be published to subscribers. In those cases, the operator will only return (or forward) the .failure completion.

6.Applying sequence operations to elements
(1)first
Publishes the first element of a stream and then finishes.

The first operator, when used without any parameters, will pass through the first value it receives, after which it sends a .finish completion message to any subscribers. If no values are received before the first operator receives a .finish completion from upstream publishers, the stream is terminated and no values are published.

.first()
If you want a set number of values from the front of the stream you can also use prefixUntilOutput or the variants: prefixWhile and tryPrefixWhile.

If you want a set number of values from the middle the stream by count, you may want to use output, 
which allows you to select either a single value, or a range value from the sequence of values received by this operator.

(2)firstWhere
A publisher that only publishes the first element of a stream to satisfy a predicate closure.

The firstWhere operator is similar to first, but instead lets you specify if the value should be the first value published by evaluating a closure. The provided closure should accept a value of the type defined by the upstream publisher, returning a bool.

.first { (incomingobject) -> Bool in
    return incomingobject.count > 3 
}
The first value received that satisfies this closure - that is, has count greater than 3 - is published.
If you want to support an error condition that will terminate the pipeline within this closure, use tryFirstWhere.

(3)tryFirstWhere
A publisher that only publishes the first element of a stream to satisfy a throwing predicate closure.
The tryFirstWhere operator is a variant of firstWhere that accepts a closure that can throw an error. The closure provided should accept a value of the type defined by the upstream publisher, returning a bool.

.tryFirst { (incomingobject) -> Bool in
    if (incomingobject == "boom") {
        throw TestExampleError.invalidValue
    }
    return incomingobject.count > 3
}

(4)last
A publisher that only publishes the last element of a stream, once the stream finishes.

The last operator waits until the upstream publisher sends a finished completion, then publishes the last value it received. If no values were received prior to receiving the finished completion, no values are published to subscribers.

.last()

(5)lastWhere
A publisher that only publishes the last element of a stream that satisfies a predicate closure, once the stream finishes.
The lastWhere operator takes a single closure, accepting a value matching the output type of the upstream publisher, and returning a boolean. The operator publishes a value when the upstream published completes with a .finished completion. The value published will be the last one to satisfy the provide closure. If no values satisfied the closure, then no values are published and the pipeline is terminated normally with a .finished completion.

.last { (incomingobject) -> Bool in
    return incomingobject.count > 3 
}
Publishes the last value that has a length greater than 3.

(6)tryLastWhere
A publisher that only publishes the last element of a stream that satisfies a error-throwing predicate closure, once the stream finishes.

The tryLastWhere operator is a variant of the lastWhere operator that accepts a closure that may also throw an error.

.tryLast { (incomingobject) -> Bool in
    if (incomingobject == "boom") { 
        throw TestExampleError.invalidValue
    }
    return incomingobject.count > 3 
}
Publishes the last value that has a length greater than 3.
Logic that triggers an error, which will terminate the pipeline.

(7)dropUntilOutput
The dropUntilOutput operator uses another publisher as a trigger, stopping output through a pipeline until a value is received. 
Values received from the upstream publisher are ignored (and dropped) until the trigger is activated.

Any value propagated through the trigger publisher will cause the switch to activate, and allow future values through the pipeline.

Errors are still propagated from the upstream publisher, terminating the pipeline with a failure completion. An error (failure completion) on either the upstream publisher or the trigger publisher will be propagated to any subscribers and terminate the pipeline.

.drop(untilOutputFrom: triggerPublisher)
If you want to use this kind of mechanism, but with a closure determining values from the upstream publisher, use the dropWhile operator.

(8)dropWhile
A publisher that omits elements from an upstream publisher until a given closure returns false.

The dropWhile operator takes a single closure, accepting an input value of the output type defined by the upstream publisher, returning a bool. This closure is used to determine a trigger condition, after which values are allowed to propagate.

This is not the same as the filter operator, acting on each value. Instead it uses a trigger that activates once, and propagates all values after it is activated until the upstream publisher finishes.

.drop { upstreamValue -> Bool in
    return upstreamValue.count > 3
}
If you want to use this mechanism, but with a publisher as the trigger instead of a closure, use the dropUntilOutput operator.

(9)tryDropWhile
A publisher that omits elements from an upstream publisher until a given error-throwing closure returns false.
This is a variant of the dropWhile operator that accepts a closure that can also throw an error.

.tryDrop { upstreamValue -> Bool in
    return upstreamValue.count > 3
}

(10)prepend
A publisher that emits all of one publisher’s elements before those from another publisher.
The prepend operator will act as a merging of two pipelines. Also known as Publishers.Concatenate, it accepts all values from one publisher, publishing them to subscribers. Once the first publisher is complete, the second publisher is used to provide values until it is complete.

The most general form of this can be invoked directly as:

Publishers.Concatenate(prefix: firstPublisher, suffix: secondPublisher)
This is equivalent to the form directly in a pipeline:
secondPublisher
.prepend(firstPublisher)

The prepend operator is often used with single or sequence values that have a failure type of <Never>. If the publishers do accept a failure type, then all values will be published from the prefix publisher even if the suffix publisher receives a .failure completion before it is complete. Once the prefix publisher completes, the error will be propagated.

The prepend operator also has convenience operators to send a sequence. For example:

secondPublisher
.prepend(["one", "two"]) 
The sequence values will be published immediately on a subscriber requesting demand. 
Further demand will be propagated upward to secondPublisher. Values produced from secondPublisher will then be published until it completes.

Another convenience operator exists to send a single value:

secondPublisher
.prepend("one") 
The value will be published immediately on a subscriber requesting demand. Further demand will be propagated upward to secondPublisher. Values produced from secondPublisher will then be published until it completes.

(11)drop
A publisher that omits a specified number of elements before republishing later elements.

The simplest form of the drop operator drops a single value and then allows all further values to propagate through the pipeline.

.dropFirst()
A variant of this operator allows a count of values to be specified:

.dropFirst(3) 
Drops the first three values received from the upstream publisher before propagating any further values published to downstream subscribers.

(12)prefixUntilOutput
Republishes elements until another publisher emits an element. After the second publisher publishes an element, the publisher returned by this method finishes.
The prefixUntilOutput will propagate values from an upstream publisher until a second publisher is used as a trigger. 
Once the trigger is activated by receiving a value, the operator will terminate the stream.

.prefix(untilOutputFrom: secondPublisher)

(13)prefixWhile
A publisher that republishes elements while a predicate closure indicates publishing should continue.
The prefixWhile operator takes a single closure, with an input matching the output type defined by the upstream publisher, returning a boolean. This closure is evaluated on the data from the upstream publisher. While it returns true the values are propagated to the subscriber. Once the value returns false, the operator terminates the stream with a .finished completion.

.prefix { upstreamValue -> Bool in
    return upstreamValue.count > 3
}

(14)tryPrefixWhile
A publisher that republishes elements while an error-throwing predicate closure indicates publishing should continue.

The tryPrefixWhile operator is a variant of the prefixWhile operator that accepts a closure and may also throw an error.

.prefix { upstreamValue -> Bool in
    return upstreamValue.count > 3
}

(15)output
A publisher that publishes elements specified by a range in the sequence of published elements.
The output operator takes a single parameter, either an integer or a swift range. 
This value is used to select a specific value, or sequence of values, from an upstream publisher to send to subscribers.

output is choosing values from the middle of the stream. If the upstream publisher completes before the values is received, the .finished completion will be propagated to the subscriber.

.output(at: 3) 
The selection is 0 indexed (meaning the count starts at 0). This will select the fourth item published from the upstream publisher to propagate.

The alternate form takes a swift range descriptor:

.output(at: 2...3) 
The selection is 0 indexed (the count starts at 0). This will select the third and fourth item published from the upstream publisher to propagate.

7.Mixing elements from multiple publishers
(1)combineLatest
CombineLatest merges two pipelines into a single output, converting the output type to a tuple of values from the upstream pipelines, 
and providing an update when any of the upstream publishers provide a new value.

CombineLatest, and its variants of combineLatest3 and combineLatest4, take multiple upstream publishers and create a single output stream, merging the streams together. 
CombineLatest merges two upstream publishers. ComineLatest3 merges three upstream publishers and combineLatest4 merges four upstream publishers.

The output type of the operator is a tuple of the output types of each of the publishers. 
For example, if combineLatest was used to merge a publisher with the output type of <String> and another with the output type of <Int>, 
the resulting output type would be a tuple of (<String, Int>).

CombineLatest is most often used with continual publishers, and remembering the last output value provided from each publisher. 
In turn, when any of the upstream publishers sends an updated value, the operator makes a new combined tuple of all previous "current" values, 
adds in the new value in the correct place, and sends that new combined value down the pipeline.

The CombineLatest operator requires the failure types of all three upstream publishers to be identical. 
For example, you can not have one publisher that has a failure type of Error and another (or more) that have a failure type of Never. 
If the combineLatest operator does receive a failure from any of the upstream publishers, 
then the operator (and the rest of the pipeline) is cancelled after propagating that failure.

If any of the upstream publishers finish normally (that is, they send a .finished completion), 
the combineLatest operator will continue operating and processing any messages from any of the other publishers that has additional data to send.

Other operators that merge multiple upstream pipelines include merge and zip. 
If your upstream publishers have the same type and you want a stream of single values as opposed to tuples, use the merge operator. 
If you want to wait on values from all upstream provides before providing an updated value, use the zip operator.

(2)merge
Merge takes two upstream publishers and mixes the elements published into a single pipeline as they are received.

Merge subscribers to two upstream publishers, and as they provide data for the subscriber it interleaves them into a single pipeline. 
Merge3 accepts three upstream publishers, merge4 accepts four upstream publishers, and so forth - through merge8 accepting eight upstream publishers.

In all cases, the upstreams publishers are required to have the same output type, as well as the same failure type.

As with combineLatest, if an error is propagated down any of the upstream publishers, 
the cancellation from the subscriber will terminate this operator and will propagate cancel to all upstream publishers as well.

If an upstream publisher completes with a normal finish, the merge operator continues interleaving and forwarding from any values other upstream publishers.

In the unlikely event that two values are provided at the same time from upstream publishers, the merge operator will interleave the values in the order upstream publishers are specified when the operator is initialized.

If you want to mix different upstream publisher types into a single stream, then you likely want to use either combineLatest or zip, depending on how you want the timing of values to be handled.

If your upstream publishers have different types, but you want interleaved values to be propagated as they are available, use combineLatest. 
If you want to wait on values from all upstream provides before providing an updated value, then use the zip operator.

(3)MergeMany
The MergeMany publisher takes multiple upstream publishers and mixes the published elements into a single pipeline as they are received. The upstream publisher can be of any type.
When you went to mix together data from multiple sources as the data arrives, MergeMany provides a common solution for a wide number of publishers. It is an evolution of the Merge3, Merge4, etc sequence of publishers that came about as the Swift language enabled variadic parameters.

Like merge, it publishes values until all publishers send a finished completion, 
or cancels entirely if any of the publishers sends a cancellation completion

(4)zip
Zip takes two upstream publishers and mixes the elements published into a single pipeline, 
waiting until values are paired up from each upstream publisher before forwarding the pair as a tuple.

Zip works very similarly to combineLatest, connecting two upstream publishers and providing the output of those publishers as a single pipeline with a tuple output type composed of the types of the upstream publishers. Zip3 supports connecting three upstream publishers, and zip4 supports connecting four upstream publishers.

The notable difference from combineLatest is that zip waits for values to arrive from the upstream publishers, and will only publish a single new tuple when new values have been provided from all upstream publishers.

One example of using this is to wait until all streams have provided a single value to provide a synchronization point. For example, if you have two independent network requests and require them to both be complete before continuing to process the results, you can use zip to wait until both publishers are complete before forwarding the combined tuples.

Other operators that merge multiple upstream pipelines include combineLatest and merge. If your upstream publishers have different types, but you want interleaved values to be propagated as they are available, use combineLatest. 
If your upstream publishers have the same type and you want a stream of single values, as opposed to tuples, 
then you probably want to use the merge operator.

8.Error Handling
(1)catch
The operator catch handles errors (completion messages of type .failure) from an upstream publisher by replacing the failed publisher with another publisher. 
The catch operator also transforms the Failure type to <Never>.

Once catch receives a .failure completion, it won’t send any further incoming values from the original upstream publisher. 
You can also view catch as a switch that only toggles in one direction: to using a new publisher that you define, 
but only when the original publisher to which it is subscribed sends an error.

enum TestFailureCondition: Error {
    case invalidServerResponse
}

let simplePublisher = PassthroughSubject<String, Error>()

let _ = simplePublisher
    .catch { err in
        // must return a Publisher
        return Just("replacement value")
    }
    .sink(receiveCompletion: { fini in
        print(".sink() received the completion:", String(describing: fini))
    }, receiveValue: { stringValue in
        print(".sink() received \(stringValue)")
    })

simplePublisher.send("oneValue")
simplePublisher.send("twoValue")
simplePublisher.send(completion: Subscribers.Completion.failure(TestFailureCondition.invalidServerResponse))
simplePublisher.send("redValue")
simplePublisher.send("blueValue")
simplePublisher.send(completion: .finished)

in this example, we are using a PassthroughSubject so that we can control when and what gets sent from the publisher. In the above code, we are sending two good values, then a failure, then attempting to send two more good values. The values you would see printed from our .sink() closures are:

.sink() received oneValue
.sink() received twoValue
.sink() received replacement value
.sink() received the completion: finished

When the failure was sent through the pipeline, catch intercepts it and returns a replacement value. The replacement publisher it used (Just) sends a single value and then a completion. If we want the pipeline to remain active, 
we need to change how we handle the errors. See the pattern Using flatMap with catch to handle errors for an example of how that can be achieved.

(2)tryCatch
A variant of the catch operator that also allows an <Error> failure type, and doesn’t convert the failure type to <Never>.
tryCatch is a variant of catch that has a failure type of <Error> rather than catch’s failure type of <Never>. 
This allows it to be used where you want to immediately react to an error by creating another publisher that may also produce a failure type.

(3)assertNoFailure
Raises a fatal error when its upstream publisher fails, and otherwise republishes all received input and converts failure type to <Never>.
If you need to verify that no error has occurred (treating the error output as an invariant), this is the operator to use. Like its namesakes, it will cause the program to terminate if the assert is violated.

Adding it into the pipeline requires no additional parameters, but you can include a string:

.assertNoFailure()
// OR
.assertNoFailure("What could possibly go wrong?")

I’m not entirely clear on where that string would appear if you did include it.

When trying out this code in unit tests, the tests invariably drop into a debugger at the assertion point when a .failure is processed through the pipeline.

If you want to convert an failure type output of <Error> to <Never>, you probably want to look at the catch operator.

Apple asserts this function should be primarily used for testing and verifying internal sanity checks that are active during testing.

(4)retry
The retry operator is used to repeat requests to a previous publisher in the event of an error.
When you specify this operator in a pipeline and it receives a subscription, it first tries to request a subscription from its upstream publisher. If the response to that subscription fails, then it will retry the subscription to the same publisher.

The retry operator accepts a single parameter that specifies a number of retries to attempt.

Using retry with a high count can result in your pipeline not resolving any data or completions for quite a while, depending on how long each attempt takes. 
You may also want to consider also using the timeout operator to force a completion from the pipeline.
If the number of retries is specified and all requests fail, then the .failure completion is passed down to the subscriber of this operator.

In practice, this is mostly commonly desired when attempting to request network resources with an unstable connection. 
If you use a retry operator, you should add a specific number of retries so that the subscription doesn’t effectively get into an infinite loop.
struct IPInfo: Codable {
    // matching the data structure returned from ip.jsontest.com
    var ip: String
}
let myURL = URL(string: "http://ip.jsontest.com")
// NOTE(heckj): you'll need to enable insecure downloads
// in your  Info.plist for this example
// because the URL scheme is 'http'

let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: myURL!)
    // the dataTaskPublisher output combination is
    // (data: Data, response: URLResponse)
    .retry(3)
    // if the URLSession returns a .failure completion,
    // retry at most 3 times to get a successful response
    .map({ (inputTuple) -> Data in
        return inputTuple.data
    })
    .decode(type: IPInfo.self, decoder: JSONDecoder())
    .catch { err in
        return Publishers.Just(IPInfo(ip: "8.8.8.8"))
    }
    .eraseToAnyPublisher()

(5)mapError
Converts any failure from the upstream publisher into a new error.
mapError is an operator that allows you to transform the failure type by providing a closure where you convert errors from upstream publishers into a new type. 
mapError is similar to replaceError, but replaceError ignores any upstream errors and returns a single kind of error, where this operator lets you construct using the error provided by the upstream publisher.

.mapError { error -> ChangingErrorTests.APIError in
    // if it's our kind of error already, we can return it directly
    if let error = error as? APIError {
        return error
    }
    // if it is a URLError, we can convert it into our more general error kind
    if let urlerror = error as? URLError {
        return APIError.networkError(from: urlerror)
    }
    // if all else fails, return the unknown error condition
    return APIError.unknown
}

9.Adapting publisher types
(1)switchToLatest
A publisher that flattens any nested publishers, using the most recent provided publisher.

The following snippet is part of the larger example Declarative UI updates from user input:

.map { username -> AnyPublisher<[GithubAPIUser], Never> in 
    return GithubAPI.retrieveGithubUser(username: username) 
}
// ^^ type returned in the pipeline is a Publisher, so we use
// switchToLatest to flatten the values out of that
// pipeline to return down the chain, rather than returning a
// publisher down the pipeline.
.switchToLatest() 
In this example, an API instance (GithubAPI) has a function that returns a publisher.
map takes an earlier String output type, returning a publisher instance.
We want to use the value from that publisher, not the publisher itself, which is exactly what switchToLatest provides.

10.Controlling timing
(1)debounce
debounce collapses multiple values within a specified time window into a single value

The operator takes a minimum of two parameters, an amount of time over which to debounce the signal and a scheduler on which to apply the operations. The operator will collapse any values received within the timeframe provided to a single, last value received from the upstream publisher within the time window. If any value is received within the specified time window, it will collapse it. It will not return a result until the entire time window has elapsed with no additional values appearing.

This operator is frequently used with removeDuplicates when the publishing source is bound to UI interactions, 
primarily to prevent an "edit and revert" style of interaction from triggering unnecessary work.

If you wish to control the value returned within the time window, or if you want to simply control the volume of events by time, 
you may prefer to use throttle, which allows you to choose the first or last value provided.

(2)delay
Delays delivery of all output to the downstream receiver by a specified amount of time on a particular scheduler.
The delay operator passes through the data after a delay defined to the operator. The delay operator also requires a scheduler, where the delay is explicitly invoked.

.delay(for: 2.0, scheduler: headingBackgroundQueue)

(3)measureInterval
measureInterval measures and emits the time interval between events received from an upstream publisher, in turn publishing a value of SchedulerTimeType.Stride (which includes a magnitude and interval since the last value). 
The specific upstream value is ignored beyond the detail of the time at which it was received.
The operator takes a single parameter, the scheduler to be used. The output type is the type SchedulerTimeType.Stride for the scheduler you designate.
The operator takes a single parameter, the scheduler to be used. The output type is the type SchedulerTimeType.Stride for the scheduler you designate.

For example:

.measureInterval(using: q) // Output type is DispatchQueue.SchedulerTimeType.Stride
The magnitude (an Int) the stride is the number of nanoseconds since the last value, which is generally in nanoseconds. 
You can also use the interval (a DispatchTimeInterval) which carries with it the specific units of the interval.

These values are not guaranteed on a high resolution timer, so use the resulting values judiciously.

(4)throttle
Throttle constrains the stream to publishing zero or one value within a specified time window, independent of the number of elements provided by the publisher.

Throttle is akin to the debounce operator in that it collapses values. The primary difference is that debounce will wait for no further values, where throttle will last for a specific time window and then publish a result. The operator will collapse any values received within the timeframe provided to a single value received from the upstream publisher within the time window. The value chosen within the time window is influenced by the parameter latest.

If values are received very close to the edges of the time window, the results can be a little unexpected.

The operator takes a minimum of three parameters, for: an amount of time over which to collapse the values received, scheduler: a scheduler on which to apply the operations, and latest: a boolean indicating if the first value or last value should be chosen.

This operator is often used with removeDuplicates when the publishing source is bound to UI interactions, 
primarily to prevent an "edit and revert" style of interaction from triggering unnecessary work.

.throttle(for: 0.5, scheduler: RunLoop.main, latest: false)

(5)timeout
Terminates publishing if the upstream publisher exceeds the specified time interval without producing an element.

Timeout will force a resolution to a pipeline after a given amount of time, but does not guarantee either data or errors, only a completion. If a timeout does trigger and force a completion, it will not generate an failure completion with an error.

Timeout is specified with two parameters: time and scheduler.

If you are using a specific background thread (for example, with the subscribe operator), then timeout should likely be using the same scheduler.

The time period specified will take a literal integer, but otherwise needs to conform to the protocol SchedulerTimeIntervalConvertible. If you want to set a number from a Float or Int, you need to create the relevant structure, as Int or Float does not conform to SchedulerTimeIntervalConvertible. For example, while using a DispatchQueue, you could use DispatchQueue.SchedulerTimeType.Stride.

let remoteDataPublisher = urlSession.dataTaskPublisher(for: self.mockURL!)
    .delay(for: 2, scheduler: backgroundQueue)
    .retry(5) // 5 retries, 2 seconds each ~ 10 seconds for this to fall through
    .timeout(5, scheduler: backgroundQueue) // max time of 5 seconds before failing
    .tryMap { data, response -> Data in
        guard let httpResponse = response as? HTTPURLResponse,
            httpResponse.statusCode == 200 else {
                throw TestFailureCondition.invalidServerResponse
        }
        return data
    }
    .decode(type: PostmanEchoTimeStampCheckResponse.self, decoder: JSONDecoder())
    .subscribe(on: backgroundQueue)
    .eraseToAnyPublisher()

11.Encoding and decoding
(1)encode
Encode converts the output from upstream Encodable object using a specified TopLevelEncoder. For example, use JSONEncoder or PropertyListEncoder..

The encode operator takes a single parameter: encoder This is an instance of an object conforming to TopLevelEncoder. Frequently it is an instance of JSONEncoder or PropertyListEncoder.

fileprivate struct PostmanEchoTimeStampCheckResponse: Codable {
    let valid: Bool
}

let dataProvider = PassthroughSubject<PostmanEchoTimeStampCheckResponse, Never>()
    .encode(encoder: JSONEncoder())
    .sink { data in
        print(".sink() data received \(data)")
        let stringRepresentation = String(data: data, encoding: .utf8)
        print(stringRepresentation)
    })
Like the decode operator, the encode process can also fail and throw an error. Therefore it also returns a failure type of <Error>.

A common issue is if you try to pass an optional type to the encode operator. This results in a error from the compiler. 
In these cases, either you can change the type from optional to a concrete type with the tryMap operator, or use an operator such as replaceNil to provide concrete values.

(2)decode
A commonly desired operation is to decode some provided data, so Combine provides the decode operator suited to that task.
The decode operator takes two parameters:

type which is typically a reference to a struct you defined

decoder an instance of an object conforming to TopLevelDecoder, frequently an instance of JSONDecoder or PropertyListDecoder.

Since decoding can fail, the operator returns a failure type of Error. The data type returned by the operator is defined by the type you provided to decode.

let testUrlString = "https://postman-echo.com/time/valid?timestamp=2016-10-10"
// checks the validity of a timestamp - this one should return {"valid":true}
// matching the data structure returned from https://postman-echo.com/time/valid
fileprivate struct PostmanEchoTimeStampCheckResponse: Decodable, Hashable {
    let valid: Bool
}

let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: URL(string: testUrlString)!)
    // the dataTaskPublisher output combination is (data: Data, response: URLResponse)
    .map { $0.data }
    .decode(type: PostmanEchoTimeStampCheckResponse.self, decoder: JSONDecoder())

12.Working with multiple subscribers
(1)share
https://stackoverflow.com/questions/59593139/understanding-share-in-combine

A publisher implemented as a class, which otherwise behaves like its upstream publisher.

A publisher is often a struct within swift, following value semantics. share is used when you want to create a publisher as a class to take advantage of reference semantics. This is most frequently employed when creating a publisher that does expensive work so that you can isolate the expensive work and use it from multiple subscribers.

Very often, you will see share used to provide multicast - to create a shared instance of a publisher and have multiple subscribers connected to that single publisher.

let expensivePublisher = somepublisher
    .share()

(2)multicast
Use a multicast publisher when you have multiple downstream subscribers, but you want upstream publishers to only process one receive(_:) call per event.

A multicast publisher provides a means of consolidating the requests of data from a publisher into a single request. A multicast publisher does not change data or types within a pipeline. It does provide a bastion for subscriptions so that when demand is created from one subscriber, multiple subscribers can benefit from it. It effectively allows one value to go to multiple subscribers.

Multicast is often created after using share on a publisher to create a reference object as a publisher. This allows you to consolidate expensive queries, such as external network requests, and provide the data to multiple consumers.

When creating using multicast, you either provide a Subjects (with the parameter `subject) or create a Subjects inline in a closure.
let pipelineFork = PassthroughSubject<Bool, Error>()
let multicastPublisher = somepublisher.multicast(subject: pipelineFork)
let multicastPublisher = somepublisher
    .multicast {
        PassthroughSubject<Bool, Error>()
    }
A multicast publisher does not cache or maintain the history of a value. 
If a multicast publisher is already making a request and another subscriber is added after the data has been returned to previously connected subscribers, 
new subscribers may only get a completion. For this reason, multicast returns a connectable publisher.

When making a multicast publisher, make sure you explicitly connect the publishers or you will see no data flow through your pipeline. 
Do this either using connect() on your publisher after all subscribers have been connected, 
or by using autoconnect() to enable the connection on the first subscription.

13.Debugging
(1)breakpoint
The breakpoint operator raises a debugger signal when a provided closure identifies the need to stop the process in the debugger.
When any of the provided closures returns true, this publisher raises a SIGTRAP signal to stop the process in the debugger. Otherwise, this publisher passes through values and completions.

The operator takes 3 optional closures as parameters, used to trigger when to raise a SIGTRAP signal:

receiveSubscription

receiveOutput

receiveCompletion

.breakpoint(receiveSubscription: { subscription in
    return false // return true to throw SIGTRAP and invoke the debugger
}, receiveOutput: { value in
    return false // return true to throw SIGTRAP and invoke the debugger
}, receiveCompletion: { completion in
    return false // return true to throw SIGTRAP and invoke the debugger
})

(2)breakpointOnError
Raises a debugger signal upon receiving a failure.
breakpointOnError is a convenience method used to raise a SIGTRAP signal when an error is propagated through it within a pipeline.

.breakpointOnError()

(3)handleEvents
handleEvents is an all purpose operator that allow you to specify closures be invoked when publisher events occur.
handleEvents does not require any parameters, allowing you to specify a response to specific publisher events. Optional closures can be provided for the following events:

receiveSubscription

receiveOutput

receiveCompletion

receiveCancel

receiveRequest

All of the closures are expected to return Void, which makes handleEvents useful for intentionally creating side effects based on what is happening in the pipeline.

You could, for example, use handleEvents to update an activityIndicator UI element, triggering it on with the receipt of the subscription, and terminating with the receipt of either cancel or completion.

If you only want to view the information flowing through the pipeline, you might consider using the print operator instead.

.handleEvents(receiveSubscription: { _ in
    DispatchQueue.main.async {
        self.activityIndicator.startAnimating()
    }
}, receiveCompletion: { _ in
    DispatchQueue.main.async {
        self.activityIndicator.stopAnimating()
    }
}, receiveCancel: {
    DispatchQueue.main.async {
        self.activityIndicator.stopAnimating()
    }
})

(4)print
Prints log messages for all publishing events.
The print operator does not require a parameter, but if provided will prepend it to any console output.

Print is incredibly useful to see "what’s happening" within a pipeline, and can be used as printf debugging within the pipeline.

Most of the example tests illustrating the operators within this reference use a print operator to provide additional text output to illustrate lifecycle events.

The print operator is not directly integrated with Apple’s unified logging, although there is an optional to parameter that lets you specific an instance conforming to TextOutputStream to which it will send the output.

let _ = foo.$username
    .print(self.debugDescription)
    .tryMap({ myValue -> String in
        if (myValue == "boom") {
            throw FailureCondition.selfDestruct
        }
        return "mappedValue"
    })

14.Scheduler and Thread handling operators
(1)receive
Receive defines the scheduler on which to receive elements from the publisher.
Receive takes a single required parameter (on:) which accepts a scheduler, 
and an optional parameter (optional:) which can accept SchedulerOptions. Scheduler is a protocol in Combine, with the conforming types that are commonly used of RunLoop, DispatchQueue and OperationQueue. Receive is frequently used with assign to make sure any following pipeline invocations happen on a specific thread, such as RunLoop.main when updating user interface objects. Receive effects itself and any operators chained after it, but not previous operators.

If you want to influence a previously chained publishers (or operators) for where to run, 
you may want to look at the subscribe operator. Alternately, you may also want to put a receive operator earlier in the pipeline.

examplePublisher.receive(on: RunLoop.main)

(2)subscribe
Subscribe defines the scheduler on which to run a publisher in a pipeline.
Subscribe assigns a scheduler to the preceding pipeline invocation. It is relatively infrequently used, 
specifically to encourage a publisher such as Just or Deferred to run on a specific queue. If you want to control which queue operators run on, then it is more common to use the receive operator, which effects all following operators and subscribers.

Subscribe takes a single required parameter (on:) which accepts a scheduler, 
and an optional parameter (optional:) which can accept SchedulerOptions. Scheduler is a protocol in Combine, with the conforming types that are commonly used of RunLoop, DispatchQueue and OperationQueue.

Subscribe effects a subset of the functions, and does not guarantee that a publisher will run on that queue. In particular, 
it effects a publishers receive function, the subscribers request function, and the cancel function. 
Some publishers (such as URLSession.dataTaskPublisher) have complex internals that will run on alternative queues based on their configuration, 
and will be relatively unaffected by subscribe.

networkDataPublisher
    .subscribe(on: backgroundQueue) 
    .receive(on: RunLoop.main) 
    .assign(to: \.text, on: yourLabel) 
the subscribe call requests the publisher (and any pipeline invocations before this in a chain) be invoked on the backgroundQueue.
the receive call transfers the data to the main runloop, suitable for updating user interface elements
the assign call uses the assign subscriber to update the property text on a KVO compliant object, in this case yourLabel.

When creating a DispatchQueue to use with Combine publishers on background threads, 
it is recommended that you use a regular serial queue rather than a concurrent queue to allow Combine to adhere to its contracts. 
That is: do not create the queue with attributes: .concurrent.

This is not enforced by the compiler or any internal framework constraints.

15.Type erasure operators
(1)eraseToAnyPublisher
The eraseToAnyPublisher operator takes a publisher and provides a type erased instance of AnyPublisher.
When chaining operators together, the resulting type signature accumulates all the various types. This can get complicated quite quickly, and can provide an unnecessarily complex signature for an API.

eraseToAnyPublisher takes the signature and "erases" the type back to the common type of AnyPublisher. 
This provides a cleaner type for external declarations. Combine was created prior to Swift 5 inclusion of opaque types, which may have been an alternative.

.eraseToAnyPublisher() 
eraseToAnyPublisher is often at the end of chains of operators, cleaning up the signature of the returned property

(2)AnySubscriber
The AnySubscriber provides a type erased instance of AnySubscriber.
Use an AnySubscriber to wrap an existing subscriber whose details you don’t want to expose. 
You can also use AnySubscriber to create a custom subscriber by providing closures for the methods defined in Subscriber, 
rather than implementing Subscriber directly.

------------------------------Subjects
currentValueSubject:
CurrentValueSubject creates an object that can be used to integrate imperative code into a pipeline, 
starting with an initial value.

currentValueSubject creates an instance to which you can attach multiple subscribers.
When creating a currentValueSubject, you do so with an initial value of the relevant output type for the Subject.

CurrentValueSubject remembers the current value so that when a subscriber is attached, 
it immediately receives the current value. When a subscriber is connected and requests data, the initial value is sent. 
Further calls to .send() afterwards will then pass through values to any subscribers.

PassthroughSubject:
PassthroughSubject creates an object that can be used to integrate imperative code into a Combine pipeline.

PassthroughSubject creates an instance to which you can attach multiple subscribers. 
When it is created, only the types are defined.

When a subscriber is connected and requests data, it will not receive any values until a .send() call is invoked. 
PassthroughSubject doesn’t maintain any state, it only passes through provided values. Calls to .send() will then send values to any subscribers.

PassthroughSubject is commonly used in scenarios where you want to create a publisher from imperative code. 
One example of this might be a publisher from a delegate callback structure, common in Apple’s APIs. 
Another common use is to test subscribers and pipelines, providing you with imperative control of when events are sent within a pipeline.

This is very useful when creating tests, as you can put when data is sent to a pipeline under test control.

------------------------------Subscribers
assign:
Assign creates a subscriber used to update a property on a KVO compliant object.
Failure type must be <Never>.

Assign only handles data, and expects all errors or failures to be handled in the pipeline before it is invoked. 
The return value from setting up assign can be cancelled, and is frequently used when disabling the pipeline, 
such as when a viewController is disabled or deallocated. 
Assign is frequently used in conjunction with the receive operator to receive values on a specific scheduler, 
typically RunLoop.main when updating UI objects.

The type of KeyPath required for the assign operator is important. 
It requires a ReferenceWritableKeyPath, which is different from both WritableKeyPath and KeyPath. 
In particular, ReferenceWritableKeyPath requires that the object you’re writing to is a reference type (an instance of a class), 
as well as being publicly writable. A WritableKeyPath is one that’s a mutable value reference (a mutable struct), 
and KeyPath reflects that the object is simply readable by keypath, but not mutable.

examplePublisher
    .receive(on: RunLoop.main)
    .assign(to: \.text, on: yourLabel)

Cannot convert value of type 'KeyPath<SomeObject, Bool>' to specified type 'ReferenceWritableKeyPath<SomeObject, Bool>'
This happens when you are attempting to assign to a property that is read-only. An example of this is UIActivityIndicator’s `isAnimating property.

Key path value type 'UIImage?' cannot be converted to contextual type 'UIImage'
This error can occur when you are attempting to assign a non-optional type to a keypath that expects has an optional type. 
For example, UIImageView.image is of type UIImage?, so attempting to assign an output type of UIImage from a previous operator would result in this error message.

sink:
Sink creates an all-purpose subscriber. At a minimum, you provide a closure to receive values, 
and optionally a closure that receives completions.

There are two forms of the sink operator. The first is the simplest form, taking a single closure, 
receiving only the values from the pipeline (if and when provided by the publisher). 
Using the simpler version comes with a constraint: the failure type of the pipeline must be <Never>. 
If you are working with a pipeline that has a failure type other than <Never> you need to use the two closure version or add error handling into the pipeline itself.

An example of the simple form of sink:

let examplePublisher = Just(5)

let cancellable = examplePublisher.sink { value in
    print(".sink() received \(String(describing: value))")
}

Be aware that the closure may be called repeatedly. How often it is called depends on the pipeline to which it is subscribing. 
The closure you provide is invoked for every update that the publisher provides, up until the completion, and prior to any cancellation.

It may be tempting to ignore the cancellable you get returned from sink. For example, the code:

let _ = examplePublisher.sink { value in
    print(".sink() received \(String(describing: value))")
}

However, this has the side effect that as soon as the function returns, the ignored variable is deallocated, 
causing the pipeline to be cancelled. If you want the pipeline to operate beyond the scope of the function (you probably do), 
then assign it to a longer lived variable that doesn’t get deallocated until much later. 
Simply including a variable declaration in the enclosing object is often a good solution.

The second form of sink takes two closures, the first of which receives the data from the pipeline, and the second receives pipeline completion messages. 
The closure parameters are receiveCompletion and receiveValue: A .failure completion may also encapsulate an error.

An example of the two-closure sink:

let examplePublisher = Just(5)
let cancellable = examplePublisher.sink(receiveCompletion: { err in
    print(".sink() received the completion", String(describing: err))
}, receiveValue: { value in
    print(".sink() received \(String(describing: value))")
})

The type that is passed into receiveCompletion is the enum Subscribers.Completion. The completion .failure includes an Error wrapped within it, providing access to the underlying cause of the failure. 
To get to the error within the .failure completion, switch on the returned completion to determine if it is .finished or .failure, and then pull out the error.

When you chain a .sink subscriber onto a publisher (or pipeline), the result is cancellable. 
At any time before the publisher sends a completion, the subscriber can send a cancellation and invalidate the pipeline. 
After a cancel is sent, no further values will be received.

let simplePublisher = PassthroughSubject<String, Never>()
let cancellablePipeline = simplePublisher.sink { data in
  // do what you need with the data...
}

cancellablePublisher.cancel() // when invoked, this invalidates the pipeline
// no further data will be received by the sink
similar to publishers having a type-erased struct AnyPublisher to expose publishers through an API, subscribers have an equivalent: AnyCancellable. This is often used with sink to convert the resulting type into AnyCancellable.

onReceive:
onReceive is a subscriber built into SwiftUI that allows publishers to be linked into local views to trigger relevant state changes.
Failure type must be <Never>

onReceive is a subscriber, taking a reference to a publisher, 
a closure which is invoked when the publisher provided to onReceive receives data. 
This acts very similarly to the sink subscriber with a single closure, 
including requiring that the failure type of the publisher be <Never>. 
onReceive does not automatically invalidate the view, 
but allows the developers to react to the published data in whatever way is appropriate - this could be updating some local view property (@State) with the value directly, 
or first transforming the data in some fashion.

AnyCancellable:
AnyCancellable type erases a subscriber to the general form of Cancellable.

This is used to provide a reference to a subscriber that allows the use of cancel without access to the subscription itself to request items. 
This is most typically used when you want a reference to a subscriber to clean it up on deallocation. 
Since the assign returns an AnyCancellable, this is often used when you want to save the reference to a sink an AnyCancellable.

var mySubscriber: AnyCancellable?

let mySinkSubscriber = remotePublisher
    .sink { data in
        print("received ", data)
    }
mySubscriber = AnyCancellable(mySinkSubscriber)

A pattern that is supported with Combine is collecting AnyCancellable references into a set and then saving references to the cancellable subscribers with a store method.
private var cancellableSet: Set<AnyCancellable> = []

let mySinkSubscriber = remotePublisher
    .sink { data in
        print("received ", data)
    }
    .store(in: &cancellableSet)