悬垂指针（Dangling Pointer）
定义：指向**已经释放（销毁）**的内存的指针。
int *p = malloc(sizeof(int));
free(p);     // 内存被释放
*p = 5;      // p 是悬垂指针（dangling pointer）


野指针（Wild Pointer）
定义：指向不确定内存的指针（地址随机、不合法、未初始化，或者已经失效）。
int *p;      // 未初始化，p 里是随机值
/*
Xcode 运行崩溃
Thread 1: EXC_BAD_ACCESS (code=1, address=0x0)
A bad access to memory terminated the process.

修改成 int *p = nullptr; 
运行同样崩溃 EXC_BAD_ACCESS

在现代操作系统里，地址 0 所在的内存页是受保护的，不允许用户程序访问（无论读还是写）。
这是 OS 的内存保护机制，防止空指针访问造成不可预期的行为。
一旦访问，OS 会发信号终止进程：
macOS/iOS: EXC_BAD_ACCESS

int *p = NULL;     // C
int *p = nullptr;  // C++
NULL & nullptr 都是 0

正确做法
空指针只是“无目标”，不能直接解引用。
先让它指向一块有效内存再操作：
int *p = nullptr;
// 分配内存
p = new int;   // 或 malloc(sizeof(int)) in C
*p = 5;        // ✅ 现在合法
delete p;      // 或 free(p)
*/
*p = 5;      // p 是野指针（wild pointer） // Xcode报警告：Variable 'p' is uninitialized when used here。 
产生方式：
未初始化的指针变量
已释放但没置空的指针（这种情况也叫悬垂指针，但也是野指针的一种）
上面这个写法问题很大，而且属于未定义行为（undefined behavior），在 C/C++ 里是非常危险的。
p 是一个局部变量，未初始化时内容是栈上残留的随机值（并不是 0，也不是 NULL）。
*p = 5 会试图往这个随机地址写数据，可能导致：
直接 段错误（Segmentation Fault）
覆盖程序其他区域的数据（更糟糕：破坏栈/堆）
程序崩溃或者出现不可预期的行为
你必须让 p 指向一块合法的内存再解引用：
int x;
int *p = &x;   // 指向已有变量
*p = 5;        // OK
在 C 语言中，使用未初始化的指针解引用是致命错误。


“解引用”（dereference） 指的是 通过指针访问它所指向的内存内容。
指针变量本身存的是一个内存地址（比如 0x1000）。
解引用 就是顺着这个地址，找到对应的内存位置，读或写里面的值。
int x = 42;
int *p = &x;    // p 存储的是 x 的地址
int y = *p;     // 解引用：取 p 指向地址里的值（= 42）
*p = 99;        // 解引用：往 p 指向的内存写入 99


野 → “乱指” 的意思，不知道指哪去。
悬垂 → “挂着没东西” 的意思，本来有对象，现在对象没了。