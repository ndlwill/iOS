Docker 是建立在 Linux 内核机制之上的一个容器管理

Docker 依赖于 Linux 内核特性
Docker 并不是一种虚拟化技术，而是一种操作系统级别的隔离技术，核心依赖 Linux 的以下机制：

| 内核特性                         | Docker 中的作用                      |
| ---------------------------- | -------------------------------- |
| **Namespaces**               | 实现“隔离” → 不同容器看到自己的进程、网络、文件系统等环境  |
| **Cgroups (Control Groups)** | 实现“资源限制” → 限制容器的 CPU、内存、IO 等资源使用 |
| **UnionFS (OverlayFS)**      | 实现“镜像分层” → 通过层叠文件系统实现镜像复用和快速启动   |
| **Capabilities**             | 实现“精细化权限控制”                      |
| **Seccomp/AppArmor/SELinux** | 实现“安全隔离”                         |

没有这些 Linux 特性，Docker 就无法隔离或运行容器。


Docker 运行时有两个主要部分：
dockerd（守护进程）：运行在 Linux 上，负责管理镜像、容器、网络等。
docker CLI（客户端）：命令行工具，向 dockerd 发指令。
+--------------------+
|   Docker CLI       |
+--------------------+
         ↓
+--------------------+
|   Docker Daemon    | ← 直接使用 Linux 内核特性
+--------------------+
         ↓
+--------------------+
|   Linux Kernel     |
+--------------------+


Docker 本质依赖 Linux 内核，那么在 macOS 或 Windows 上怎么运行呢？
其实是通过一个轻量级虚拟机（通常运行一个精简版的 Linux）来实现的
即在非 Linux 系统中，Docker 是“借”一个 Linux 内核来运行的。



#####
容器是一个运行在宿主机（Host）上的、被操作系统内核隔离起来的“独立运行环境”。
#####
你可以把容器想象成：
在同一个 Linux 系统里，被“虚拟出”多个独立的“小操作系统”，每个容器都有自己独立的文件系统、网络、进程空间、用户环境，但共享同一个内核。


虚拟机是“跑多个系统”，
容器是“在一个系统中跑多个独立应用环境”。


容器是从“镜像（Image）”启动的。
镜像相当于一个应用的模板（包含应用 + 依赖 + 配置），而容器是它的运行实例。
就像：
镜像：一个 class 定义；
容器：这个 class 的实例对象。

宿主机（Host） 就是运行容器或虚拟机的那台“真实的计算机”。

| 术语             | 含义                 |
| -------------- | ------------------ |
| **宿主机（Host）**  | 运行容器或虚拟机的“物理或虚拟机器” |
| **客户机（Guest）** | 被宿主机隔离出来运行的容器或虚拟机  |


你自己的 Mac / Windows / Linux 电脑 就可以是宿主机；
它可以运行 Docker 容器（Host → Container）；
或者运行 虚拟机（Host → VM）。


宿主机与容器的关系图
+-----------------------------------------------------------+
|          宿主机 (Host)                                    |
|  +-----------------------------------------------+        |
|  | 操作系统 (Host OS, e.g. Linux)                |        |
|  |  +-------------------------+                  |        |
|  |  | Docker Engine (dockerd) |                  |        |
|  |  +----------+--------------+                  |        |
|  |             |                                 |        |
|  |     +-------v--------+    +-------v--------+  |        |
|  |     |  容器 A        |    |  容器 B        |  |        |
|  |     | 独立文件系统   |    | 独立文件系统   |  |        |
|  |     | 独立网络命名空间 |  | 独立网络命名空间 | |        |
|  |     +----------------+    +----------------+  |        |
|  +-----------------------------------------------+        |
+-----------------------------------------------------------+
这里每个“容器”其实就是宿主机上被隔离出来的一组进程。


#####
容器里只是运行了一组被隔离的进程，
它们共享宿主机的 Linux 内核，
但有自己的文件系统、网络、环境变量等。
#####


容器的网络和宿主机的网络到底是什么关系？
容器的网络其实是由 Linux 内核的 Network Namespace（网络命名空间） 机制隔离出来的，
而 Docker（或其他容器引擎）通过不同的“网络模式”来决定容器与宿主机网络的关系。

核心机制：Network Namespace
在 Linux 里，每个进程可以运行在不同的 Network Namespace 里。
这意味着：
每个容器看到的网卡、IP、路由表都可以是独立的；
但底层还是共用宿主机的网络设备（通过虚拟桥接）。
所以容器网络 ≠ 完全独立的物理网络，
而是宿主机网络上通过虚拟设备隔离出来的“虚拟网络”。


Docker 提供的几种网络模式
| 模式                        | 容器与宿主机网络关系                    | 特点                      | 常见用途             |
| ------------------------- | ----------------------------- | ----------------------- | ---------------- |
| **bridge（默认）**            | 容器在一个独立虚拟网桥中，和宿主机隔离，通过 NAT 出网 | 容器有自己的 IP，访问外部时通过宿主机转发  | 一般应用容器（如 Web 服务） |
| **host**                  | 容器和宿主机共享同一个网络命名空间             | 容器直接使用宿主机的 IP，性能好但无隔离   | 性能敏感、网络透明需求      |
| **none**                  | 容器没有网络接口                      | 完全隔离                    | 自定义网络栈的特殊情况      |
| **container:**`<name/id>` | 与另一个容器共享网络命名空间                | 多容器共享网络栈                | Sidecar 模式       |
| **macvlan**               | 容器直接在宿主机物理网卡上创建虚拟子接口          | 容器拥有独立 MAC/IP，可直接被局域网访问 | 高级网络场景，如与物理设备通信  |


+-------------------------------------------------------------+
|                       宿主机 (Host)                         |
|                                                             |
|  +--------------------+       +--------------------------+  |
|  | eth0 (宿主机网卡)  |-------| 外部网络 (Internet/LAN) |  |
|  +--------------------+       +--------------------------+  |
|           |                                               |
|           v                                               |
|     +-----------+                                         |
|     | docker0   |  ← 虚拟网桥 (bridge)                   |
|     +-----------+                                         |
|      |       |                                            |
|   veth0a   veth1a    ← veth pair 虚拟网线                 |
|      |       |                                            |
|  +--------+  +--------+                                   |
|  | 容器 A |  | 容器 B |                                   |
|  | eth0→veth0b | eth0→veth1b |                            |
|  +--------+  +--------+                                   |
|  容器IP:172.17.0.2  容器IP:172.17.0.3                    |
+-------------------------------------------------------------+

每个容器里看到的 eth0 是虚拟网卡；
宿主机会为每个容器创建一对 “veth（虚拟以太网对）”；
一头在容器里，一头连到宿主机的虚拟网桥（docker0）；
宿主机通过 NAT 转发容器流量出外网。


容器与宿主机网络的交互总结
| 方向                | 是否可达                  | 说明 |
| ----------------- | --------------------- | -- |
| 容器 → 外网           | ✅ 默认可达（NAT）           |    |
| 外网 → 容器           | 🚫 默认不行，需要 `-p` 端口映射  |    |
| 容器 ↔ 容器（同 bridge） | ✅ 可直接通信               |    |
| 容器 ↔ 容器（不同网络）     | 🚫 默认不通，需要自定义网络或 link |    |
| 容器 ↔ 宿主机          | ✅ 可通过宿主机 IP 通信        |    |



举个实际例子
假设你在宿主机上执行：
$ docker run -d --name test busybox sleep 9999
$ docker exec test ip addr
你可能看到容器里有个 IP：
eth0: 172.17.0.2
而宿主机上执行：
$ ip addr show docker0
会看到：
docker0: inet 172.17.0.1/16
说明容器的网络是通过虚拟网桥 docker0 和宿主机连接的。
容器访问外网时，会通过 NAT：
172.17.0.2:8080 → [宿主机IP]:随机端口 → Internet