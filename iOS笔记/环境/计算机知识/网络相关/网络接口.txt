“网络接口”指的就是网卡（网络接口卡）,但它的含义稍微比“网卡”更广泛一些


网卡（NIC）
网卡是物理硬件，比如插在主板上的以太网卡、Wi-Fi 卡等。
一张网卡就是一个物理网络接口。


网络接口（Network Interface）
网络接口可以指：
物理网卡（上面说的）
虚拟网卡（比如 VPN、虚拟机创建的网卡、Docker bridge 接口、loopback 回环接口 lo）
所以，网络接口 = 网卡（硬件）+ 虚拟接口（软件模拟出来的）


接口类型	名字示例	说明
物理网卡	eth0, en0	真正的以太网卡
无线网卡	wlan0	无线接口
回环接口	lo	自己跟自己通信用（127.0.0.1）
虚拟网卡	tun0, tap0	VPN、Docker、虚拟机创建的接口


网卡是网络接口的一种，但网络接口不一定是物理网卡。虚拟接口也是网络接口的一部分。


在手机里，5G 和 Wi-Fi 就是两个不同的 网络接口，它们分别对应不同的硬件模块和连接方式



虚拟网络接口确实是“软件模拟出来的”，在某些系统实现中，它确实通过“文件”或者“设备文件”来实现数据的收发:
虚拟网络接口的底层原理
在类 Unix 系统（比如 Linux）中，虚拟网络接口其实就是一种 “虚拟设备”，这些设备通常通过内核驱动+用户空间之间的接口来交换数据，很多时候是通过设备文件（比如 /dev/tun0）来读写数据包的。


接口类型	接口名字	数据怎么进出	举例用途
TUN 接口	tun0	/dev/net/tun 读写 IP 层数据包	VPN 客户端（OpenVPN, WireGuard）
TAP 接口	tap0	/dev/net/tun 读写以太网帧	虚拟机桥接、Docker 容器等
Loopback 接口	lo	内核内部直接转发，无需文件	127.0.0.1 通信
Docker bridge	docker0	虚拟网桥 + veth pair	容器通信
VPN 虚拟网卡	utun0（macOS）	通过系统 API（不是设备文件）读写	WireGuard、L2TP 等 VPN



举个最典型的例子：/dev/net/tun
这是 Linux 下创建 TUN/TAP 接口时使用的设备文件：
int fd = open("/dev/net/tun", O_RDWR);
// 然后通过 ioctl 配置接口（比如 tun0）
// 之后你就可以 read()/write() 这个 fd 来收发 IP 数据包了
这个 fd 就是你程序的“网卡收发通道”。 相当于你自己写了一个虚拟网卡的驱动，内核帮你挂在了系统里。


背后机制:
用户态程序通过 /dev/net/tun 拿到一个 fd
这个 fd 和内核的网络协议栈绑定在一起
数据从内核协议栈写进接口（发出去）时 → 用户程序可以 read(fd)
用户写入接口（模拟接收到网络包） → 内核就像从真实网卡收到一样处理


不是所有虚拟接口都通过设备文件
macOS 的 utunX 是通过专用的 socket 接口（不是 /dev/ 设备）

大多数虚拟网络接口，底层是通过设备文件或 socket 等形式暴露出“可读写的接口”，用于和用户空间交换数据包。