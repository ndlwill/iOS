socket是内核对底层协议封装给上层调用的函数

https://zhuanlan.zhihu.com/p/453788129

BBR (Bottleneck Bandwidth and Round-trip propagation time)是 Google 在 2016 年发布的一套拥塞控制算法。
它尤其适合在存在一定丢包率的弱网环境下使用，在这类环境下，BBR 的性能远超 CUBIC 等传统的拥塞控制算法。

网络拥塞与控制:
网络中的数通设备(交换机路由器)在入方向通常都会有缓存入报文的队列，其目的是为了应付短时间内涌入的大量报文。
但如果入方向的报文持续超负荷，缓存队列也一定会被填满，此后的报文就只能被无情丢弃，之后发送端便能感知到报文丢了。

可以把网络链路想象为一根水管，路径上的数通设备会自带一个蓄水池，一般不会使用。
而当水流变大时，蓄水池开始蓄水，如果超过蓄水极限，则水流会溢出(报文丢包)。

###
当发送端感知到丢包时，传统的 TCP 拥塞控制算法会减小发送端的拥塞窗口 Cwnd，限制报文的发送。
这类拥塞控制算法也被称为基于丢包(Loss-based)的拥塞控制算法。
###

这显然不是最好的时机! 因为使用缓存队列并不能提升整个链路的带宽，反而还会增大报文的 RTT (每个报文的排队时间变长了)。
缓存队列只是应急区域，平时是不应该被使用的。

BBR 的设计思路:
控制时机提前，不再等到丢包时再进行暴力限制，而是控制稳定的发包速度，尽量榨干带宽，却又不让报文在中间设备的缓存队列上累积。

TCP Pacing功能控制TCP的发包速率
RTT是Round Trip Time

为了得到稳定的发包速度，BBR 使用 TCP Pacing 进行发包控制，因此 BBR 的实现也需要底层支持 TCP Pacing; 
为了榨干带宽，BBR 会周期性地去探测是否链路条件变好了，如果是，则加大发送速率; 
为了不让报文在中间设备的缓存队列上累积，BBR 会周期性地探测链路的最小 RTT，并使用该最小 RTT 计算发包速率。