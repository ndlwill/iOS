usr 全称是 Unix System Resources（Unix 系统资源）


#!/usr/bin/env python3 // 这段在 update-checkout 中
这两个字符 #! 用于指定脚本的解释器
当你在终端运行 ./update-checkout 这样的脚本时，操作系统会检查这行代码，并使用指定的解释器运行脚本内容。
env 是一个命令，作用是 根据环境变量 PATH 查找可执行程序的位置。
指定使用 python3 作为解释器


解释器与编译器
编译型语言需要编译器处理:
源代码(source code)→预处理器(preprocessor) →编译器(compiler)→目标代码(object code)→链接器(Linker)一可执行程序(executables)

解释型语言需要解释器处理:
源代码(source code) +解释器(interpreter)

一、Shell初探
#!/bin/bash
Shebang（Hashbang）：一个由井号和叹号构成的字符序列#!出现在文本文件的第一行的前两个字符。
操作系统的程序加载器会分析Shebang后的内容，将这些内容作为解释器指令。
并调用该指令，并将载有Shebang的文件路径作为该解释器的参数。
#!/usr/bin/python

#!/usr/bin/env python
env：不同操作系统，脚本解释器可能被安装于系统的不同的目录，设置到系统的PATH中。
env可以在系统的PATH目录中查找
上述命令，使用在用户路径中找到的第一个Python版本
但是可以通过指定版本号：
#!/usr/bin/env pythonX.x
env也可以指定搜索目录：
#!/usr/bin/env -S -P/usr/local/bin:/usr/bin:${PATH} python
会在/usr/local/bin、/usr/bin、系统PATH搜索python。

HOME：代表用户主文件夹。
SHELL：当前使用的是那个SHELL
PATH：文件查找路径

----------注释
# echo "单行注释"

: << !
    多行注释方式一：
        echo "多行注释"
!

: << COMMENT
    多行注释方式二：
        echo "多行注释"
COMMENT

: '
    多行注释方式三：
        echo "多行注释"
'

if false; then
    多行注释方式四：
        echo "多行注释"
fi

read 读取键盘变量:
read var1
ndl
echo $var1

二、特殊符号
1. 双引号 " "：
双引号常用于包含一组字符串，在双引号中，除了 "$"、"\"、" ` (反引号)"有特殊含义外，其余字符（如换行符、回车符等）没有特殊含义。
2. 单引号 ' '：
单引号的功能与双引号类似，不过单引号中的所有字符都没有特殊含义。
3. 反引号 ` `：
反引号的功能是命令替换，在反引号 ` ` 中的内容通常是命令行，程序会优先执行反引号中的内容，并使用运行结果替换掉反引号处的内容。
4. $ + 小括号$( )：
作用与反引号一样，也是命令替换。
5. $ + 双小括号 $(( ))：
$(( )) 的功能是进行算术运算，括号中的内容为数学表达式。 $(( 20 + 5 * 6))返回双括号内算数运算的结果。
6. $ + 中括号 $[ ]：
$[ ] 的功能与 $(( )) 一样，都是用于算术运算。
7. $ + 大括号 ${ }：
${ } 的功能是变量引用，类似于 $ 符，但是 ${ } 比 $ 的替换范围更精准。
8. 小括号 ( )：
用来定义一个数组变量。
9. 双小括号 (( ))：
双小括号命令允许在比较过程中使用高级数学表达式。
10. 中括号 [ ]：
单个的中括号的功能与 test 命令一样，都是用作条件测试。
11. 双中括号 [[ ]]
双中括号提供了针对字符串比较的高级特性，使用双中括号 [[ ]] 进行字符串比较时，可以把右边的项看做一个模式，故而可以在 [[ ]] 中使用正则表达式。
11. 大括号 { }：
大括号用于括起一个语句块。
12. 冒号(:)作为内建命令：占位符、参数扩展和重定向
13. expr命令是一款表达式计算工具，使用它完成表达式的求值操作。
14. eval会对后面的cmdLine进行两遍扫描，如果第一遍扫描后，cmdLine是个普通命令，则执行此命令；如果cmdLine中含有变量的间接引用，则保证间接引用的语义。
        
type：显示命令属性，会显示该命令所在的位置。

文字色：
echo -e "\e[1;31mThis is red text\e[0m"
\e[1;31m 将颜色设置为红色
\e[0m 将颜色重新置回
颜色码：重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37
背景色：
echo -e "\e[1;42mGreed Background\e[0m"
颜色码：重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47


三、路径相关
如果路径中包含空格，则有三种不同的解决策略：
# 加 \ 转义
/mnt/c/Program\ Files/Walterlv/Foo

# 加双引号
"/mnt/c/Program Files/Walterlv/Foo"

# 加单引号
'/mnt/c/Program Files/Walterlv/Foo'
#转义空格。如果路径中包含空格，那么使用 \ 转义可以避免路径被分割成 Shell 的两个参数。

# grep "$KEY_WORD" --color=auto -- $FILE
# -- 表示该命令后没有参数了，后面接的是文件路径

四、标准输出&输入&错误
标准输入（stdin）：代码为0，使用<或<<;
标准输出（stdout）：代码为1，使用>或>>;
标准错误输出（stderr）：代码为2，使用2>或2>>;
1> 以覆盖的方式将正确的数据输出到指定到文件或设备；
1>> 以累加到方法将正确到数据输出到指定到文件或者设备上；
2> 以覆盖的方式将错误的数据输出到指定到文件或设备；
2>> 以累加的方式将错误的数据输出到指定到文件或设备；
< 标准输入；
<< 结束输入，后接一个结束输入符；
2>/dev/null 将错误到数据丢弃，只显示正确到数据；
2>&1 或者 &>将正确的数据和错误的数据写入同一个文件；
1>&2 正确返回值传递给2输出通道 &2表示2输出通道；
2>&1 错误返回值传递给1输出通道, 同样&1表示1输出通道；

##
scriptname >filename 重定向scriptname的输出到文件filename中. 如果filename存在的话, 那么将会被覆盖.
command &>filename 重定向command的stdout和stderr到filename中.
command >&2 重定向command的stdout到stderr中.
##

cmd;cmd 不考虑命令相关性，连续执行。
当前一个命令执行成功会回传一个 $?=0的值。
cmd1 && cmd2 如果第一个命令的$?不为0，则执行第二个命令。
cmd1 || cmd2 如果第一个命令的$?不为0，则不执行第二个命令。否则执行第二个命令。
｜：管道仅能处理前面一个命令传来的正确信息，将正确信息作为stdin传给下一个命令。
1、管道命令只处理前一个命令正确输出，不处理错误输出;

2、管道命令右边命令，必须能够接收标准输入流命令才行；

3、大多数命令都不接受标准输入作为参数，只能直接在命令行输入参数，这导致无法用管道命令传递参数。

- ：减号在一些命令中表示从标准输入(stdin)中获取内容，可省略
xargs：是将标准输入转为命令行参数

五、Shell的三种运行方式
1. sh：
使用$ sh script.sh执行脚本时，当前shell是父进程，生成一个子shell进程，在子shell中执行脚本。
脚本执行完毕，退出子shell，回到当前shell。$ ./script.sh与$ sh script.sh等效。也叫fork方式
2. source：
使用$ source script.sh方式，在当前上下文中执行脚本，不会生成新的进程。脚本执行完毕，回到当前shell。
$ . script.sh与$ source script.sh等效。不需要有"执行权限"
3. exec方式：
使用exec ./scriptsh方式，会用command进程替换当前shell进程，并且保持PID不变。
执行完毕，直接退出，不回到之前的shell环境。
# 为build.sh添加可执行权限：chmod +x ./build.sh 

是否需要权限：
1. sh script.sh不需要有"执行权限"
2. ./script.sh需要有"执行权限"
3. source script.sh不需要有"执行权限"
4. exec需要有"执行权限"

六、Shell变量
1. Shell变量默认为字符串。
2. Shell默认的数值运算是整数类型。所以若要进行数学运算，必须使用一些命令例如declare、expr、双括号等。
3. Shell变量可分为两类：
i. 局部变量：只在创建它们的shell中可用。在函数内定义，函数执行后就被删除。
ii. 环境变量：可以在创建它们的shell及其派生出来的任意子进程中使用。在整个脚本执行期间，只要没有被删除就一直存在。
3. 定义规则：变量名必须以字母或下划线字符开头。其余的字符可以是字母、数字(0~9)或下划线字符。任何其他的字符都标志着变量名的终止。
小写敏感。
4. 给变量赋值时，等号周围不能有任何空白符。
5. 通常大写字符为系统默认变量。
6. set：查看所有变量（含环境变量与自定义变量），以及设置shell变量的新变量值。
    -a：标示已修改的变量，以供输出至环境变量。
    -b：使被中止的后台程序立刻回报执行状态。
    -e：若指令传回值不等于0，则立即退出shell。
    -f：取消使用通配符。
    -h：自动记录函数的所在位置。
    -H Shell：可利用"!"加<指令编号>的方式来执行history中记录的指令。
    -k：指令所给的参数都会被视为此指令的环境变量。
    -l：记录for循环的变量名称。
    -m：使用监视模式。
    -n：只读取指令，而不实际执行。
    -p：启动优先顺序模式。
    -P：启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接。
    -t：执行完随后的指令，即退出shell。
    -u：当执行时使用到未定义过的变量，则显示错误信息。
    -v：显示shell所读取的输入值。
    -x：执行指令后，会先显示该指令及所下的参数。
7. declare/typeset [-aixrp] 变量
-a 将变量定义成数组
-i 将变量定义成整数
-x 将变量定义成环境变量
-r 将变量定义成readonly
-p：显示变量定义的方式和值
+：取消变量属性，但是 +a 和 +r 无效，无法删除数组和只读属性，可以使用unset删除数组，但是 unset 不能删除只读变量。
8. local关键字，用来在作用域内创建变量。出来作用域被销毁。
9. export为shell变量或函数设置导出属性，成为环境变量。无法对未定义的函数添加导出属性。同时，重要的一点是，export的效力仅及于该次登陆操作。
注销或者重新开一个窗口，export命令给出的环境变量都不存在了。
-f：代表[变量名称]为函数名称。。
-n：删除变量的导出属性。变量实际上并未删除，只是不会输出到后续指令的执行环境中。
-p：显示全部拥有导出属性的变量。
-pf：显示全部拥有导出属性的函数。
-nf：删除函数的导出属性。
--：在它之后的选项无效。
10. 通配符
*：匹配任意字符串，包括空字符串，不包含对“/”字符的匹配。
?：匹配任意单个字符，不能匹配“/”字符。
[abc]：匹配“a”或者“b”或者“c”字符。
[^abc]：不匹配“a”或者“b”或者“c”字符。
[a-z]：匹配26个英文小写字符中任意一个。

用set命令可以查看所有的变量，unset var命令可以清除变量var，var相当于没有定义过。
readonly var可以把var变为只读变量，定义之后不能对var进行任何更改。

# expr 3+4
# expr 3 + 4
# RESLUT=`expr 3 + 4`
# RESLUT=$(( 1 + 2 ))
# echo $RESLUT
# echo ${RESLUT}

# declare a=3 b=4 c
# c=a+b
# echo $c

定义为整数
# declare -i a=3 b=4 c
# c=a+b
# echo $c
# declare -p c

定义环境变量
# export a b=3
# export -n a b

定义多个参数
set 11 22 33 44 55 

echo $1 $2 $3 $4

参数个数：$#
所有参数：$@

七、函数
函数的声明形式：
function 函数名 {
    函数体
}
function 函数名() {
    函数体
}
函数名() {
    函数体
}
1. 有funtion，可以不写()，没有function，必须写()。
2. 函数名和”{“之间必须有空格。
3. 不得声明形式参数。
4. 必须在调用函数地方之前，声明函数
5. 无法重载
6. 后来的声明会覆盖之前的声明
7. 没有返回值的函数，默认返回函数内最后一条指令的返回值。有返回值的函数，只能返回整数。
8. 需要获得函数值，只能通过$?获得。通过=获得是空值。

我们可以将shell中函数，看作是定义一个新的命令，因此各个输入参数直接用空格分隔。
一次，命令里面获得参数方法可以通过：$0...$n得到。$0代表函数本身。
$#：传入的参数的个数。
$*：所有的位置参数(作为单个字符串)。
$@：所有的位置参数(每个都作为独立的字符串)。
$?：当前shell进程中，上一个命令的返回值，如果上一个命令成功执行则$?的值为0，否则为其他非零值。
$$：当前shell进程的pid。
$!：后台运行的最后一个进程的pid。
$-：显示shell使用的当前选项。
$_：之前命令的最后一个参数。

八、Test与判断
多分支语句判断:
除最后一个分支外（这个分支可以是普通分支，也可以是*)分支），其它的每个分支都必须以;;结尾，;;代表一个分支的结束，不写的话会有语法错误。
最后一个分支可以写;;，也可以不写，因为无论如何，执行到 esac 都会结束整个 case in 语句。
case $变量 in
"第一个变量内容")
    程序
    ;;    #结束
*)  # 用来托底，没有匹配到数据
    ;;
esac

一个条件判断：
if [ condation ]; then
    成立
else
    不成立
fi

多条件判断：
if [ condation ]; then
    成立
elif [ condation ]; then
    成立
else
    不成立
fi

[]：判断符号，两个等号和一个等号，效果类似。
1. 中括号里面的每个组件都需要空格分隔。
2. 中括号的变量，使用双引号
3. 中括号的常量，使用单引号或双引号


http://www.reddragonfly.org/abscn/index.html
test命令测试：
1. test n1 -eq n2:
    -eq：相等
    -ne：不等
    -gt：大于
    -lt：小于
    -ge：大于等于
    -le：小于等于
2. 字符串判断
-z
字符串为"null", 意思就是字符串长度为零
-n
字符串不为"null"
    string1 = string2：字符串是否相等，相等为true。
    string1 != string2：字符串是否不等，相等为false。
3. 多重条件判断
    -a：两个条件同时成立，为true。
    -o：两个条件任何一个成立，为true。
    !：反向。
4. 文件类型判断
    -e：文件名是否存在。
    -f：该文件名是否存在且是否为文件。
    -d：该名称是否存在且为目录。
    -L：该名称是否存在且是否为链接文件。
5. 文件权限检测
    -r：是否存在是否有可读权限。
    -w：是否存在是否有可写权限。
    -x：是否存在是否有可执行权限。
    -s：是否存在且为非空白文件。
6. 两文件比较
    -nt 文件1是否比文件2新。
    -ot 文件1是否比文件2旧。
    -ef 文件1和文件2是否为同一个文件。

if [ ture ]; then
    :
fi

当-n使用在中括号中进行条件测试的时候, 必须要把字符串用双引号引用起来. 
检查字符串是否为null:
如果字符串并没有被初始化, 那么它里面的值未定义.
这种状态被称为"null" (注意这与零值不同).
#false
#判断的是a这个参数，因为没赋值，所以返回flase
if [ -n "$a" ] # "$a"不为"null", false, 因为他是null
then
    echo true
else
    echo false
fi
#true
#判断的是“-n $a”这个字符串，此时非空即为true
#可以使用[[ -n $a ]] 来达到上面案例的效果
if [ -n $a ]
then
    echo true
else
    echo false
fi

"if COMMAND"结构将会返回COMMAND的退出状态码.

在中括号中的条件判断也不一定非得要if不可, 也可以使用列表结构.
var1=20
var2=22
[ "$var1" -ne "$var2" ] && echo "$var1 is not equal to $var2"

九、循环
当条件成立，就进行循环：
while [ condation ]  #判断条件
do                   #循环开始
    程序
done                 #循环结束
当条件成立，就终止循环：
until [ condation ]  #判断条件
do                   #循环开始
    程序
done                 #循环结束
按照指定次数循环：
for var in con1 con2 con3 ...
do
    程序
done

for (( 初始值; 限制值; 执行步长 ))
do
    程序
done

十、参数扩展
参数扩展：通过符号$获得参数中存储的值。
1. 间接参数扩展
i. ${parameter-string}：当parameter未设置则替换成string，不更改parameter值。否则，不做处理。
ii. ${parameter=string}：当parameter未设置则替换成string，更改parameter值。否则，不做处理。
iii. ${parameter?string}：parameter没有设置，则把string输出到标准错误中。否则，不做处理。
iiii. ${parameter+string}：当parameter为空的时替换成string。否则，不做处理。
${!parameter}，zsh不支持
2. 冒号后面跟 等号，加号，减号，问号（⚠不能有空格）：
i. ${parameter:-string}：当parameter未设置或者为空则替换成string，不更改parameter值。
ii. ${parameter:=string}：当parameter未设置或者为空则替换成string，更改parameter值。
iii. ${parameter:?string}：若变量parameter不为空，则使用变量parameter的值。
        若为空，则把string输出到标准错误中，并从脚本中退出。
iiii. ${parameter:+string}：当parameter不为空的时替换成string。若为空时则不替换或者说是替换空值。
3. 子串扩展：${parameter:offset}和${parameter:offset:length}。
从offset位置开始截取长度为length的子串，如果没有提供length，则是从offset开始到结尾。
i. offset可以是负值，且必须与冒号有间隔或者用()包裹。开始位置是从字符串末尾开始算起，然后取长度为length的子串。
    例如，-1代表是从最后一个字符开始。
ii. parameter是@，也就是所有的位置参数时，offset必须从1开始。
4. 替换：${parameter/pattern/string}、${parameter//pattern/string}、${parameter/pattern}和${parameter//pattern}。
    大小写敏感。string为空时，则相当于将匹配的子串删除。 parameter之后如果是/，则只匹配遇到的第一个子串；
    parameter之后如果是//，则匹配所有的子串。
5. 删除：${parameter#pattern}、${parameter##pattern}、${parameter%pattern}和${parameter%%pattern}。
i. # 是去掉左边，% 是去掉右边。单一符号是最小匹配﹔两个符号是最大匹配。
6. 参数长度：${#parameter}


###
变量的名字就是变量保存值的地方. 引用变量的值就叫做变量替换.
###

y=`eval ls -l` # 与 y=`ls -l` 很相似
echo $y # 但是换行符将会被删除, 因为"echo"的变量未被""引用.
echo
echo "$y" # 用""将变量引用起来, 换行符就不会被空格替换了.

LF(换行符)

# 用"eval"命令来"扩展"一个变量
for i in 1 2 3 4 5; do
eval value=$i
#  value=$i 具有相同的效果, 在这里并不是非要使用"eval"不可.
#  一个缺乏特殊含义的变量将被评价为自身 -- 也就是说,
#  这个变量除了能够被扩展成自身所表示的字符外, 不能被扩展成任何其他的含义.
echo $value
done

for i in ls df; do
value=eval $i
#  value=$i 在这里就与上边这句有了本质上的区别.
#  "eval" 将会评价命令 "ls" 和 "df" . . .
#  术语 "ls" 和 "df" 就具有特殊含义,
#+ 因为它们被解释成命令,
#+ 而不是字符串本身.
echo $value
done

==================================================. : () {} [] [[]] (())
一、.(source)
.（点）与source命令一样，从文件中读取并执行命令，无论该文件是否都有可执行权限都能够正确的执行。
且是在当前shell下执行，而不是产生一个子shell来执行（我们通常使用“./filename.sh”去执行一个文件是在当前shell下产生一个子shell去执行的）。
所以在设置bash的环境的变量时，就必须用该命令或者source命令去执行设置的环境变量才会对当前shell生效，如下：

for i in /etc/profile.d/*.sh ; do
    if [ -r "$i" ]; then
        . $i
    fi
done

二、:
： 该命令什么都不做，但执行后会返回一个正确的退出代码，即exit 0。比如在if语句中，then后面不想做任何操作，但是又不能空着，这时就可以使用“:”来解决，如下：

if [ "$i" -ne 1 ];then
    :
else
    echo "$i is not equal 1"
fi

三、()
() 将多个命令组合在一起执行，相当于一个命令组。

四、{}
{}  和()类似，也是将多个命令组合在一起。它们之间的区别是，()是在产生的子shell下执行，而{}是在当前的shell下执行。
这与前面讲到是使用".  filename.sh"和"./filename.sh"的区别一样。举一个很简单的例子：

# A=123
# (A=abc;echo $A);echo $A
abc
123

# { A=abc;echo $A; };echo $A
abc
abc

当在()中赋值的变量，影响的只是自身的子shell，而不能将该值赋给父shell，因为“父亲不能继承儿子”。而在{}中赋值的变量，因为就在当前的shell执行的，所以就能改变原来变量的值。
注意：()里面两边可以不使用空格，{}里面两边必须使用空格，且最后一个命令也需要以“；”结尾，表示命令结束。

五、[](test)
[] 与test命令一样，用于比较值以及检查文件类型。如下：
1、[ "$A" = 123 ]：是字符串的测试
2、[ "$A" -eq 123 ]：是整数的测试
3、[ -e "$A" ]：是关于文件的测试

六、[[]]
[[]]可以说是[]的“增强版”，它能够将多个test命令支持的测试组合起来，例如：

# [[ (-d "$HOME") && (-w "$HOME") ]] && echo "home is a writable directory"  

home is a writable directory

shell中数值比较只能使用 -lt -le -gt -ge -ne -eq,对于ASCII码值的比较使用< >,重点:[[ ]]中< >无需转义,[ ]需转义
但在[]中，>和<必须使用\进行转义，即\>和\<
# [ a \> 1 ] && echo ture || echo false
ture
# [[ a > 1 ]] && echo ture || echo false
ture

逻辑测试： 
[]为 -a -o !  
[[ ]] 为&& || !

数学运算： [] 不可以使用 [[ ]]可以使用+ - */ %

七、(())
(())专门来做数值运算，如果表达式求值为 0，则设置退出状态为 1；如果求值为非 0 值，则设置为 0。不需要对 (( 和 )) 之间的操作符转义。算术只对整数进行。除 0 会产生错误，但不会产生溢出。可以执行 C 语言中常见的算术、逻辑和位操作。如下：

# ((i=1+99));echo $i
100

# i=99;((i++));echo $i
100

除此之外，也可以使用$(())直接进行数值运算，如下：
# echo $((2**3))
8

注意：使用 (( )) 时，不需要空格分隔各值和运算符，使用[]和[[ ]] 时需要用空格分隔各值和运算符。'

==================================================[] , [[]]
判断变量是否为空:
a=abc
echo $a
[ $a ]
echo $? # 0

if [ $a ]; then
echo "true"
else
echo "false"
fi
true

[[ $a ]]
echo $? # 0


b=""
echo $b
[ $b ] 
echo $? # 1

if [ $b ]; then
echo "true"
else
echo "false"
fi
false

[[ $b ]]
echo $? # 1

上面判断的时候，[[xx]] xx为空的时候[[xx]]返回的结果是大于0或者说市非0的,不为空的时候返回真值也就是0；所以if判断可以成立；



[ -n "$var" ];echo $?
[[ -n $var ]];echo $?
[ ],判断变量时必须加"",[[ ]],不受此限制.