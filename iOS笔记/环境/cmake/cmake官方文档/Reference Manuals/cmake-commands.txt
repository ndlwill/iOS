https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html

==============================list
Reading
  list(LENGTH <list> <out-var>)
  list(GET <list> <element index> [<index> ...] <out-var>)
  list(JOIN <list> <glue> <out-var>)
  list(SUBLIST <list> <begin> <length> <out-var>)

Search
  list(FIND <list> <value> <out-var>)

Modification
  list(APPEND <list> [<element>...])
  list(FILTER <list> {INCLUDE | EXCLUDE} REGEX <regex>)
  list(INSERT <list> <index> [<element>...])
  list(POP_BACK <list> [<out-var>...])
  list(POP_FRONT <list> [<out-var>...])
  list(PREPEND <list> [<element>...])
  list(REMOVE_ITEM <list> <value>...)
  list(REMOVE_AT <list> <index>...)
  list(REMOVE_DUPLICATES <list>)
  list(TRANSFORM <list> <ACTION> [...])

Ordering
  list(REVERSE <list>)
  list(SORT <list> [...])

The list subcommands APPEND, INSERT, FILTER, PREPEND, POP_BACK, POP_FRONT, REMOVE_AT, REMOVE_ITEM, REMOVE_DUPLICATES, REVERSE and SORT may create new values for the list within the current CMake variable scope.
Similar to the set() command, the LIST command creates new variable values in the current scope, even if the list itself is actually defined in a parent scope. 
To propagate the results of these operations upwards, use set() with PARENT_SCOPE, set() with CACHE INTERNAL, or some other means of value propagation.

Note A list in cmake is a ; separated group of strings. 
To create a list the set command can be used.
For example, set(var a b c d e) creates a list with a;b;c;d;e, and set(var "a b c d e") creates a string or a list with one item in it.
(Note macro arguments are not variables, and therefore cannot be used in LIST commands.)

Note When specifying index values, if <element index> is 0 or greater, it is indexed from the beginning of the list, with 0 representing the first list element.
If <element index> is -1 or lesser, it is indexed from the end of the list, with -1 representing the last list element.
Be careful when counting with negative indices: they do not start from 0. -0 is equivalent to 0, the first list element.

----------Reading
list(LENGTH <list> <output variable>)
Returns the list's length.

list(GET <list> <element index> [<element index> ...] <output variable>)
Returns the list of elements specified by indices from the list.

list(JOIN <list> <glue> <output variable>)
New in version 3.12.
Returns a string joining all list's elements using the glue string. To join multiple strings, which are not part of a list, use JOIN operator from string() command.

list(SUBLIST <list> <begin> <length> <output variable>)
New in version 3.12.
Returns a sublist of the given list. If <length> is 0, an empty list will be returned. If <length> is -1 or the list is smaller than <begin>+<length> then the remaining elements of the list starting at <begin> will be returned.

----------Search
list(FIND <list> <value> <output variable>)
Returns the index of the element specified in the list or -1 if it wasn't found.

----------Modification
list(APPEND <list> [<element> ...])
Appends elements to the list. If no variable named <list> exists in the current scope its value is treated as empty and the elements are appended to that empty list.

----------Ordering


==============================install
Specify rules to run at install time.

This command generates installation rules for a project. 
Install rules specified by calls to the install() command within a source directory are executed in order during installation.

install(TARGETS <target>... [...])
install(IMPORTED_RUNTIME_ARTIFACTS <target>... [...])
install({FILES | PROGRAMS} <file>... [...])
install(DIRECTORY <dir>... [...])
install(SCRIPT <file> [...])
install(CODE <code> [...])
install(EXPORT <export-name> [...])
install(RUNTIME_DEPENDENCY_SET <set-name> [...])

Changed in version 3.14: Install rules in subdirectories added by calls to the add_subdirectory() command are interleaved with those in the parent directory to run in the order declared

Changed in version 3.22: The environment variable CMAKE_INSTALL_MODE can override the default copying behavior of install().

There are multiple signatures for this command. 
Some of them define installation options for files and targets. 
Options common to multiple signatures are covered here but they are valid only for signatures that specify them. The common options are:
1.DESTINATION
Specify the directory on disk to which a file will be installed. Arguments can be relative or absolute paths.
If a relative path is given it is interpreted relative to the value of the CMAKE_INSTALL_PREFIX variable. 
The prefix can be relocated at install time using the DESTDIR mechanism explained in the CMAKE_INSTALL_PREFIX variable documentation.

If an absolute path (with a leading slash or drive letter) is given it is used verbatim.

As absolute paths are not supported by cpack installer generators, it is preferable to use relative paths throughout. 
In particular, there is no need to make paths absolute by prepending CMAKE_INSTALL_PREFIX; this prefix is used by default if the DESTINATION is a relative path.

2.CONFIGURATIONS
Specify a list of build configurations for which the install rule applies (Debug, Release, etc.). Note that the values specified for this option only apply to options listed AFTER the CONFIGURATIONS option. 
For example, to set separate install paths for the Debug and Release configurations, do the following:

install(TARGETS target
        CONFIGURATIONS Debug
        RUNTIME DESTINATION Debug/bin)
install(TARGETS target
        CONFIGURATIONS Release
        RUNTIME DESTINATION Release/bin)
Note that CONFIGURATIONS appears BEFORE RUNTIME DESTINATION.

3.COMPONENT
Specify an installation component name with which the install rule is associated, such as Runtime or Development. 
During component-specific installation only install rules associated with the given component name will be executed. 
During a full installation all components are installed unless marked with EXCLUDE_FROM_ALL. 
If COMPONENT is not provided a default component "Unspecified" is created. 
The default component name may be controlled with the CMAKE_INSTALL_DEFAULT_COMPONENT_NAME variable.

4.EXCLUDE_FROM_ALL
New in version 3.6.

Specify that the file is excluded from a full installation and only installed as part of a component-specific installation


==============================Installing Targets
install(TARGETS targets... [EXPORT <export-name>]
        [RUNTIME_DEPENDENCIES args...|RUNTIME_DEPENDENCY_SET <set-name>]
        [[ARCHIVE|LIBRARY|RUNTIME|OBJECTS|FRAMEWORK|BUNDLE|
          PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE|FILE_SET <set-name>|CXX_MODULES_BMI]
         [DESTINATION <dir>]
         [PERMISSIONS permissions...]
         [CONFIGURATIONS [Debug|Release|...]]
         [COMPONENT <component>]
         [NAMELINK_COMPONENT <component>]
         [OPTIONAL] [EXCLUDE_FROM_ALL]
         [NAMELINK_ONLY|NAMELINK_SKIP]
        ] [...]
        [INCLUDES DESTINATION [<dir> ...]]
        )

The TARGETS form specifies rules for installing targets from a project. There are several kinds of target Output Artifacts that may be installed:

ARCHIVE
Target artifacts of this kind include:
Static libraries (except on macOS when marked as FRAMEWORK, see below);
DLL import libraries (on all Windows-based systems including Cygwin; they have extension .lib, in contrast to the .dll libraries that go to RUNTIME);
On AIX, the linker import file created for executables with ENABLE_EXPORTS enabled.

EXPORT:
This option associates the installed target files with an export called <export-name>. 
It must appear before any target options. 
To actually install the export file itself, call install(EXPORT). 
If EXPORT is used and the targets include PUBLIC or INTERFACE file sets, 
all of them must be specified with FILE_SET arguments. 
All PUBLIC or INTERFACE file sets associated with a target are included in the export.

RUNTIME:
Target artifacts of this kind include:
Executables (except on macOS when marked as MACOSX_BUNDLE);
DLLs (on all Windows-based systems including Cygwin; note that the accompanying import libraries are of kind ARCHIVE).

LIBRARY:
Target artifacts of this kind include:
Shared libraries, except
DLLs (these go to RUNTIME),
on macOS when marked as FRAMEWORK.

FRAMEWORK
Both static and shared libraries marked with the FRAMEWORK property are treated as FRAMEWORK targets on macOS.

BUNDLE
Executables marked with the MACOSX_BUNDLE property are treated as BUNDLE targets on macOS.

PUBLIC_HEADER:
Any PUBLIC_HEADER files associated with a library are installed in the destination specified by the PUBLIC_HEADER argument on non-Apple platforms. 
Rules defined by this argument are ignored for FRAMEWORK libraries on Apple platforms because the associated files are installed into the appropriate locations inside the framework folder.

PRIVATE_HEADER
Similar to PUBLIC_HEADER, but for PRIVATE_HEADER files.

RESOURCE
Similar to PUBLIC_HEADER and PRIVATE_HEADER, but for RESOURCE files.

For shared libraries on DLL platforms, if neither RUNTIME nor ARCHIVE destinations are specified, 
both the RUNTIME and ARCHIVE components are installed to their default destinations. 
If either a RUNTIME or ARCHIVE destination is specified, the component is installed to that destination, and the other component is not installed. 
If both RUNTIME and ARCHIVE destinations are specified, then both components are installed to their respective destinations.

The following table shows the target types with their associated variables and built-in defaults that apply when no destination is given:
Target Type
GNUInstallDirs Variable
Built-In Default

RUNTIME
${CMAKE_INSTALL_BINDIR}
bin

LIBRARY
${CMAKE_INSTALL_LIBDIR}
lib

ARCHIVE
${CMAKE_INSTALL_LIBDIR}
lib

PRIVATE_HEADER
${CMAKE_INSTALL_INCLUDEDIR}
include

PUBLIC_HEADER
${CMAKE_INSTALL_INCLUDEDIR}
include

FILE_SET (type HEADERS)
${CMAKE_INSTALL_INCLUDEDIR}
include

==============================Installing Exports
install(EXPORT <export-name> DESTINATION <dir>
        [NAMESPACE <namespace>] [FILE <name>.cmake]
        [PERMISSIONS permissions...]
        [CONFIGURATIONS [Debug|Release|...]
        [CXX_MODULES_DIRECTORY <directory>]
        [EXPORT_LINK_INTERFACE_LIBRARIES]
        [COMPONENT <component>]
        [EXCLUDE_FROM_ALL])
install(EXPORT_ANDROID_MK <export-name> DESTINATION <dir> [...])

The EXPORT form generates and installs a CMake file containing code to import targets from the installation tree into another project.
Target installations are associated with the export <export-name> using the EXPORT option of the install(TARGETS) signature documented above.
The NAMESPACE option will prepend <namespace> to the target names as they are written to the import file.
By default the generated file will be called <export-name>.cmake but the FILE option may be used to specify a different name.
The value given to the FILE option must be a file name with the .cmake extension.
If a CONFIGURATIONS option is given then the file will only be installed when one of the named configurations is installed.

Note The installed <export-name>.cmake file may come with additional per-configuration <export-name>-*.cmake files to be loaded by globbing.
Do not use an export name that is the same as the package name in combination with installing a <package-name>-config.cmake file or the latter may be incorrectly matched by the glob and loaded.

The EXPORT form is useful to help outside projects use targets built and installed by the current project. For example, the code:
install(TARGETS myexe EXPORT myproj DESTINATION bin)
install(EXPORT myproj NAMESPACE mp_ DESTINATION lib/myproj)
install(EXPORT_ANDROID_MK myproj DESTINATION share/ndk-modules)

will install the executable myexe to <prefix>/bin and code to import it in the file <prefix>/lib/myproj/myproj.cmake and <prefix>/share/ndk-modules/Android.mk.
An outside project may load this file with the include command and reference the myexe executable from the installation tree using the imported target name mp_myexe as if the target were built in its own tree.

Note This command supersedes the install_targets() command and the PRE_INSTALL_SCRIPT and POST_INSTALL_SCRIPT target properties. 
It also replaces the FILES forms of the install_files() and install_programs() commands.
The processing order of these install rules relative to those generated by install_targets(), install_files(), and install_programs() commands is not defined.

==============================include_directories
Add include directories to the build.

include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...])

Add the given directories to those the compiler uses to search for include files. 
Relative paths are interpreted as relative to the current source directory.

The include directories are added to the INCLUDE_DIRECTORIES directory property for the current CMakeLists file.
They are also added to the INCLUDE_DIRECTORIES target property for each target in the current CMakeLists file.
The target property values are the ones used by the generators.

By default the directories specified are appended onto the current list of directories.
This default behavior can be changed by setting CMAKE_INCLUDE_DIRECTORIES_BEFORE to ON.
By using AFTER or BEFORE explicitly, you can select between appending and prepending, independent of the default.

If the SYSTEM option is given, the compiler will be told the directories are meant as system include directories on some platforms.
Signalling this setting might achieve effects such as the compiler skipping warnings, or these fixed-install system files not being considered in dependency calculations.

Arguments to include_directories may use "generator expressions" with the syntax "$<...>".
See the cmake-generator-expressions(7) manual for available expressions
See the cmake-buildsystem(7) manual for more on defining buildsystem properties.

Note:
Prefer the target_include_directories() command to add include directories to individual targets and optionally propagate/export them to dependents.

==============================target_include_directories
###
Add include directories to a target.
###

target_include_directories(<target> [SYSTEM] [AFTER|BEFORE]
  <INTERFACE|PUBLIC|PRIVATE> [items1...]
  [<INTERFACE|PUBLIC|PRIVATE> [items2...] ...])

Specifies include directories to use when compiling a given target. 
The named <target> must have been created by a command such as add_executable() or add_library() and must not be an ALIAS target.

By using AFTER or BEFORE explicitly, you can select between appending and prepending, independent of the default.

The INTERFACE, PUBLIC and PRIVATE keywords are required to specify the scope of the following arguments. PRIVATE and PUBLIC items will populate the INCLUDE_DIRECTORIES property of <target>. 
PUBLIC and INTERFACE items will populate the INTERFACE_INCLUDE_DIRECTORIES property of <target>. The following arguments specify include directories.

New in version 3.11: Allow setting INTERFACE items on IMPORTED targets.

Repeated calls for the same <target> append items in the order called.

If SYSTEM is specified, the compiler will be told the directories are meant as system include directories on some platforms. 
This may have effects such as suppressing warnings or skipping the contained headers in dependency calculations (see compiler documentation). 
Additionally, system include directories are searched after normal include directories regardless of the order specified.

If SYSTEM is used together with PUBLIC or INTERFACE, the INTERFACE_SYSTEM_INCLUDE_DIRECTORIES target property will be populated with the specified directories.

Arguments to target_include_directories may use "generator expressions" with the syntax $<...>.

Specified include directories may be absolute paths or relative paths. A relative path will be interpreted as relative to the current source directory (i.e. CMAKE_CURRENT_SOURCE_DIR) and converted to an absolute path before storing it in the associated target property. 
If the path starts with a generator expression, it will always be assumed to be an absolute path (with one exception noted below) and will be used unmodified.

Include directories usage requirements commonly differ between the build-tree and the install-tree. 
The BUILD_INTERFACE and INSTALL_INTERFACE generator expressions can be used to describe separate usage requirements based on the usage location. 
Relative paths are allowed within the INSTALL_INTERFACE expression and are interpreted as relative to the installation prefix. 
Relative paths should not be used in BUILD_INTERFACE expressions because they will not be converted to absolute. For example:

target_include_directories(mylib PUBLIC
  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include/mylib>
  $<INSTALL_INTERFACE:include/mylib>  # <prefix>/include/mylib
)

==============================target_compile_definitions
Add compile definitions to a target.

target_compile_definitions(<target>
  <INTERFACE|PUBLIC|PRIVATE> [items1...]
  [<INTERFACE|PUBLIC|PRIVATE> [items2...] ...])

Specifies compile definitions to use when compiling a given <target>. The named <target> must have been created by a command such as add_executable() or add_library() and must not be an ALIAS target.

The INTERFACE, PUBLIC and PRIVATE keywords are required to specify the scope of the following arguments.
PRIVATE and PUBLIC items will populate the COMPILE_DEFINITIONS property of <target>.
PUBLIC and INTERFACE items will populate the INTERFACE_COMPILE_DEFINITIONS property of <target>.
The following arguments specify compile definitions. Repeated calls for the same <target> append items in the order called.

New in version 3.11: Allow setting INTERFACE items on IMPORTED targets.

Arguments to target_compile_definitions may use "generator expressions" with the syntax $<...>

Any leading -D on an item will be removed. Empty items are ignored. For example, the following are all equivalent:
target_compile_definitions(foo PUBLIC FOO)
target_compile_definitions(foo PUBLIC -DFOO)  # -D removed
target_compile_definitions(foo PUBLIC "" FOO) # "" ignored
target_compile_definitions(foo PUBLIC -D FOO) # -D becomes "", then ignored

Definitions may optionally have values:
target_compile_definitions(foo PUBLIC FOO=1)

Note that many compilers treat -DFOO as equivalent to -DFOO=1, but other tools may not recognize this in all circumstances (e.g. IntelliSense).

==============================file
File manipulation command.

This command is dedicated to file and path manipulation requiring access to the filesystem.

For other path manipulation, handling only syntactic aspects, have a look at cmake_path() command.

Filesystem
  file({GLOB | GLOB_RECURSE} <out-var> [...] [<globbing-expr>...])

file(GLOB <variable>
     [LIST_DIRECTORIES true|false] [RELATIVE <path>] [CONFIGURE_DEPENDS]
     [<globbing-expressions>...])
file(GLOB_RECURSE <variable> [FOLLOW_SYMLINKS]
     [LIST_DIRECTORIES true|false] [RELATIVE <path>] [CONFIGURE_DEPENDS]
     [<globbing-expressions>...])

Generate a list of files that match the <globbing-expressions> and store it into the <variable>
Globbing expressions are similar to regular expressions, but much simpler.
If RELATIVE flag is specified, the results will be returned as relative paths to the given path.

Changed in version 3.6: The results will be ordered lexicographically.

On Windows and macOS, globbing is case-insensitive even if the underlying filesystem is case-sensitive (both filenames and globbing expressions are converted to lowercase before matching). 
On other platforms, globbing is case-sensitive.

New in version 3.3: By default GLOB lists directories - directories are omitted in result if LIST_DIRECTORIES is set to false.

New in version 3.12: If the CONFIGURE_DEPENDS flag is specified, CMake will add logic to the main build system check target to rerun the flagged GLOB commands at build time. 
If any of the outputs change, CMake will regenerate the build system.

Note:
We do not recommend using GLOB to collect a list of source files from your source tree. 
If no CMakeLists.txt file changes when a source is added or removed then the generated build system cannot know when to ask CMake to regenerate. 
The CONFIGURE_DEPENDS flag may not work reliably on all generators, or if a new generator is added in the future that cannot support it, 
projects using it will be stuck. Even if CONFIGURE_DEPENDS works reliably, there is still a cost to perform the check on every rebuild.

Examples of globbing expressions include:
*.cxx      - match all files with extension cxx
*.vt?      - match all files with extension vta,...,vtz
f[3-5].txt - match files f3.txt, f4.txt, f5.txt

==============================set
Set a normal, cache, or environment variable to a given value.
See the cmake-language(7) variables documentation for the scopes and interaction of normal variables and cache entries.

Signatures of this command that specify a <value>... placeholder expect zero or more arguments. 
Multiple arguments will be joined as a semicolon-separated list to form the actual variable value to be set. 
Zero arguments will cause normal variables to be unset. See the unset() command to unset variables explicitly.

1.Set Normal Variable
set(<variable> <value>... [PARENT_SCOPE])
Sets the given <variable> in the current function or directory scope.

If the PARENT_SCOPE option is given the variable will be set in the scope above the current scope.
Each new directory or function() command creates a new scope.
A scope can also be created with the block() command.
This command will set the value of a variable into the parent directory, calling function or encompassing scope (whichever is applicable to the case at hand).
The previous state of the variable's value stays the same in the current scope (e.g., if it was undefined before, it is still undefined and if it had a value, it is still that value).

The block(PROPAGATE) and return(PROPAGATE) commands can be used as an alternate method to the set(PARENT_SCOPE) and unset(PARENT_SCOPE) commands to update the parent scope.

2.Set Cache Entry
set(<variable> <value>... CACHE <type> <docstring> [FORCE])

Sets the given cache <variable> (cache entry). Since cache entries are meant to provide user-settable values this does not overwrite existing cache entries by default.
Use the FORCE option to overwrite existing entries.

The <type> must be specified as one of:

BOOL
Boolean ON/OFF value. cmake-gui(1) offers a checkbox.

FILEPATH
Path to a file on disk. cmake-gui(1) offers a file dialog.

PATH
Path to a directory on disk. cmake-gui(1) offers a file dialog.

STRING
A line of text. cmake-gui(1) offers a text field or a drop-down selection if the STRINGS cache entry property is set.

INTERNAL
A line of text. cmake-gui(1) does not show internal entries. They may be used to store variables persistently across runs. Use of this type implies FORCE.

The <docstring> must be specified as a line of text providing a quick summary of the option for presentation to cmake-gui(1) users.

If the cache entry does not exist prior to the call or the FORCE option is given then the cache entry will be set to the given value.

Note:
The content of the cache variable will not be directly accessible if a normal variable of the same name already exists (see rules of variable evaluation). 
If policy CMP0126 is set to OLD, any normal variable binding in the current scope will be removed.

It is possible for the cache entry to exist prior to the call but have no type set if it was created on the cmake(1) command line by a user through the -D<var>=<value> option without specifying a type. In this case the set command will add the type. Furthermore, 
if the <type> is PATH or FILEPATH and the <value> provided on the command line is a relative path, 
then the set command will treat the path as relative to the current working directory and convert it to an absolute path.

3.Set Environment Variable
set(ENV{<variable>} [<value>])
Sets an Environment Variable to the given value. Subsequent calls of $ENV{<variable>} will return this new value.

This command affects only the current CMake process, not the process from which CMake was called, nor the system environment at large, nor the environment of subsequent build or test processes.
If no argument is given after ENV{<variable>} or if <value> is an empty string, then this command will clear any existing value of the environment variable.
Arguments after <value> are ignored. If extra arguments are found, then an author warning is issued.


==============================add_library
Add a library to the project using the specified source files.

1.Normal Libraries
add_library(<name> [STATIC | SHARED | MODULE]
            [EXCLUDE_FROM_ALL]
            [<source>...])

Adds a library target called <name> to be built from the source files listed in the command invocation.
The <name> corresponds to the logical target name and must be globally unique within a project. 
The actual file name of the library built is constructed based on conventions of the native platform (such as lib<name>.a or <name>.lib).

New in version 3.1: Source arguments to add_library may use "generator expressions" with the syntax $<...>. See the cmake-generator-expressions(7) manual for available expressions.

New in version 3.11: The source files can be omitted if they are added later using target_sources().

STATIC, SHARED, or MODULE may be given to specify the type of library to be created.
STATIC libraries are archives of object files for use when linking other targets.
SHARED libraries are linked dynamically and loaded at runtime.
MODULE libraries are plugins that are not linked into other targets but may be loaded dynamically at runtime using dlopen-like functionality.

If no type is given explicitly the type is STATIC or SHARED based on whether the current value of the variable BUILD_SHARED_LIBS is ON.
For SHARED and MODULE libraries the POSITION_INDEPENDENT_CODE target property is set to ON automatically.
A SHARED library may be marked with the FRAMEWORK target property to create an macOS Framework.

New in version 3.8: A STATIC library may be marked with the FRAMEWORK target property to create a static Framework.

If a library does not export any symbols, it must not be declared as a SHARED library.
For example, a Windows resource DLL or a managed C++/CLI DLL that exports no unmanaged symbols would need to be a MODULE library.
This is because CMake expects a SHARED library to always have an associated import library on Windows.

By default the library file will be created in the build tree directory corresponding to the source tree directory in which the command was invoked.
See documentation of the ARCHIVE_OUTPUT_DIRECTORY, LIBRARY_OUTPUT_DIRECTORY, and RUNTIME_OUTPUT_DIRECTORY target properties to change this location.
See documentation of the OUTPUT_NAME target property to change the <name> part of the final file name.

If EXCLUDE_FROM_ALL is given the corresponding property will be set on the created target. See documentation of the EXCLUDE_FROM_ALL target property for details.

See also HEADER_FILE_ONLY on what to do if some sources are pre-processed, and you want to have the original sources reachable from within IDE.

2.Object Libraries
add_library(<name> OBJECT [<source>...])
Creates an Object Library. An object library compiles source files but does not archive or link their object files into a library.

Instead other targets created by add_library() or add_executable() may reference the objects using an expression of the form $<TARGET_OBJECTS:objlib> as a source, where objlib is the object library name. For example:
add_library(... $<TARGET_OBJECTS:objlib> ...)
add_executable(... $<TARGET_OBJECTS:objlib> ...)
will include objlib's object files in a library and an executable along with those compiled from their own sources.
Object libraries may contain only sources that compile, header files, and other files that would not affect linking of a normal library (e.g. .txt).
They may contain custom commands generating such sources, but not PRE_BUILD, PRE_LINK, or POST_BUILD commands.
Some native build systems (such as Xcode) may not like targets that have only object files, so consider adding at least one real source file to any target that references $<TARGET_OBJECTS:objlib>.

New in version 3.12: Object libraries can be linked to with target_link_libraries().

3.Interface Libraries
add_library(<name> INTERFACE)
Creates an Interface Library. An INTERFACE library target does not compile sources and does not produce a library artifact on disk.
However, it may have properties set on it and it may be installed and exported.
Typically, INTERFACE_* properties are populated on an interface target using the commands:
set_property(),
target_link_libraries(INTERFACE),
target_link_options(INTERFACE),
target_include_directories(INTERFACE),
target_compile_options(INTERFACE),
target_compile_definitions(INTERFACE), and
target_sources(INTERFACE),
and then it is used as an argument to target_link_libraries() like any other target.

An interface library created with the above signature has no source files itself and is not included as a target in the generated buildsystem.

New in version 3.15: An interface library can have PUBLIC_HEADER and PRIVATE_HEADER properties. The headers specified by those properties can be installed using the install(TARGETS) command.

New in version 3.19: An interface library target may be created with source files:
add_library(<name> INTERFACE [<source>...] [EXCLUDE_FROM_ALL])
Source files may be listed directly in the add_library call or added later by calls to target_sources() with the PRIVATE or PUBLIC keywords.

If an interface library has source files (i.e. the SOURCES target property is set), or header sets (i.e. the HEADER_SETS target property is set), 
it will appear in the generated buildsystem as a build target much like a target defined by the add_custom_target()
It does not compile any sources, but does contain build rules for custom commands created by the add_custom_command() command.

Note:
In most command signatures where the INTERFACE keyword appears, 
the items listed after it only become part of that target's usage requirements and are not part of the target's own settings. 
However, in this signature of add_library, the INTERFACE keyword refers to the library type only. 
Sources listed after it in the add_library call are PRIVATE to the interface library and do not appear in its INTERFACE_SOURCES target property.

4.Imported Libraries
add_library(<name> <type> IMPORTED [GLOBAL])
Creates an IMPORTED library target called <name>.
No rules are generated to build it, and the IMPORTED target property is True.
The target name has scope in the directory in which it is created and below, but the GLOBAL option extends visibility.
It may be referenced like any target built within the project.
IMPORTED libraries are useful for convenient reference from commands like target_link_libraries()
Details about the imported library are specified by setting properties whose names begin in IMPORTED_ and INTERFACE_.

The <type> must be one of:

STATIC, SHARED, MODULE, UNKNOWN
References a library file located outside the project. The IMPORTED_LOCATION target property (or its per-configuration variant IMPORTED_LOCATION_<CONFIG>) specifies the location of the main library file on disk:

For a SHARED library on most non-Windows platforms, the main library file is the .so or .dylib file used by both linkers and dynamic loaders. If the referenced library file has a SONAME (or on macOS, has a LC_ID_DYLIB starting in @rpath/), the value of that field should be set in the IMPORTED_SONAME target property. If the referenced library file does not have a SONAME, but the platform supports it, then the IMPORTED_NO_SONAME target property should be set.

For a SHARED library on Windows, the IMPORTED_IMPLIB target property (or its per-configuration variant IMPORTED_IMPLIB_<CONFIG>) specifies the location of the DLL import library file (.lib or .dll.a) on disk, and the IMPORTED_LOCATION is the location of the .dll runtime library (and is optional, but needed by the TARGET_RUNTIME_DLLS generator expression).

Additional usage requirements may be specified in INTERFACE_* properties.

An UNKNOWN library type is typically only used in the implementation of Find Modules. It allows the path to an imported library (often found using the find_library() command) to be used without having to know what type of library it is. This is especially useful on Windows where a static library and a DLL's import library both have the same file extension.

OBJECT
References a set of object files located outside the project. The IMPORTED_OBJECTS target property (or its per-configuration variant IMPORTED_OBJECTS_<CONFIG>) specifies the locations of object files on disk. Additional usage requirements may be specified in INTERFACE_* properties.

INTERFACE
Does not reference any library or object files on disk, but may specify usage requirements in INTERFACE_* properties.

See documentation of the IMPORTED_* and INTERFACE_* properties for more information.

5.Alias Libraries
add_library(<name> ALIAS <target>)
Creates an Alias Target, such that <name> can be used to refer to <target> in subsequent commands. 
The <name> does not appear in the generated buildsystem as a make target. The <target> may not be an ALIAS.

New in version 3.11: An ALIAS can target a GLOBAL Imported Target

New in version 3.18: An ALIAS can target a non-GLOBAL Imported Target. 
Such alias is scoped to the directory in which it is created and below. 
The ALIAS_GLOBAL target property can be used to check if the alias is global or not.

ALIAS targets can be used as linkable targets and as targets to read properties from. They can also be tested for existence with the regular if(TARGET) subcommand. 
The <name> may not be used to modify properties of <target>, that is, it may not be used as the operand of set_property(), set_target_properties(), target_link_libraries() etc. An ALIAS target may not be installed or exported.

==============================find_package
https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html

Find a package (usually provided by something external to the project),and load its package-specific details.
Calls to this command can also be intercepted by dependency providers.

----------Search Modes
The command has a few modes by which it searches for packages:
1.Module mode:
In this mode, CMake searches for a file called Find<PackageName>.cmake, looking first in the locations listed in the CMAKE_MODULE_PATH, then among the Find Modules provided by the CMake installation.
If the file is found, it is read and processed by CMake.
It is responsible for finding the package, checking the version, and producing any needed messages.
Some Find modules provide limited or no support for versioning; check the Find module's documentation.
Find Modules:
https://cmake.org/cmake/help/latest/manual/cmake-developer.7.html#find-modules

The Find<PackageName>.cmake file is not typically provided by the package itself.
Rather, it is normally provided by something external to the package, such as the operating system, CMake itself, or even the project from which the find_package() command was called.

Being externally provided, Find Modules tend to be heuristic in nature and are susceptible to becoming out-of-date. 
They typically search for certain libraries, files and other package artifacts.

Module mode is only supported by the basic command signature.
https://cmake.org/cmake/help/latest/command/find_package.html#basic-signature

2.Config mode:
In this mode, CMake searches for a file called <lowercasePackageName>-config.cmake or <PackageName>Config.cmake.
It will also look for <lowercasePackageName>-config-version.cmake or <PackageName>ConfigVersion.cmake if version details were specified
(see Config Mode Version Selection for an explanation of how these separate version files are used).
https://cmake.org/cmake/help/latest/command/find_package.html#version-selection

In config mode, the command can be given a list of names to search for as package names.
The locations where CMake searches for the config and version files is considerably more complicated than for Module mode (see Config Mode Search Procedure).
https://cmake.org/cmake/help/latest/command/find_package.html#search-procedure

The config and version files are typically installed as part of the package, so they tend to be more reliable than Find modules. 
They usually contain direct knowledge of the package contents, so no searching or heuristics are needed within the config or version files themselves.
Config mode is supported by both the basic and full command signatures.

3.FetchContent redirection mode:
New in version 3.24: A call to find_package() can be redirected internally to a package provided by the FetchContent module.
To the caller, the behavior will appear similar to Config mode, except that the search logic is by-passed and the component information is not used.
See FetchContent_Declare() and FetchContent_MakeAvailable() for further details.

When not redirected to a package provided by FetchContent, the command arguments determine whether Module or Config mode is used. 
When the basic signature is used, the command searches in Module mode first.
If the package is not found, the search falls back to Config mode.
A user may set the CMAKE_FIND_PACKAGE_PREFER_CONFIG variable to true to reverse the priority and direct CMake to search using Config mode first before falling back to Module mode.
The basic signature can also be forced to use only Module mode with a MODULE keyword.
If the full signature is used, the command only searches in Config mode.

Where possible, user code should generally look for packages using the basic signature, since that allows the package to be found with any mode. 
Project maintainers wishing to provide a config package should understand the bigger picture, as explained in Full Signature and all subsequent sections on this page.

----------Basic Signature
find_package(<PackageName> [version] [EXACT] [QUIET] [MODULE]
             [REQUIRED] [[COMPONENTS] [components...]]
             [OPTIONAL_COMPONENTS components...]
             [REGISTRY_VIEW  (64|32|64_32|32_64|HOST|TARGET|BOTH)]
             [GLOBAL]
             [NO_POLICY_SCOPE]
             [BYPASS_PROVIDER])

The basic signature is supported by both Module and Config modes.
The MODULE keyword implies that only Module mode can be used to find the package, with no fallback to Config mode.

Regardless of the mode used, a <PackageName>_FOUND variable will be set to indicate whether the package was found.
When the package is found, package-specific information may be provided through other variables and Imported Targets documented by the package itself.
The QUIET option disables informational messages, including those indicating that the package cannot be found if it is not REQUIRED.
The REQUIRED option stops processing with an error message if the package cannot be found.

A package-specific list of required components may be listed after the COMPONENTS keyword.
If any of these components are not able to be satisfied, the package overall is considered to be not found.
If the REQUIRED option is also present, this is treated as a fatal error, otherwise execution still continues.
As a form of shorthand, if the REQUIRED option is present, the COMPONENTS keyword can be omitted and the required components can be listed directly after REQUIRED.

Additional optional components may be listed after OPTIONAL_COMPONENTS. 
If these cannot be satisfied, the package overall can still be considered found, as long as all required components are satisfied.

The set of available components and their meaning are defined by the target package. 
Formally, it is up to the target package how to interpret the component information given to it, but it should follow the expectations stated above.

New in version 3.24: The REGISTRY_VIEW keyword specifies which registry views should be queried. 
This keyword is only meaningful on Windows platforms and will be ignored on all others.
Formally, it is up to the target package how to interpret the registry view information given to it.

New in version 3.24: Specifying the GLOBAL keyword will promote all imported targets to a global scope in the importing project.
Alternatively, this functionality can be enabled by setting the CMAKE_FIND_PACKAGE_TARGETS_GLOBAL variable.

The [version] argument requests a version with which the package found should be compatible.
There are two possible forms in which it may be specified:
1.A single version with the format major[.minor[.patch[.tweak]]], where each component is a numeric value.
2.A version range with the format versionMin...[<]versionMax where versionMin and versionMax have the same format and constraints on components being integers as the single version. 
By default, both end points are included. By specifying <, the upper end point will be excluded. 
Version ranges are only supported with CMake 3.19 or later.

The EXACT option requests that the version be matched exactly. 
This option is incompatible with the specification of a version range.

If no [version] and/or component list is given to a recursive invocation inside a find-module, the corresponding arguments are forwarded automatically from the outer call (including the EXACT flag for [version]).
Version support is currently provided only on a package-by-package basis (see the Version Selection section below).
When a version range is specified but the package is only designed to expect a single version, the package will ignore the upper end point of the range and only take the single version at the lower end of the range into account.

See the cmake_policy() command documentation for discussion of the NO_POLICY_SCOPE option.
https://cmake.org/cmake/help/latest/command/cmake_policy.html#command:cmake_policy

New in version 3.24: The BYPASS_PROVIDER keyword is only allowed when find_package() is being called by a dependency provider.

----------Full Signature
find_package(<PackageName> [version] [EXACT] [QUIET]
             [REQUIRED] [[COMPONENTS] [components...]]
             [OPTIONAL_COMPONENTS components...]
             [CONFIG|NO_MODULE]
             [GLOBAL]
             [NO_POLICY_SCOPE]
             [BYPASS_PROVIDER]
             [NAMES name1 [name2 ...]]
             [CONFIGS config1 [config2 ...]]
             [HINTS path1 [path2 ... ]]
             [PATHS path1 [path2 ... ]]
             [REGISTRY_VIEW  (64|32|64_32|32_64|HOST|TARGET|BOTH)]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [NO_DEFAULT_PATH]
             [NO_PACKAGE_ROOT_PATH]
             [NO_CMAKE_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_PACKAGE_REGISTRY]
             [NO_CMAKE_BUILDS_PATH] # Deprecated; does nothing.
             [NO_CMAKE_SYSTEM_PATH]
             [NO_CMAKE_INSTALL_PREFIX]
             [NO_CMAKE_SYSTEM_PACKAGE_REGISTRY]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH])

The CONFIG option, the synonymous NO_MODULE option, or the use of options not specified in the basic signature all enforce pure Config mode. 
In pure Config mode, the command skips Module mode search and proceeds at once with Config mode search.

Config mode search attempts to locate a configuration file provided by the package to be found.
A cache entry called <PackageName>_DIR is created to hold the directory containing the file.
By default, the command searches for a package with the name <PackageName>.
If the NAMES option is given, the names following it are used instead of <PackageName>.
The names are also considered when determining whether to redirect the call to a package provided by FetchContent.

The command searches for a file called <PackageName>Config.cmake or <lowercasePackageName>-config.cmake for each name specified.
A replacement set of possible configuration file names may be given using the CONFIGS option.
The Config Mode Search Procedure is specified below.
Once found, any version constraint is checked, and if satisfied, the configuration file is read and processed by CMake.
Since the file is provided by the package it already knows the location of package contents.
The full path to the configuration file is stored in the cmake variable <PackageName>_CONFIG

All configuration files which have been considered by CMake while searching for the package with an appropriate version are stored in the <PackageName>_CONSIDERED_CONFIGS variable,
and the associated versions in the <PackageName>_CONSIDERED_VERSIONS variable.

If the package configuration file cannot be found CMake will generate an error describing the problem unless the QUIET argument is specified.
If REQUIRED is specified and the package is not found a fatal error is generated and the configure step stops executing.
If <PackageName>_DIR has been set to a directory not containing a configuration file CMake will ignore it and search from scratch.

Package maintainers providing CMake package configuration files are encouraged to name and install them such that the Config Mode Search Procedure outlined below will find them without requiring use of additional options.

----------###Config Mode Search Procedure###
Note When Config mode is used, this search procedure is applied regardless of whether the full or basic signature was given.

New in version 3.24: All calls to find_package() (even in Module mode) first look for a config package file in the CMAKE_FIND_PACKAGE_REDIRECTS_DIR directory.
The FetchContent module, or even the project itself, may write files to that location to redirect find_package() calls to content already provided by the project.
If no config package file is found in that location, the search proceeds with the logic described below.

CMake constructs a set of possible installation prefixes for the package.
Under each prefix several directories are searched for a configuration file.
The tables below show the directories searched.
Each entry is meant for installation trees following Windows (W), UNIX (U), or Apple (A) conventions:
Entry
Convention

<prefix>/
W

<prefix>/(cmake|CMake)/
W

<prefix>/<name>*/
W

<prefix>/<name>*/(cmake|CMake)/
W

<prefix>/<name>*/(cmake|CMake)/<name>*/ 1
W

<prefix>/(lib/<arch>|lib*|share)/cmake/<name>*/
U

<prefix>/(lib/<arch>|lib*|share)/<name>*/
U

<prefix>/(lib/<arch>|lib*|share)/<name>*/(cmake|CMake)/
U

<prefix>/<name>*/(lib/<arch>|lib*|share)/cmake/<name>*/
W/U

<prefix>/<name>*/(lib/<arch>|lib*|share)/<name>*/
W/U

<prefix>/<name>*/(lib/<arch>|lib*|share)/<name>*/(cmake|CMake)/
W/U

New in version 3.25.
On systems supporting macOS FRAMEWORK and BUNDLE, the following directories are searched for Frameworks or Application Bundles containing a configuration file:
Entry
Convention

<prefix>/<name>.framework/Resources/
A

<prefix>/<name>.framework/Resources/CMake/
A

<prefix>/<name>.framework/Versions/*/Resources/
A

<prefix>/<name>.framework/Versions/*/Resources/CMake/
A

<prefix>/<name>.app/Contents/Resources/
A

<prefix>/<name>.app/Contents/Resources/CMake/
A

In all cases the <name> is treated as case-insensitive and corresponds to any of the names specified (<PackageName> or names given by NAMES).

Paths with lib/<arch> are enabled if the CMAKE_LIBRARY_ARCHITECTURE variable is set.
lib* includes one or more of the values lib64, lib32, libx32 or lib (searched in that order).
Paths with lib64 are searched on 64 bit platforms if the FIND_LIBRARY_USE_LIB64_PATHS property is set to TRUE.
Paths with lib32 are searched on 32 bit platforms if the FIND_LIBRARY_USE_LIB32_PATHS property is set to TRUE.
Paths with libx32 are searched on platforms using the x32 ABI if the FIND_LIBRARY_USE_LIBX32_PATHS property is set to TRUE.
The lib path is always searched.

Changed in version 3.24: On Windows platform, it is possible to include registry queries as part of the directories specified through HINTS and PATHS keywords, using a dedicated syntax.
Such specifications will be ignored on all other platforms.

New in version 3.24: REGISTRY_VIEW can be specified to manage Windows registry queries specified as part of PATHS and HINTS.

Specify which registry views must be queried.
This option is only meaningful on Windows platforms and will be ignored on other ones.
When not specified, the TARGET view is used when the CMP0134 policy is NEW.
Refer to CMP0134 for the default view when the policy is OLD.
64
Query the 64-bit registry. On 32-bit Windows, it always returns the string /REGISTRY-NOTFOUND.

32
Query the 32-bit registry.

64_32
Query both views (64 and 32) and generate a path for each.

32_64
Query both views (32 and 64) and generate a path for each.

HOST
Query the registry matching the architecture of the host: 64 on 64-bit Windows and 32 on 32-bit Windows.

TARGET
Query the registry matching the architecture specified by the CMAKE_SIZEOF_VOID_P variable. If not defined, fall back to HOST view.

BOTH
Query both views (32 and 64). The order depends on the following rules: If the CMAKE_SIZEOF_VOID_P variable is defined, use the following view depending on the content of this variable:
8: 64_32
4: 32_64
If the CMAKE_SIZEOF_VOID_P variable is not defined, rely on the architecture of the host:
64-bit: 64_32
32-bit: 32

If PATH_SUFFIXES is specified, the suffixes are appended to each (W) or (U) directory entry one-by-one.

This set of directories is intended to work in cooperation with projects that provide configuration files in their installation trees.
Directories above marked with (W) are intended for installations on Windows where the prefix may point at the top of an application's installation directory.
Those marked with (U) are intended for installations on UNIX platforms where the prefix is shared by multiple packages.
This is merely a convention, so all (W) and (U) directories are still searched on all platforms. 
Directories marked with (A) are intended for installations on Apple platforms. The CMAKE_FIND_FRAMEWORK and CMAKE_FIND_APPBUNDLE variables determine the order of preference.

The set of installation prefixes is constructed using the following steps. If NO_DEFAULT_PATH is specified all NO_* options are enabled.
1.New in version 3.12: Search paths specified in the <PackageName>_ROOT CMake variable and the <PackageName>_ROOT environment variable, where <PackageName> is the package to be found. 
The package root variables are maintained as a stack so if called from within a find module, root paths from the parent's find module will also be searched after paths for the current package.
This can be skipped if NO_PACKAGE_ROOT_PATH is passed or by setting the CMAKE_FIND_USE_PACKAGE_ROOT_PATH to FALSE. See policy CMP0074.

2.Search paths specified in cmake-specific cache variables.
These are intended to be used on the command line with a -DVAR=VALUE.
The values are interpreted as semicolon-separated lists.
This can be skipped if NO_CMAKE_PATH is passed or by setting the CMAKE_FIND_USE_CMAKE_PATH to FALSE:
CMAKE_PREFIX_PATH
CMAKE_FRAMEWORK_PATH
CMAKE_APPBUNDLE_PATH

3.Search paths specified in cmake-specific environment variables.
These are intended to be set in the user's shell configuration, and therefore use the host's native path separator (; on Windows and : on UNIX).
This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed or by setting the CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH to FALSE:
<PackageName>_DIR
CMAKE_PREFIX_PATH
CMAKE_FRAMEWORK_PATH
CMAKE_APPBUNDLE_PATH

4.Search paths specified by the HINTS option.
These should be paths computed by system introspection, such as a hint provided by the location of another item already found.
Hard-coded guesses should be specified with the PATHS option.

5.Search the standard system environment variables.
This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is passed or by setting the CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH to FALSE.
Path entries ending in /bin or /sbin are automatically converted to their parent directories:
PATH

6.Search paths stored in the CMake User Package Registry.
This can be skipped if NO_CMAKE_PACKAGE_REGISTRY is passed or by setting the variable CMAKE_FIND_USE_PACKAGE_REGISTRY to FALSE or the deprecated variable CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY to TRUE.
See the cmake-packages(7) manual for details on the user package registry.

7.Search cmake variables defined in the Platform files for the current system.
The searching of CMAKE_INSTALL_PREFIX and CMAKE_STAGING_PREFIX can be skipped if NO_CMAKE_INSTALL_PREFIX is passed or by setting the CMAKE_FIND_USE_INSTALL_PREFIX to FALSE.
All these locations can be skipped if NO_CMAKE_SYSTEM_PATH is passed or by setting the CMAKE_FIND_USE_CMAKE_SYSTEM_PATH to FALSE:
CMAKE_SYSTEM_PREFIX_PATH
CMAKE_SYSTEM_FRAMEWORK_PATH
CMAKE_SYSTEM_APPBUNDLE_PATH
The platform paths that these variables contain are locations that typically include installed software. An example being /usr/local for UNIX based platforms.

8.Search paths stored in the CMake System Package Registry.
This can be skipped if NO_CMAKE_SYSTEM_PACKAGE_REGISTRY is passed or by setting the CMAKE_FIND_USE_SYSTEM_PACKAGE_REGISTRY variable to FALSE or the deprecated variable CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY to TRUE.
See the cmake-packages(7) manual for details on the system package registry.

9.Search paths specified by the PATHS option. These are typically hard-coded guesses.

The CMAKE_IGNORE_PATH, CMAKE_IGNORE_PREFIX_PATH, CMAKE_SYSTEM_IGNORE_PATH and CMAKE_SYSTEM_IGNORE_PREFIX_PATH variables can also cause some of the above locations to be ignored.

New in version 3.16: Added the CMAKE_FIND_USE_<CATEGORY> variables to globally disable various search locations.

The CMake variable CMAKE_FIND_ROOT_PATH specifies one or more directories to be prepended to all other search directories.
This effectively "re-roots" the entire search under given locations.
Paths which are descendants of the CMAKE_STAGING_PREFIX are excluded from this re-rooting, because that variable is always a path on the host system.
By default the CMAKE_FIND_ROOT_PATH is empty.

The CMAKE_SYSROOT variable can also be used to specify exactly one directory to use as a prefix.
Setting CMAKE_SYSROOT also has other effects. See the documentation for that variable for more.

These variables are especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too.
By default at first the directories listed in CMAKE_FIND_ROOT_PATH are searched, then the CMAKE_SYSROOT directory is searched, and then the non-rooted directories will be searched.
The default behavior can be adjusted by setting CMAKE_FIND_ROOT_PATH_MODE_PACKAGE.
This behavior can be manually overridden on a per-call basis using options:
CMAKE_FIND_ROOT_PATH_BOTH
Search in the order described above.
NO_CMAKE_FIND_ROOT_PATH
Do not use the CMAKE_FIND_ROOT_PATH variable.
ONLY_CMAKE_FIND_ROOT_PATH
Search only the re-rooted directories and directories below CMAKE_STAGING_PREFIX.

The default search order is designed to be most-specific to least-specific for common use cases.
Projects may override the order by simply calling the command multiple times and using the NO_* options:
find_package (<PackageName> PATHS paths... NO_DEFAULT_PATH)
find_package (<PackageName>)
Once one of the calls succeeds the result variable will be set and stored in the cache so that no call will search again.

By default the value stored in the result variable will be the path at which the file is found.
The CMAKE_FIND_PACKAGE_RESOLVE_SYMLINKS variable may be set to TRUE before calling find_package in order to resolve symbolic links and store the real path to the file.

Every non-REQUIRED find_package call can be disabled or made REQUIRED:
Setting the CMAKE_DISABLE_FIND_PACKAGE_<PackageName> variable to TRUE disables the package. This also disables redirection to a package provided by FetchContent.
Setting the CMAKE_REQUIRE_FIND_PACKAGE_<PackageName> variable to TRUE makes the package REQUIRED.
Setting both variables to TRUE simultaneously is an error.

----------###Config Mode Version Selection###
Note When Config mode is used, this version selection process is applied regardless of whether the full or basic signature was given.

When the [version] argument is given, Config mode will only find a version of the package that claims compatibility with the requested version (see format specification).
If the EXACT option is given, only a version of the package claiming an exact match of the requested version may be found.
CMake does not establish any convention for the meaning of version numbers.
Package version numbers are checked by "version" files provided by the packages themselves or by FetchContent.
For a candidate package configuration file <config-file>.cmake the corresponding version file is located next to it and named either <config-file>-version.cmake or <config-file>Version.cmake.
If no such version file is available then the configuration file is assumed to not be compatible with any requested version.
A basic version file containing generic version matching code can be created using the CMakePackageConfigHelpers module.
When a version file is found it is loaded to check the requested version number.
The version file is loaded in a nested scope in which the following variables have been defined:

PACKAGE_FIND_NAME
The <PackageName>

PACKAGE_FIND_VERSION
Full requested version string

PACKAGE_FIND_VERSION_MAJOR
Major version if requested, else 0

PACKAGE_FIND_VERSION_MINOR
Minor version if requested, else 0

PACKAGE_FIND_VERSION_PATCH
Patch version if requested, else 0

PACKAGE_FIND_VERSION_TWEAK
Tweak version if requested, else 0

PACKAGE_FIND_VERSION_COUNT
Number of version components, 0 to 4
When a version range is specified, the above version variables will hold values based on the lower end of the version range.
This is to preserve compatibility with packages that have not been implemented to expect version ranges.
In addition, the version range will be described by the following variables:

PACKAGE_FIND_VERSION_RANGE
Full requested version range string

PACKAGE_FIND_VERSION_RANGE_MIN
This specifies whether the lower end point of the version range should be included or excluded. Currently, the only supported value for this variable is INCLUDE.

PACKAGE_FIND_VERSION_RANGE_MAX
This specifies whether the upper end point of the version range should be included or excluded. The supported values for this variable are INCLUDE and EXCLUDE.

PACKAGE_FIND_VERSION_MIN
Full requested version string of the lower end point of the range

PACKAGE_FIND_VERSION_MIN_MAJOR
Major version of the lower end point if requested, else 0

PACKAGE_FIND_VERSION_MIN_MINOR
Minor version of the lower end point if requested, else 0

PACKAGE_FIND_VERSION_MIN_PATCH
Patch version of the lower end point if requested, else 0

PACKAGE_FIND_VERSION_MIN_TWEAK
Tweak version of the lower end point if requested, else 0

PACKAGE_FIND_VERSION_MIN_COUNT
Number of version components of the lower end point, 0 to 4

PACKAGE_FIND_VERSION_MAX
Full requested version string of the upper end point of the range

PACKAGE_FIND_VERSION_MAX_MAJOR
Major version of the upper end point if requested, else 0

PACKAGE_FIND_VERSION_MAX_MINOR
Minor version of the upper end point if requested, else 0

PACKAGE_FIND_VERSION_MAX_PATCH
Patch version of the upper end point if requested, else 0

PACKAGE_FIND_VERSION_MAX_TWEAK
Tweak version of the upper end point if requested, else 0

PACKAGE_FIND_VERSION_MAX_COUNT
Number of version components of the upper end point, 0 to 4

Regardless of whether a single version or a version range is specified, the variable PACKAGE_FIND_VERSION_COMPLETE will be defined and will hold the full requested version string as specified.

The version file checks whether it satisfies the requested version and sets these variables:

PACKAGE_VERSION
Full provided version string

PACKAGE_VERSION_EXACT
True if version is exact match

PACKAGE_VERSION_COMPATIBLE
True if version is compatible

PACKAGE_VERSION_UNSUITABLE
True if unsuitable as any version

These variables are checked by the find_package command to determine whether the configuration file provides an acceptable version.
They are not available after the find_package call returns. If the version is acceptable the following variables are set:

<PackageName>_VERSION
Full provided version string

<PackageName>_VERSION_MAJOR
Major version if provided, else 0

<PackageName>_VERSION_MINOR
Minor version if provided, else 0

<PackageName>_VERSION_PATCH
Patch version if provided, else 0

<PackageName>_VERSION_TWEAK
Tweak version if provided, else 0

<PackageName>_VERSION_COUNT
Number of version components, 0 to 4

and the corresponding package configuration file is loaded. 
When multiple package configuration files are available whose version files claim compatibility with the version requested it is unspecified which one is chosen: 
unless the variable CMAKE_FIND_PACKAGE_SORT_ORDER is set no attempt is made to choose a highest or closest version number.

To control the order in which find_package checks for compatibility use the two variables CMAKE_FIND_PACKAGE_SORT_ORDER and CMAKE_FIND_PACKAGE_SORT_DIRECTION.
For instance in order to select the highest version one can set
SET(CMAKE_FIND_PACKAGE_SORT_ORDER NATURAL)
SET(CMAKE_FIND_PACKAGE_SORT_DIRECTION DEC)
before calling find_package.

----------Package File Interface Variables
When loading a find module or package configuration file find_package defines variables to provide information about the call arguments (and restores their original state before returning):

CMAKE_FIND_PACKAGE_NAME
The <PackageName> which is searched for

<PackageName>_FIND_REQUIRED
True if REQUIRED option was given

<PackageName>_FIND_QUIETLY
True if QUIET option was given

<PackageName>_FIND_REGISTRY_VIEW
The requested view if REGISTRY_VIEW option was given

<PackageName>_FIND_VERSION
Full requested version string

<PackageName>_FIND_VERSION_MAJOR
Major version if requested, else 0

<PackageName>_FIND_VERSION_MINOR
Minor version if requested, else 0

<PackageName>_FIND_VERSION_PATCH
Patch version if requested, else 0

<PackageName>_FIND_VERSION_TWEAK
Tweak version if requested, else 0

<PackageName>_FIND_VERSION_COUNT
Number of version components, 0 to 4

<PackageName>_FIND_VERSION_EXACT
True if EXACT option was given

<PackageName>_FIND_COMPONENTS
List of specified components (required and optional)

<PackageName>_FIND_REQUIRED_<c>
True if component <c> is required, false if component <c> is optional

When a version range is specified, the above version variables will hold values based on the lower end of the version range. This is to preserve compatibility with packages that have not been implemented to expect version ranges. In addition, the version range will be described by the following variables:

<PackageName>_FIND_VERSION_RANGE
Full requested version range string

<PackageName>_FIND_VERSION_RANGE_MIN
This specifies whether the lower end point of the version range is included or excluded. Currently, INCLUDE is the only supported value.

<PackageName>_FIND_VERSION_RANGE_MAX
This specifies whether the upper end point of the version range is included or excluded. The possible values for this variable are INCLUDE or EXCLUDE.

<PackageName>_FIND_VERSION_MIN
Full requested version string of the lower end point of the range

<PackageName>_FIND_VERSION_MIN_MAJOR
Major version of the lower end point if requested, else 0

<PackageName>_FIND_VERSION_MIN_MINOR
Minor version of the lower end point if requested, else 0

<PackageName>_FIND_VERSION_MIN_PATCH
Patch version of the lower end point if requested, else 0

<PackageName>_FIND_VERSION_MIN_TWEAK
Tweak version of the lower end point if requested, else 0

<PackageName>_FIND_VERSION_MIN_COUNT
Number of version components of the lower end point, 0 to 4

<PackageName>_FIND_VERSION_MAX
Full requested version string of the upper end point of the range

<PackageName>_FIND_VERSION_MAX_MAJOR
Major version of the upper end point if requested, else 0

<PackageName>_FIND_VERSION_MAX_MINOR
Minor version of the upper end point if requested, else 0

<PackageName>_FIND_VERSION_MAX_PATCH
Patch version of the upper end point if requested, else 0

<PackageName>_FIND_VERSION_MAX_TWEAK
Tweak version of the upper end point if requested, else 0

<PackageName>_FIND_VERSION_MAX_COUNT
Number of version components of the upper end point, 0 to 4