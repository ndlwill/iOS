https://clang.llvm.org/

https://clang.llvm.org/docs/index.html#

Clang: a C language family frontend for LLVM
The Clang project provides a language front-end and tooling infrastructure for languages in the C language family (C, C++, Objective C/C++, OpenCL, CUDA, and RenderScript) for the LLVM project.

LibClang:
LibClang is a stable high level C interface to clang. When in doubt LibClang is probably the interface you want to use. Consider the other interfaces only when you have a good reason not to use LibClang.

LibTooling:
LibTooling is a C++ interface aimed at writing standalone tools, as well as integrating into services that run clang tools.
Clang tools are a collection of specific developer tools built on top of the LibTooling infrastructure as part of the Clang project. 
They are targeted at automating and improving core development activities of C/C++ developers.
Examples of tools we are building or planning as part of the Clang project:
Syntax checking (clang-check)
Automatic fixing of compile errors (clang-fixit)
Automatic code formatting (clang-format)

==================================================Getting Started: Building and Running Clang
从github下载完llvm项目llvm-project-main后，不知道如何构建llvm和clang的话，可以进入到llvm和clang的目录，先看下里面的readme文件，非常重要！

https://clang.llvm.org/get_started.html

This is a compiler front-end for the C family of languages (C, C++, Objective-C, and Objective-C++) which is built as part of the LLVM compiler infrastructure project.
Clang is designed to be built as part of an LLVM build.
Information on Clang:             http://clang.llvm.org/
Building and using Clang:         http://clang.llvm.org/get_started.html
Clang Static Analyzer:            http://clang-analyzer.llvm.org/
Information on the LLVM project:  http://llvm.org/

Clang is also provided in all major BSD or GNU/Linux distributions as part of their respective packaging systems. From Xcode 4.2, Clang is the default compiler for Mac OS X.

Building Clang and Working with the Code
On Unix-like Systems:
If you would like to check out and build Clang, the current procedure is as follows:

1. Get the required tools.
See Getting Started with the LLVM System - Requirements. https://llvm.org/docs/GettingStarted.html#requirements
Note also that Python is needed for running the test suite. Get it at: https://www.python.org/downloads/
Standard build process uses CMake. Get it at: https://cmake.org/download/

2. Check out the LLVM project:
Change directory to where you want the llvm directory placed.
git clone https://github.com/llvm/llvm-project.git
The above command is very slow. It can be made faster by creating a shallow clone. Shallow clone saves storage and speeds up the checkout time. This is done by using the command:
git clone --depth=1 https://github.com/llvm/llvm-project.git (using this only the latest version of llvm can be built)
For normal users looking to just compile, this command works fine. But if someone later becomes a contributor, since they can't push code from a shallow clone, it needs to be converted into a full clone:
cd llvm-project
git fetch --unshallow

3. Build LLVM and Clang:
cd llvm-project
mkdir build (in-tree build is not supported)
cd build
This builds both LLVM and Clang in release mode. Alternatively, if you need a debug build, switch Release to Debug. See frequently used cmake variables for more options.
cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G "Unix Makefiles" ../llvm
make
Note: For subsequent Clang development, you can just run make clang.
CMake allows you to generate project files for several IDEs: Xcode, Eclipse CDT4, CodeBlocks, Qt-Creator (use the CodeBlocks generator), KDevelop3. 
For more details see Building LLVM with CMake page.
https://llvm.org/docs/CMake.html

4. If you intend to use Clang's C++ support, you may need to tell it how to find your C++ standard library headers. 
In general, Clang will detect the best version of libstdc++ headers available and use them - it will look both for system installations of libstdc++ as well as installations adjacent to Clang itself. 
If your configuration fits neither of these scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option to tell Clang where the gcc containing the desired libstdc++ is installed.

5. Try it out (assuming you add llvm/build/bin to your path):
clang --help
clang file.c -fsyntax-only (check for correctness)
clang file.c -S -emit-llvm -o - (print out unoptimized llvm code)
clang file.c -S -emit-llvm -o - -O3
clang file.c -S -O3 -o - (output native machine code)

6. Run the testsuite:
make check-clang


==================================================https://clang.llvm.org/docs/UsersManual.html#terminology
Command Line Options:
1. Options to Control Error and Warning Messages


==================================================Clang AST
https://clang.llvm.org/docs/IntroductionToTheClangAST.html

Clang’s AST is different from ASTs produced by some other compilers in that it closely resembles both the written C++ code and the C++ standard. 
For example, parenthesis expressions and compile time constants are available in an unreduced form in the AST.

A good way to familiarize yourself with the Clang AST is to actually look at it on some simple example code. 
Clang has a builtin AST-dump mode, which can be enabled with the flag -ast-dump.

$ cat test.cc
int f(int x) {
  int result = (x / 42);
  return result;
}

# Clang by default is a frontend for many tools; -Xclang is used to pass
# options directly to the C++ frontend.
$ clang -Xclang -ast-dump -fsyntax-only test.cc
TranslationUnitDecl 0x5aea0d0 <<invalid sloc>>
... cutting out internal declarations of clang ...
`-FunctionDecl 0x5aeab50 <test.cc:1:1, line:4:1> f 'int (int)'
  |-ParmVarDecl 0x5aeaa90 <line:1:7, col:11> x 'int'
  `-CompoundStmt 0x5aead88 <col:14, line:4:1>
    |-DeclStmt 0x5aead10 <line:2:3, col:24>
    | `-VarDecl 0x5aeac10 <col:3, col:23> result 'int'
    |   `-ParenExpr 0x5aeacf0 <col:16, col:23> 'int'
    |     `-BinaryOperator 0x5aeacc8 <col:17, col:21> 'int' '/'
    |       |-ImplicitCastExpr 0x5aeacb0 <col:17> 'int' <LValueToRValue>
    |       | `-DeclRefExpr 0x5aeac68 <col:17> 'int' lvalue ParmVar 0x5aeaa90 'x' 'int'
    |       `-IntegerLiteral 0x5aeac90 <col:21> 'int' 42
    `-ReturnStmt 0x5aead68 <line:3:3, col:10>
      `-ImplicitCastExpr 0x5aead50 <col:10> 'int' <LValueToRValue>
        `-DeclRefExpr 0x5aead28 <col:10> 'int' lvalue Var 0x5aeac10 'result' 'int'

The toplevel declaration in a translation unit is always the translation unit declaration.
In this example, our first user written declaration is the function declaration of “f”. 
The body of “f” is a compound statement, whose child nodes are a declaration statement that declares our result variable, and the return statement.

AST Context:
All information about the AST for a translation unit is bundled up in the class ASTContext. 
It allows traversal of the whole translation unit starting from getTranslationUnitDecl, or to access Clang’s table of identifiers for the parsed translation unit.

AST Nodes:
Clang’s AST nodes are modeled on a class hierarchy that does not have a common ancestor. 
Instead, there are multiple larger hierarchies for basic node types like Decl and Stmt. 
Many important AST nodes derive from Type, Decl, DeclContext or Stmt, with some classes deriving from both Decl and DeclContext.

There are also a multitude of nodes in the AST that are not part of a larger hierarchy, and are only reachable from specific other nodes, like CXXBaseSpecifier.

Thus, to traverse the full AST, one starts from the TranslationUnitDecl and then recursively traverses everything that can be reached from that node - this information has to be encoded for each specific node type. 
This algorithm is encoded in the RecursiveASTVisitor.

The two most basic nodes in the Clang AST are statements (Stmt) and declarations (Decl). 
Note that expressions (Expr) are also statements in Clang’s AST.

==================================================LibTooling
For the information on how to setup Clang Tooling for LLVM see How To Setup Clang Tooling For LLVM

LibTooling is a library to support writing standalone tools based on Clang. 
This will provide a basic walkthrough of how to write a tool using LibTooling.

If you ever wanted to run a FrontendAction over some sample code, for example to unit test parts of the Clang AST, runToolOnCode is what you looked for. 
Let me give you an example:
#include "clang/Tooling/Tooling.h"

TEST(runToolOnCode, CanSyntaxCheckCode) {
  // runToolOnCode returns whether the action was correctly run over the
  // given code.
  EXPECT_TRUE(runToolOnCode(std::make_unique<clang::SyntaxOnlyAction>(), "class X {};"));
}


==================================================How To Setup Clang Tooling For LLVM:
Clang Tooling needs a compilation database to figure out specific build options for each file. 
Currently it can create a compilation database from the compile_commands.json file, generated by CMake. 
When invoking clang tools, you can either specify a path to a build directory using a command line parameter -p or let Clang Tooling find this file in your source tree. 
In either case you need to configure your build using CMake to use clang tools.


CMake：
构建配置工具：CMake 是一个跨平台的构建配置工具，用于生成适用于不同编译器和操作系统的构建文件。
生成构建系统：CMake 会生成用于构建项目的 Makefile、Visual Studio 项目文件或其他构建系统的配置文件。
Make：
构建工具：Make 是一个构建工具，用于执行构建过程，通常通过读取 Makefile 中的规则来构建项目。
自动化构建：Make 可以自动化执行编译、链接和其他构建任务，以确保项目的可执行文件或库得以创建。


clang 和 clang++ 都是 Clang 编译器家族的一部分，它们用于编译 C 和 C++ 程序，但它们之间有一些关键区别：
语言支持：
clang 是 Clang 编译器家族中的 C 编译器，用于编译 C 语言程序。
clang++ 是 Clang 编译器家族中的 C++ 编译器，用于编译 C++ 语言程序。

默认链接器：
clang 通常会将生成的目标文件链接到 C 标准库（如 libc）。
clang++ 通常会将生成的目标文件链接到 C++ 标准库（如 libstdc++ 或 libc++）。

标准库支持：
clang 针对 C 语言提供了对应的标准库支持。
clang++ 针对 C++ 语言提供了对应的标准库支持，包括 C++ 标准模板库（STL）。

语法检查：
clang 和 clang++ 都使用 Clang 静态分析器来执行语法和语义检查，但在检查 C 和 C++ 代码时可能会有一些差异。


make check-all 是一个常见的用于构建和测试软件项目的命令。具体含义取决于项目的 Makefile 或构建系统的设置。
一般情况下，make check-all 做以下几件事情：
构建项目：它将编译项目的源代码，生成可执行文件或库文件。
运行测试：它执行项目中的测试套件，这些测试套件通常包括单元测试、集成测试和功能测试。测试用例将检查代码的不同部分，确保其行为符合预期。
报告结果：测试运行后，make check-all 通常会生成测试报告，告诉你哪些测试通过了，哪些失败了。

----------Setup Clang Tooling Using CMake and Make: ###(已验证成功)###
First, you need to generate Makefiles for LLVM with CMake. You need to make a build directory and run CMake from it:
mkdir llvm-project-main/build
cd build
// CMAKE_EXPORT_COMPILE_COMMANDS: Generate a CompilationDatabase (compile_commands.json file)
cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=XX -DLLVM_ENABLE_PROJECTS="clang" llvm文件夹路径 // -DCMAKE_BUILD_TYPE=Release
cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=/Users/youdun-ndl/Desktop/llvm/llvm-project-main/installation -DLLVM_ENABLE_PROJECTS="clang" /Users/youdun-ndl/Desktop/llvm/llvm-project-main/llvm

If you want to use clang instead of GCC, you can add -DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++. 
You can also use ccmake, which provides a curses interface to configure CMake variables.

As a result, the new compile_commands.json file should appear in the current directory. 
You should link it to the LLVM source tree so that Clang Tooling is able to use it:
ln -s $PWD/compile_commands.json llvm文件夹路径
ln -s $PWD/compile_commands.json /Users/youdun-ndl/Desktop/llvm/llvm-project-main/llvm

Now you are ready to build and test LLVM using make:
make check-all (有问题就分别执行make和make install，已验证需要使用括号内的命令)

https://clang.llvm.org/docs/HowToSetupToolingForLLVM.html
Optionally you can use the Ninja build system instead of make.

----------Using Clang Tools
After you completed the previous steps, you are ready to run clang tools. 
If you have a recent clang installed, you should have clang-check in $PATH. 
###
Try to run it on any .cpp file inside the LLVM source tree:
###

clang-check tools/clang/lib/Tooling/CompilationDatabase.cpp --ast-print

Other clang-check options that can be useful when working with clang AST:
-ast-print — Build ASTs and then pretty-print them.
-ast-dump — Build ASTs and then debug dump them.
-ast-dump-filter=<string> — Use with -ast-dump or -ast-print to dump/print only AST declaration nodes having a certain substring in a qualified name. Use -ast-list to list all filterable declaration node names.
-ast-list — Build ASTs and print the list of declaration node qualified names.

Examples:
clang-check tools/clang/tools/clang-check/ClangCheck.cpp -ast-dump -ast-dump-filter ActionFactory::newASTConsumer
Processing: tools/clang/tools/clang-check/ClangCheck.cpp.
Dumping ::ActionFactory::newASTConsumer:
clang::ASTConsumer *newASTConsumer() (CompoundStmt 0x44da290 </home/alexfh/local/llvm/tools/clang/tools/clang-check/ClangCheck.cpp:64:40, line:72:3>
  (IfStmt 0x44d97c8 <line:65:5, line:66:45>
    <<<NULL>>>
      (ImplicitCastExpr 0x44d96d0 <line:65:9> '_Bool' <UserDefinedConversion>
...

==================================================LibClang
The C Interface to Clang provides a relatively small API that exposes facilities for parsing source code into an abstract syntax tree (AST), 
loading already-parsed ASTs, traversing the AST, associating physical source locations with elements within the AST, 
and other facilities that support Clang-based development tools.

All types of libclang are prefixed with CX

CXIndex
An Index that consists of a set of translation units that would typically be linked together into an executable or library.

CXTranslationUnit
A single translation unit, which resides in an index.

CXCursor
A cursor representing a pointer to some element in the abstract syntax tree of a translation unit.

Code example:
// file.cpp
struct foo{
  int bar;
  int* bar_pointer;
};

#include <clang-c/Index.h>
#include <iostream>

int main(){
  CXIndex index = clang_createIndex(0, 0); //Create index
  CXTranslationUnit unit = clang_parseTranslationUnit(
    index,
    "file.cpp", nullptr, 0,
    nullptr, 0,
    CXTranslationUnit_None); //Parse "file.cpp"


  if (unit == nullptr){
    std::cerr << "Unable to parse translation unit. Quitting.\n";
    return 0;
  }
  CXCursor cursor = clang_getTranslationUnitCursor(unit); //Obtain a cursor at the root of the translation unit
}

Visiting elements of an AST:
The elements of an AST can be recursively visited with pre-order traversal with clang_visitChildren.
clang_visitChildren(
  cursor, //Root cursor
  [](CXCursor current_cursor, CXCursor parent, CXClientData client_data){

    CXString current_display_name = clang_getCursorDisplayName(current_cursor);
    //Allocate a CXString representing the name of the current cursor

    std::cout << "Visiting element " << clang_getCString(current_display_name) << "\n";
    //Print the char* value of current_display_name

    clang_disposeString(current_display_name);
    //Since clang_getCursorDisplayName allocates a new CXString, it must be freed. This applies
    //to all functions returning a CXString

    return CXChildVisit_Recurse;


  }, //CXCursorVisitor: a function pointer
  nullptr //client_data
  );

The return value of CXCursorVisitor, the callable argument of clang_visitChildren, can return one of the three:
CXChildVisit_Break: Terminates the cursor traversal
CXChildVisit_Continue: Continues the cursor traversal with the next sibling of the cursor just visited, without visiting its children.
CXChildVisit_Recurse: Recursively traverse the children of this cursor, using the same visitor and client data

The expected output of that program is
Visiting element foo
Visiting element bar
Visiting element bar_pointer

Extracting information from a Cursor:

1. Extracting the Cursor kind
CXCursorKind clang_getCursorKind(CXCursor) Describes the kind of entity that a cursor refers to. Example values:
CXCursor_StructDecl: A C or C++ struct.
CXCursor_FieldDecl: A field in a struct, union, or C++ class.
CXCursor_CallExpr: An expression that calls a function.

2. Extracting the Cursor type
CXType clang_getCursorType(CXCursor): Retrieve the type of a CXCursor (if any).
A CXType represents a complete C++ type, including qualifiers and pointers. 
It has a member field CXTypeKind kind and additional opaque data.

Example values for CXTypeKind kind
CXType_Invalid: Represents an invalid type (e.g., where no type is available)
CXType_Pointer: A pointer to another type
CXType_Int: Regular int
CXType_Elaborated: Represents a type that was referred to using an elaborated type keyword e.g. struct S, or via a qualified name, e.g., N::M::type, or both.

Any CXTypeKind can be converted to a CXString using clang_getTypeKindSpelling(CXTypeKind).

A CXType holds additional necessary opaque type info, such as:
Which struct was referred to?
What type is the pointer pointing to?
Qualifiers (e.g. const, volatile)?

Qualifiers of a CXType can be queried with:
clang_isConstQualifiedType(CXType) to check for const
clang_isRestrictQualifiedType(CXType) to check for restrict
clang_isVolatileQualifiedType(CXType) to check for volatile

Code example:
//structs.cpp
struct A{
  int value;
};
struct B{
  int value;
  A struct_value;
};

#include <clang-c/Index.h>
#include <iostream>

int main(){
  CXIndex index = clang_createIndex(0, 0); //Create index
  CXTranslationUnit unit = clang_parseTranslationUnit(
    index,
    "structs.cpp", nullptr, 0,
    nullptr, 0,
    CXTranslationUnit_None); //Parse "structs.cpp"

  if (unit == nullptr){
    std::cerr << "Unable to parse translation unit. Quitting.\n";
    return 0;
  }
  CXCursor cursor = clang_getTranslationUnitCursor(unit); //Obtain a cursor at the root of the translation unit

  clang_visitChildren(
  cursor,
  [](CXCursor current_cursor, CXCursor parent, CXClientData client_data){
    CXType cursor_type = clang_getCursorType(current_cursor);

    CXString type_kind_spelling = clang_getTypeKindSpelling(cursor_type.kind);
    std::cout << "Type Kind: " << clang_getCString(type_kind_spelling);
    clang_disposeString(type_kind_spelling);

    if(cursor_type.kind == CXType_Pointer ||                     // If cursor_type is a pointer
      cursor_type.kind == CXType_LValueReference ||              // or an LValue Reference (&)
      cursor_type.kind == CXType_RValueReference){               // or an RValue Reference (&&),
      CXType pointed_to_type = clang_getPointeeType(cursor_type);// retrieve the pointed-to type

      CXString pointed_to_type_spelling = clang_getTypeSpelling(pointed_to_type);     // Spell out the entire
      std::cout << "pointing to type: " << clang_getCString(pointed_to_type_spelling);// pointed-to type
      clang_disposeString(pointed_to_type_spelling);
    }
    else if(cursor_type.kind == CXType_Record){
      CXString type_spelling = clang_getTypeSpelling(cursor_type);
      std::cout <<  ", namely " << clang_getCString(type_spelling);
      clang_disposeString(type_spelling);
    }
    std::cout << "\n";
    return CXChildVisit_Recurse;
  },
  nullptr
  );

The expected output of program is:

Type Kind: Record, namely A
Type Kind: Int
Type Kind: Record, namely B
Type Kind: Int
Type Kind: Record, namely A
Type Kind: Record, namely A

Reiterating the difference between CXType and CXTypeKind: For an example
const char* __restrict__ variable;
Type Kind will be: CXType_Pointer spelled "Pointer"
Type will be a complex CXType structure, spelled "const char* __restrict__

----------Retrieving source locations
CXSourceRange clang_getCursorExtent(CXCursor) returns a CXSourceRange, representing a half-open range in the source code.
Use clang_getRangeStart(CXSourceRange) and clang_getRangeEnd(CXSourceRange) to retrieve the starting and end CXSourceLocation from a source range, respectively.
Given a CXSourceLocation, use clang_getExpansionLocation to retrieve file, line and column of a source location.

Code example
// Again, file.cpp
struct foo{
  int bar;
  int* bar_pointer;
};

clang_visitChildren(
  cursor,
  [](CXCursor current_cursor, CXCursor parent, CXClientData client_data){

    CXType cursor_type = clang_getCursorType(current_cursor);
    CXString cursor_spelling = clang_getCursorSpelling(current_cursor);
    CXSourceRange cursor_range = clang_getCursorExtent(current_cursor);
    std::cout << "Cursor " << clang_getCString(cursor_spelling);

    CXFile file;
    unsigned start_line, start_column, start_offset;
    unsigned end_line, end_column, end_offset;

    clang_getExpansionLocation(clang_getRangeStart(cursor_range), &file, &start_line, &start_column, &start_offset);
    clang_getExpansionLocation(clang_getRangeEnd  (cursor_range), &file, &end_line  , &end_column  , &end_offset);
    std::cout << " spanning lines " << start_line << " to " << end_line;
    clang_disposeString(cursor_spelling);

    std::cout << "\n";
    return CXChildVisit_Recurse;
  },
  nullptr
);

The expected output of this program is:

Cursor foo spanning lines 2 to 5
Cursor bar spanning lines 3 to 3
Cursor bar_pointer spanning lines 4 to 4

----------Complete example code
#include <clang-c/Index.h>
#include <iostream>

int main(){
  CXIndex index = clang_createIndex(0, 0); //Create index
  CXTranslationUnit unit = clang_parseTranslationUnit(
    index,
    "file.cpp", nullptr, 0,
    nullptr, 0,
    CXTranslationUnit_None); //Parse "file.cpp"

  if (unit == nullptr){
    std::cerr << "Unable to parse translation unit. Quitting.\n";
    return 0;
  }
  CXCursor cursor = clang_getTranslationUnitCursor(unit); //Obtain a cursor at the root of the translation unit


  clang_visitChildren(
  cursor,
  [](CXCursor current_cursor, CXCursor parent, CXClientData client_data){
    CXType cursor_type = clang_getCursorType(current_cursor);

    CXString type_kind_spelling = clang_getTypeKindSpelling(cursor_type.kind);
    std::cout << "TypeKind: " << clang_getCString(type_kind_spelling);
    clang_disposeString(type_kind_spelling);

    if(cursor_type.kind == CXType_Pointer ||                     // If cursor_type is a pointer
      cursor_type.kind == CXType_LValueReference ||              // or an LValue Reference (&)
      cursor_type.kind == CXType_RValueReference){               // or an RValue Reference (&&),
      CXType pointed_to_type = clang_getPointeeType(cursor_type);// retrieve the pointed-to type

      CXString pointed_to_type_spelling = clang_getTypeSpelling(pointed_to_type);     // Spell out the entire
      std::cout << "pointing to type: " << clang_getCString(pointed_to_type_spelling);// pointed-to type
      clang_disposeString(pointed_to_type_spelling);
    }
    else if(cursor_type.kind == CXType_Record){
      CXString type_spelling = clang_getTypeSpelling(cursor_type);
      std::cout <<  ", namely " << clang_getCString(type_spelling);
      clang_disposeString(type_spelling);
    }
    std::cout << "\n";
    return CXChildVisit_Recurse;
  },
  nullptr
  );


  clang_visitChildren(
  cursor,
  [](CXCursor current_cursor, CXCursor parent, CXClientData client_data){

    CXType cursor_type = clang_getCursorType(current_cursor);
    CXString cursor_spelling = clang_getCursorSpelling(current_cursor);
    CXSourceRange cursor_range = clang_getCursorExtent(current_cursor);
    std::cout << "Cursor " << clang_getCString(cursor_spelling);

    CXFile file;
    unsigned start_line, start_column, start_offset;
    unsigned end_line, end_column, end_offset;

    clang_getExpansionLocation(clang_getRangeStart(cursor_range), &file, &start_line, &start_column, &start_offset);
    clang_getExpansionLocation(clang_getRangeEnd  (cursor_range), &file, &end_line  , &end_column  , &end_offset);
    std::cout << " spanning lines " << start_line << " to " << end_line;
    clang_disposeString(cursor_spelling);

    std::cout << "\n";
    return CXChildVisit_Recurse;
  },
  nullptr
  );
}

==================================================LibFormat
LibFormat is a library that implements automatic source code formatting based on Clang.

If you just want to use clang-format as a tool or integrated into an editor, checkout ClangFormat.
https://clang.llvm.org/docs/ClangFormat.html
ClangFormat describes a set of tools that are built on top of LibFormat. 
It can support your workflow in a variety of ways including a standalone tool and editor integrations.
Standalone Tool:
clang-format is located in clang/tools/clang-format and can be used to format C/C++/Java/JavaScript/JSON/Objective-C/Protobuf/C# code.
clang-format --help

When the desired code formatting style is different from the available options, 
the style can be customized using the -style="{key: value, ...}" option 
or by putting your style configuration in the .clang-format or _clang-format file in your project’s directory and using clang-format -style=file.
An easy way to create the .clang-format file is:
clang-format -style=llvm -dump-config > .clang-format


==================================================Clang-Format Style Options
https://clang.llvm.org/docs/ClangFormatStyleOptions.html

clang-format supports two ways to provide custom style options: directly specify style configuration in the -style= command line option 
or use -style=file and put style configuration in the .clang-format or _clang-format file in the project directory.

When using -style=file, clang-format for each input file will try to find the .clang-format file located in the closest parent directory of the input file. 
When the standard input is used, the search is started from the current directory.

When using -style=file:<format_file_path>, clang-format for each input file will use the format file located at <format_file_path>. 
The path may be absolute or relative to the working directory.

The .clang-format file uses YAML format:
key1: value1
key2: value2
# A comment.
...

The configuration file can consist of several sections each having different Language: parameter denoting the programming language this section of the configuration is targeted at. 
See the description of the Language option below for the list of supported languages. 
The first section may have no language set, it will set the default style options for all languages. 
Configuration sections for specific language will override options set in the default section.

When clang-format formats a file, it auto-detects the language using the file name. 
When formatting standard input or a file that doesn’t have the extension corresponding to its language, 
-assume-filename= option can be used to override the file name clang-format uses to detect the language.

An example of a configuration file for multiple languages:
---
# We'll use defaults from the LLVM style, but with 4 columns indentation.
BasedOnStyle: LLVM
IndentWidth: 4
---
Language: Cpp
# Force pointers to the type for C++.
DerivePointerAlignment: false
PointerAlignment: Left
---
Language: JavaScript
# Use 100 columns for JS.
ColumnLimit: 100
---
Language: Proto
# Don't format .proto files.
DisableFormat: true
---
Language: CSharp
# Use 100 columns for C#.
ColumnLimit: 100
...


An easy way to get a valid .clang-format file containing all configuration options of a certain predefined style is:
clang-format -style=llvm -dump-config > .clang-format
When specifying configuration in the -style= option, the same configuration is applied for all input files. The format of the configuration is:
-style='{key1: value1, key2: value2, ...}'

Disabling Formatting on a Piece of Code:
Clang-format understands also special comments that switch formatting in a delimited range. 
The code between a comment // clang-format off or /* clang-format off */ up to a comment // clang-format on or /* clang-format on */ will not be formatted. 
The comments themselves will be formatted (aligned) normally. 
Also, a colon (:) and additional text may follow // clang-format off or // clang-format on to explain why clang-format is turned off or back on.

int formatted_code;
// clang-format off
    void    unformatted_code  ;
// clang-format on
void formatted_code_again;


Configuring Style in Code:
When using clang::format::reformat(...) functions, the format is specified by supplying the clang::format::FormatStyle structure.

==================================================Clang Plugins
Clang Plugins make it possible to run extra user defined actions during a compilation.
Clang Plugins run FrontendActions over code. See the FrontendAction tutorial on how to write a FrontendAction using the RecursiveASTVisitor. 

Writing a PluginASTAction:
The main difference from writing normal FrontendActions is that you can handle plugin command line options. 
The PluginASTAction base class declares a ParseArgs method which you have to implement in your plugin.
bool ParseArgs(const CompilerInstance &CI,
               const std::vector<std::string>& args) {
  for (unsigned i = 0, e = args.size(); i != e; ++i) {
    if (args[i] == "-some-arg") {
      // Handle the command line argument.
    }
  }
  return true;
}

Registering a plugin:
A plugin is loaded from a dynamic library at runtime by the compiler.
To register a plugin in a library, use FrontendPluginRegistry::Add<>:
static FrontendPluginRegistry::Add<MyPlugin> X("my-plugin-name", "my plugin description");

Defining pragmas:
Plugins can also define pragmas by declaring a PragmaHandler and registering it using PragmaHandlerRegistry::Add<>:
// Define a pragma handler for #pragma example_pragma
class ExamplePragmaHandler : public PragmaHandler {
public:
  ExamplePragmaHandler() : PragmaHandler("example_pragma") { }
  void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,
                    Token &PragmaTok) {
    // Handle the pragma
  }
};

static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y("example_pragma","example pragma description");

Defining attributes:
Plugins can define attributes by declaring a ParsedAttrInfo and registering it using ParsedAttrInfoRegister::Add<>:

class ExampleAttrInfo : public ParsedAttrInfo {
public:
  ExampleAttrInfo() {
    Spellings.push_back({ParsedAttr::AS_GNU,"example"});
  }
  AttrHandling handleDeclAttribute(Sema &S, Decl *D,
                                   const ParsedAttr &Attr) const override {
    // Handle the attribute
    return AttributeApplied;
  }
};

static ParsedAttrInfoRegistry::Add<ExampleAttrInfo> Z("example_attr","example attribute description");

The members of ParsedAttrInfo that a plugin attribute must define are:
Spellings, which must be populated with every Spelling of the attribute, each of which consists of an attribute syntax and how the attribute name is spelled for that syntax.
If the syntax allows a scope then the spelling must be “scope::attr” if a scope is present or “::attr” if not.

handleDeclAttribute, which is the function that applies the attribute to a declaration.
It is responsible for checking that the attribute’s arguments are valid, and typically applies the attribute by adding an Attr to the Decl.
It returns either AttributeApplied, to indicate that the attribute was successfully applied, or AttributeNotApplied if it wasn’t.

The members of ParsedAttrInfo that may need to be defined, depending on the attribute, are:
NumArgs and OptArgs, which set the number of required and optional arguments to the attribute.
diagAppertainsToDecl, which checks if the attribute has been used on the right kind of declaration and issues a diagnostic if not.
diagLangOpts, which checks if the attribute is permitted for the current language mode and issues a diagnostic if not.
existsInTarget, which checks if the attribute is permitted for the given target.

Putting it all together:
Let’s look at an example plugin that prints top-level function names. This example is checked into the clang repository
llvm-project-main/clang/examples/PrintFunctionNames 

#include "clang/Frontend/FrontendPluginRegistry.h"
#include "clang/AST/AST.h"
#include "clang/AST/ASTConsumer.h"
#include "clang/AST/RecursiveASTVisitor.h"
#include "clang/Frontend/CompilerInstance.h"
#include "clang/Sema/Sema.h"
#include "llvm/Support/raw_ostream.h"
using namespace clang;

namespace {

class PrintFunctionsConsumer : public ASTConsumer {
  CompilerInstance &Instance;
  std::set<std::string> ParsedTemplates;

public:
  PrintFunctionsConsumer(CompilerInstance &Instance,
                         std::set<std::string> ParsedTemplates)
      : Instance(Instance), ParsedTemplates(ParsedTemplates) {}

  bool HandleTopLevelDecl(DeclGroupRef DG) override {
    for (DeclGroupRef::iterator i = DG.begin(), e = DG.end(); i != e; ++i) {
      const Decl *D = *i;
      if (const NamedDecl *ND = dyn_cast<NamedDecl>(D))
        llvm::errs() << "top-level-decl: \"" << ND->getNameAsString() << "\"\n";
    }

    return true;
  }

  void HandleTranslationUnit(ASTContext& context) override {
    if (!Instance.getLangOpts().DelayedTemplateParsing)
      return;

    // This demonstrates how to force instantiation of some templates in
    // -fdelayed-template-parsing mode. (Note: Doing this unconditionally for
    // all templates is similar to not using -fdelayed-template-parsig in the
    // first place.)
    // The advantage of doing this in HandleTranslationUnit() is that all
    // codegen (when using -add-plugin) is completely finished and this can't
    // affect the compiler output.
    struct Visitor : public RecursiveASTVisitor<Visitor> {
      const std::set<std::string> &ParsedTemplates;
      Visitor(const std::set<std::string> &ParsedTemplates)
          : ParsedTemplates(ParsedTemplates) {}
      bool VisitFunctionDecl(FunctionDecl *FD) {
        if (FD->isLateTemplateParsed() &&
            ParsedTemplates.count(FD->getNameAsString()))
          LateParsedDecls.insert(FD);
        return true;
      }

      std::set<FunctionDecl*> LateParsedDecls;
    } v(ParsedTemplates);
    v.TraverseDecl(context.getTranslationUnitDecl());
    clang::Sema &sema = Instance.getSema();
    for (const FunctionDecl *FD : v.LateParsedDecls) {
      clang::LateParsedTemplate &LPT =
          *sema.LateParsedTemplateMap.find(FD)->second;
      sema.LateTemplateParser(sema.OpaqueParser, LPT);
      llvm::errs() << "late-parsed-decl: \"" << FD->getNameAsString() << "\"\n";
    }   
  }
};

class PrintFunctionNamesAction : public PluginASTAction {
  std::set<std::string> ParsedTemplates;
protected:
  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,
                                                 llvm::StringRef) override {
    return std::make_unique<PrintFunctionsConsumer>(CI, ParsedTemplates);
  }

  bool ParseArgs(const CompilerInstance &CI,
                 const std::vector<std::string> &args) override {
    for (unsigned i = 0, e = args.size(); i != e; ++i) {
      llvm::errs() << "PrintFunctionNames arg = " << args[i] << "\n";

      // Example error handling.
      DiagnosticsEngine &D = CI.getDiagnostics();
      if (args[i] == "-an-error") {
        unsigned DiagID = D.getCustomDiagID(DiagnosticsEngine::Error,
                                            "invalid argument '%0'");
        D.Report(DiagID) << args[i];
        return false;
      } else if (args[i] == "-parse-template") {
        if (i + 1 >= e) {
          D.Report(D.getCustomDiagID(DiagnosticsEngine::Error,
                                     "missing -parse-template argument"));
          return false;
        }
        ++i;
        ParsedTemplates.insert(args[i]);
      }
    }
    if (!args.empty() && args[0] == "help")
      PrintHelp(llvm::errs());

    return true;
  }
  void PrintHelp(llvm::raw_ostream& ros) {
    ros << "Help for PrintFunctionNames plugin goes here\n";
  }

};

}

static FrontendPluginRegistry::Add<PrintFunctionNamesAction>
X("print-fns", "print function names");

Running the plugin:
1. Using the compiler driver
The Clang driver accepts the -fplugin option to load a plugin. 
Clang plugins can receive arguments from the compiler driver command line via the fplugin-arg-<plugin name>-<argument> option.
Using this method, the plugin name cannot contain dashes itself, but the argument passed to the plugin can.
export BD=/path/to/build/directory
make -C $BD CallSuperAttr
clang++ -fplugin=$BD/lib/CallSuperAttr.so \
          -fplugin-arg-call_super_plugin-help \
          test.cpp
If your plugin name contains dashes, either rename the plugin or used the cc1 command line options listed below.

2. Using the cc1 command line
To run a plugin, the dynamic library containing the plugin registry must be loaded via the -load command line option.
This will load all plugins that are registered, and you can select the plugins to run by specifying the -plugin option. 
Additional parameters for the plugins can be passed with -plugin-arg-<plugin-name>.

Note that those options must reach clang’s cc1 process. There are two ways to do so:
（1）Directly call the parsing process by using the -cc1 option; this has the downside of not configuring the default header search paths,
so you’ll need to specify the full system path configuration on the command line.
（2）Use clang as usual, but prefix all arguments to the cc1 process with -Xclang.

For example, to run the print-function-names plugin over a source file in clang, first build the plugin, and then call clang with the plugin from the source tree
export BD=/path/to/build/directory
(cd $BD && make PrintFunctionNames )
clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \
          -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \
          -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \
          tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \
          -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \
          -plugin -Xclang print-fns

3. Using the clang command line
Using -fplugin=plugin on the clang command line passes the plugin through as an argument to -load on the cc1 command line. If the plugin class implements the getActionType method then the plugin is run automatically. 
For example, to run the plugin automatically after the main AST action (i.e. the same as using -add-plugin):

// Automatically run the plugin after the main AST action
PluginASTAction::ActionType getActionType() override {
  return AddAfterMainAction;
}


clang -load
选项用于加载 Clang 插件
当你想要在 Clang 中使用一个自定义的插件时，可以使用 -load 选项来指定插件的路径。插件可以修改编译过程、添加新的检查器或转换等。
典型的用法是：-Xclang -load -Xclang /path/to/YourPlugin.so，其中 /path/to/YourPlugin.so 是插件的路径。

-Xclang 是一个用于传递额外参数给 Clang 的选项
具体来说，-Xclang 用于将后面的参数传递给 Clang 的前端（clang -cc1）。
这种方式允许你在 Clang 的前端部分使用一些定制选项。
-Xclang 主要用于传递那些不是标准 Clang 命令行选项的参数，因为标准选项可以直接传递给 Clang 而不需要 -Xclang。

-cc1 是 Clang 的内部选项，通常不直接由用户调用。
用于指定 Clang 的 "driver" 部分应该将命令行传递给 Clang 的前端 (clang -cc1)，而不是传递给整个编译器。
在一些高级用例中，用户可能需要直接与 Clang 的前端交互，而不经过整个编译过程。这时可以使用 -cc1 选项。

标准选项是 Clang 命令行的通用选项，它们无需额外的 -Xclang 标志。这些标准选项包括常见的编译和链接选项:
源文件和目标文件:

指定源文件：source.c 或 source.cpp
指定目标文件：-o output.o 或 -o output
语言选项:

指定编译语言：-x c 或 -x c++
指定 C++ 标准：-std=c++11 或 -std=c++14
优化选项:

指定优化级别：-O1、-O2、-O3 等
警告选项:

启用或禁用特定警告：-Wsomething 或 -Wno-something
头文件搜索路径:

添加头文件搜索路径：-I /path/to/include
库搜索路径:

添加库搜索路径：-L /path/to/lib
链接库:

链接静态库：-l library
调试信息选项:

生成调试信息：-g

如果参数不使用 -Xclang，它将被视为整个编译器的标准选项，可能会被前端和后端都处理。
例如，-O2 是一个优化选项，会影响整个编译流程，而不仅仅是前端。这类选项通常是标准选项，对整个编译流程都有影响。

==================================================How to write RecursiveASTVisitor based ASTFrontendActions.
##
learn how to create a FrontendAction that uses a RecursiveASTVisitor to find CXXRecordDecl AST nodes with a specified name.
##

Creating a FrontendAction:
When writing a clang based tool like a Clang Plugin or a standalone tool based on LibTooling, the common entry point is the FrontendAction. 
FrontendAction is an interface that allows execution of user specific actions as part of the compilation. 
To run tools over the AST clang provides the convenience interface ASTFrontendAction, which takes care of executing the action. 
The only part left is to implement the CreateASTConsumer method that returns an ASTConsumer per translation unit.

class FindNamedClassAction : public clang::ASTFrontendAction {
public:
  virtual std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(
    clang::CompilerInstance &Compiler, llvm::StringRef InFile) {
    return std::make_unique<FindNamedClassConsumer>();
  }
};

Creating an ASTConsumer:
ASTConsumer is an interface used to write generic actions on an AST, regardless of how the AST was produced. 
ASTConsumer provides many different entry points, but for our use case the only one needed is HandleTranslationUnit, which is called with the ASTContext for the translation unit.

class FindNamedClassConsumer : public clang::ASTConsumer {
public:
  virtual void HandleTranslationUnit(clang::ASTContext &Context) {
    // Traversing the translation unit decl via a RecursiveASTVisitor
    // will visit all nodes in the AST.
    Visitor.TraverseDecl(Context.getTranslationUnitDecl());
  }
private:
  // A RecursiveASTVisitor implementation.
  FindNamedClassVisitor Visitor;
};

Using the RecursiveASTVisitor:
Now that everything is hooked up, the next step is to implement a RecursiveASTVisitor to extract the relevant information from the AST.

The RecursiveASTVisitor provides hooks of the form bool VisitNodeType(NodeType *) for most AST nodes; 
the exception are TypeLoc nodes, which are passed by-value. We only need to implement the methods for the relevant node types.

Let’s start by writing a RecursiveASTVisitor that visits all CXXRecordDecl’s.
class FindNamedClassVisitor
  : public RecursiveASTVisitor<FindNamedClassVisitor> {
public:
  bool VisitCXXRecordDecl(CXXRecordDecl *Declaration) {
    // For debugging, dumping the AST nodes will show which nodes are already
    // being visited.
    Declaration->dump();

    // The return value indicates whether we want the visitation to proceed.
    // Return false to stop the traversal of the AST.
    return true;
  }
};
In the methods of our RecursiveASTVisitor we can now use the full power of the Clang AST to drill through to the parts that are interesting for us.
For example, to find all class declaration with a certain name, we can check for a specific qualified name:
bool VisitCXXRecordDecl(CXXRecordDecl *Declaration) {
  if (Declaration->getQualifiedNameAsString() == "n::m::C")
    Declaration->dump();
  return true;
}

Accessing the SourceManager and ASTContext:
Some of the information about the AST, like source locations and global identifier information, are not stored in the AST nodes themselves, but in the ASTContext and its associated source manager.
To retrieve them we need to hand the ASTContext into our RecursiveASTVisitor implementation.
The ASTContext is available from the CompilerInstance during the call to CreateASTConsumer. 
We can thus extract it there and hand it into our freshly created FindNamedClassConsumer:
virtual std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(
  clang::CompilerInstance &Compiler, llvm::StringRef InFile) {
  return std::make_unique<FindNamedClassConsumer>(&Compiler.getASTContext());
}

Now that the ASTContext is available in the RecursiveASTVisitor, we can do more interesting things with AST nodes, like looking up their source locations:
bool VisitCXXRecordDecl(CXXRecordDecl *Declaration) {
  if (Declaration->getQualifiedNameAsString() == "n::m::C") {
    // getFullLoc uses the ASTContext's SourceManager to resolve the source
    // location and break it up into its line and column parts.
    FullSourceLoc FullLocation = Context->getFullLoc(Declaration->getBeginLoc());
    if (FullLocation.isValid())
      llvm::outs() << "Found declaration at "
                   << FullLocation.getSpellingLineNumber() << ":"
                   << FullLocation.getSpellingColumnNumber() << "\n";
  }
  return true;
}

Putting it all together:
Now we can combine all of the above into a small example program
#include "clang/AST/ASTConsumer.h"
#include "clang/AST/RecursiveASTVisitor.h"
#include "clang/Frontend/CompilerInstance.h"
#include "clang/Frontend/FrontendAction.h"
#include "clang/Tooling/Tooling.h"

using namespace clang;

class FindNamedClassVisitor
  : public RecursiveASTVisitor<FindNamedClassVisitor> {
public:
  explicit FindNamedClassVisitor(ASTContext *Context)
    : Context(Context) {}

  bool VisitCXXRecordDecl(CXXRecordDecl *Declaration) {
    if (Declaration->getQualifiedNameAsString() == "n::m::C") {
      FullSourceLoc FullLocation = Context->getFullLoc(Declaration->getBeginLoc());
      if (FullLocation.isValid())
        llvm::outs() << "Found declaration at "
                     << FullLocation.getSpellingLineNumber() << ":"
                     << FullLocation.getSpellingColumnNumber() << "\n";
    }
    return true;
  }

private:
  ASTContext *Context;
};

class FindNamedClassConsumer : public clang::ASTConsumer {
public:
  explicit FindNamedClassConsumer(ASTContext *Context)
    : Visitor(Context) {}

  virtual void HandleTranslationUnit(clang::ASTContext &Context) {
    Visitor.TraverseDecl(Context.getTranslationUnitDecl());
  }
private:
  FindNamedClassVisitor Visitor;
};

class FindNamedClassAction : public clang::ASTFrontendAction {
public:
  virtual std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(
    clang::CompilerInstance &Compiler, llvm::StringRef InFile) {
    return std::make_unique<FindNamedClassConsumer>(&Compiler.getASTContext());
  }
};

int main(int argc, char **argv) {
  if (argc > 1) {
    clang::tooling::runToolOnCode(std::make_unique<FindNamedClassAction>(), argv[1]);
  }
}

We store this into a file called FindClassDecls.cpp and create the following CMakeLists.txt to link it:
set(LLVM_LINK_COMPONENTS
  Support
  )

add_clang_executable(find-class-decls FindClassDecls.cpp)

target_link_libraries(find-class-decls
  PRIVATE
  clangAST
  clangBasic
  clangFrontend
  clangSerialization
  clangTooling
  )

When running this tool over a small code snippet it will output all declarations of a class n::m::C it found:
$ ./bin/find-class-decls "namespace n { namespace m { class C {}; } }"
Found declaration at 1:29

==================================================Clang Transformer
https://clang.llvm.org/docs/ClangTransformerTutorial.html

how to write a source-to-source translation tool using Clang Transformer.

Clang Transformer is a framework for writing C++ diagnostics and program transformations. 
It is built on the clang toolchain and the LibTooling library, but aims to hide much of the complexity of clang’s native, low-level libraries.

The core abstraction of Transformer is the rewrite rule, which specifies how to change a given program pattern into a new form. 
Here are some examples of tasks you can achieve with Transformer:
warn against using the name MkX for a declared function,
change MkX to MakeX, where MkX is the name of a declared function,
change s.size() to Size(s), where s is a string,
collapse e.child().m() to e.m(), for any expression e and method named m.