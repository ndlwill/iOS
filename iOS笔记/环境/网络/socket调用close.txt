当服务器（server）在TCP连接上执行close操作时，客户端（client）将接收到一个特定的消息。根据TCP协议的规范，服务器在关闭连接时会向客户端发送一个TCP FIN（Finish）包。
TCP FIN包用于表示发送端已经完成发送数据，不再发送数据，并请求关闭连接。当客户端收到服务器发送的FIN包时，它可以执行以下操作：
1.客户端接收到FIN包后，首先确认收到该包，并发送一个ACK（Acknowledgment）包作为响应。ACK包用于告知服务器已经接收到了FIN包。
2.在发送ACK包之后，客户端进入TIME_WAIT状态，等待一段时间（通常为2倍的最大报文段生存时间，也就是MSL）以确保服务器收到ACK包。这是为了处理可能出现的网络延迟、重传或乱序报文的情况。
3.客户端在等待时间结束后，可以关闭连接并释放相应的资源。
即使客户端在收到服务器的FIN包后发送了ACK包，服务器仍然可能继续发送一些剩余的数据。
这是因为TCP是一个全双工的协议，允许在连接关闭之前进行双向通信。因此，客户端在接收到FIN包后，应该继续接收数据直到服务器关闭连接。
总结起来，当服务器执行关闭操作时，客户端将收到服务器发送的FIN包，并向服务器发送一个确认的ACK包。随后，客户端进入TIME_WAIT状态，等待一段时间后关闭连接。

在UDP协议中，与TCP不同，没有显式的连接建立和关闭过程。UDP是一种无连接的协议，每个数据包都是独立发送的，没有持久的连接状态。
当UDP服务器执行关闭操作时，它实际上不会向客户端发送任何特定的消息。
UDP协议没有提供关闭连接的机制，因此服务器可以简单地停止接收或处理UDP数据包。
对于UDP客户端来说，它不会自动收到任何通知或指示服务器已关闭。客户端可能会继续发送数据包到服务器，但服务器不再响应或处理这些数据包。
因此，在UDP中，服务器的关闭操作对客户端而言是透明的。客户端需要自己决定何时停止发送数据包或处理来自服务器的响应。在应用层，客户端可以通过超时机制或其他手段来判断服务器是否不可用或已关闭。


==================================================
1.server端close之后，client端write，导致server端发送RST（服务器关闭套接字）：对方已经关闭或者异常终止，但是client端，不知道，这个成为半打开
当server端close套接字的时候，假设此时server端的接受缓冲区没有数据了。
则close发送的是FIN，client端如果收到FIN之后，调用read函数，是返回0的，因为FIN的接收，表明client端以后再无数据可以接收，因为对方发来FIN，就表明对方不在发送数据了。
然后client发送应答ack报文，表明收到FIN报文，server收到ack报文之后，就进去了FIN_WAIT_2阶段
根据tcp协议，向一个 FIN_WAIT2 状态的服务 TCP（已 ACK 响应 FIN ）写入数据不成问题，所以此时我们可以在client端调用write函数，写入client端的发送缓冲区，由tcp连接，发送到server的接收缓冲区。
但是此时，由于server端已经关闭了socket，所以此时的接收缓冲区的内容都被抛弃，同时server端返回RST
收到RST的client端，如果调用read函数，读取，是返回RST错误的
如果我们的client对这个RST错误，不采取处理，继续调用write，会发生epipe错误。
这种情况一般发生在客户进程不理会（或未及时处理）Socket 错误，继续向服务 TCP 写入更多数据时，内核将向客户进程发送 SIGPIPE 信号，该信号默认会使进程终止
结合上边的 ECONNRESET 错误可知，向一个 FIN_WAIT2 状态的服务 TCP（已 ACK 响应 FIN ）写入数据不成问题，但是写一个已接收了 RST 的 Socket 则是一个错误。
接收到RST包(异常关闭)的一端采取的操作:
(1)丢弃任何待发的已经无意义的 数据，并立即发送RST报文段
(2)RST的接收方利用关闭方式来 区分另一端执行的是异常关闭还是正常关闭（通过read操作的返回值，正常的返回读取字节或者堵塞，RST的返回错误）
值得注意的是RST报文段不会导致另一端产生任何响应（不用发送ack响应）,另一端根本不进行确认。收到RST的一方将终止该连接。程序行为如下:
阻塞模型下，内核无法主动通知应用层出错，只有应用层主动调用read()或者write()这样的IO系统调用时，内核才会利用出错来通知应用层对端RST。
非阻塞模型下，select或者epoll会返回sockfd可读,应用层对其进行读取时，read()会报错RST。 

2.server端close套接字，此时server端的接收缓冲区还有数据，没有被读取，则此时server端发送RST给client端，接收缓冲区的数据丢失，服务器server提前关闭socket

3.client端发起连接请求，发送了SYN报文，由于server端的套接字没有listen端口，则向cllient发送RST