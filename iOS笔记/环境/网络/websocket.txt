==================================================WebSocket & HTTP/HTTPS
WebSocket 和 HTTPS 都是网络通信协议

| 特性   | HTTPS                                  | WebSocket                              |
| ---- | -------------------------------------- | -------------------------------------- |
| 协议   | 基于 HTTP/1.1 或 HTTP/2 的加密传输（HTTP + TLS） | 独立协议 ws/wss（WebSocket Secure = TLS 加密） |
| 连接方式 | 请求-响应（短连接，HTTP/1.1 可复用 TCP）            | 长连接（客户端和服务器保持 TCP 连接）                  |
| 数据流  | 单向（客户端请求 → 服务器响应）                      | 双向（客户端 ↔ 服务器，实时推送）                     |
| 通信模式 | 每次请求需要建立 TCP + TLS 连接（HTTP/1.1可复用）     | 先通过 HTTP(s) 升级为 WebSocket，然后保持连接持续通信 |
| 延迟   | 较高，每次请求都可能有握手和 TLS 建立延迟                | 较低，一旦连接建立，可以即时收发消息                     |
| 用途   | 页面加载、API 请求、表单提交等                      | 实时聊天、游戏、股票行情推送、IoT 实时控制等               |
| 数据格式 | HTTP/HTTPS 规定的请求和响应格式（文本/JSON/XML 等）   | WebSocket 封装的数据帧，可传文本或二进制              |
| 安全性  | HTTPS 使用 TLS 加密，安全性高                   | WSS 使用 TLS 加密，安全性高；WS 明文不安全            |


HTTPS 本质是 HTTP 在 TLS 上的加密版本，它是请求-响应模式。客户端发请求，服务器响应后，连接可能就关闭了（HTTP/1.1 支持 Keep-Alive 复用 TCP，但仍是短连接模式）。
WebSocket 则是为实时、低延迟通信设计的协议。它先通过 HTTP/HTTPS 建立连接，然后升级到 WebSocket，双方保持长连接，可以随时互相推送消息。


==================================================WebSocket & TCP Socket
WebSocket = 应用层协议
TCP = 传输层协议

WebSocket 和 Socket（通常指 TCP Socket）

| 特性    | Socket（TCP/UDP）                    | WebSocket                              |
| ----- | ---------------------------------- | -------------------------------------- |
| 协议层   | 传输层 TCP/UDP                        | 应用层协议，基于 TCP 的升级（ws/wss）               |
| 连接方式  | 原生 TCP/UDP 连接，需要自己设计通信协议           | 先通过 HTTP/HTTPS 握手，然后升级为 WebSocket 长连接  |
| 数据格式  | 自定义，可以传任何字节流                       | 定义了数据帧格式，支持文本和二进制                      |
| 通信模式  | 双向通信（客户端 ↔ 服务器），可实时                | 双向通信（客户端 ↔ 服务器），实时，浏览器友好               |
| 使用门槛  | 需要自己处理协议、分包、心跳、重连等                 | 浏览器原生支持，易用，框架多，底层处理分包、心跳               |
| 安全性   | TCP 默认不加密，需要自己加 TLS/SSL            | WSS 基于 TLS 加密，安全性高，WS 明文不安全            |
| 浏览器支持 | 原生浏览器无法直接使用，需要 WebSocket 或 HTTP 代理 | 浏览器原生支持，JavaScript 可直接使用 WebSocket API |
| 用途    | 游戏服务器、文件传输、RPC、IoT、低延迟服务           | 实时聊天、实时通知、股票行情推送、浏览器端实时交互              |

#####
Socket 是 传输层概念，直接操作 TCP 或 UDP。
WebSocket 是 应用层协议，在 TCP 之上定义了消息帧和握手方式。
#####

TCP Socket 传输字节流，需要自己解析消息边界、编码等。
WebSocket 内置消息帧，浏览器和服务器可以直接发送文本或二进制数据。

Socket 是打通网络的基础“管道”，WebSocket 是在浏览器和服务器之间用 TCP 管道做的标准化实时通信协议。


==================================================
WebSocket 协议本身
标准协议是 ws://（非加密）和 wss://（加密）。
它本质是 独立的应用层协议，运行在 TCP 之上，不依赖 HTTP/HTTPS 来传输数据。

WebSocket 建立连接的第一步是通过 HTTP 协议握手（HTTP Upgrade）。
浏览器发送一个 HTTP/HTTPS 请求，服务器响应同意升级到 WebSocket。
这个握手使用的就是 HTTP/HTTPS，但握手完成后，通信就不再走 HTTP，而是 WebSocket 协议。

ws:// → 明文 TCP 连接。
wss:// → 基于 TLS 的加密 TCP 连接，相当于在 HTTPS 上建立 WebSocket。
所以 WebSocket 可以利用 HTTPS 的 TLS 加密

#####
WebSocket 依赖 TCP，但握手可以通过 HTTP/HTTPS。
#####

==================================================
HTTPS 握手:
协议：HTTP + TLS（HTTPS）
流程：
客户端 TCP 连接服务器。

TLS 握手：
客户端发 ClientHello。
服务器发 ServerHello + 证书。
双方协商加密算法和密钥。
生成对称密钥，建立加密通道。

HTTP 请求通过 TLS 加密发送，服务器响应。



#####
WebSocket 通过 HTTP/HTTPS 请求发起握手
#####
WebSocket 握手:
协议：基于 HTTP/HTTPS 的升级请求（Upgrade）
流程：

客户端发 HTTP/HTTPS 请求：
GET /chat HTTP/1.1
Host: server.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: <随机值>
Sec-WebSocket-Version: 13

服务器响应，确认升级：
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: <服务器计算值>

握手完成后，HTTP 连接升级为 WebSocket 长连接，开始双向消息通信。


特性	HTTPS	WebSocket
握手目的	建立安全通道	协议升级，保持长连接


握手流程:
1. 客户端发送 HTTP/HTTPS 请求
这个请求是标准 HTTP/HTTPS 请求，但它包含 Upgrade: websocket 的头。
作用：告诉服务器“我想把这个 HTTP/HTTPS 连接升级成 WebSocket”。
2. 服务器响应
如果服务器支持 WebSocket，就返回 101 Switching Protocols。
这一步 完成协议升级。
3. 握手结束，WebSocket 开始通信
后续数据 不再走 HTTP/HTTPS 协议，而是 WebSocket 帧格式。
长连接保持，客户端和服务器可以随时互发消息。
#####
WebSocket 依赖 HTTP/HTTPS 发起握手，但握手完成后 通信协议独立于 HTTP/HTTPS。
如果使用 wss://，握手和数据都经过 TLS 加密，这类似 HTTPS 的加密通道，但不是 HTTPS 请求。
简单记：HTTP/HTTPS 是握手通道，WebSocket 是升级后的通信协议。
#####


==================================================HTTPS 请求流程
DNS 解析
客户端先把域名解析成服务器 IP。

TCP 连接
客户端与服务器建立 TCP 连接（通常是三次握手）。

TLS 握手（HTTPS 特有）
客户端发 ClientHello，服务器回 ServerHello + 证书。
双方协商加密算法和密钥，生成对称密钥。
握手完成 → 建立安全加密通道。

HTTP 请求发送
TLS 通道建立好之后，客户端通过这个加密通道发送 HTTP 请求。
服务器响应，同样通过加密通道返回数据。

连接复用或关闭
HTTP/1.1 默认 Keep-Alive，可复用 TCP 连接发送下一次请求。
HTTP/2 也可以复用单一连接并行发送多个请求。

#####
TLS 握手 发生在 HTTP 请求前，它的目的是建立安全通道。
只有握手成功后，HTTP 请求的数据才真正通过安全通道发送。
所以 HTTPS 请求确实是 先握手 → 再发送数据。
#####


==================================================WebSocket 请求流程
DNS 解析
客户端把服务器域名解析成 IP。

TCP 连接
客户端与服务器建立 TCP 连接（通常是三次握手）。

TLS 握手（可选）
如果使用 wss://，先进行 TLS 握手，建立加密通道。
如果是 ws://，这一步跳过，直接明文 TCP 连接。

HTTP/HTTPS 请求（升级握手）
客户端发一个特殊的 HTTP/HTTPS 请求，告诉服务器想要升级到 WebSocket：
GET /chat HTTP/1.1
Host: server.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: <随机值>
Sec-WebSocket-Version: 13
这是握手请求，还不是 WebSocket 数据。

服务器响应
服务器确认支持 WebSocket 协议，返回：
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: <服务器计算值>
握手完成。

WebSocket 长连接建立
TCP 连接继续保持，HTTP 协议升级为 WebSocket 协议。
客户端和服务器可以随时双向发送消息（文本或二进制）。

数据通信阶段
握手完成后，HTTP 不再参与，所有数据以 WebSocket 帧格式发送。
长连接可持续使用，直到客户端或服务器关闭连接。

WebSocket 使用自己的 数据帧（frame） 格式，分为几类：
| 类型           | 用途              |
| ------------ | --------------- |
| Text Frame   | 发送文本数据（UTF-8）   |
| Binary Frame | 发送二进制数据（如图片、音频） |
| Ping / Pong  | 心跳检测，保持连接活跃     |
| Close        | 关闭连接            |


#####
HTTPS：TLS 握手 → HTTP 请求 → 响应 → 可复用连接
WebSocket：TLS（可选）→ HTTP Upgrade 握手 → 协议升级 → 双向通信
WebSocket 握手依赖 HTTP/HTTPS，但握手完成后通信独立于 HTTP。
#####

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebSocket Demo</title>
</head>
<body>
  <h1>WebSocket Demo</h1>
  <button id="sendBtn">发送消息</button>

  <script>
    // 建立连接
    const ws = new WebSocket('ws://localhost:8080');

    ws.onopen = () => {// 表示 WebSocket 握手成功，长连接建立完成。握手成功后，你就可以开始发送消息ws.send('Hello');
      console.log('连接已打开');
    };

    ws.onmessage = (event) => {
      console.log('收到服务器消息：', event.data);
    };

    ws.onclose = () => {
      console.log('连接已关闭');
    };

    ws.onerror = (err) => {
      console.error('WebSocket 错误：', err);
    };

    // 点击按钮发送消息
    document.getElementById('sendBtn').addEventListener('click', () => {
      ws.send('你好，服务器！');
    });
  </script>
</body>
</html>


const ws = new WebSocket('ws://localhost:8080');表示：
浏览器会自动处理整个握手过程：
DNS 解析 → 找到服务器 IP。
TCP 连接 → 建立底层连接（三次握手）。
TLS 握手（如果是 wss://）。
HTTP Upgrade 请求 → 请求升级协议为 WebSocket
服务器响应 101 Switching Protocols → 协议升级完成。
#####
所以浏览器封装了握手的整个流程，你不需要自己手动发 HTTP 请求或者处理协议升级。
#####


==================================================HTTP/1.1 默认 Keep-Alive，可复用 TCP 连接发送下一次请求
1. 域名相同的情况
如果两个请求的 协议、域名、端口 都相同（比如都是 https://aaa.com，默认 443 端口），HTTP/1.1 客户端通常会复用同一个 TCP 连接。
也就是说：
第一次请求 /A 时，客户端和 aaa.com:443 建立 TCP（三次握手）+ TLS（若是 HTTPS）连接。
请求完成后，连接不会立刻关闭，而是保持 keep-alive。
第二次请求 /B 就可以直接在这个连接上发，省掉了再次建立 TCP/TLS 的开销。

2. 限制点
不能同时并发复用：HTTP/1.1 的一个缺点是“队头阻塞”（Head-of-line blocking）。
一个连接上只能同时处理一个请求，必须等前一个响应返回，才能发下一个请求。
所以浏览器一般会为同一域名开 多个连接（常见上限是 6 个），以支持并发。

HTTP/2 以后才解决了这个问题，可以在一个连接里并发多个请求。


对于 iOS 客户端 app 也一样，只不过 iOS 客户端里由谁来管连接池 要看你用的 API：
1. URLSession
iOS 上如果你用 URLSession（或者老的 NSURLConnection），系统底层用的是 CFNetwork / NSURLSessiond，它有一个 连接池。
连接池会根据 域名+端口+协议 来复用连接。
第一个请求到 https://aaa.com/A 会建立 TCP+TLS。
第二个请求到 https://aaa.com/B，如果前一个连接还在 keep-alive 状态，系统会直接复用同一个连接。
所以行为和浏览器类似。

2. 并发请求
HTTP/1.1 下，一个连接不能并发多个请求（必须等前一个响应完才发下一个）。
为了并发，iOS 的 URLSession 也会为同一域名开多个连接（数量受限，苹果的实现和浏览器类似，一般 4~6 个）。
如果用 HTTP/2（服务器支持的话，iOS 9+ 默认开启），那就更高效了：一个 TLS 连接里可以并发多个请求，不再需要开多个 TCP 连接。

#####
当客户端（比如 iOS app）要和同一个服务器开多个 TCP 连接时，本机确实会分配多个本地端口

一个 TCP 连接是由四元组唯一标识的：
(客户端IP, 客户端端口, 服务器IP, 服务器端口)

服务器端口固定（443）。
服务器IP固定（aaa.com 对应的 IP）。
客户端IP一般固定（你的设备的 IP）。
客户端端口必须不同，这样 OS 才能区分多个连接。

端口 ≠ 进程
一个进程可以同时用很多端口（比如一个浏览器 Tab 就能开几十个 TCP 连接，每个都是不同端口）。
一个端口也不是永远只能给一个进程用（端口释放后可被别的进程复用）。

可以把 端口 想象成“门牌号”：
进程是一个大楼（一个 app）。
一个大楼里可以有很多门（不同端口）。
如果要同时跟不同的人通信，就得开不同的门口，不可能所有人都从同一个门进出。
#####