SOCKS5 属于应用层协议（Application Layer Protocol）

在 OSI 七层模型 或 TCP/IP 五层模型 中：
应用层 ← SOCKS5 在这里
传输层 ← TCP（或 UDP）
网络层 ← IP
SOCKS5 使用 TCP（或者在 UDP 代理时也会用到 UDP）作为底层传输通道；
它定义的是 客户端与代理服务器之间的通信协议格式（包括认证、请求、响应结构）。


SOCKS5 不是为特定应用（如 HTTP）设计的，而是通用的“传输代理”协议，它能代理：
TCP 流量（比如浏览器、SSH、游戏连接等）；
UDP 流量（比如 DNS、VoIP 等）。


它工作流程大致是：
TCP 三次握手（客户端 ↔ SOCKS5 服务器）；
SOCKS5 握手阶段（认证协商）；
建立代理连接请求；
代理转发流量。


| 特性         | SOCKS5     | HTTP Proxy          |
| ---------- | ---------- | ------------------- |
| 所在层        | 应用层（通用）    | 应用层（专用于 HTTP/HTTPS） |
| 代理内容       | 任意 TCP/UDP | 仅 HTTP(S)           |
| 协议格式       | 二进制        | 文本                  |
| 是否需要解析上层协议 | 不需要        | 需要解析 HTTP 请求头       |


为什么有人觉得 SOCKS5 “不完全是应用层”？
它不像 HTTP 那样携带“应用级语义”；
它只是“转发原始 TCP/UDP 数据流”；
因此在某种意义上，它像是 应用层实现的“传输层代理”。
换句话说：
SOCKS5 是一个工作在应用层的通用流量转发协议，但它的功能定位是“传输层的代理”。

总结：
SOCKS5 是应用层协议，用于在应用层实现通用的 TCP/UDP 流量转发，但它本身并不关心具体的应用语义。


什么是“应用级语义”
“语义”指的是 协议所传递的信息的意义 —— 也就是它“想表达的内容”。
| 项目    | HTTP 协议                         | SOCKS5 协议          |
| ----- | ------------------------------- | ------------------ |
| 协议作用  | 浏览网页、传输文件、接口通信                  | 转发任意 TCP/UDP 流量    |
| 携带的语义 | 有“资源”“方法”“状态”等语义                | 没有“业务语义”，只是转发      |
| 请求内容  | `GET /index.html`、`POST /login` | CONNECT 到某个 IP 和端口 |
| 响应内容  | 状态码（200、404）、Header、Body        | 成功/失败 + 数据转发       |
| 面向的对象 | 应用开发者（浏览器、API、Web服务）            | 网络层代理软件            |

例子：
HTTP 请求：
GET /articles/123 HTTP/1.1
Host: example.com
User-Agent: Safari/17.0
Accept: text/html
这其中的“语义”很强：
“GET” 表示读取资源；
“/articles/123” 是具体资源；
“Accept: text/html” 表示想要 HTML 页面。
浏览器和服务器都能理解这些语义，进而完成业务逻辑。

SOCKS5 请求：
0x05 0x01 0x00  （版本号 + 认证方式）
0x05 0x01 0x00 0x03 0x0B "example.com" 0x00 0x50
这只是告诉代理服务器：
“帮我建立到 example.com:80 的 TCP 连接。”
这里没有任何“语义内容”：
不知道用户是要访问网页，还是开 SSH，还是玩游戏；
SOCKS5 只负责“管道转发”。


==================================================Socks5代理协议:
SS内部使用的正是socks5协议
socks5是一种网络传输协议，主要用于客户端与目标服务器之间通讯的透明传递。
该协议设计之初是为了让有权限的用户可以穿过防火墙的限制，访问外部资源。

需要了解一些代理的知识，因此看了一下sock5协议。

1.RFC地址:
socks5协议规范rfc1928
https://www.ietf.org/rfc/rfc1928.txt
socks5账号密码鉴权规范rfc1929
https://www.ietf.org/rfc/rfc1929.txt

2.协议过程:
客户端连接上代理服务器之后需要发送请求告知服务器目前的socks协议版本以及支持的认证方式
代理服务器收到请求后根据其设定的认证方式返回给客户端
如果代理服务器不需要认证，客户端将直接向代理服务器发起真实请求
代理服务器收到该请求之后连接客户端请求的目标服务器
代理服务器开始转发客户端与目标服务器之间的流量

3.认证过程:
3.1 客户端发出请求
客户端连接服务器之后将直接发出该数据包给代理服务器

VERSION	METHODS_COUNT	METHODS…
1字节	1字节	1到255字节，长度由METHODS_COUNT值决定
0x05	0x03	0x00 0x01 0x02

VERSION SOCKS协议版本，目前固定0x05
METHODS_COUNT 客户端支持的认证方法数量
METHODS… 客户端支持的认证方法，每个方法占用1个字节

METHOD定义:
0x00 不需要认证（常用）
0x01 GSSAPI认证
0x02 账号密码认证（常用）
0x03 - 0x7F IANA分配
0x80 - 0xFE 私有方法保留
0xFF 无支持的认证方法

3.2 服务端返回选择的认证方法
接收完客户端支持的认证方法列表后，代理服务器从中选择一个受支持的方法返回给客户端

3.2.1 无需认证
VERSION	METHOD
1字节	1字节
0x05	0x00

VERSION SOCKS协议版本，目前固定0x05
METHOD 本次连接所用的认证方法

3.2.2 账号密码认证
VERSION	METHOD
1字节	1字节
0x05	0x02

3.2.3 客户端发送账号密码
服务端返回的认证方法为0x02(账号密码认证)时，客户端会发送账号密码数据给代理服务器

VERSION	USERNAME_LENGTH	USERNAME	PASSWORD_LENGTH	PASSWORD
1字节	1字节	1-255字节	1字节	1-255字节
0x01	0x01	0x0a	0x01	0x0a

VERSION 认证子协商版本（与SOCKS协议版本的0x05无关系）
USERNAME_LENGTH 用户名长度
USERNAME 用户名字节数组，长度为USERNAME_LENGTH
PASSWORD_LENGTH 密码长度
PASSWORD 密码字节数组，长度为PASSWORD_LENGTH

3.2.4 服务端响应账号密码认证结果
收到客户端发来的账号密码后，代理服务器加以校验，并返回校验结果

VERSION	STATUS
1字节	1字节
VERSION 认证子协商版本，与客户端VERSION字段一致
STATUS 认证结果
0x00 认证成功
大于0x00 认证失败

4. 命令过程:
认证成功后，客户端会发送连接命令给代理服务器，代理服务器会连接目标服务器，并返回连接结果

4.1 客户端请求
VERSION	COMMAND	RSV	ADDRESS_TYPE	DST.ADDR	DST.PORT
1字节	1字节	1字节	1字节	1-255字节	2字节

VERSION SOCKS协议版本，固定0x05
COMMAND 命令
0x01 CONNECT 连接上游服务器
0x02 BIND 绑定，客户端会接收来自代理服务器的链接，著名的FTP被动模式
0x03 UDP ASSOCIATE UDP中继
RSV 保留字段
ADDRESS_TYPE 目标服务器地址类型
0x01 IP V4地址
0x03 域名地址(没有打错，就是没有0x02)，域名地址的第1个字节为域名长度，剩下字节为域名名称字节数组
0x04 IP V6地址
DST.ADDR 目标服务器地址
DST.PORT 目标服务器端口

4.2 代理服务器响应
VERSION	RESPONSE	RSV	ADDRESS_TYPE	BND.ADDR	BND.PORT
1字节	1字节	1字节	1字节	1-255字节	2字节

VERSION SOCKS协议版本，固定0x05
RESPONSE 响应命令
0x00 代理服务器连接目标服务器成功
0x01 代理服务器故障
0x02 代理服务器规则集不允许连接
0x03 网络无法访问
0x04 目标服务器无法访问（主机名无效）
0x05 连接目标服务器被拒绝
0x06 TTL已过期
0x07 不支持的命令
0x08 不支持的目标服务器地址类型
0x09 - 0xFF 未分配
RSV 保留字段
BND.ADDR 代理服务器连接目标服务器成功后的代理服务器IP
BND.PORT 代理服务器连接目标服务器成功后的代理服务器端口

5. 通信过程:
经过认证与命令过程后，客户端与代理服务器进入正常通信，客户端发送需要请求到目标服务器的数据给代理服务器，
代理服务器转发这些数据，并把目标服务器的响应转发给客户端，起到一个“透明代理”的功能。

6. 实际例子:
无需认证和需要账号密码认证是互斥的，同一请求只会采取一种

6.1 客户端发送受支持的认证方法
0x05 0x02 0x00 0x02

0x05 SOCKS5协议版本
0x02 支持的认证方法数量
0x00 免认证
0x02 账号密码认证

6.2 服务端响应选择的认证方法
6.2.1 无需认证
以下是无需认证，客户端收到该响应后直接发送需要发送给目标服务器的数据给到代理服务器，此时进入通信错过程
0x05 0x00
0x05 SOCKS5协议版本
0x00 免认证


6.2.2 需要账号密码认证
0x05 0x02
0x05 SOCKS5协议版本
0x02 账号密码认证

6.2.3 客户端发送账号密码
0x01 0x04 0x61 0x61 0x61 0x61 0x04 0x61 0x61 0x61 0x61
0x01 子协商版本
0x04 用户名长度
0x61 0x61 0x61 0x61 转换为ascii字符之后为”aaaa”
0x04 密码长度
0x61 0x61 0x61 0x61 转换为ascii字符之后”aaaa”


6.2.4 代理服务器响应认证结果
0x01 0x00
0x01 子协商版本
0x00 认证成功（也就是代理服务器允许aaaa账号以aaaa密码登录）


6.3 客户端请求代理服务器连接目标服务器
以127.0.0.1和80端口为例

0x05 0x01 0x01 0x01 0x7f 0x00 0x00 0x01 0x00 0x50
0x05 SOCKS协议版本
0x01 CONNECT命令
0x01 RSV保留字段
0x01 地址类型为IPV4
0x7f 0x00 0x00 0x01 目标服务器IP为127.0.0.1
0x00 0x50 目标服务器端口为80

6.4 代理服务器连接目标主机，并返回结果给客户端
0x05 0x00 0x01 0x01 0x7f 0x00 0x00 0x01 0x00 0xaa 0xaa
0x05 SOCKS5协议版本
0x00 连接成功
0x01 RSV保留字段
0x01 地址类型为IPV4
0x7f 0x00 0x00 0x01 代理服务器连接目标服务器成功后的代理服务器IP, 127.0.0.1
0xaa 0xaa 代理服务器连接目标服务器成功后的代理服务器端口（代理服务器使用该端口与目标服务器通信），本例端口号为43690

6.5 客户端发送请求数据给代理服务器
如果客户端需要请求目标服务器的HTTP服务,就会发送HTTP协议报文给代理服务器,代理服务器将这些报文原样转发给目标服务器,并将目标服务器的响应发送给客户端,代理服务器不会对客户端或者目标服务器的报文做任何解析。