netif 是 network interface（网络接口）的缩写。

在网络协议栈（例如 lwIP）中，netif 通常代表一个 网络接口对象，即系统中能进行数据包收发的逻辑或物理接口，比如：
以太网卡（Ethernet interface）
Wi-Fi 接口
虚拟网卡（TUN/TAP、PPP、SLIP 等）
VPN 逻辑接口


在 lwIP 源码中，netif 对应结构体：

struct netif {
    struct netif *next;               // 链表结构，用于管理多个接口
    ip_addr_t ip_addr;                // IP 地址
    ip_addr_t netmask;                // 子网掩码
    ip_addr_t gw;                     // 网关
    const struct netif_addr *addr;    // 地址信息
    netif_input_fn input;             // 收包回调函数（交给上层协议处理，比如 IP 层）
    netif_output_fn output;           // 发包函数（交给底层驱动发送）
    netif_linkoutput_fn linkoutput;   // 链路层发送函数（底层驱动函数）
    void *state;                      // 驱动层自定义数据
    u8_t flags;                       // 接口标志（up/down、广播、支持ARP等）
    char name[2];                     // 接口名（例如 "en", "pp", "ut"）
    u8_t num;                         // 接口编号
    ...
};

| 字段                         | 含义                                           |
| -------------------------- | -------------------------------------------- |
| `ip_addr`, `netmask`, `gw` | 网络层地址配置                                      |
| `input`                    | 收到数据包时调用（进入协议栈）                              |
| `output`                   | 协议层要发送数据包时调用                                 |
| `linkoutput`               | 实际由底层驱动发送数据                                  |
| `state`                    | 保存底层驱动或虚拟接口的上下文                              |
| `flags`                    | 状态标志，比如 NETIF_FLAG_UP, NETIF_FLAG_BROADCAST  |
| `name`                     | 接口名字，例如 `"en"` 表示以太网，`"ut"` 表示虚拟接口（user tun） |


如果你在 iOS VPN、TUN、lwIP 等场景看到 netif，
它其实代表一个“逻辑网卡”：
lwIP 上层（TCP/IP 栈）通过 netif->output 发数据
底层实现（如你的 TUN 虚拟网卡）负责真正把包写出去
反之，TUN 收到包后通过 netif->input 把数据交给 lwIP


netif->output 和 netif->linkoutput 在 lwIP 中都用于“发送数据”，
但它们分别位于 不同的网络层。
可以一句话概括：
output 是 IP 层到数据链路层（L2） 的接口；
linkoutput 是 数据链路层（L2）到底层硬件驱动 的接口。

+-----------------------------+
|         TCP / UDP           |
+-----------------------------+
|            IP               | ← 调用 netif->output()
+-----------------------------+
|       Ethernet / PPP        | ← 调用 netif->linkoutput()
+-----------------------------+
|      驱动层（网卡/TUN）      |
+-----------------------------+


| 函数指针                             | 所在层级           | 谁调用它                               | 作用                           | 举例                 |
| -------------------------------- | -------------- | ---------------------------------- | ---------------------------- | ------------------ |
| `netif_output_fn output`         | **IP 层 → 链路层** | IP 层调用 (`ip_output()`)             | 负责封装 IP 包为链路层帧（如 Ethernet 帧） | 添加 MAC 地址、ARP 查询   |
| `netif_linkoutput_fn linkoutput` | **链路层 → 驱动层**  | Ethernet 层调用 (`ethernet_output()`) | 负责把帧交给物理或虚拟网卡发送              | 写入 TUN 设备或发送到硬件寄存器 |


发送流程举例（以以太网接口为例）：
1. 上层（如 TCP）要发一个数据包 → 调用 ip_output()
2. ip_output() → 调用 netif->output()（通常是 etharp_output）
3. etharp_output()：
查 ARP 缓存，找到目标 MAC 地址
封装 Ethernet header（MAC 源/目的）
调用 netif->linkoutput()
4. netif->linkoutput() 由驱动实现，例如：
把以太帧写入网卡发送队列
或写入 TUN 虚拟设备文件（比如 /dev/tun0）


ARP 全称是 Address Resolution Protocol（地址解析协议）。
它的作用是：
在同一个局域网内，把 IP 地址 转换成 MAC 地址。

假设有两台主机：
| 主机 | IP 地址        | MAC 地址            |
| -- | ------------ | ----------------- |
| A  | 192.168.1.10 | 00:11:22:33:44:55 |
| B  | 192.168.1.20 | 66:77:88:99:AA:BB |
当 A 想给 B 发包时，A 只知道目标 IP 是 192.168.1.20，
但不知道目标 MAC。

于是 A 会广播一个 ARP 请求：
Who has 192.168.1.20? Tell 192.168.1.10
局域网内的 B 收到后，回应：
192.168.1.20 is at 66:77:88:99:AA:BB
然后 A 就把这个映射关系保存下来。

IP ↔ MAC 对应表 就是 ARP 缓存表。
它是一个本地内存表，用来加速后续访问。
每次发送前，系统会先查表，而不是重复广播。


ARP 缓存（ARP Cache）只用于局域网（LAN）内的通信。
原因在于：ARP 协议本身是一个 链路层（Layer 2）协议，
只在同一个以太网广播域中工作。

所以当主机要发包时，它必须：
根据目标 IP 判断是否在同一网段；
如果在同一网段 → 通过 ARP 解析目标 IP 的 MAC；
如果不在同一网段 → 通过 ARP 解析 网关（Gateway） 的 MAC。




| 主机          | IP           | MAC               |
| ----------- | ------------ | ----------------- |
| A           | 192.168.1.10 | 00:11:22:33:44:55 |
| B           | 192.168.1.20 | 66:77:88:99:AA:BB |
| 网关 (Router) | 192.168.1.1  | AA:BB:CC:DD:EE:FF |

情况一：A → B（同一网段）
A 检查发现 192.168.1.20 在本子网内；
查 ARP 缓存（或发送 ARP 请求）得到 B 的 MAC；
直接封装以太网帧，目标 MAC = B 的 MAC。

情况二：A → 8.8.8.8（不同网段）
A 判断目标 IP 不在本地网段；
查找网关 IP（192.168.1.1）；
通过 ARP 获取 网关的 MAC 地址；
封装以太网帧，目标 MAC = 网关的 MAC；
网关再根据路由表转发。


跨网段通信靠什么？
当离开局域网时，就不再使用 ARP，而是：
    IP 层的路由表（Routing Table） 决定下一跳；
    每一跳路由器内部再用自己的 ARP 解析本地下一跳的 MAC。
可以理解为：
每一跳路由器只在自己的局域网范围内使用 ARP。
整个 Internet 是通过“分段 + 路由”层层转发的。


| 通信场景              | 是否使用 ARP       | 说明                   |
| ----------------- | -------------- | -------------------- |
| 同一个局域网内（A ↔ B）    | ✅ 是            | 直接查或广播获取对方 MAC       |
| 跨网段（A → Internet） | ✅ 是，但只查网关的 MAC | 实际包发给路由器，由路由器继续转发    |
| 路由器转发             | ✅ 是            | 每一跳路由器在自己的子网中再次用 ARP |
| 广域网（Internet）     | ❌ 否            | 不直接使用 ARP，靠 IP 路由    |



“同一网段” = 可以直接通过二层（MAC 层）通信，不需要路由； // 局域网通信（Local communication）。
“不同网段” = 必须经过路由器（Gateway）转发，属于跨网通信（可能是外网，也可能是另一个内网）。// 不同网段 = 必须通过路由器


| 概念                   | 含义           | 举例                     |
| -------------------- | ------------ | ---------------------- |
| **局域网 (LAN)**        | 同一网段内的主机集合   | 192.168.1.x            |
| **不同网段**             | 网络号不同，需要路由转发 | 192.168.1.x ↔ 10.0.0.x |
| **外网 (Internet)**    | 通过公网路由转发的网络  | 访问 8.8.8.8             |
| **内网 (Private LAN)** | 使用私有 IP 段的网络 | 192.168.x.x、10.x.x.x 等 |


“同一网段” ⟹ 一定是局域网通信
“不同网段” ⟹ 一定需要路由器，但不一定就是外网
（可能只是另一个内网，比如公司内的不同部门网段）


以太网层（Ethernet layer）就是数据链路层（Data Link Layer）的一种实现。// 以太网层 (Ethernet Layer) ：数据链路层的一种实现
“数据链路层”是 OSI 七层模型中的第二层（Layer 2），
而“以太网（Ethernet）”只是这一层的具体协议标准之一。
| 层级 | 名称        | 典型协议或技术                         | 功能              |
| -- | --------- | ------------------------------- | --------------- |
| 7  | 应用层       | HTTP、DNS、SSH                    | 应用服务            |
| 6  | 表示层       | TLS、MIME                        | 加密、编码           |
| 5  | 会话层       | SSL、NetBIOS                     | 会话管理            |
| 4  | 传输层       | TCP、UDP                         | 端口、可靠传输         |
| 3  | 网络层       | IP、ICMP、ARP（半跨层）                | 路由、寻址           |
| 2  | **数据链路层** | **Ethernet、PPP、Wi-Fi (802.11)** | MAC 地址、帧传输、错误检测 |
| 1  | 物理层       | 光纤、电缆、无线信号                      | 比特传输            |

以太网帧的结构示例
| 目标MAC | 源MAC | EtherType | Payload (上层数据，例如IP包) | CRC |
| 6 bytes | 6 bytes | 2 bytes   |        46~1500 bytes         | 4 bytes |

目标MAC/源MAC：物理地址（网卡唯一标识）
EtherType：标明上层协议类型（例如 0x0800 = IPv4, 0x86DD = IPv6）
Payload：实际承载的数据，比如 IP 数据包
CRC：用于错误检测