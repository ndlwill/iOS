Diffie-Hellman:一种确保共享KEY安全穿越不安全网络的方法
密钥交换协议，称为Diffie-Hellman密钥交换协议/算法(Diffie-Hellman Key Exchange/Agreement Algorithm).
这个机制的巧妙在于需要安全通信的双方可以用这个方法确定对称密钥。然后可以用这个密钥进行加密和解密。
但是注意，这个密钥交换协议/算法只能用于密钥的交换，而不能进行消息的加密和解密。
双方确定要用的密钥后，要使用其他对称密钥操作加密算法实现加密和解密消息。


由于TLS对交互信息的时序有规定，所以下层协议必须能够提供这种时序服务，因此TLS不能使用UDP来传输。
针对UDP的安全应用场景，可参照DTLS规范。

https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247486088&idx=1&sn=48812205b3040a3ab869db39904047f6&chksm=eb538fbedc2406a818ffa658caa29359689c78f790610faeed47e2d3e64e2eba62a6bdbf58a8&scene=21#wechat_redirect

如何保证公钥不被篡改？
解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。

公钥加密计算量太大，如何减少耗用的时间？
解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。
由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。

SSL/TLS协议的基本过程是这样的：
（1） 客户端向服务器端索要并验证公钥。
（2） 双方协商生成”对话密钥”。
（3） 双方采用”对话密钥”进行加密通信。
上面过程的前两步，又称为”握手阶段”（handshake）。
1.客户端发出请求（ClientHello）
客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。
客户端主要向服务器提供以下信息。
（1） 支持的协议版本，比如TLS 1.0版。
（2） 一个客户端生成的随机数，稍后用于生成”对话密钥”。
（3） 支持的加密方法，比如RSA公钥加密。
（4） 支持的压缩方法。

2.服务器回应（SeverHello）
服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。
（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
（2） 一个服务器生成的随机数，稍后用于生成”对话密钥”。
（3） 确认使用的加密方法，比如RSA公钥加密。
（4） 服务器证书。
除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。
比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。

3.客户端回应
客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。
如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。
（1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。
（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。

上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。

至于为什么一定要用三个随机数，来生成”会话密钥”?
“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。
对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。
pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，
那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”

如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。

4.服务器的最后回应
服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。
（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。

至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。

==============================
单向认证:
1、客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。

2、服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书

3、客户端使用服务端返回的信息验证服务器的合法性，包括：

证书是否过期

发型服务器证书的CA是否可靠

返回的公钥是否能正确解开返回证书中的数字签名

服务器证书上的域名是否和服务器的实际域名相匹配

验证通过后，将继续进行通信，否则，终止通信

4、客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择

5、服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。

6、服务器将选择好的加密方案通过明文方式返回给客户端

7、客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器

8、服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。 在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。

双向认证:
双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证

1、客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。

2、服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书

3、客户端使用服务端返回的信息验证服务器的合法性，包括：

证书是否过期

发型服务器证书的CA是否可靠

返回的公钥是否能正确解开返回证书中的数字签名

服务器证书上的域名是否和服务器的实际域名相匹配

验证通过后，将继续进行通信，否则，终止通信

4、服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端

5、验证客户端的证书，通过验证后，会获得客户端的公钥

6、客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择

7、服务器端在客户端提供的加密方案中选择加密程度最高的加密方式

8、将加密方案通过使用之前获取到的公钥进行加密，返回给客户端

9、客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端

10、服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。

==============================

https://xz.aliyun.com/t/2531#toc-17

https://halfrost.com/https-begin/
TLS/SSL 协议位于应用层和传输层 TCP 协议之间。TLS 粗略的划分又可以分为 2 层:
靠近应用层的握手协议 TLS Handshaking Protocols
靠近 TCP 的记录层协议 TLS Record Protocol

TLS 握手协议还能细分为 5 个子协议:
change_cipher_spec (在 TLS 1.3 中这个协议已经删除，为了兼容 TLS 老版本，可能还会存在)
alert
handshake
application_data
heartbeat (这个是 TLS 1.3 新加的，TLS 1.3 之前的版本没有这个协议)

github.com

1.DNS解析
github.com的IP响应为192.30.253.113

2.发起TLS握手
解析IP后，浏览器将通过http请求页面，如果服务器支持TLS，那么它将发送协议升级请求来响应浏览器，这个新的地址https://github.com ,将使用端口号443来指定，随后浏览器将启动TLS握手请求。
大多数现代浏览器都存有与Web服务器的最后一次连接的记录，如果最后一次连接是通过https进行的，那么下次浏览器将自动启动https请求而无需等待服务器。

TLS握手分为以下几个步骤:
客户端发送Hello报文
服务器接收Hello报文
共享证书和服务器密钥交换
更改密码规范
加密握手

==========(1)客户端发送Hello报文
TLS是在TCP之上实现的协议，TLS本身是一层协议并且它的底层叫做记录协议(Record protocol)，这意味着所有数据都被记录
典型的记录格式如下:
HH V1:V2 L1:L2 data

HH是单个字节，表示记录中的数据类型。共定义了四种类型：change_cipher_spec（20），alert（21），handshake（22）和application_data（23）。
V1：V2是协议版本，用两个以上的字节表示。对于当前定义的所有版本，V1的值为0x03，而对于SSLv3，V2的值为0x00，对于TLS 1.0为0x01，对于TLS 1.1为0x02，对于TLS 1.2为0x03。
L1：L2是数据的长度，以字节为单位（使用big-endian约定：长度为256 * L1 + L2），数据的总长度不能超过18432字节，但实际上它无法达到这个值。

内容类型是Handshake，TLS版本1.0，数据长度为512.真实数据位于名为 Handshake Protocol：Client Hello的下拉列表中(客户端发送Hello报文的内容)。
客户端版本

客户端的随机数

会话id(Session id)
如果客户端第一次连接到服务器，那么这个字段就会保持为空
可以看到Session id正在给服务器发送东西，之所以会发生这种情况是由于我之前是通过https连接到github.com的，在此期间，服务器将使用Session id映射对称密钥，并将Session id存储在客户端浏览器中，为映射设置一个时间限。
如果浏览器将来连接到同一台服务器（当然要在时间限到期之前），它将发送Session id，服务器将对映射的Session进行验证，并使用以前用过的对称密钥来恢复Session，这种情况下，就不需要完全握手。

密码套件
客户端还将发送自己已经知道的密码套件列表，这个是由客户按优先顺序排列的，但完全由服务器来决定发送与否。TLS中使用的密码套件有一种标准格式。
Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xc02b)
TLS：指使用的协议是TLS
ECDHE：密钥交换算法
ECDSA：签名或验证算法
AES_128_GCM：称为批量加密算法。对称密钥加密算法是AES，密钥长度为128位，AES是块密码，也就是对输入的纯文本用固定长度的块来进行加密，加密后的每个块按再顺序发送，最后按类似的方式来进行解密。
SHA256：消息验证代码（MAC）算法。

压缩数据
为了减少带宽，可以进行压缩。
从TLS 1.3开始，协议就禁用了TLS压缩。

扩展名
其他参数（如服务器名称，填充，支持的签名算法等）可以作为扩展名使用

==========(2)服务器接收Hello报文
收到客户端问候之后服务器必须发送服务器问候信息，服务器会检查指定诸如TLS版本和算法的客户端问候的条件，如果服务器接受并支持所有条件，它将发送其证书以及其他详细信息，否则，服务器将发送握手失败消息。
看到服务器响应0x0303表示服务器同意使用TLS 1.2

服务器接收Hello报文的内容:
服务器版本
如果客户端可以支持，则服务器将选择客户端指定的TLS版本，这里选择了TLS 1.2

服务器的随机数
客户端和服务器随机将用来创建加密密钥

密码套件
我们已经将发送支持的密码套件发送到客户端问候中的github.com吗？Github从名单中选出了第一个

会话id(Session id)
服务器将约定的Session参数存储在TLS缓存中，并生成与其对应的Session id。
它与Server Hello一起发送到客户端。
客户端可以写入约定的参数到此Session id，并给定到期时间。
客户端将在Client Hello中包含此id。
如果客户端在此到期时间之前再次连接到服务器，则服务器可以检查与Session id对应的缓存参数，并重用它们而无需完全握手。
这非常有用，因为服务器和客户端都可以节省大量的计算成本。

在涉及亚马逊和谷歌等流量巨大的应用程序时，这种方法存在缺点。
每天都有数百万人连接到服务器，服务器必须使用Session密钥保留所有Session参数的TLS缓存。
这是一个巨大的开销。为了解决之前介绍过的Session Tickets的问题, 
在这里，客户端可以在client hello中指定它是否支持Session Ticket。
然后，服务器将创建一个新的会话票证(Session Ticket)，并使用只有服务器知道的经过私钥加密的Session参数。
它将存储在客户端上，因此所有Session数据仅存储在客户端计算机上，但Ticket仍然是安全的，因为该密钥只有服务器知道。

此数据可以作为名为Session Ticket的扩展包含在Client Hello中。
在我们的例子中，此参数为空，因为这是第一次连接到github.com或前一个Session的浏览器已过期。

压缩数据
如果支持，服务器将同意客户端的首选压缩方法。在这里，您可以看到服务器响应为空响应，则意味着不需要压缩。


服务器不在ServerHello消息中发送任何证书; 它会在正确命名的证书消息中发送证书。
服务器证书的信息:
在我们的例子中，证书消息长度为3080字节
这是包含所有信息的服务器证书。服务器按信任链的顺序发送完整的证书列表。
该链中的第一个是服务器证书，接着是颁发服务器证书的intermediate CA 的证书,然后是下一个intermediate CA 的证书......直到Root CA的证书。
服务器不可以发送Root CA证书，因为在大多数情况下，浏览器可以从任何intermediate CA 识别Root CA。

在我们的例子中，您可以看到第一个证书是github.com，第二个证书是中间件Digicert SHA2扩展验证Server CA。 检查id-at-commonName参数。

可以通过开发者工具 -> 安全标签（Security）进行查看证书
让我们分析证书的内容，看看浏览器如何验证它:
证书的内容:
证书被发送到浏览器，因此我们可以在访问github.com时查看Github的证书
（1）版本和序列号
版本表示使用的是哪个版本的X.509标准。X.509是用于定义公钥证书格式的标准。X.509有3个版本，github使用最新版本version 3。
从RFC 5280开始，CA为每个证书分配的序列号必须是正整数。因此对于每个发布CA证书，它必须是唯一的（即颁发者名称和序列号标识唯一的证书）。所以，CA必须强制serialNumber为非负整数。

（2）证书的签名算法与值
浏览器需要知道签名算法以验证签名。如果使用的是RSA签名，则需要相同的算法来验证签名。对于Github，使用的是PKCS＃1 SHA-256和RSA加密，即SHA-256用于生成散列，RSA用于签名。
证书数据使用SHA-256算法进行哈希处理，并使用RSA加密过Github的私钥对此哈希进行签名。

（3）颁布机构
此字段包含颁发证书的颁发机构的详细信息。Github的证书由Digicert的intermediate CA 颁发

（4）合法性
该字段有两个值Not Before 和Not After 。如果当前日期时间不在这些值之间，则证书无效。浏览器就不会信任该证书。

（5）子公钥信息(Subject Public Key Info)
该字段携带公钥和用于生成公钥的算法。此密钥用于交换密钥

（6）指纹
浏览器生成了两个指纹SHA 1和SHA-256，而且不会发送到服务器。这些指纹分别是通过SHA 1和SHA-256函数散列DER格式的证书产生的。我们可以通过将证书下载到我们的机器并应用哈希函数来验证这一点。
单击详细信息选项卡左下角的“ 导出” 按钮以下载证书，保存为.crt 扩展名，并在终端上运行以下命令以生成证书的指纹。
$ openssl x509 -noout -fingerprint -sha256 -inform pem -in [certificate-file.crt]
$ openssl x509 -noout -fingerprint -sha1 -inform pem -in [certificate-file.crt]
这些值不是证书的一部分，而是根据证书计算出来的。
Root CA证书的指纹将在浏览器中进行硬编码，因此可以轻松地进行交叉验证。除此之外，这些指纹主要用于识别和组织证书。

这里讨论的证书信息是关于github.com的服务器证书。Github的intermediate CA 证书也将在同一请求中发送给客户，
所有上述字段也适用于该证书。您可以通过转到详细信息选项卡并单击intermediate CA 来检查

==========（3）服务器端密钥交换
随后是Server Hello和证书消息(Certificate message)，服务器密钥交换(Server Key Exchange)是可选的。
仅当服务器提供的证书不足以允许客户端交换预主密钥时，才会发送此消息。
看看为什么github.com必须发送服务器密钥交换消息。

我们可以看到github.com首选Session的密码套件是TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256。这意味着双方使用Elliptic Curve Diffie Hellman算法来交换密钥。
ECDH (Elliptic Curve Diffie–Hellman Key Exchange) 
在Diffie-Hellman中，客户端无法自行计算预主密钥; 双方都有助于计算它，因此客户端需要从服务器获取Diffie-Hellman公钥。
当使用Elliptic Curve Diffie-Hellman时，该公钥不在证书中。因此，服务器必须在单独的消息中向客户端发送其DH公钥，以便客户端可以计算预主密钥。
请注意，此密钥交换也由签名保护。
服务器密钥交换完成后，服务器将发送Server Hello Done 消息。客户端将开始计算Pre-Master Secret。

1.如何计算Pre-Master Secret
Pre-Master Secret计算取决于商定的密钥交换算法的类型。当使用RSA进行密钥交换时，从客户端（即浏览器）计算预主密钥，客户端通过连接协议版本（2个字节）和客户端随机生成的一些字节（46个字节）来生成48字节的预主密钥。
客户端从加密安全的伪随机数发生器（PRNG）获得这46个字节。
实际上，这意味着使用操作系统提供的PRNG，例如/dev/urandom。
然后，使用服务器的公共和共享对此Pre-Master密钥进行加密，以便服务器稍后可以使用它来创建主密钥。

Diffie-Hellman key exchange is a method of digital encryption that securely exchanges cryptographic keys between two parties over a public channel without their conversation being transmitted over the internet. 

在Github的情况下，如上所述，Diffie-Hellman算法用于密钥交换。这里的情况略有不同。服务器立即生成一对DH私钥 - 公钥。然后，与客户共享公钥。这是如上所述的"服务器密钥交换消息( Server Key Exchange)"。

作为响应，客户端还将创建DH密钥对，并通过客户端密钥交换消息与服务器共享公钥
您可以看到共享的客户端公钥。

change_cipher_spec (以下简称 CCS 协议) 协议，是 TLS 记录层对应用数据是否进行加密的分界线。
客户端或者服务端一旦收到对端发来的 CCS 协议，就表明接下来传输数据过程中可以对应用数据协议进行加密了。

==========(4)客户端密钥交换
客户端的DH公钥通过客户端密钥交换消息共享给服务器。
但是如果使用RSA，则客户端将如上所述通过其自己计算预主密钥，使用服务器的公钥（RSA公钥）对其进行加密，并通过客户端密钥交换消息将其发送回服务器。
然后，服务器可以使用其私钥解密它。
无论算法是什么，此时客户端和服务器都达到了共同的Pre-Master Secert 。完成此操作后，客户端将发送Change Cipher Spec 消息

1.如何计算主秘钥
现在客户端和服务器都有哪些随机数据呢？根据RFC 5346标准，在问候消息期间客户端和服务器共享的预主密钥和随机值都会使用PRF（伪随机函数）产生的值来计算主密钥。
master_secret = PRF（pre_master_secret，“master secret”，ClientHello.random + ServerHello.random）[0..47];
pre_master_secret - 双方计算的48字节Pre-Master密码。
“master secret” - 它只是一个使用ASCII字节的字符串。
ClientHello.random - 客户端hello中共享的随机值
ServerHello.random - 服务器hello中共享的随机值。
主密钥的大小共48个字节
双方都可以使用主密钥加密数据并来回发送
你认为双方使用相同的秘钥是个好办法吗？当然不是！TLS为客户端和服务器分配了单独的密钥，它们都来自主密钥本身，换句话说，主密钥不直接用于加密数据，而是将单独的加密密钥用于客户端和服务器。
由于双方都有两个密钥，服务器用其密钥加密的数据可以由客户端轻松解密，反之亦然。

2.消息验证代码（MAC）和TLS数据完整性
窃听者可以对传输中的加密数据进行两种可能的攻击：尝试解密数据或尝试修改数据。
只要密钥安全，我们就可以认为解密基本上是不可能的，但如果是修改数据呢？客户端和服务器是怎么知道攻击者没有修改过数据呢？
TLS不仅仅是加密数据，还可以保护数据，使其免受未检测到的修改，换句话说，TLS可以检查数据的完整性。

当服务器或客户端使用主密钥加密数据时，它还会计算明文数据的校验和（哈希值），这个校验和称为消息验证代码（MAC）
然后在发送之前将MAC包含在加密数据中。密钥用于从数据中生成MAC，以确保传输过程中攻击者无法从数据中生成相同的MAC，故而MAC被称为HMAC（哈希消息认证码）
另一方面，在接收到消息时，解密器将MAC与明文分开，然后用它的密钥计算明文的校验和，并将其与接收到的MAC进行比较，如果匹配，那我们就可以得出结论：数据在传输过程中没有被篡改。
客户端和服务器必须使用相同的散列算法来创建以及验证MAC，还记得Github同意的密码套件的最后一部分吗？
TLS_ECDHE_ECDSA_WITH_AES_128_GCM_ SHA256。即SHA256 是用于处理HMAC的哈希函数，为了提高安全性，客户端和服务器使用MAC密钥。

3.生成测试数据
现在双方都有了加密密钥，我们准备加密，但是在将TLS放到应用层之前，我们需要像每个进程一样来测试并验证客户端加密数据是否可以由服务器解密，反之亦然。
为此，客户端将使用伪随机函数（PRF）计算12字节的verify_data
verify_data = PRF(master_secret, "client finished", MD5(handshake_messages) + SHA-1(handshake_messages) ) [12]

其中handshake_messages 是所有握手消息的缓冲区，以上版本适用于版本1.2的TLS。版本1.2略有变化，即verify_data的长度取决于密码套件而不总是12字节，任何未明确指定verify_data_length的密码套件都等于12。
此外，伪随机函数（PRF）中的MD5 / SHA-1组合具有已被密码套件指定的PRF替换。所以根据最新规范，
Verify_data = PRF(master_secret, finished_label, Hash(handshake_messages)) [0..verify_data_length-1];

因此我们有测试数据，用密钥和算法来加密测试数据。客户端所需要做的就是用客户端加密密钥（或简称客户端写入密钥）使用AES算法加密测试数据，如上所述还得计算HMAC，客户端获取结果并添加记录头字节“0x14”表明“已完成”，再通过客户端生成消息并且发送到服务器。

4.验证磋商
服务器处理过程也几乎相同。它发出一个Change Cipher Spec ，然后发送一条包含所有握手消息的已完成信息。
除此之外，服务器的完成消息将包含对客户端的完成消息进行解密的版本，一旦客户端收到此数据，它将使用服务器写入密钥对其进行解密。故而这就向客户证明了服务器能够成功解密我们的消息
我们完成了TLS握手。

==========(5）加密应用程序数据
GET https://github.com/

Host: github.com

User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:61.0) Gecko/20100101 Firefox/61.0

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

Accept-Language: en-US,en;q=0.5

Accept-Encoding: gzip, deflate, br

Connection: keep-alive

Upgrade-Insecure-Requests: 1

Cache-Control: max-age=0



wireshark info显示的是: Application Data

// 17 使用的是16进制
前3个字节17 03 03 表示内容的数据类型（应用程序数据）和TLS版本（TLS 1.2）。