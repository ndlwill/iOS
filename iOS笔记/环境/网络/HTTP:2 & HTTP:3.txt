HTTP/2
核心特性
多路复用（Multiplexing）
一个 TCP 连接上可以同时发送多个请求和响应
避免了 HTTP/1.x “队头阻塞”（Head-of-Line Blocking）问题
对 CDN 下载大量小文件（比如 CocoaPods JSON）特别有用

头部压缩（Header Compression）
HTTP/1.x 每个请求头都要重复发送，HTTP/2 用 HPACK 压缩
减少网络带宽

请求优先级（Stream Prioritization）
可以给不同请求分配优先级，先下载重要资源

优点总结
并行请求不必建立多个 TCP 连接 → 减少延迟
小文件下载更快
带宽利用率更高



HTTP/3
核心特性
基于 QUIC 协议（UDP）
TCP → QUIC（UDP）
自带多路复用和拥塞控制
减少连接建立和重传延迟

解决 TCP 队头阻塞问题
即使某个包丢失，也不会阻塞其他请求
适合高丢包、跨境网络环境

零握手连接（0-RTT）
支持快速重新连接，减少延迟


#####
头部压缩（Header Compression）

GET /api/user HTTP/1.1
Host: example.com
User-Agent: MyApp/1.0
Accept: */*
Cookie: session=abc123

HTTP 请求和响应都有 Header
Header 内容通常重复，例如 Host、User-Agent、Cookie 等
HTTP/1.1 每次请求都完整发送一遍 → 浪费带宽

HTTP/2 使用 HPACK 压缩算法
核心机制：
静态表 + 动态表存储常见 Header 键值
编码索引而不是重复发送完整字符串
可以只发送变化部分 → 节省流量
举例：
第一次请求发送完整 Header
后续请求同样的 Host、User-Agent → 直接发送索引或者差异
Cookie 改变了只发送新值
#####


#####
TCP 队头阻塞（Head-of-Line Blocking, HOL），这是理解 HTTP/1.1 与 HTTP/2 多路复用差异的关键点。
队头阻塞（HOL）：TCP 的顺序交付机制导致前面一个包慢或丢 → 后续数据也被阻塞

前面的数据包阻塞了后面的数据包处理
在 单个 TCP 连接 上，如果第一个包丢失，TCP 必须等待这个包重传，后面的包即使已经到达也不能被处理
换句话说：TCP 保证 顺序交付，即数据一定按发送顺序到达应用层。
如果前面一个包慢或者丢失，后面的包就被“堵住”了 → 队头阻塞。
#####

优点总结
延迟更低，尤其是跨国网络
丢包环境下性能稳定
更适合 CDN、视频流、大量小文件分发

==================================================

一个 TCP 连接由 四个元素唯一确定：
源 IP + 源端口 + 目标 IP + 目标端口
源 IP：客户端本地 IP
源端口：客户端本地随机端口（通常由操作系统分配）
目标 IP：服务器 IP
目标端口：服务器端口（HTTP 默认 80，HTTPS 默认 443）
这四个值唯一标识一条 TCP 连接。

多连接情况
当客户端和同一个服务器建立多条连接时：
目标 IP 和目标端口 是一样的（同一个服务器和端口）
源端口 会随机分配不同的值
源 IP 一般一样（除非多网卡或代理）
所以即使是同一台客户端和同一台服务器，也能同时建立多条 TCP 连接，因为 源端口不同。

| 连接 | 源 IP         | 源端口   | 目标 IP   | 目标端口 |
| -- | ------------ | ----- | ------- | ---- |
| 1  | 192.168.1.10 | 54321 | 8.8.8.8 | 443  |
| 2  | 192.168.1.10 | 54322 | 8.8.8.8 | 443  |
| 3  | 192.168.1.10 | 54323 | 8.8.8.8 | 443  |

目标 IP/端口相同
源端口不同 → TCP 栈认为是不同连接


多连接并行靠的就是 源端口不同 来区分连接
同一客户端和同一服务器可以建立任意多条 TCP 连接（受操作系统限制）
HTTP/2 多路复用则 只需要一条 TCP 连接，不必开多个端口



端口与 App 的关系
源端口：客户端用来区分不同 TCP 连接的标识，由操作系统分配（通常 1024–65535）
一个 App 可以同时建立多条 TCP 连接：
每条连接都会有一个 不同的源端口
这些连接可以指向 同一个服务器 或 不同服务器


一个 App 可以同时建立 多条 TCP 连接，每条连接都有自己的 源端口


App 可以同时和同一服务器建立多条 TCP 连接 → 多个端口
例子：
app发起不同的api接口请求服务器 （HTTP/1.1 多连接场景）

假设你的 App 有三个不同 API 请求要调用：
获取用户信息 → /api/user
获取好友列表 → /api/friends
上传日志 → /api/log

HTTP/1.1 （单连接顺序执行）
TCP 连接 1（源端口 50001）:
    请求 /api/user → 等响应
    请求 /api/friends → 等响应
    请求 /api/log → 等响应
所有请求在同一条 TCP 连接上顺序执行
队头阻塞：第一个请求慢，后面请求也得等

HTTP/1.1 多连接并行
TCP 连接 1（源端口 50001）: 请求 /api/user
TCP 连接 2（源端口 50002）: 请求 /api/friends
TCP 连接 3（源端口 50003）: 请求 /api/log
三条 TCP 连接同时发送请求 → 并行下载
每条连接使用不同源端口

HTTP/2 多路复用
TCP 连接 1（源端口 50001）:
    请求 /api/user
    请求 /api/friends
    请求 /api/log
所有请求共享同一条 TCP 连接（同一个源端口）
服务器按 stream ID 返回响应 → 并行处理
不需要多条端口连接
