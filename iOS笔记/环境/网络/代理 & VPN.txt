代理（Proxy）
作用：代理服务器是中间人，设备向代理发送请求，由代理再去访问目标服务器。
特性：
可以只代理 HTTP/HTTPS 流量，也可以支持 SOCKS 代理。
不会改变设备的整个网络出口，只处理特定流量。

全局 HTTP 代理
作用：只拦截 HTTP/HTTPS 请求（通常是 TCP 443/80），把流量先发到代理服务器，由代理服务器再转发到目标。
特点：
可拦截/修改：代理可以看到请求内容，甚至修改。
只针对应用层流量：低层 TCP/UDP 可能不走代理（例如 DNS、某些加密协议、非 HTTP 的 UDP 游戏流量等）。
优点：灵活，可做请求监控、过滤、加速。
缺点：不一定能覆盖所有流量，尤其是非 HTTP/HTTPS 流量。


VPN
作用：VPN 会把设备整个网络流量（或部分流量，取决于 split tunnel）通过 VPN 隧道发送。
特性：
所有流量经过 VPN，就像设备在 VPN 端网络内部。
可以是 IPSec、IKEv2、OpenVPN、WireGuard 等协议。

VPN（全路由）
作用：拦截整个设备的流量（全路由模式），所有网络流量都会经过 VPN 服务器。
特点：
系统层拦截：不管是 HTTP、HTTPS、UDP、ICMP 等全都能转发。
透明：应用无需感知，所有流量被统一处理。
通常加密：设备与 VPN 服务器间流量被加密，防止本地网络嗅探。
优点：覆盖面广，适合安全、穿透、访问限制地区网络。
缺点：配置复杂，性能依赖 VPN 服务器和加密开销。


全局 HTTP 代理只是覆盖 HTTP/HTTPS 的“半个 VPN”，VPN 才是真正的全流量通道。
VPN 通常加密整个隧道，代理不一定加密。


==================================================HTTP 代理 vs SOCKS 代理

| 特性     | HTTP 代理              | SOCKS 代理                                |
| ------ | -------------------- | --------------------------------------- |
| 协议层    | 应用层（只能处理 HTTP/HTTPS） | 传输层（TCP/UDP 都可以）                        |
| 流量类型   | 只支持 HTTP/HTTPS 请求    | 可以转发任意 TCP/UDP 流量（例如 SSH、游戏、BitTorrent） |
| 可拦截/修改 | 可以看 HTTP 内容，甚至修改     | 仅转发数据包，不关心内容                            |
| 配置方式   | 浏览器或系统代理设置           | 浏览器、系统、App 支持 SOCKS 或第三方工具              |
| 使用场景   | 网页加速、访问限制网站          | 全流量穿透、游戏加速、P2P 等   


SOCKS 代理和 VPN 的关系
SOCKS 代理可以 接近 VPN 的效果，因为它支持任意 TCP/UDP 流量转发。
但是：
通常不加密（除非配合 SSH 或 TLS），VPN 默认会加密整个隧道。
不是系统透明：如果某些 app 不支持 SOCKS，流量可能不会走代理。
路由管理：VPN 可以全局接管路由表，SOCKS 只能针对配置的应用/端口。                     |

HTTP 代理只处理 HTTP/HTTPS，SOCKS 可以处理更多类型流量。
SOCKS 代理 + 全局配置，和 VPN 很像，但 VPN 更加全面、安全、透明。

SOCKS 代理的生效范围 = 只对 支持 SOCKS 的应用
SOCKS = 你开了条小道，只有会走这条小道的人（支持 SOCKS 的 app）才能走。
VPN = 你改了整个城市的高速路网，所有车都必须走你的通道。


==================================================在 iOS 上，HTTP 请求配置代理主要有 系统层级代理 和 应用自定义代理 两种方式

系统层级代理（Wi-Fi 或蜂窝网络）
iOS 可以在 设置 → Wi-Fi → 当前网络 → 配置代理 中设置：
手动：输入代理服务器 IP 和端口
自动：输入 PAC 脚本 URL


应用内 NSURLSession 配置代理
使用 URLSessionConfiguration.connectionProxyDictionary
代理认证（如果代理需要用户名密码）
// URLSessionDelegate
func urlSession(_ session: URLSession, task: URLSessionTask, 
                didReceive challenge: URLAuthenticationChallenge, 
                completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
    let credential = URLCredential(user: "username", password: "password", persistence: .forSession)
    completionHandler(.useCredential, credential)
}



PAC（Proxy Auto-Configuration）脚本 URL 是指一个 JavaScript 文件的网络地址，它定义了浏览器或 iOS 设备如何根据请求的 URL 动态选择代理服务器。
它就是一套“规则”，告诉系统“哪些请求走代理，哪些直接访问”。

PAC 脚本作用
自动决定 HTTP/HTTPS 请求是否使用代理
可以根据 目标域名、IP 或 URL 动态选择不同代理
支持多个代理、备用代理或直接连接

PAC 文件基本格式
PAC 文件是一个 JavaScript 函数 FindProxyForURL(url, host)：
function FindProxyForURL(url, host) {
    // 例子 1：所有请求走代理
    return "PROXY 192.168.1.100:8080";

    // 例子 2：访问 apple.com 直连，其它走代理
    if (shExpMatch(host, "*.apple.com")) {
        return "DIRECT";
    } else {
        return "PROXY 192.168.1.100:8080";
    }

    // 例子 3：多个代理，备用
    return "PROXY 192.168.1.100:8080; PROXY 192.168.1.101:8080; DIRECT";
}
PROXY host:port → 走指定代理
DIRECT → 直接连接，不走代理
可以用 shExpMatch()、dnsDomainIs() 等函数判断 URL 或 host


在 设置 → Wi-Fi → 当前网络 → 配置代理 → 自动 中输入 URL
URL 可以是 HTTP 或 HTTPS 地址，例如：
http://192.168.1.200/proxy.pac
设备会下载 PAC 文件，并根据 FindProxyForURL 的逻辑决定每个请求走哪个代理


==================================================不走代理和走代理的请求区别
不走代理（Direct 直连）
流程：
App 发起 HTTPS 请求 https://example.com
系统直接建立 TCP 连接到 example.com:443
TLS 握手（加密协商）
HTTPS 请求和响应在 TLS 隧道中传输
数据直接从 App 到目标服务器，没有第三方中转


走代理（HTTP CONNECT 代理）
流程（HTTPS 通过代理）：
App 发起 HTTPS 请求 https://example.com
系统连接到代理服务器 192.168.1.100:8080
通过 HTTP CONNECT example.com:443 命令请求代理建立隧道
隧道建立成功后，TLS 握手和 HTTPS 数据在代理和目标服务器之间传输
代理只知道你要访问的目标 IP/域名和端口，但 无法解密 HTTPS 内容



从 网络传输角度：
请求行 + Header + Body 全部作为 TCP 的 payload 被发送。也就是 HTTP 协议的数据

代理服务器的行为：（HTTP 代理）
收到 TCP 数据 → 提取 HTTP 请求。
看 URL http://example.com/path → 知道目标服务器。
再去建立自己的 TCP 连接到 example.com，发送真正的请求。
把响应返回给客户端。


Nginx 是一个开源的、高性能的 HTTP/反向代理和负载均衡服务器。它已经实现了代理服务器的逻辑


#####
使用代理 vs 不使用代理 时，TCP/IP 层和应用层的数据包差异：
#####
1. 不使用代理（直连）
应用层：
HTTP/HTTPS 请求直接写目标主机和端口。
HTTP：GET /path HTTP/1.1 + Host: example.com
HTTPS：TLS 握手直接向目标服务器端口 443 发起
传输层：
TCP 连接目标服务器 IP:Port
网络层：
IP 包目标地址 = 服务器 IP
源地址 = 本机 IP
总结：
目标地址 = 最终服务器
端口 = 目标服务器端口（80/443）
数据内容 = HTTP/HTTPS 请求

2. 使用 HTTP/HTTPS 代理
HTTP：
请求会改写为全路径：GET http://example.com/path HTTP/1.1
目标仍在 Host header，但 TCP 建立的连接是代理服务器
HTTPS：
使用 CONNECT 方法：CONNECT example.com:443 HTTP/1.1
CONNECT 成功后，客户端和目标服务器建立 TLS 隧道（代理透明转发）
传输层：
TCP 连接 不是目标服务器，而是 代理 IP:Port // ##### 变的是这个，HTTP 层只关注内容，它不知道你 TCP 连接的是谁。
网络层：
IP 包目标地址 = 代理服务器 IP
源地址 = 本机 IP
总结：
目标地址 = 代理服务器
端口 = 代理端口（80/443/自定义）
数据内容 = HTTP 请求或者 HTTPS 隧道建立请求

3. 使用 SOCKS 代理
应用层：
SOCKS 是传输层代理，应用不改写 HTTP 请求
客户端向 SOCKS 发送目标服务器 IP + 端口请求，SOCKS 服务器负责转发
传输层：
TCP 连接建立在 SOCKS 服务器
网络层：
IP 包目标地址 = SOCKS 服务器
源地址 = 本机 IP
总结：
目标地址 = SOCKS 代理
端口 = SOCKS 端口
数据内容 = 原始请求（HTTP/HTTPS/其他 TCP）

TCP/IP 层面：
代理模式下，目标地址永远是代理服务器，而非最终目的服务器。
应用层面：
HTTP 代理会改写请求 URL（全路径）
SOCKS 代理不改写，只负责转发


#####
代理服务器如何判断一条 TCP/HTTP/HTTPS 请求是普通直接请求还是通过代理发来的请求：
#####
1. HTTP 代理的识别方式
关键点：HTTP 代理是 应用层代理，它通过请求的 格式 来判断流量是不是经过它转发的。
（1）HTTP 请求
直连普通 HTTP 请求：
GET /path HTTP/1.1
Host: example.com
只有相对路径 /path，Host 指向目标服务器
如果浏览器直连服务器，这就是普通请求，服务器直接处理

通过 HTTP 代理的请求：
GET http://example.com/path HTTP/1.1
Host: example.com
路径变为 完整 URL（scheme+host+path）
这是 HTTP 代理约定：代理通过绝对 URI 来知道真正的目标服务器 // #####

结论：
代理服务器通过 请求行是否是绝对 URL 来识别：
是绝对 URL → 来自代理客户端 → 需要转发
否 → 直接请求 → 不是代理请求

(2) HTTPS 请求（CONNECT 方法）
浏览器通过 HTTPS 代理建立隧道：
CONNECT example.com:443 HTTP/1.1
Host: example.com:443
代理识别逻辑：
请求方法是 CONNECT → 代理知道客户端想建立 TLS 隧道
代理只负责建立隧道，不需要解密内容
直连 HTTPS：
客户端直接 TCP 连接目标服务器 443 → 不会发送 CONNECT → 代理服务器根本收不到

2. SOCKS 代理的识别方式
SOCKS 是 传输层协议，不是应用层：
客户端在建立 TCP/UDP 连接时，先向 SOCKS 服务器发 Socks握手数据包（版本号、认证信息、目标地址/端口）
代理服务器通过握手识别这是 SOCKS 流量
直连流量：
如果客户端不发 SOCKS 握手，而直接 TCP 连接目标服务器 → 代理服务器无法识别，也就不是代理流量


==================================================常见支持 SOCKS（尤其是 SOCKS5） 的开源代理/中间件
经典通用代理
Shadowsocks
基于 SOCKS5 协议的安全代理，广泛使用。
Dante
专业的 SOCKS 代理服务器，支持 SOCKS4/SOCKS5。

支持 SOCKS 的多功能代理
Squid
主要是 HTTP/HTTPS 代理，但通过扩展/编译选项支持 SOCKS。

新一代工具
V2Ray
功能很全，内置 SOCKS 入站/出站。
Xray
V2Ray 的一个高性能分支，也支持 SOCKS。


如果你只是想快速跑一个 SOCKS5 服务端，推荐 Dante 或 Microsocks；
如果你需要 跨协议 + 强大路由规则，推荐 V2Ray/Xray；
如果是 传统企业环境，很多人会用 Squid + SOCKS 模块。


==================================================“代理可拦截/限制 HTTPS 请求” 时，需要明确区分 两种层级，或者说有两种代理方式
普通 HTTP/HTTPS 代理 和 MITM（中间人）代理


1. 普通 HTTPS 代理（HTTP CONNECT 隧道）
客户端流程：
App/浏览器向代理发起 HTTP CONNECT 请求：// 目的是告诉代理：“请帮我和 example.com 建立一个 TCP 隧道，我要在里面做 HTTPS 通信。”
CONNECT example.com:443 HTTP/1.1
Host: example.com:443
代理收到请求后，建立 到目标服务器的 TCP 连接
代理返回 200 Connection Established 给客户端
客户端直接在这个隧道上做 TLS 握手，与目标服务器建立加密连接

#####
客户端直接在隧道里进行 TLS 握手：
客户端把 TLS ClientHello 发到代理，代理转发到目标服务器
目标服务器返回 ServerHello，完成 TLS 握手 // ServerHello 是返回给客户端的，但它是 通过代理转发的。
此时 TLS 会话直接在客户端和目标服务器之间建立
#####

#####
关键点：TLS 的安全设计就是“即便中间人看到握手数据，也无法推导出对称密钥”，保证了端到端加密。因为没有私钥，也无法解密 pre-master secret

代理虽然转发 ClientHello/ServerHello，但没有私钥，也无法生成 pre-master secret → 无法生成对称密钥
#####


关键点：
代理不参与 TLS 握手内容
HTTPS 请求内容 客户端和目标服务器之间加密传输
代理只负责 转发 TCP 包，不能解密

客户端  ——TLS隧道——> 代理 ——TCP——> 目标服务器


2. MITM 代理（企业/中间人）// MITM 的全称是 “Man In The Middle”，中文意思是 “中间人攻击”或“中间人”。
客户端流程：
客户端连接到代理（代理伪造证书）
代理和客户端完成 TLS 握手（客户端认为这是目标服务器）
代理和目标服务器建立独立 TLS 握手
代理解密、检查或修改内容后，再加密转发给客户端

关键点：
代理在 转发前先和客户端建立 TLS
代理必须有客户端信任的证书，否则 HTTPS 会报错
HTTPS 内容在代理被解密，代理可以查看/修改

客户端  ——TLS握手——> 代理 ——TLS握手——> 目标服务器


==================================================SOCKS5
SOCKS 代理的握手过程确实发生在 TCP 三次握手建立完成之后

1. TCP 三次握手
客户端 → SOCKS 服务器：发送 SYN
SOCKS 服务器 → 客户端：回复 SYN+ACK
客户端 → SOCKS 服务器：回复 ACK
此时，TCP 连接建立完成，双方可以在这个可靠的 TCP 通道上传输数据。

2. SOCKS 握手阶段（发生在 TCP 三次握手之后）
(a) 客户端发送“方法选择”消息
+----+----------+----------+
|VER | NMETHODS | METHODS  |
+----+----------+----------+
VER: 协议版本（SOCKS5 = 0x05）
NMETHODS: 支持的认证方法数量
METHODS: 每个字节表示一种认证方式（如 0x00 表示无需认证，0x02 表示用户名/密码认证）

05 02 00 02
表示：SOCKS5，支持两种方法：无认证 (0x00) 和 用户名密码认证 (0x02)。

(b) 服务器回复“选择的方法”
+----+--------+
|VER | METHOD |
+----+--------+

05 00
表示：使用 SOCKS5 协议，并选择“无认证”。

(c) （可选）认证阶段
如果服务器选择了 0x02（用户名/密码认证），则客户端会发：
+----+------+----------+------+----------+
|VER | ULEN |  UNAME   | PLEN |  PASSWD  |
+----+------+----------+------+----------+
服务器返回认证是否成功。

3. SOCKS 请求阶段
客户端正式发起代理请求（要连接的目标地址/端口）：
+----+-----+-------+------+----------+----------+
|VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
+----+-----+-------+------+----------+----------+
VER: 版本 (0x05)
CMD: 命令（0x01=CONNECT，0x02=BIND，0x03=UDP ASSOCIATE）
ATYP: 地址类型（0x01=IPv4，0x03=域名，0x04=IPv6）
DST.ADDR: 目标地址
DST.PORT: 目标端口

05 01 00 03 0b 65 78 61 6d 70 6c 65 2e 63 6f 6d 00 50
表示：SOCKS5，CONNECT 请求，目标地址是域名 example.com，端口 80。

#####
这一阶段客户端只是告诉 SOCKS 服务器：
“我想连到哪个目标 IP/域名 + 端口”。这里不包含应用层数据，只是请求 SOCKS 服务器帮你建立 TCP 连接。
#####

4. SOCKS 服务器回复请求结果
+----+-----+-------+------+----------+----------+
|VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
+----+-----+-------+------+----------+----------+
REP 表示结果（0x00=成功，其他为错误代码）// #####到这里，SOCKS 代理已经和目标服务器建立好 TCP 连接了。#####
如果成功，客户端后续所有数据都会通过 SOCKS 服务器转发。

总结时序：
TCP 三次握手（正常 TCP 连接建立）
SOCKS 握手：客户端先发 VER/NMETHODS/METHODS
服务器回复选择的 METHOD
（可选）认证过程
客户端发起 CONNECT/BIND/UDP ASSOCIATE 请求
服务器回复结果
双方开始转发数据（HTTP/TLS/WebSocket 等应用层协议的数据）
#####
SOCKS 服务器确认后

应用层数据开始传输：
从这一步开始：
客户端发送的 原始 TCP 负载数据（比如 HTTP GET 请求、TLS ClientHello、SMTP 命令等），直接写入这个已经建立的 TCP 通道；
SOCKS 代理不再修改数据，而是 原封不动地转发 给目标服务器；
目标服务器返回的数据同样通过 SOCKS 代理中转回来。

换句话说：
SOCKS 请求阶段只是“打通隧道”；
真正的应用层数据（HTTP/TLS/...）是在 隧道建立成功之后才发的。
#####


#####
TCP 三次握手
这是 客户端 ↔ SOCKS 代理服务器 的 TCP 连接建立过程。
此时双方只保证有一个可靠的字节流通道，还没有涉及 SOCKS 协议。

SOCKS 握手 & 请求阶段
这些数据（方法协商、认证、CONNECT 请求等）都是 客户端和代理服务器之间的应用层数据。
代理服务器看到这些字段，才能知道这是 SOCKS 流量，而不是普通的 TCP 应用层协议（比如 HTTP）。

CONNECT 成功后
SOCKS 代理会在自己和目标服务器之间再建立一个 TCP 连接。
从客户端的角度，它的数据依然是发给 代理服务器 的；
代理只是把数据转发到目标主机，所以客户端“感觉”自己直连了目标。


三次握手 → 建立的是 TCP 通道（客户端 ↔ 代理）
SOCKS 握手/请求 → 是走在这个通道里的协议数据（客户端 ↔ 代理）
CONNECT 成功后 → 代理再代替客户端和目标通信，代理只做中转，不再改动数据
#####




两条不同的 TCP 连接：
在 SOCKS5 CONNECT 成功后，实际上存在两条 TCP 连接：
客户端 ↔ SOCKS 代理
这是最早建立的 TCP 连接（你做三次握手时建立的）。
客户端所有数据都先写到这个 socket 里。

SOCKS 代理 ↔ 目标服务器
当代理收到客户端的 CONNECT 请求时，它会帮你和目标地址（DST.ADDR:DST.PORT）再建立一条新的 TCP 连接。

#####打通隧道后，代理服务器是怎么判断它需要转发客户端发送的 原始 TCP 负载数据？
整体逻辑：
SOCKS 握手完成前：
代理服务器必须解析每一个字节，因为它要确认这是 SOCKS 流量、选择认证方式、获取目标地址端口。

SOCKS 握手完成后（隧道建立成功）：
客户端和代理服务器之间的 TCP 连接就进入 “转发模式”。
在这个阶段，代理服务器 不再解析客户端发来的负载（HTTP、TLS、SMTP…它都不关心）。
它只做一件事：
把客户端发来的原始 TCP 字节流，原封不动转发给目标服务器；
把目标服务器返回的字节流，再原封不动转发给客户端。

代理是怎么“知道”的？
代理靠两个条件来判断是否要转发：
1. 连接上下文（Connection State）
（1）SOCKS 服务器为每个客户端连接维护一个“状态机”：
初始状态（等待方法协商）
等待认证
等待请求（CONNECT/BIND/UDP）
已建立隧道（转发模式）
（2）当状态机切换到“隧道建立成功”，它就知道后续所有字节都无需再解析，而是直接转发。

2. 目标地址和端口（在请求阶段得到的 DST.ADDR/DST.PORT）
SOCKS 代理在 CONNECT 阶段已经与目标服务器建立好了 TCP 连接。
所以当客户端再往这个 TCP 通道里写数据时，代理只需要把它写入目标服务器的 TCP socket 即可。 // #####客户端“再往这个 TCP 通道里写数据”，指的其实是 客户端继续往自己和 SOCKS 代理之间的 TCP 连接写数据，而不是直接写到目标服务器。#####
#####


==================================================SOCKS 代理怎么记住某个客户端的“上下文”？这正是网络代理实现的核心
SOCKS 代理维护的是 连接对象（TCP socket）

在 TCP 语义里：
每次 三次握手 成功，就会在代理服务器上生成一个 socket 结构，它由四元组唯一标识：
(客户端IP, 客户端端口, 代理服务器IP, 代理服务器端口)
(192.168.1.10, 55001, 10.0.0.1, 1080)
这条记录唯一标识一个客户端与代理的 TCP 连接。

代理的状态机怎么绑定？
代理服务器内部一般这样做：
1. accept() 一个新的 TCP 连接 → 创建一个 连接上下文对象（connection context）。
#####
里面记录：客户端 socket fd、状态（初始）、缓冲区等。
#####
2. 状态机存放在这个连接上下文里：
初始：等客户端发 VER/NMETHODS/METHODS
方法协商完成：可能进入认证状态
请求阶段：收到目标地址/端口
转发模式：在上下文里记录目标服务器 socket
3. 建立目标服务器连接后，连接上下文里会保存一对 socket：
client_socket_fd （客户端 ↔ 代理）
target_socket_fd （代理 ↔ 目标服务器）
4. **事件循环（epoll/kqueue/select）**监听这两个 fd：
如果 client_socket_fd 可读 → 读数据 → 写到 target_socket_fd
如果 target_socket_fd 可读 → 读数据 → 写到 client_socket_fd

这样，代理就知道某个客户端发来的数据应该往哪个目标服务器转发。


#####
socketFd: Fd 全称是 File Descriptor（文件描述符）
SOCKS 代理维护的是每个 TCP 连接的状态（即 socket 对象），这个和普通 socket 服务端 accept 后维护 client socket 的方式完全一致。
#####


#####
服务端创建 socket：
int serverFd = socket(AF_INET, SOCK_STREAM, 0);
bind(serverFd, ...);
listen(serverFd, ...);
等待客户端连接：
int clientFd = accept(serverFd, ...);

accept 返回的 clientFd 就是针对这个客户端的专属 socket。
服务器可以通过 clientFd 和这个客户端通信。
服务器内部维护的状态通常就是和 clientFd 绑定的数据结构（比如客户端地址、状态、缓冲区等）


bind(serverFd, ...)
作用：把一个 socket 绑定到本地的 IP 地址和端口号。
为什么要绑定：
内核需要知道当客户端发请求到某个 IP:Port 时，这个请求应该交给哪个 socket。
struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_addr.s_addr = INADDR_ANY; // 监听本机所有网卡
addr.sin_port = htons(8080);       // 监听端口 8080

bind(serverFd, (struct sockaddr*)&addr, sizeof(addr));
这里 serverFd 只是一个文件描述符，还没有“和端口关联”，bind 就是建立这种关联。


listen(serverFd, backlog)
作用：把这个绑定好的 socket 标记为 被动监听状态，允许客户端连接。
参数 backlog：
内核在 socket 上维护一个半连接队列，#####存放还没被 accept 接收的客户端连接。#####
backlog 指定队列最大长度。
流程：
当客户端发起 connect，#####内核把连接放到这个队列里#####。
服务器通过 accept 从队列取出，得到 clientFd，与客户端通信。
#####