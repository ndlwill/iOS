其中INADDR_ANY就是指定地址为0.0.0.0的地址,这个地址事实上表示不确定地址,或“所有地址”、“任意地址”。
如果指定ip地址为通配地址(INADDR_ANY)，那么内核将等到套接字已连接(TCP)或已在套接字上发出数据报时才选择一个本地IP地址。


一般情况下，如果你要建立网络服务器，则你要通知服务器操作系统：请在某地址 xxx.xxx.xxx.xxx上的某端口 yyyy上进行侦听，并且把侦听到的数据包发送给我。
这个过程，你是通过bind（）系统调用完成的。也就是说，你的程序要绑定服务器的某地址，或者说：把服务器的某地址上的某端口占为已用。


如果你的服务器有多个网卡，而你的服务（不管是在udp端口上侦听，还是在tcp端口上侦听），出于某种原因：可能是你的服务器操作系统可能随时增减IP地址，也有可能是为了省去确定服务器上有什么网络端口（网卡）的麻烦
可以要在调用bind()的时候，告诉操作系统：“我需要在 yyyy 端口上侦听，所以发送到服务器的这个端口，不管是哪个网卡/哪个IP地址接收到的数据，都是我处理的。”这时候，服务器则在0.0.0.0这个地址上进行侦听。


比如你的机器有三个ip   
192.168.1.1   
202.202.202.202   
61.1.2.3    
如果你serv.sin_addr.s_addr=inet_addr("192.168.1.1"); 然后监听100端口   
这时其他机器只有connect   192.168.1.1:100才能成功。   
connect   202.202.202.202:100和connect   61.1.2.3:100都会失败。    
如果serv.sin_addr.s_addr=htonl(INADDR_ANY);   的话，无论连接哪个ip都可以连上的,只要是往这个端口发送的所有ip都能连上。
对于客户端如果绑定INADDR_ANY，情况类似。

对于TCP而言，在connect()系统调用时将其绑顶到一具体的IP地址。选择的依据是该地址所在子网到目标地址是可达的（reachable). 这时通过getsockname（）系统调用就能得知具体使用哪一个地址。

对于UDP而言, 情况比较特殊。即使使用connect()系统调用也不会绑定到一具体地址。这是因为对UDP使用connect()并不会真正向目标地址发送任何建立连接的数据，也不会验证到目标地址的可达性。
它只是将目标地址的信息记录在内部的socket数据结构之中，共以后使用。只有当调用sendto()/send()时,由系统内核根据路由表决定由哪一个地址（网卡）发送UDP packet.