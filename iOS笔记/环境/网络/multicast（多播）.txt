multicast（多播）是一种特殊的 IP 通信方式，
它既不是单播（unicast，也就是一对一），
也不是广播（broadcast，一对全网），
而是一对多：发送方把数据发给一组特定接收方。

IPv4 多播地址范围
IPv4 多播地址范围：224.0.0.0 ~ 239.255.255.255
特点：
发送给多播地址的数据，会被所有加入这个多播组的主机接收。
不会被不属于这个多播组的主机接收。


使用场景:
服务发现
某些协议用多播来广播自己，比如：
    mDNS（Bonjour）
    SSDP（UPnP）
客户端加入特定多播组，就能收到局域网内的服务信息。


| 类型        | IPv4 范围                     | 发送目标   | 典型用途         |
| --------- | --------------------------- | ------ | ------------ |
| Unicast   | 任意非特殊地址                     | 单个主机   | 普通客户端-服务器通信  |
| Broadcast | 255.255.255.255 或子网广播       | 子网所有主机 | ARP、局域网广播消息  |
| Multicast | 224.0.0.0 – 239.255.255.255 | 特定组成员  | 视频流、服务发现、IoT |

multicast 就是“一对多的组播”，只发送给加入这个多播组的主机，不是全网广播，也不是单播。

==================================================

子网（Subnet, Subnetwork）是指把一个大的网络划分成若干个更小的网络段的概念。

子网就是把大网络分成小块，每块叫一个子网，每个子网有自己的 网络地址 和 可用主机地址。
用 子网掩码（Subnet Mask） 或 CIDR 表示法 来划分。

假设你的网络是 192.168.1.0/24：
/24 意思：前 24 位是网络号，后 8 位是主机号。
这个网络可以容纳 2^8 - 2 = 254 台主机（减去网络地址和广播地址）。
如果你只想在局域网里分两个小子网，可以改为 /25：
    前 25 位是网络号，后 7 位是主机号。
    每个子网可容纳 2^7 - 2 = 126 台主机。
    这样你就把原来的 254 台设备的网络划分成了两个小子网。
例子：
| 子网  | 网络号           | 可用主机范围            | 广播地址          |
| --- | ------------- | ----------------- | ------------- |
| 子网1 | 192.168.1.0   | 192.168.1.1~126   | 192.168.1.127 |
| 子网2 | 192.168.1.128 | 192.168.1.129~254 | 192.168.1.255 |

192.168.1.0/24 分成两个 /25 子网：
第一个：192.168.1.0/25
第二个：192.168.1.128/25


为什么要划分子网：
减少广播流量
子网内部的广播不会影响其他子网。

提高安全性
不同子网可以用路由器或防火墙隔离。

方便管理
可以按部门、区域、用途划分不同子网。

节省 IP
精确分配主机数量，避免浪费。


网络地址（Network Address）
网络地址用于标识整个网络。它代表“这一网段的所有主机”。
网络地址中，主机位（host bits）全是 0。
路由器用它来判断某个 IP 地址属于哪个网络。例如，192.168.1.0/24 表示整个 192.168.1.* 这一个网段。
例子：
192.168.1.0/24
网络地址 = 192.168.1.0  (主机位全为0)

广播地址（Broadcast Address）
广播地址是用于向该网络内所有主机发送消息的特殊地址。
广播地址中，主机位全是 1。
当一台设备发送一个广播包到这个地址时，网段内所有主机会收到。
例子：
192.168.1.0/24
广播地址 = 192.168.1.255  (主机位全为1)

主机地址范围
去掉网络地址和广播地址，中间的部分才是可以分配给主机（电脑、手机、路由器接口等）的 IP：
192.168.1.0/24
网络地址:   192.168.1.0
主机范围:   192.168.1.1  ~  192.168.1.254
广播地址:   192.168.1.255
可用主机数: 2^8 - 2 = 254




mDNS（Multicast DNS） 是 Apple 的 Bonjour 协议的核心部分之一，用于在没有 DNS 服务器的局域网内，自动解析主机名。
就像一个“局域网内的迷你 DNS 服务”，但它是通过 多播 来实现的。
普通 DNS：问外部 DNS 服务器（单播）
mDNS：通过局域网内多播地址问“谁是这个主机？”
举个例子：打印机广播自己
假设你家里有一台支持 AirPrint 的打印机，连在 Wi-Fi 上。
这台打印机会通过 mDNS 广播（多播） 告诉局域网里的其他设备：
“我叫 HP-OfficeJet-Pro.local，我能提供打印服务，端口在 631。”
实际上它发送的是：
目的地址（多播地址）：224.0.0.251（IPv4）或 ff02::fb（IPv6）
目的端口：5353
协议内容：告诉别人“我的名字”和“我支持的服务类型”。



mDNS 使用的多播地址和端口确实是固定的，这是由标准协议定义的，不能随意更改。
mDNS 用的多播地址是：
IPv4: 224.0.0.251
IPv6: ff02::fb
端口: 5353
多播（multicast）通信必须基于一个 “组”（multicast group） 的概念。
多播组可以理解为一个虚拟的接收者集合。
每个多播组都有一个专属的多播 IP 地址（例如 IPv4 的 224.0.0.251）。
想接收该组的消息，设备必须**“加入”**这个多播组。
就像一个“QQ群”：
谁加入这个群，谁才能收到群里发的消息；
没加群的，就收不到。

为什么要固定？
因为 mDNS 是一个 “零配置” 协议（Zero Configuration Networking, Bonjour 的核心之一）：
它的目的是让局域网内的设备 自动互相发现；
如果每个设备都随意使用不同的地址和端口，那别人就收不到它的广播；
所以标准必须固定地址和端口，所有厂商统一实现，才能互通。

你会发现很多网络协议都有自己固定的多播组地址。
| 协议               | IPv4 多播地址             | 端口   | 功能                       |
| ---------------- | --------------------- | ---- | ------------------------ |
| **mDNS**         | 224.0.0.251           | 5353 | 主机名解析（如 `printer.local`） |
| **SSDP（UPnP）**   | 239.255.255.250       | 1900 | 设备发现（智能电视、路由器）           |
| **RIP v2**       | 224.0.0.9             | 520  | 路由信息交换                   |
| **OSPF**         | 224.0.0.5 / 224.0.0.6 | —    | 路由器通信                    |
| **NTP（广播/多播模式）** | 224.0.1.1             | 123  | 时间同步                     |


| 步骤 | 设备行为              | 描述                                                   |
| -- | ----------------- | ---------------------------------------------------- |
| ①  | 打印机上线             | 加入多播组 224.0.0.251（告诉操作系统：我要接收这个组的包）                  |
| ②  | Mac/iPhone 也加入这个组 | 它们也要监听局域网的 mDNS 消息                                   |
| ③  | Mac 发出查询          | 发送到 **224.0.0.251:5353**：“谁提供 `_ipp._tcp.local` 服务？” |
| ④  | 打印机收到后回应          | 它通过同样的多播组回应：“我有这个服务！”                                |
| ⑤  | Mac 收到回应          | 就知道这台打印机的存在了                                         |


“加入多播组”在底层怎么实现？
在网络层：
应用程序通过操作系统调用（如 setsockopt(IP_ADD_MEMBERSHIP)）告诉网卡：// socket 选项，用来让你的程序 加入某个多播组（multicast group）。
“请帮我接收发往 224.0.0.251 的包。”
在链路层（以太网）：
网卡会为这个组生成一个对应的多播 MAC 地址。
当有设备往这个组发包时，交换机只会把包发给加入这个组的端口（不是全网广播）。



#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>

int sock = socket(AF_INET, SOCK_DGRAM, 0);  // 创建 UDP socket

// 1️⃣ 绑定端口（5353）
struct sockaddr_in addr = {0};
addr.sin_family = AF_INET;
addr.sin_addr.s_addr = htonl(INADDR_ANY);
addr.sin_port = htons(5353);
bind(sock, (struct sockaddr*)&addr, sizeof(addr));

// 2️⃣ 加入多播组
struct ip_mreq mreq;
mreq.imr_multiaddr.s_addr = inet_addr("224.0.0.251"); // 多播组地址
mreq.imr_interface.s_addr = htonl(INADDR_ANY);         // 使用默认网卡
setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));

// ✅ 现在这个 socket 就能收到发往 224.0.0.251:5353 的数据包

在多播（multicast）或 UDP 中，bind() 的作用不是“服务器”，而是“确定我想接收哪些端口的数据”。
在 UDP（无连接协议）中，bind() 并不表示“我要作为服务器等待连接”。
它的意思是：
“我希望操作系统把发往这个端口的 UDP 包交给我。”
“如果有 UDP 数据包发到 任意网卡 (INADDR_ANY) 的 5353 端口，请交给我这个 socket。”

UDP 是 无连接协议，不像 TCP 需要 listen 和 accept。

#####
端口是进程的通信端点，不是进程本身；它标识了数据包应该交给哪个进程或哪个应用程序。
#####