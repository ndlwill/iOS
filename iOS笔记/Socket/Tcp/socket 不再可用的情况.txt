假定现在有一对已经连接的 socket，在以下情况发生时候，socket 将不再可用：

1）某一端关闭socket：主动关闭的一方会发送 FIN，通知对方要关闭 TCP 连接。在这种情况下，另一端如果去读 socket，将会读到 EoF（End of File）。于是我们知道对方关闭了 socket；

2）应用程序奔溃：此时 socket 会由内核关闭，结果跟情况1一样；

3）系统奔溃：这时候系统是来不及发送 FIN 的，因为它已经跪了。此时对方无法得知这一情况。对方在尝试读取数据时，最后会返回 read time out。如果写数据，则是 host unreachable 之类的错误。

4）电缆被挖断、网线被拔：跟情况3差不多，如果没有对 socket 进行读写，两边都不知道发生了事故。跟情况3不同的是，如果我们把网线接回去，socket 依旧可以正常使用


只要去读、写 socket，只要 socket 连接不正常，我们就能够知道。基于这一点，要实现一个 socket 长连接，我们需要做的就是不断地给对方写数据，然后读取对方的数据，也就是所谓的心跳。只要心还在跳，socket 就是活的。写数据的间隔，需要根据实际的应用需求来决定


心跳包不是实际的业务数据，根据通信协议的不同，需要做不同的处理
我们使用 JSON 进行通信，那么，可以为协议包加一个 type 字段，表面这个 JSON 是心跳还是业务数据：
{
    "type": 0,  // 0 表示心跳
    // ...
}

如果想节省资源，在有客户发送数据的时候可以省略 heart beat