HTTP通信机制是在一次完整的 HTTP 通信过程中，客户端与服务器之间将完成下列7个步骤：

1）建立 TCP 连接：在HTTP工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是80；

2）客户端向服务器发送请求命令：一旦建立了TCP连接，客户端就会向服务器发送请求命令；

例如：GET/sample/hello.jsp HTTP/1.1；

3）客户端发送请求头信息：客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送；

4）服务器应答：客户端向服务器发出请求后，服务器会客户端返回响应；

例如： HTTP/1.1 200 OK

响应的第一部分是协议的版本号和响应状态码；

5）服务器返回响应头信息：正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档；

6）服务器向客户端发送数据：服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据；

7）服务器关闭 TCP 连接：一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

===================HTTP 协议基础
HTTP 是一种无状态协议,协议自身不对请求和响应之间的通信状态进行保存.也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理
可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了

Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存Cookie

持久连接：
HTTP 协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无畏的 TCP 连接建立和断开，增加通信量的开销。
为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。

管线化：
持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了

HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本


===================首部字段结构
HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“：”分隔

HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段


===================状态码
200 OK

请求成功（其后是对GET和POST请求的应答文档。）

201 Created

请求被创建完成，同时新的资源被创建。

202 Accepted

供处理的请求已被接受，但是处理未完成。

203 Non-authoritative Information

文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。

204 No Content

没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。

205 Reset Content

没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。

206 Partial Content

客户发送了一个带有Range头的GET请求，服务器完成了它


400 Bad Request

服务器未能理解请求。

401 Unauthorized

被请求的页面需要用户名和密码。

401.1

登录失败。

401.2

服务器配置导致登录失败。

401.3

由于 ACL 对资源的限制而未获得授权。

401.4

筛选器授权失败。

401.5

ISAPI/CGI 应用程序授权失败。

401.7

访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。

402 Payment Required

此代码尚无法使用。

403 Forbidden

对被请求页面的访问被禁止。

403.1

执行访问被禁止。

403.2

读访问被禁止。

403.3

写访问被禁止。

403.4

要求 SSL。

403.5

要求 SSL 128。

403.6

IP 地址被拒绝。

403.7

要求客户端证书。

403.8

站点访问被拒绝。

403.9

用户数过多。

403.10

配置无效。

403.11

密码更改。

403.12

拒绝访问映射表。

403.13

客户端证书被吊销。

403.14

拒绝目录列表。

403.15

超出客户端访问许可。

403.16

客户端证书不受信任或无效。

403.17

客户端证书已过期或尚未生效。

403.18

在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。

403.19

不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。

403.20

Passport 登录失败。这个错误代码为 IIS 6.0 所专用。

404 Not Found

服务器无法找到被请求的页面。

404.0

（无）–没有找到文件或目录。

404.1

无法在所请求的端口上访问 Web 站点。

404.2

Web 服务扩展锁定策略阻止本请求。

404.3

MIME 映射策略阻止本请求。

405 Method Not Allowed

请求中指定的方法不被允许。

406 Not Acceptable

服务器生成的响应无法被客户端所接受。

407 Proxy Authentication Required

用户必须首先使用代理服务器进行验证，这样请求才会被处理。

408 Request Timeout

请求超出了服务器的等待时间。

409 Conflict

由于冲突，请求无法被完成。

410 Gone

被请求的页面不可用。

411 Length Required

"Content-Length" 未被定义。如果无此内容，服务器不会接受请求。

412 Precondition Failed

请求中的前提条件被服务器评估为失败。

413 Request Entity Too Large

由于所请求的实体的太大，服务器不会接受请求。

414 Request-url Too Long

由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。

415 Unsupported Media Type

由于媒介类型不被支持，服务器不会接受请求。

416 Requested Range Not Satisfiable

服务器不能满足客户在请求中指定的Range头。

417 Expectation Failed

执行失败。

423

锁定的错误

500 Internal Server Error

请求未完成。服务器遇到不可预知的情况。

500.12

应用程序正忙于在 Web 服务器上重新启动。

500.13

Web 服务器太忙。

500.15

不允许直接请求 Global.asa。

500.16

UNC 授权凭据不正确。这个错误代码为 IIS 6.0 所专用。

500.18

URL 授权存储不能打开。这个错误代码为 IIS 6.0 所专用。

500.100

内部 ASP 错误。

501 Not Implemented

请求未完成。服务器不支持所请求的功能。

502 Bad Gateway

请求未完成。服务器从上游服务器收到一个无效的响应。

502.1

CGI 应用程序超时。　·

502.2

CGI 应用程序出错。

503 Service Unavailable

请求未完成。服务器临时过载或当机。

504 Gateway Timeout

网关超时。

505 HTTP Version Not Supported

服务器不支持请求中指明的HTTP协议版本


===================HTTP 报文实体
内容编码 内容编码是对报文的主体进行的可逆变换
传输编码 传输编码是为了改变报文中的数据在网络上传输的方式

分块编码
分块编码把报文分割成若干已知大小的块。块之间是紧挨着发送的，这样就不需要在发送之前知道整个报文的大小了。分块编码是一种传输编码，是报文的属性

只要允许服务器把主体分块发送，说明每块的大小就可以了。因为主体是动态创建的，服务器可以缓冲它的一部分，发送其大小和相应的块，然后在主体发送完之前重复这个过程。服务器可以用大小为 0 的块作为主体结束的信号，这样就可以继续保持连接，为下一个响应做准备

多部分媒体类型：
multipart/form-data：在 Web 表单文件上传时使用；
multipart/byteranges：状态码 206 Partial Content 响应报文包含了多个范围的内容时使用。

范围请求：
假设你正在下载一个很大的文件，已经下了四分之三，忽然网络中断了，那下载就必须重头再来一遍。为了解决这个问题，需要一种可恢复的机制，即能从之前下载中断处恢复下载。要实现该功能，这就要用到范围请求
有了范围请求， HTTP 客户端可以通过请求曾获取失败的实体的一个范围（或者说一部分），来恢复下载该实体

===================与 HTTP 协作的 Web 服务器
HTTP 通信时，除客户端和服务器外，还有一些用于协助通信的应用程序。如下列出比较重要的几个：代理、缓存、网关、隧道、Agent 代理

代理：
出于安全考虑，通常会将代理作为转发所有 Web 流量的可信任中间节点使用。代理还可以对请求和响应进行过滤，安全上网或绿色上网

缓存：
Web 缓存或代理缓存是一种特殊的 HTTP 代理服务器，可以将经过代理传输的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了。客户端从附近的缓存下载文档会比从远程 Web 服务器下载快得多

网关：
网关是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将 HTTP 流量转换成其他的协议。网关接收请求时就好像自己是资源的源服务器一样

隧道：
隧道是会在建立起来之后，就会在两条连接之间对原始数据进行盲转发的 HTTP 应用程序。HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。
HTTP 隧道的一种常见用途就是通过 HTTP 连接承载加密的安全套接字层（SSL）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了

Agent 代理：
Agent 代理是代表用户发起 HTTP 请求的客户端应用程序。所有发布 Web 请求的应用程序都是 HTTP Agent 代理