依赖注入（DI）本质上就是为“可测试性”而生的。

依赖注入 = 让你的代码“可替换”
可替换 = 可 mock
可 mock = 可测试



先看没有 DI 的代码。
final class LoginService {
    func login() async throws -> User {
        let data = try await URLSession.shared.data(from: url)
        return parse(data)
    }
}
问题：
真实网络请求
不可控
不可重复
测试慢
测试不稳定




用依赖注入改造
protocol NetworkClient {
    func request() async throws -> Data
}

final class LoginService {
    let client: NetworkClient
    
    init(client: NetworkClient) {
        self.client = client
    }

    func login() async throws -> User {
        let data = try await client.request()
        return parse(data)
    }
}

测试时：
struct MockClient: NetworkClient {
    func request() async throws -> Data {
        return fakeData
    }
}

现在：
没有真实网络
立即返回
可控数据
可测试错误分支



DI 在单元测试里的几个核心用途
1️⃣ Mock 外部依赖
网络
数据库
文件系统
时间
UUID
随机数

2️⃣ 控制时间
timeout 5 秒
retry 3 次
debounce 1 秒
如果不用 DI：
测试极其痛苦。

3️⃣ 测错误分支
真实系统很难制造：
网络 500
超时
解码错误
时钟跳变
Mock 可以 100% 可控。