tail recursion

求阶乘:

int func(int n)
{
    if (n <= 1) return 1;

    return (n * func(n-1));
}

如果这个函数调用的深度太深，很容易会有爆栈的危险

函数调用的大概过程：
1）调用开始前，调用方（或函数本身）会往栈上压相关的数据，参数，返回地址，局部变量等。
2）执行函数。
3）清理栈上相关的数据，返回。

因此，在函数 A 执行的时候，如果在第二步中，它又调用了另一个函数 B，B 又调用 C.... 栈就会不断地增长不断地装入数据，当这个调用链很深的时候，栈很容易就满 了，这就是一般递归函数所容易面临的大问题

在上面写的一般递归函数 func() 中，我们可以看到，func(n)  是依赖于 func(n-1) 的，func(n) 只有在得到 func(n-1) 的结果之后，才能计算它自己的返回值，因此理论上，在 func(n-1) 返回之前，func(n)，不能结束返回。因此func(n)就必须保留它在栈上的数据，直到func(n-1)先返回，而尾递归的实现则可以在编译器的帮助下，消除这个限制：

int tail_func(int n, int res)
{
     if (n <= 1) return res;

     return tail_func(n - 1, n * res);
}

tail_func(10000000000, 1);
从上可以看到尾递归把返回结果放到了调用的参数里。这个细小的变化导致，tail_func(n, res)不必像以前一样，非要等到拿到了tail_func(n-1, n*res)的返回值，才能计算它自己的返回结果 -- 它完全就等于tail_func(n-1, n*res)的返回值
因此理论上：tail_func(n)在调用tail_func(n-1)前，完全就可以先销毁自己放在栈上的东西

这就是为什么尾递归如果在得到编译器的帮助下，是完全可以避免爆栈的原因：每一个函数在调用下一个函数之前，都能做到先把当前自己占用的栈给先释放了，尾递归的调用链上可以做到只有一个函数在使用栈，因此可以无限地调用



#include <stdio.h>

int tail_func(int n, int res)
{
     if (n <= 1) return res;

     return tail_func(n - 1, n * res);
}


int main()
{
    int dummy[1024*1024]; // 尽可能占用栈。
    
    tail_func(2048*2048, 1);
    
    return 1;
}
上面这个程序在开了编译优化和没开编译优化的情况下编出来的结果是不一样的，如果不开启优化，直接 gcc -o tr func_tail.c 编译然后运行的话，程序会爆栈崩溃，但如果开优化的话：gcc -o tr -O2 func_tail.c，上面的程序最后就能正常运行。 

这里面的原因就在于，尾递归的写法只是具备了使当前函数在调用下一个函数前把当前占有的栈销毁，但是会不会真的这样做，是要具体看编译器是否最终这样做，如果在语言层面上，没有规定要优化这种尾调用，那编译器就可以有自己的选择来做不同的实现，在这种情况下，尾递归就不一定能解决一般递归的问题

这就是尾递归所能带来的效果: 控制栈的增长，且减少压栈，程序运行的效率也可能更高

尾递归的优化属于尾调用优化这个大范畴，所谓尾调用，形式它与尾递归很像，都是一个函数内最后一个动作是调用下一个函数，不同的只是调用的是谁，显然尾递归只是尾调用的一个特例
int func1(int a)
{
   static int b = 3;
   return a + b;
}

int func2(int c)
{
    static int b = 2;

    return func1(c+b);
}