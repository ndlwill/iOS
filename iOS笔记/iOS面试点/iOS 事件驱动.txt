
在 iOS 上你常见的这些底层封装都基于同样原理：
| 框架 / 接口                            | 内部机制                          |
| ---------------------------------- | ----------------------------- |
| `NSURLSession`                     | CFNetwork + runloop + kqueue  |
| `NWConnection` / Network.framework | DispatchSource + epoll/kqueue |
| `GCDAsyncSocket`                   | `dispatch_source_read`        |
| BSD sockets                        | select/poll/kqueue            |
这些都不是 busy loop，而是事件驱动的阻塞等待。



“阻塞（blocking）”和“挂起（suspend）”
| 概念                       | 层级        | 谁触发   | 说明                                                             |
| ------------------------ | --------- | ----- | -------------------------------------------------------------- |
| **阻塞 (blocking)**        | 用户态/系统调用层 | 线程自己  | 指线程执行系统调用（如 `select()` / `read()`）后，**进入等待状态**，暂时无法继续执行用户代码。   |
| **挂起 (suspend / sleep)** | 内核态调度层    | 内核调度器 | 当线程阻塞后，内核检测到它暂时不可运行，就会**从运行队列中移除**，放入“等待队列”，即挂起。CPU 不再给它分配时间片。 |

#####
阻塞是线程行为（主动调用导致）
挂起是内核行为（响应阻塞而做的）
#####

也可以用一行时间轴来理解：
用户代码调用 select() →
系统调用进入内核 →
内核发现没有数据可读 →
标记该线程为阻塞(waiting) →
调度器将其挂起（移出运行队列） →
CPU 转去执行别的线程。

==================================================

阻塞等待（select()/poll()）
线程行为：线程在内核态调用阻塞 I/O 系统调用
CPU 占用：1~5%
仍有少量 CPU 占用：
系统内核调度 overhead
超时判断（timeout）
上下文切换

异步回调（CFRunLoop / dispatch_source_read）
线程行为：
没有主动循环
GCD/RunLoop 机制让线程挂起，直到事件到来才唤醒执行 block
CPU 占用：<1%
内核只在事件发生时唤醒线程
系统调度、上下文切换、事件分发的开销极低

核心区别：
阻塞等待 → 线程还在内核等待队列里，内核每次事件/timeout 都要检查 → 有少量 CPU
异步回调 → 完全事件驱动，线程基本不动，CPU 占用最低


| 模式                   | CPU 占用 | 线程状态          |
| -------------------- | ------ | ------------- |
| Busy loop            | 🔥 高   | 一直运行          |
| 阻塞等待（select/poll）    | 🌙 低   | 阻塞挂起，少量内核调度开销 |
| **RunLoop / 异步事件驱动** | 🌿 最低  | 线程常驻休眠，仅事件唤醒  |
关键区别：RunLoop 完全事件驱动，几乎没有轮询，也不涉及 select/poll 的 timeout 检查，所以更节能。



kqueue
类型：内核事件通知机制（Kernel Event Queue）
作用：让应用程序高效地等待 文件描述符、定时器、信号等事件，避免忙轮询（busy loop）
特点：
事件驱动，不占用 CPU（线程挂起等待事件）
可以同时监听大量事件源
比 select() / poll() 更高效，尤其是大数量文件描述符

kqueue 是 Unix/BSD 系统特有的内核事件通知机制，并不是跨平台的标准接口
kqueue = BSD/macOS/iOS 专属