
https://www.jianshu.com/u/1e877b3dcc34

相似点
1.函数指针和Block都可以实现回调的操作，声明上也很相似，实现上都可以看成是一个代码片段。

2.函数指针类型和Block类型都可以作为变量和函数参数的类型。（typedef定义别名之后，这个别名就是一个类型）

不同点
1.函数指针只能指向预先定义好的函数代码块（可以是其他文件里面定义，通过函数参数动态传入的），函数地址是在编译链接时就已经确定好的。

2.Block本质是Objective-C对象，是NSObject的子类，可以接收消息。

3.函数里面只能访问全局变量，而Block代码块不光能访问全局变量，还拥有当前栈内存和堆内存变量的可读性（当然通过__block访问指示符修饰的局部变量还可以在block代码块里面进行修改）。

4.从内存的角度看，函数指针只不过是指向代码区的一段可执行代码，而block实际上是程序运行过程中在栈内存动态创建的对象，可以向其发送copy消息将block对象拷贝到堆内存，以延长其生命周期。 关于第2点可以作一个实验，在定义block之后打一个断点，Cmd+R运行后，可以在调试窗口看到，block确实是一个对象，拥有isa指针。 另外，采用block写法，gcc编译出来可执行文件体积更大，这应该还是跟block是对象有关。


Command+B和Command+R 这中间发生了什么:
https://leomobiledeveloper.blog.csdn.net/article/details/85226147
把一种编程语言(原始语言)转换为另一种编程语言(目标语言)的程序叫做编译器。
大多数编译器由两部分组成：前端和后端
前端负责词法分析，语法分析，生成中间代码
后端以中间代码作为输入，进行行架构无关的代码优化，接着针对不同架构生成不同的机器码
前后端依赖统一格式的中间代码(IR)，使得前后端可以独立的变化。新增一门语言只需要修改前端，而新增一个CPU架构只需要修改后端即可。

编译过程
预处理 (预处理会替进行头文件引入，宏替换，注释处理，条件编译(#ifdef)等操作)
词法分析 (将输入的代码转换为一系列符合特定语言的词法单元，这些词法单元类型包括了关键字，操作符，变量等等 告诉计算机这是什么意思)
语法分析 （词法分析的Token流会被解析成一颗抽象语法树，有了抽象语法树，clang就可以对这个树进行分析，找出代码中的错误。比如类型不匹配，亦或Objective C中向target发送了一个未实现的消息）
CodeGen （CodeGen遍历语法树，生成LLVM IR代码。LLVM IR是前端的输出，后端的输入，Objective C代码在这一步会进行runtime的桥接）
生成汇编代码 （LLVM对LR进行优化后，会针对不同架构生成不同的目标代码，最后以汇编代码的格式输出，看人下菜碟，什么架构 arm64 就给 arm64 架构的代码）
汇编器 （汇编器以汇编代码作为输入，将汇编代码转换为机器代码，最后输出目标文件(object file) main.c 转main.o）
链接link （连接器把编译产生的.o文件和（dylib,a,tbd）文件，生成一个mach-o可执行文件）
运行过程
dyld动态链接器 装载 Mach-O 文件，递归链接所有的动态库，静态库.a也是 dyld 加载到内存中去的
rebase/binding （可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。 rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。）
runtime 阶段 调用 map_Image解析处理可执行文件 注册 objc 类，初始化类对象，调用类和分类的+load 方法，调用 C++静态初始化起和attribute修饰的函数
AppDelegate类中的didFinishLaunchingWithOptions:
