https://www.jianshu.com/u/258216970fd5

rvm 是用来管理 ruby 的
ruby 的其中一个“程序”叫 rubygems ，简称 gem
bundle用来管理项目的gem


======================

创建 gemfile 文件:
cd 项目目录
bundle init

Gemfile
gem 'cocoapods'
gem "fastlane"
bundle install 安装当前项目的gem库


如果在一个没有 Gemfile 的文件夹下执行
bundle exec pod --version 报
Could not locate Gemfile or .bundle/ directory
bundle exec 它的作用是让你：在项目的 Gemfile 所指定的依赖环境中，运行某个命令（比如 pod）。
bundle exec 是项目级别的命令执行器，必须在有 Gemfile 的项目路径中使用。


bundle exec pod install


我发现在Gemfile文件所在的路径和不在这个路径下进行pod --version得到的版本是不同的
但打印which pod是相同的，它是怎么实现的，原理是啥?
which pod 找的是 shell PATH 中的实际「可执行文件路径」
但这个路径其实是一个Wrapper（包装器）脚本，它并不是你以为的真正的 Pod 本体

实际的 pod 文件内容你可以看一下：
cat $(which pod)

#!/usr/bin/env ruby_executable_hooks
#
# This file was generated by RubyGems.
#
# The application 'cocoapods' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require 'rubygems'

Gem.use_gemdeps

version = ">= 0.a"

str = ARGV.first
if str
  str = str.b[/\A_(.*)_\z/, 1]
  if str and Gem::Version.correct?(str)
    version = str
    ARGV.shift
  end
end

if Gem.respond_to?(:activate_bin_path)
load Gem.activate_bin_path('cocoapods', 'pod', version)
else
gem "cocoapods", version
load Gem.bin_path("cocoapods", "pod", version)
end


Gem.use_gemdeps
它会尝试去找当前目录或环境变量指定的 Gemfile，如果找到了，就会激活该 Gemfile 指定的依赖环境。
这就是为什么：
同一个 which pod，不同路径下运行却能调用到不同版本的原因。
在项目目录下，Gemfile 控制了 pod 实际使用的版本。

在 Gemfile 文件路径下执行
bundle exec ruby -e 'puts Gem.bin_path("cocoapods", "pod")'
/Users/youdun-ndl/.rvm/gems/ruby-3.4.3/gems/cocoapods-1.15.0/bin/pod

不在 Gemfile 文件路径下执行
ruby -e 'puts Gem.bin_path("cocoapods", "pod")'
/Users/youdun-ndl/.rvm/gems/ruby-3.4.3/gems/cocoapods-1.16.2/bin/pod


在ruby-3.4.3中安装多个版本pod
发现pod是可执行文件，但可以查看里面的脚本代码
而/usr/bin/env也是可执行文件，但它是二进制文件（是编译好的系统工具），没发查看这个文件
项目	类型	是否文本可读
pod	Ruby 脚本文件	✅ 可读
/usr/bin/env	系统工具（二进制）	❌ 不可读


要区分一个文件是 脚本文件（比如 Ruby 脚本、Shell 脚本）还是 二进制可执行文件（如 ELF 或 Mach-O），你可以用file：
file /usr/bin/env
/usr/bin/env: Mach-O universal binary with 2 architectures: [x86_64:Mach-O 64-bit executable x86_64] [arm64e:Mach-O 64-bit executable arm64e]
/usr/bin/env (for architecture x86_64):	Mach-O 64-bit executable x86_64
/usr/bin/env (for architecture arm64e):	Mach-O 64-bit executable arm64e

file $(which pod)
/Users/youdun-ndl/.rvm/gems/ruby-3.4.3/bin/pod: Ruby script text executable, ASCII text


创建一个类似上面pod的可执行文件
创建 mytool 文件（没有 .rb 后缀）
touch ~/bin/mytool
chmod +x ~/bin/mytool // 核心，这样会变成黑色的exec
编写脚本
#!/usr/bin/env ruby
require 'rubygems'
puts "Hello from mytool!"



======================多个版本的 CocoaPods 的切换
gem list --local | grep cocoapods

Bundler 是一个 Ruby 项目的管理工具，可以理解成为 Ruby 界的 "CocoaPods"。
准确来说，CocoaPods 是借鉴了 Bundler 的思想和模式
CocoaPods 本身也是一个 Ruby 项目
可以通过 Bundler 来管理我们要使用的 CocoaPods 版本