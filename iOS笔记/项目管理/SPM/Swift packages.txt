https://developer.apple.com/documentation/xcode/swift-packages

==================================================Coordinate package versions across your team
When collaborating on a project, make sure everyone uses the same version of a package dependency.
When you add a package dependency to a project, Xcode creates the Package.resolved file.
It lists the specific Git commits to which each package dependency resolves and the checksum of each binary dependency.
Commit this file in Git to ensure that everyone is using the same version of a package dependency.

Tip
You can find the Package.resolved file inside your .xcodeproj directory at [appName].xcodeproj/project.workspace/xcshareddata/swiftpm/Package.resolved.

==================================================Decide on package requirements
When you enter the package dependency’s URL or pick a Swift package from the list of packages, choose one of three package requirements. 
Package requirements determine the allowed versions of the package dependency in your project, 
and Xcode updates your package dependency based on the requirement that you choose.

Version
Decide whether your project accepts updates to a package dependency up to the next major version or up to the next minor version.
To be more restrictive, select a specific version range or an exact version. 
Major versions tend to have more significant changes than minor versions, and may require you to modify your code when they update. 
The version rule requires Swift packages to conform to semantic versioning. 
To learn more about the semantic versioning standard, visit Semantic Versioning 2.0.0. // https://semver.org/
Selecting the version requirement is the recommended way to add a package dependency. 
It allows you to create a balance between restricting changes and obtaining improvements and features.

Branch

Commit

After you choose a package requirement, Xcode resolves and fetches the package dependency.

Tip
Although Xcode updates your package dependencies and resolves package versions automatically, 
you can trigger both actions from the File > Packages menu.


Semantic Versioning 2.0.0（语义化版本控制）是一种用于给软件版本号命名的规范
MAJOR.MINOR.PATCH-<预发布标签>

预发布版本的优先级低于正式版本
1.0.0-alpha < 1.0.0-beta < 1.0.0-rc < 1.0.0 // rc: Release Candidate 的缩写.“发布候选版本” —— 表示软件已经接近最终正式版（1.0.0），功能已冻结，仅等待最后测试阶段。
alpha: 初始开发版本，功能可能不完整。
beta: 功能基本完成，但可能仍存在较多 bug。
rc: 候选发布版本，如果没有重大问题就可以作为正式版本发布。
1.0.0: 最终稳定版本。

MAJOR（主版本号）
MINOR（次版本号）
PATCH（修订号）

类型	举例	含义
Patch 修复更新	1.2.3 → 1.2.4	修复 bug，向后兼容
Minor 功能更新	1.2.3 → 1.3.0	增加新功能，向后兼容
Major 破坏性更新	1.2.3 → 2.0.0	有破坏性更改，不兼容旧版本


==================================================Package.swift
The Package.swift file, or package manifest, describes the configuration for the Swift package.
You can double-click it in Finder to open the package in Xcode.
The package manifest uses Swift and the PackageDescription framework to define the package’s name, products, targets, dependencies on other packages, and so on.

Source files reside in a folder named Sources and are scoped per Target. 
A Swift package can contain several targets, and, as a convention, each target’s code resides in its own subfolder.

The package manifest must begin with the string // swift-tools-version:, followed by a version number such as // swift-tools-version:5.3.
The Swift tools version declares:
The version of the PackageDescription framework
The Swift language compatibility version to process the manifest
The required minimum version of the Swift tools to use the package

Each version of Swift can introduce updates to the PackageDescription framework, 
but the previous API version is available to packages that declare a prior Swift tools version. 
This behavior allows you take advantage of new releases of Swift, the Swift tools, and the PackageDescription framework, 
without having to update your package manifest and without losing access to existing packages.

To learn more about the PackageDescription framework, see Package.
https://developer.apple.com/documentation/PackageDescription/Package

Note
Xcode provides code completion when you edit the package manifest.


Per convention, source files reside in a subfolder of the package’s Sources directory that has the same name as the target they belong to.
Note how the package manifest above declares the MyLibrary target. 
Its source files reside in Sources/MyLibrary while source files for tests reside in Tests/MyLibraryTests.