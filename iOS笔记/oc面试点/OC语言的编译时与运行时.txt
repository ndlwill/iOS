编译时： 即编译器对语言的编译阶段，编译时只是对语言进行最基本的检查报错，包括词法分析、语法分析等等，将程序代码翻译成计算机能够识别的语言（例如汇编等），编译通过并不意味着程序就可以成功运行。
运行时： 即程序通过了编译后，编译好的代码被装载到内存中跑起来的阶段，这个时候会具体对类型进行检查，而不仅仅是对代码简单扫描分析，此时若出错，程序会崩溃。
可以说编译时是一个静态的阶段，类型错误很明显可以直接检查出来，可读性也好；而运行时则是动态的阶段，开始具体与运行环境结合起来。

OC语言的动态性
动态类型
动态绑定
动态加载

动态类型:
动态类型指对象指针类型的动态性，具体是指使用id类型将对象的类型确定推迟到运行时，由赋给它的对象类型决定对象指针的类型。
另外类型确定推迟到运行时之后，可以通过NSObject的isKindOfClass方法动态判断对象最后的类型（动态类型识别）
也就是说id修饰的对象为动态类型对象
NSString *testObject = [[NSData alloc]init]; 
首先testObject是一个指向某个对象的指针，不论何时指针的空间大小是固定的

编译时：指针的类型为NSString，即编译时会被当做一个NSString实例来处理，
编译器在类型检查的时候如果发现类型不匹配则会给出黄色警告，该语句给指针赋值用的是一个NSData对象，则编译时编译器则会给出类型不匹配警告。
但编译时，如果testObject调用NSString的方法编译器会认为是正确的，既不会警告也不会报错。
运行时：运行时指针指向的实际是一个NSData对象，因此如果指针调用NSString的方法，虽然编译时通过了，但运行时会崩溃，因为NSData对象没有该方法；
虽然运行时指针实际指向的是NSData，但编译时编译器并不知道（前面说了编译器会把指针当成NSString对象处理），
因此如果试图用这个指针调用NSData的方法会直接编译不通过，给出红色报错，程序也运行不起来。

动态绑定:
动态绑定指的是方法确定的动态性，具体指的是利用OC的消息传递机制将要执行的方法的确定推迟到运行时，可以动态添加方法。
一个OC对象是否调用某个方法不是由编译器决定的，而是由运行时决定的；另外关于动态绑定的关键一点是基于消息传递机制的消息转发机制，主要处理应对一些接收者无法处理的消息，此时有机会将消息转发给其他接收者处理。
动态绑定是基于动态类型的，在运行时对象的类型确定后，那么对象的属性和方法也就确定了（包括类中原来的属性和方法以及运行时动态新加入的属性和方法），这就是所谓的动态绑定了。
动态绑定的核心就是在运行时动态的为类添加属性和方法

void objc_msgSend(id self, SEL cmd, ...)
这个原语函数参数可变，第一个参数填入消息的接收者，第二个参数是消息‘选择子’，后面跟着可选的消息的参数。

动态加载:
动态加载主要包括两个方面，一个是动态资源加载，一个是一些可执行代码模块的加载，这些资源在运行时根据需要动态的选择性的加入到程序中，
是一种代码和资源的‘懒加载’模式，可以降低内存需求，提高整个程序的性能，另外也大大提高了可扩展性。