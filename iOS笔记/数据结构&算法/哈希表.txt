https://juejin.im/user/5b9b0ef16fb9a05d353c6418/posts
数组 + 链表
哈希表（Hash table，也叫散列表），是根据键（Key）而直接访问在内存存储位置的数据结构
它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表
通过把Key通过一个固定的算法函数（hash函数）转换成一个整型数字，然后就对该数字对数组的长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里
当使用hash表查询时，就是使用hash函数将key转换成对应的数组下标，并定位到该下标的数组空间里获取value，这样就充分利用到数组的定位性能进行数据定位
hash函数就是根据key计算出该存储地址的位置，hash表就是基于hash函数建立的一种查找表


什么是hash冲突:
对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)=f(k2)，或f(k1) MOD 容量 =f(k2) MOD 容量，这种现象称为碰撞，亦称冲突

解决hash冲突
1.开放定址法:
这种方法也称再散列法，基本思想是：当关键字key的hash地址p=F(key)出现冲突时，以p为基础，产生另一个hash地址p1，如果p1仍然冲突，再以p为基础，再产生另一个hash地址p2，。。。直到找出一个不冲突的hash地址pi，然后将元素存入其中
再散列函数的形式:
H = (F(key) + di) MOD m
m为表长
F(key)为hash函数
di为增量序列，增量序列的取值方式不同，相应的再散列方式也不同
线性探测再散列: di = 1，2，3，。。。，m-1
二次探测再散列: di = 1^2, -1^2, 2^2, -2^2,..., k^2, -k^2 (k <= m-1)
伪随机数探测再散列: di = 伪随机序列
eg:
哈希表: 0,1,...10
现有一个长度为11的哈希表，已填有关键字分别为17，60，29的三条记录 (存在的地址分别为: 6, 5, 7)
其中采用的哈希函数为f(key)= key MOD 11
现有第四个记录，关键字为38。根据以上哈希算法，得出哈希地址为5，跟关键字60的哈希地址一样，产生了冲突

线性探测法： 当发生冲突时，因为f(key) + d，所以首先5 + 1 = 6，得到下一个hash地址为6，又冲突，依次类推，最后得到空闲的hash地址是8，然后将数据填入hash地址为8的空闲区域
二次探测法： 当发生冲突时，因为d = 1^2，所以5 + 1 = 6，得到的下一个hash地址为6，又冲突，因为d = -1^2,所以5 + (-1) = 4，得到下一个hash地址为4，是空闲则将数据填入该区域
伪随机数探测法： 随机数法就是完全根据伪随机序列来决定的，如果根据一个随机数种子得到一个伪随机序列{1，-2，2，。。。，k}，那么首先得到的地址为6，第二个是3，依次类推，空闲则将数据填入

2.链地址法（拉链法，位桶法）:

负载因子（load factor）:
初始容量，加载因子，这两个参数是影响hash表性能的重要参数
容量： 表示hash表中数组的长度，初始容量是创建hash表时的容量
加载因子： 是hash表在其容量自动增加之前可以达到多满的一种尺度（存储元素的个数），它衡量的是一个散列表的空间的使用程度
loadFactor = 加载因子 / 容量

扩容:
当hash表中元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对数组进行扩容。
而在数组扩容之后，最消耗性能的点就出现了，原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是扩容。
表中元素个数超过了容量 * loadFactor时，就会进行数组扩容

开放定址法可以通过动态扩容数组长度解决表存储满无法插入的问题，也符合O(1)的查询速度

============================######
哈希表的本质是一个数组，数组中每一个元素称为一个箱子(bin)，箱子中存放的是键值对

哈希表的存储过程:
1.根据key计算出它的哈希值h。
2.假设箱子的个数为n，那么这个键值对应该放在第(h % n)个箱子中。
3.如果该箱子中已经有了键值对，就使用开放寻址法或者拉链法解决冲突
在使用拉链法解决哈希冲突时，每个箱子其实是一个链表，属于同一个箱子的所有键值对都会排列在链表中
哈希表还有一个重要的属性:负载因子(load factor)，它用来衡量哈希表的空/满程度，一定程度上也可以体现查询的效率，计算公式为:
负载因子=总键值对数/箱子个数
负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。因此，一般来说，当负载因子大于某个常数(可能是1，或者0.75等)时，哈希表将自动扩容

重哈希概念:
哈希表在自动扩容时，一般会创建两倍于原来个数的箱子，因此即使key的哈希值不变，对箱子个数取余的结果也会发生改变，因此所有键值对的存放位置都有可能发生改变，这个过程也称为重哈希(rehash)。

============================
存取效率高
作为线性数据结构，哈希表无疑是查找速度比较快的一种

哈希表其实就是一个一维数组，而数组中的每一个元素都是一个单向链表而已。这样的数据结构解决了数组的增删元素的不足和链表的查询效率的不足
数组是存在连续的存储空间，而链表的存储空间不连续

哈希算法:
存储位置=f(关键字)
我们可以通过查找关键字不需要比较就可获得需要的记录的存储位置。这就是一种新的存储技术一一散列技术(哈希算法)
散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key 对应一个存储位置f (key)

如果散列一段明文而且哪怕只更改该段落的一个字母，随后的哈希都将产生不同的值。
要找到散列为同一个值的两个不同的输入，在计算上是不可能的，所以数据的哈希值可以检验数据的完整性

哈希通过将单向数学函数（有时称为“哈希算法”）应用到任意数量的数据所得到的固定大小的结果。如果输入数据中有变化，则哈希也会发生变化
哈希可用于许多操作，包括身份验证和数字签名。也称为“消息摘要”

哈希表是根据设定的哈希函数H(key)将一组关键字映象到一个有限的地址区间上，并以关键字在地址区间中的象作为记录在表中的存储位置，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址

哈希算法存取之所以快,是因为其 直接通过关键字key得到要存取的记录内存存储位置

存储位置=f(关键字)
散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系
使得每个关键字key 对应一个存储位置f (key)
把这种对应关系f 称为散列函数， 又称为哈希(Hash) 函数
采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)。 那么关键字对应的记录存储位置我们称为散列地址
散列表是个一维数组，是连续的，而散列地址是不连续的

散列过程其实就是两步:
(1) 在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。
(2) 当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。
散列技术既是一种存储方法，也是一种查找方法.散列主要是面向查找的存储结构

我们时常会碰到两个关键字key1 != key2，但是却有f(key1) = f(key2)，这种现象我们称为哈希冲突,如果没有哈希冲突,散列表是一种非常高效的查找数据结构,其时间复杂度为O(1)


哈希算法会根据你要存入的数据,先通过该算法,计算出一个地址值,这个地址值就是你需要存入到集合当中的数据的位置,而不会像数组那样一个个的进行挨个存储,挨个遍历一遍后面有空位就存这种情况了,而你查找的时候,也是根据这个哈希算法来的,将你的要查找的数据进行计算,得出一个地址,这个地址会印射到集合当中的位置,这样就能够直接到这个位置上去找了,而不需要像数组那样,一个个遍历,一个个对比去寻找,这样自然增加了速度,提高了效率了


hash算法将你传入的key运算成一个地址值，类似指针那样，指向内存中的某块区域，存的时候根据该地址值，将value存到这个地址值映射的内存区域里，取得时候从key作hash运算后得出的地址值所对应的内存区域中取出结果
