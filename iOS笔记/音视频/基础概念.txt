https://ffmpeg.org/

FFmpeg的名字由FF和mpeg组成。
FF是Fast Forward（译为：快进、快速前进）的简称
mpeg来源于Moving Picture Experts Group（简称：MPEG，译为：动态影像专家小组）
MPEG是源自ISO与IEC等国际组织的工作小组
MPEG的其中一项工作是：制定音视频相关的标准（比如压缩标准）




https://www.jianshu.com/u/08ef8e6eb2f6

视频实质：
纯粹的视频（不包括音频）实质上就是一组帧图片，经过视频编码成为视频（video）文件再把音频（audio）文件有些还有字幕文件组装在一起成为我们看到的视频（movie）文件。
1秒内出现的图片数就是帧率，图片间隔越小画面就越流畅，所以帧率越高效果就越好，需要的存储空间也就越多。



Codec 就是编解码器的统称
codec 是一个组合词，全称是：
co der + dec oder = codec

Codec 表示一套用于压缩（编码）和解压缩（解码）音频或视频的算法或工具。
你可以把它理解成：
原始媒体 →（编码器）→ 压缩后的格式 →（解码器）→ 可播放的内容

Coder（编码器）：负责把原始媒体数据（如摄像头采集的原始帧、未压缩的音频）压缩成文件格式，如 .mp4、.aac
Decoder（解码器）：负责将压缩后的数据解码回可播放的形式（用于播放、编辑、显示等）



类型	简单理解	特点
硬件编码/解码	调用专门的芯片或指令来加速处理	快速、省电、效率高，但灵活性差
软件编码/解码	完全由 CPU 上的软件算法执行	灵活、可定制、兼容性好，但耗 CPU、多线程开销大


硬件加速适用场景（优先考虑）：
场景	原因
移动端 / 嵌入式设备（如 iPhone、Android、Raspberry Pi）	更省电、响应快，延长电池寿命
实时视频处理（如视频通话、直播）	延迟低、解码快
高分辨率视频播放（如 4K 视频播放）	软件解码可能会掉帧或卡顿
大规模转码/编码时的性能瓶颈	比如直播推流时硬编可以明显减轻 CPU 压力

常见框架接口：
iOS/macOS: VideoToolbox（H.264、HEVC 硬编硬解）
FFmpeg: -hwaccel 参数


软件编码/解码适用场景：
场景	原因
需要高度自定义或控制（如 bitrate、GOP、滤镜等）	软件可以自定义参数、插入复杂逻辑
开发跨平台应用	软件编码不依赖平台硬件，一套代码通用
设备无硬编支持或兼容性差	如早期设备或某些 Linux 环境无硬件支持
格式冷门、非主流编解码器	比如 VP8、Theora、AV1 在硬件支持较弱时只能用软件解码
离线转码（不追求实时性）	CPU 资源充足可以跑慢一点但质量高

常见软件库：
FFmpeg (libx264、libx265)
x264 / x265
libvpx / libaom
OpenH264


需求	推荐方式
iOS 直播推流	✅ 硬件编码（VideoToolbox）
网页端播放 MP4 视频	✅ 硬件解码（浏览器 GPU 加速）
跨平台视频批量转码工具	✅ 软件编码（FFmpeg + libx264）
自研编解码格式实验项目	✅ 软件实现，便于调试和控制
实时视频会议应用（低延迟）	✅ 硬件解码 + 硬件编码



如果你追求 性能、低功耗、实时性 → 用硬件加速；
如果你追求 灵活性、兼容性、定制能力 → 用软件编码/解码。


视频分辨率等级划分
分辨率名称	像素尺寸（宽 × 高）	简称	说明
SD（标清）	720×480	480p	传统DVD或早期网络视频
HD（高清）	1280×720	720p	最低限度可称“高清”
Full HD	1920×1080	1080p	主流高清视频标准
2K	2048×1080 或 2560×1440	2K	一些电影制作或高端显示器使用
4K UHD	3840×2160	4K	超高清视频，主流4K电视/摄像头支持
8K UHD	7680×4320	8K	极高分辨率，未来趋势

普通分辨率（低分辨率）：
720p（1280×720）：常称为HD（高清）

高分辨率：
1080p（1920×1080）：Full HD，现代设备的基本标准
2K（2560×1440）：比1080p更细腻，常用于高端手机和显示器
4K（3840×2160）：超高分辨率，常见于电视和高端显示器
8K（7680×4320）：极高分辨率，目前仍不普及



在使用 OpenGL 时，很多平台（尤其是 macOS、iOS、Windows）在读取或传输图像数据（如 glTexImage2D、glReadPixels）时会选择使用 BGRA 而不是默认的 RGBA，主要原因有以下几点：
1. 与原始图像格式匹配，避免转换
大多数图像加载库（如 macOS/iOS 的 Core Graphics、Windows 的 DIB、DirectX）和硬件内存布局使用的是 BGRA 顺序。为了避免在 CPU 或 GPU 上进行颜色通道的转换，直接用 BGRA 可以提升性能。
2. 硬件优化支持
许多 GPU 驱动对 GL_BGRA 有专门优化，尤其是在上传或下载纹理数据时。它可能使用特殊的路径，比如：
快速 DMA 拷贝
零拷贝贴图（Zero-copy texture mapping）
高效的纹理缓存格式
3. Apple 推荐 BGRA（尤其是 iOS/macOS 平台）
在 Apple 平台（iOS、macOS）中，kCVPixelFormatType_32BGRA 是系统图像缓冲区（如 CVPixelBufferRef）的默认格式。
你若使用 Metal、Core Image 或 AVFoundation，输出的图像也是 BGRA 格式。为了避免在 OpenGL 和系统框架之间进行格式转换，直接使用 BGRA 是最优解。
4. API 支持良好
OpenGL 中的 GL_BGRA 是被广泛支持的格式（从 OpenGL 1.2 起就支持）。相比 GL_RGBA，它在现代图形管线中处理图像数据时提供了更好的兼容性和效率，尤其是配合 GL_UNSIGNED_BYTE 类型。
