==========VPN有什么用
VPN可以提高上网的安全性
VPN可以隐藏上网者的身份
VPN可以突破网站的地域限制
突破网络封锁

客户端虚拟网卡负责模拟客户端的VPN内网接口，服务器虚拟网卡负责模拟VPN服务器的内网接口。两者配合构成完整的虚拟网络环境，实现数据加密隧道和通信。

虚拟网卡的作用是“隔离和区分网络流量”
服务器的物理网卡（比如 eth0）收到的，是来自真实物理网络（互联网、局域网）的数据包。
虚拟网卡（如 tun0、tap0）则专门承载 VPN 隧道内的“虚拟网络”流量。
这样，服务器操作系统就能通过接口区分：
物理网卡收的普通网络流量
虚拟网卡收的 VPN 隧道流量


VPN隧道的工作原理：
VPN隧道数据包从客户端虚拟网卡到服务器虚拟网卡的流程
1. 客户端虚拟网卡发出数据包
客户端虚拟网卡（如utun0）发出的是**虚拟内网IP地址（比如10.8.0.12）**的数据包，目标是VPN网络里的某个地址（通常是服务器的虚拟IP，比如10.8.0.1）。
但这只是**“虚拟内网层”的包**，还不是物理网络能识别的包。

2. VPN客户端软件对数据包进行封装
VPN客户端软件会将虚拟网卡发出的内网数据包封装成物理网络可传输的格式（比如UDP或TCP包）。
这个封装过程叫做隧道封装（tunneling）。

3. 封装后的包通过物理网卡发送
封装好的包通过客户端的物理网卡，发送到服务器的公网IP（也就是serverIp）。
这个公网IP是VPN服务器的真实地址，客户端是知道的。

4. 服务器收到物理网络包
服务器物理网卡收到这个封装好的包。
VPN服务器软件负责解封装（decapsulation），从包里取出虚拟内网层的数据包。

5. 服务器虚拟网卡接收虚拟内网包
解封装后的数据包被注入服务器的虚拟网卡（如tun0）接口。
服务器的虚拟网卡地址（serverVirtualIp）就是这个虚拟网络的“网关”地址。
服务器系统看到这些内网IP包，就像在局域网内收到的一样，进行相应的处理和转发。

所以客户端是知道服务器公网IP（serverIp）的，隧道包发过去，服务器的虚拟网卡才是真正接收和处理虚拟内网包的地方。

如果没有服务器虚拟网卡：
服务器没法接收解封装后的内网数据包；
VPN隧道就没法完成内网通信；
VPN就无法正常工作。


虚拟网卡？
VPN 的本质是把“远程的数据”伪装成本地网络数据；
所以服务端不能直接把数据扔给物理网卡（物理网卡代表的是真实公网）；
而是将它写入一个虚拟网卡接口（如 tun0）：
这样操作系统会认为是本机产生的数据；
从而可以走 NAT、路由转发等；
类似于“接入了一个虚拟子网”。


服务端是把客户端通过 TCP 发来的数据（VPN 封装包）解封装后写入虚拟网卡（比如 tun0）；
是为了“让操作系统内核处理”这些虚拟 IP 包。

阶段	处理者	说明
接收 TCP 封装数据	VPN 程序	你们的逻辑，读取 socket，解封装 proxy 协议
写入虚拟网卡（tun）	VPN 程序	将解出的原始 IP 包写入虚拟网卡
处理虚拟 IP 数据包	操作系统内核	继续路由/转发/响应处理


名称	描述
物理网卡	系统用于真实网络收发数据
虚拟网卡	VPN 接入点，用户态注入 IP 包


========================================重要
当你使用 TUN 接口 拦截 IP 数据包时，操作系统（OS）不会再把这些包送入内核的 TCP/IP 协议栈进行解析和处理。它只是：
把完整的 IP 包原样交给你（VPN 程序）处理。


如果一个 App 发起 HTTP 请求：
App 调用 socket() → send()

在 普通网络情况下（没用 VPN）：
系统 TCP/IP 协议栈处理三次握手；
系统协议栈把数据从 TCP 分片、组包、校验；
系统路由模块决定发往哪里；
系统网卡驱动发送出去；

在 VPN / TUN 模式下：
App 的数据包还没到物理网卡；
系统协议栈看到你注册了一个 TUN 接口；
所有出站 IP 包会被拦截并写入 TUN 设备；
系统协议栈就不再做后续的任何处理，交给你！

你需要负责的“处理”包括：
步骤	是否系统处理？	解释
TCP/IP 协议解析	❌ 你自己做（用 lwIP）	
连接状态管理（三次握手）	❌ 你自己维护（lwIP pcb）	
数据重组、滑动窗口、ACK、重传	❌ 你自己处理（TCP 协议栈）	
判断是哪个连接发来的包	❌ 你自己建连接表	
发包给服务端（外网）	✅ 可用系统 socket	
收到服务端回应后回写给 App	✅ 可写入 TUN 接口（再被系统转发给 App）

在 TUN 模式下，系统把 TCP/IP 协议栈“撇一边”，你拿到的就是原始 IP 包，你得自己像操作系统一样解析并处理它们，否则包就“死”在你手里，App 永远等不到响应。


系统只帮你做“转发”，不帮你“理解”
VPN 模式下，系统只负责：
把所有出站 IP 包交给你（readPackets）
你写回 TUN，系统再把它转交给目标 App（writePackets）
但理解这些 IP 包（是否是 TCP，是否连接成功），这些 协议逻辑处理，系统都不管了。


========================================
典型流程（大多数 VPN 架构）
1. 用户打开 VPN 客户端
2. 客户端连接中控（例如：api.vpn.com）
3. 客户端发送请求（包含用户凭证、请求的节点ID等）
4. 中控验证并返回授权结果（成功/失败，以及可连接参数）
5. 客户端根据中控结果连接对应的 VPN 节点服务器


节点为客户端中转请求授权（代理模式）
VPN 客户端 -> VPN 节点（连接请求）
         ↳ 节点 → 中控：用户A要连，我查下授权可以吗？


说法	是否准确	备注
“用户连接节点时，用户向中控请求授权”	✅ 推荐使用的表达	标准 VPN 架构流程
“用户连接节点时，节点向中控请求授权”	⚠️ 可行但较少见	多为特殊设计（如节点代理模式）